// src/lib/dummy-data.ts

import type { ProjectScorecard } from '@/types'; // Assuming you create a types.ts for your interfaces

export const DUMMY_PROJECT_SCORECARD: ProjectScorecard = {
  "runId": "2025-08-06T01:13:21.045Z",
  "repoName": "hedera-smart-contracts",
  "model": "gpt-4o-mini",
  "preliminaryProjectScore": 7.2301543610709595,
  "mainDomain": "Hedera dApp",
  "techStack": [
    "Hardhat"
  ],
  "projectEssence": "The 'Hedera Smart Contracts' project serves as a reference library for implementing and utilizing smart contracts within the Hedera network. It facilitates access to various Hedera services by providing defined system contracts, including those for Hedera Token Service (HTS), Hedera Account Service (HAS), exchange rate, and a pseudo-random number generator (PRNG). The project leverages the Hardhat development environment, enabling developers to interact with Hedera's unique transaction functionalities through Ethereum-compatible smart contracts.",
  "profile": {
    "complexity": 6.840091501588388,
    "quality": 7.612224358772214,
    "maintainability": 6.928861799639342,
    "best_practices": 7.758662003983249
  },
  "usage": {
    "prompt_tokens": 56048,
    "completion_tokens": 3112,
    "total_tokens": 59160
  },
  "totalRetries": 0,
  "totalFailedFiles": 0,
  "warnings": {
    "vendedCodeFlagged": []
  },
  "scoredFiles": [
    {
      "filePath": "repo_cache/hedera-smart-contracts/scripts/hedera-response-codes-protobuf-parser.js",
      "totalOriginalTokens": 422,
      "finalTokenCount": 447,
      "impactScore": 66.66666666666667,
      "averageComplexity": 8,
      "averageQuality": 8.333333333333334,
      "usage": {
        "prompt_tokens": 545,
        "completion_tokens": 128,
        "total_tokens": 673
      },
      "retries": 0,
      "hadError": false,
      "scoredChunkGroups": [
        {
          "groupId": 1,
          "score": {
            "file_path": "scripts/hedera-response-codes-protobuf-parser.js",
            "complexity_score": 8,
            "code_quality_score": 9,
            "maintainability_score": 8,
            "best_practices_adherence": 8,
            "positive_feedback": "Automating the generation of response code constants streamlines development and reduces potential manual errors.",
            "improvement_suggestion": "Document the generated contract for better understanding among developers using the script.",
            "group_summary": "A script that generates a Solidity contract for Hedera response codes from protobuf definitions."
          },
          "totalTokens": 447,
          "usage": {
            "prompt_tokens": 545,
            "completion_tokens": 128,
            "total_tokens": 673
          }
        }
      ],
      "chunkingDetails": {
        "filePath": "repo_cache/hedera-smart-contracts/scripts/hedera-response-codes-protobuf-parser.js",
        "totalFileTokens": 422,
        "chunks": [
          {
            "originalText": "// SPDX-License-Identifier: Apache-2.0\n\nconst fs = require('fs');\nconst axios = require('axios');\nconst protobufjs = require('protobufjs');\n\nasync function main() {\n  const version = (await axios.get('https://raw.githubusercontent.com/hashgraph/hedera-services/refs/heads/main/version.txt')).data.replace('\\n', '');\n  const res = (await axios.get('https://raw.githubusercontent.com/hashgraph/hedera-services/refs/heads/main/hapi/hedera-protobufs/services/response_code.proto')).data;\n  const parsedProto = protobufjs.parse(res, {\n    keepCase: true,\n    alternateCommentMode: true,\n    preferTrailingComment: true\n  });\n  const responseCodes = parsedProto.root.nested.proto.nested.ResponseCodeEnum;\n\n  let contract =\n      `// SPDX-License-Identifier: Apache-2.0\\n` +\n      `pragma solidity >=0.4.9 <0.9.0;\\n` +\n      `\\n// this contract is auto-generated by a manual triggered script in utils/hedera-response-codes-protobuf-parser.js` +\n      `\\n// the generated contract is using hedera response codes from services version ${version}` +\n      `\\n// https://github.com/hashgraph/hedera-services/blob/main/hapi/hedera-protobufs/services/response_code.proto\\n\\n` +\n      `library HederaResponseCodes {\\n`;\n  for (const [name, code] of Object.entries(responseCodes.values)) {\n    const comment = responseCodes?.comments[name];\n    if (comment) {\n      contract += `    /// ${comment.replaceAll('\\n', ' ') ?? ''}\\n`;\n    }\n    contract += `    int32 internal constant ${name} = ${code};\\n\\n`;\n  }\n  contract += '}\\n';\n\n  console.log(`The generated contract is using hedera response codes from services version ${version}`);\n\n  fs.writeFileSync('./contracts/system-contracts/HederaResponseCodes.sol', contract);\n}\n\nmain();\n",
            "codeOnlyTokens": 422,
            "startLine": 1,
            "endLine": 39,
            "type": ".js",
            "isOversized": false
          }
        ],
        "groupedChunks": [
          {
            "combinedText": "// File: scripts/hedera-response-codes-protobuf-parser.js\n// Relevant file context:\n// Type: .js\n// SPDX-License-Identifier: Apache-2.0\n\nconst fs = require('fs');\nconst axios = require('axios');\nconst protobufjs = require('protobufjs');\n\nasync function main() {\n  const version = (await axios.get('https://raw.githubusercontent.com/hashgraph/hedera-services/refs/heads/main/version.txt')).data.replace('\\n', '');\n  const res = (await axios.get('https://raw.githubusercontent.com/hashgraph/hedera-services/refs/heads/main/hapi/hedera-protobufs/services/response_code.proto')).data;\n  const parsedProto = protobufjs.parse(res, {\n    keepCase: true,\n    alternateCommentMode: true,\n    preferTrailingComment: true\n  });\n  const responseCodes = parsedProto.root.nested.proto.nested.ResponseCodeEnum;\n\n  let contract =\n      `// SPDX-License-Identifier: Apache-2.0\\n` +\n      `pragma solidity >=0.4.9 <0.9.0;\\n` +\n      `\\n// this contract is auto-generated by a manual triggered script in utils/hedera-response-codes-protobuf-parser.js` +\n      `\\n// the generated contract is using hedera response codes from services version ${version}` +\n      `\\n// https://github.com/hashgraph/hedera-services/blob/main/hapi/hedera-protobufs/services/response_code.proto\\n\\n` +\n      `library HederaResponseCodes {\\n`;\n  for (const [name, code] of Object.entries(responseCodes.values)) {\n    const comment = responseCodes?.comments[name];\n    if (comment) {\n      contract += `    /// ${comment.replaceAll('\\n', ' ') ?? ''}\\n`;\n    }\n    contract += `    int32 internal constant ${name} = ${code};\\n\\n`;\n  }\n  contract += '}\\n';\n\n  console.log(`The generated contract is using hedera response codes from services version ${version}`);\n\n  fs.writeFileSync('./contracts/system-contracts/HederaResponseCodes.sol', contract);\n}\n\nmain();\n",
            "totalTokens": 447,
            "chunks": [
              {
                "originalText": "// SPDX-License-Identifier: Apache-2.0\n\nconst fs = require('fs');\nconst axios = require('axios');\nconst protobufjs = require('protobufjs');\n\nasync function main() {\n  const version = (await axios.get('https://raw.githubusercontent.com/hashgraph/hedera-services/refs/heads/main/version.txt')).data.replace('\\n', '');\n  const res = (await axios.get('https://raw.githubusercontent.com/hashgraph/hedera-services/refs/heads/main/hapi/hedera-protobufs/services/response_code.proto')).data;\n  const parsedProto = protobufjs.parse(res, {\n    keepCase: true,\n    alternateCommentMode: true,\n    preferTrailingComment: true\n  });\n  const responseCodes = parsedProto.root.nested.proto.nested.ResponseCodeEnum;\n\n  let contract =\n      `// SPDX-License-Identifier: Apache-2.0\\n` +\n      `pragma solidity >=0.4.9 <0.9.0;\\n` +\n      `\\n// this contract is auto-generated by a manual triggered script in utils/hedera-response-codes-protobuf-parser.js` +\n      `\\n// the generated contract is using hedera response codes from services version ${version}` +\n      `\\n// https://github.com/hashgraph/hedera-services/blob/main/hapi/hedera-protobufs/services/response_code.proto\\n\\n` +\n      `library HederaResponseCodes {\\n`;\n  for (const [name, code] of Object.entries(responseCodes.values)) {\n    const comment = responseCodes?.comments[name];\n    if (comment) {\n      contract += `    /// ${comment.replaceAll('\\n', ' ') ?? ''}\\n`;\n    }\n    contract += `    int32 internal constant ${name} = ${code};\\n\\n`;\n  }\n  contract += '}\\n';\n\n  console.log(`The generated contract is using hedera response codes from services version ${version}`);\n\n  fs.writeFileSync('./contracts/system-contracts/HederaResponseCodes.sol', contract);\n}\n\nmain();\n",
                "codeOnlyTokens": 422,
                "startLine": 1,
                "endLine": 39,
                "type": "full_file",
                "isOversized": false
              }
            ],
            "startLine": 1,
            "endLine": 39,
            "groupId": 1
          }
        ],
        "oversizedChunks": [],
        "sendStrategy": "full_file",
        "finalTokenCount": 447,
        "skippedContent": [],
        "contextHeader": "// File: scripts/hedera-response-codes-protobuf-parser.js\n// Relevant file context:\n// Type: .js\n",
        "tokenBreakdown": {
          "originalFile": 422,
          "finalSent": 447,
          "codeTokensInGroups": 422,
          "fileHeaderTokensInGroups": 25,
          "shellContextTokensInGroups": 0,
          "separatorTokensInGroups": 0,
          "skippedCodeTokens": 0,
          "unprocessedOversizedTokens": 0,
          "totalSavings": -25,
          "savingsPercentage": -5.924170616113744,
          "fileHeaderCount": 1,
          "fileHeaderAvgSize": 25,
          "shellContextCount": 0,
          "shellContextAvgSize": 0,
          "separatorCount": 1,
          "separatorAvgSize": 0
        }
      }
    },
    {
      "filePath": "repo_cache/hedera-smart-contracts/contracts/system-contracts/hedera-token-service/IHederaTokenService.sol",
      "totalOriginalTokens": 9663,
      "finalTokenCount": 9995,
      "impactScore": 57.47916666666667,
      "averageComplexity": 7.75,
      "averageQuality": 7.5,
      "usage": {
        "prompt_tokens": 13370,
        "completion_tokens": 475,
        "total_tokens": 13845
      },
      "retries": 0,
      "hadError": false,
      "scoredChunkGroups": [
        {
          "groupId": 1,
          "score": {
            "complexity_score": 8,
            "code_quality_score": 8,
            "maintainability_score": 7,
            "best_practices_adherence": 8,
            "positive_feedback": "The use of structs for representing complex token properties and transfer mechanisms effectively captures the intricate logic around Hedera's token service.",
            "improvement_suggestion": "Consider implementing custom events for critical operations to enhance tracking and logging of token transfers and state changes.",
            "group_summary": "Defines interfaces for Hedera token transfer operations and properties through well-structured Solidity contracts."
          },
          "totalTokens": 2517,
          "usage": {
            "prompt_tokens": 3355,
            "completion_tokens": 122,
            "total_tokens": 3477,
            "prompt_tokens_details": {
              "cached_tokens": 0,
              "audio_tokens": 0
            },
            "completion_tokens_details": {
              "reasoning_tokens": 0,
              "audio_tokens": 0,
              "accepted_prediction_tokens": 0,
              "rejected_prediction_tokens": 0
            }
          }
        },
        {
          "groupId": 2,
          "score": {
            "complexity_score": 8,
            "code_quality_score": 7,
            "maintainability_score": 8,
            "best_practices_adherence": 7,
            "positive_feedback": "The struct definitions and function signatures are well-documented, which enhances code readability and usability within the Hedera ecosystem.",
            "improvement_suggestion": "Consider implementing additional checks for the maximum and minimum amounts within the fee structures to ensure better validation, avoiding potential vulnerabilities.",
            "group_summary": "Defines fees and transfers for Hedera token operations, facilitating custom fee mechanisms and token management."
          },
          "totalTokens": 2497,
          "usage": {
            "prompt_tokens": 3342,
            "completion_tokens": 126,
            "total_tokens": 3468,
            "prompt_tokens_details": {
              "cached_tokens": 0,
              "audio_tokens": 0
            },
            "completion_tokens_details": {
              "reasoning_tokens": 0,
              "audio_tokens": 0,
              "accepted_prediction_tokens": 0,
              "rejected_prediction_tokens": 0
            }
          }
        },
        {
          "groupId": 3,
          "score": {
            "complexity_score": 7,
            "code_quality_score": 8,
            "maintainability_score": 7,
            "best_practices_adherence": 8,
            "positive_feedback": "The clear structuring of functions for token operations facilitates both readability and scalability for developers.",
            "improvement_suggestion": "Consider adding comments on complex interactions to improve understanding for future maintainers.",
            "group_summary": "Defines interfaces for managing Hedera tokens and their transfers, including support for custom fee structures."
          },
          "totalTokens": 2502,
          "usage": {
            "prompt_tokens": 3348,
            "completion_tokens": 111,
            "total_tokens": 3459,
            "prompt_tokens_details": {
              "cached_tokens": 0,
              "audio_tokens": 0
            },
            "completion_tokens_details": {
              "reasoning_tokens": 0,
              "audio_tokens": 0,
              "accepted_prediction_tokens": 0,
              "rejected_prediction_tokens": 0
            }
          }
        },
        {
          "groupId": 4,
          "score": {
            "complexity_score": 8,
            "code_quality_score": 7,
            "maintainability_score": 6,
            "best_practices_adherence": 8,
            "positive_feedback": "The use of custom fees and various token operations demonstrates a solid understanding of Hedera's token service capabilities.",
            "improvement_suggestion": "Consider implementing modifiers for repetitive access control patterns to reduce code redundancy and enhance maintainability.",
            "group_summary": "This code defines the interface for managing various token operations in the Hedera ecosystem."
          },
          "totalTokens": 2479,
          "usage": {
            "prompt_tokens": 3325,
            "completion_tokens": 116,
            "total_tokens": 3441,
            "prompt_tokens_details": {
              "cached_tokens": 0,
              "audio_tokens": 0
            },
            "completion_tokens_details": {
              "reasoning_tokens": 0,
              "audio_tokens": 0,
              "accepted_prediction_tokens": 0,
              "rejected_prediction_tokens": 0
            }
          }
        }
      ],
      "chunkingDetails": {
        "filePath": "repo_cache/hedera-smart-contracts/contracts/system-contracts/hedera-token-service/IHederaTokenService.sol",
        "totalFileTokens": 9663,
        "chunks": [
          {
            "originalText": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.9 <0.9.0;\npragma experimental ABIEncoderV2;\n\ninterface IHederaTokenService {\n    /// Transfers cryptocurrency among two or more accounts by making the desired adjustments to their\n    /// balances. Each transfer list can specify up to 10 adjustments. Each negative amount is withdrawn\n    /// from the corresponding account (a sender), and each positive one is added to the corresponding\n    /// account (a receiver). The amounts list must sum to zero. Each amount is a number of tinybars\n    /// (there are 100,000,000 tinybars in one hbar).  If any sender account fails to have sufficient\n    /// hbars, then the entire transaction fails, and none of those transfers occur, though the\n    /// transaction fee is still charged. This transaction must be signed by the keys for all the sending\n    /// accounts, and for any receiving accounts that have receiverSigRequired == true. The signatures\n    /// are in the same order as the accounts, skipping those accounts that don't need a signature.\n    /// @custom:version 0.3.0 previous version did not include isApproval\n    struct AccountAmount {\n        // The Account ID, as a solidity address, that sends/receives cryptocurrency or tokens\n        address accountID;\n\n        // The amount of  the lowest denomination of the given token that\n        // the account sends(negative) or receives(positive)\n        int64 amount;\n\n        // If true then the transfer is expected to be an approved allowance and the\n        // accountID is expected to be the owner. The default is false (omitted).\n        bool isApproval;\n    }\n\n    /// A sender account, a receiver account, and the serial number of an NFT of a Token with\n    /// NON_FUNGIBLE_UNIQUE type. When minting NFTs the sender will be the default AccountID instance\n    /// (0.0.0 aka 0x0) and when burning NFTs, the receiver will be the default AccountID instance.\n    /// @custom:version 0.3.0 previous version did not include isApproval\n    struct NftTransfer {\n        // The solidity address of the sender\n        address senderAccountID;\n\n        // The solidity address of the receiver\n        address receiverAccountID;\n\n        // The serial number of the NFT\n        int64 serialNumber;\n\n        // If true then the transfer is expected to be an approved allowance and the\n        // accountID is expected to be the owner. The default is false (omitted).\n        bool isApproval;\n    }\n\n    struct TokenTransferList {\n        // The ID of the token as a solidity address\n        address token;\n\n        // Applicable to tokens of type FUNGIBLE_COMMON. Multiple list of AccountAmounts, each of which\n        // has an account and amount.\n        AccountAmount[] transfers;\n\n        // Applicable to tokens of type NON_FUNGIBLE_UNIQUE. Multiple list of NftTransfers, each of\n        // which has a sender and receiver account, including the serial number of the NFT\n        NftTransfer[] nftTransfers;\n    }\n\n    struct TransferList {\n        // Multiple list of AccountAmounts, each of which has an account and amount.\n        // Used to transfer hbars between the accounts in the list.\n        AccountAmount[] transfers;\n    }\n\n    /// Expiry properties of a Hedera token - second, autoRenewAccount, autoRenewPeriod\n    struct Expiry {\n        // The epoch second at which the token should expire; if an auto-renew account and period are\n        // specified, this is coerced to the current epoch second plus the autoRenewPeriod\n        int64 second;\n\n        // ID of an account which will be automatically charged to renew the token's expiration, at\n        // autoRenewPeriod interval, expressed as a solidity address",
            "codeOnlyTokens": 805,
            "startLine": 1,
            "endLine": 74,
            "type": ".sol_part_1",
            "isOversized": false
          },
          {
            "originalText": "        address autoRenewAccount;\n\n        // The interval at which the auto-renew account will be charged to extend the token's expiry\n        int64 autoRenewPeriod;\n    }\n\n    /// A Key can be a public key from either the Ed25519 or ECDSA(secp256k1) signature schemes, where\n    /// in the ECDSA(secp256k1) case we require the 33-byte compressed form of the public key. We call\n    /// these public keys <b>primitive keys</b>.\n    /// A Key can also be the ID of a smart contract instance, which is then authorized to perform any\n    /// precompiled contract action that requires this key to sign.\n    /// Note that when a Key is a smart contract ID, it <i>doesn't</i> mean the contract with that ID\n    /// will actually create a cryptographic signature. It only means that when the contract calls a\n    /// precompiled contract, the resulting \"child transaction\" will be authorized to perform any action\n    /// controlled by the Key.\n    /// Exactly one of the possible values should be populated in order for the Key to be valid.\n    struct KeyValue {\n\n        // if set to true, the key of the calling Hedera account will be inherited as the token key\n        bool inheritAccountKey;\n\n        // smart contract instance that is authorized as if it had signed with a key\n        address contractId;\n\n        // Ed25519 public key bytes\n        bytes ed25519;\n\n        // Compressed ECDSA(secp256k1) public key bytes\n        bytes ECDSA_secp256k1;\n\n        // A smart contract that, if the recipient of the active message frame, should be treated\n        // as having signed. (Note this does not mean the <i>code being executed in the frame</i>\n        // will belong to the given contract, since it could be running another contract's code via\n        // <tt>delegatecall</tt>. So setting this key is a more permissive version of setting the\n        // contractID key, which also requires the code in the active message frame belong to the\n        // the contract with the given id.)\n        address delegatableContractId;\n    }\n\n    /// A list of token key types the key should be applied to and the value of the key\n    struct TokenKey {\n\n        // bit field representing the key type. Keys of all types that have corresponding bits set to 1\n        // will be created for the token.\n        // 0th bit: adminKey\n        // 1st bit: kycKey\n        // 2nd bit: freezeKey\n        // 3rd bit: wipeKey\n        // 4th bit: supplyKey\n        // 5th bit: feeScheduleKey\n        // 6th bit: pauseKey\n        // 7th bit: ignored\n        uint keyType;\n\n        // the value that will be set to the key type\n        KeyValue key;\n    }\n\n    /// Basic properties of a Hedera Token - name, symbol, memo, tokenSupplyType, maxSupply,\n    /// treasury, freezeDefault. These properties are related both to Fungible and NFT token types.\n    struct HederaToken {\n        // The publicly visible name of the token. The token name is specified as a Unicode string.\n        // Its UTF-8 encoding cannot exceed 100 bytes, and cannot contain the 0 byte (NUL).\n        string name;\n\n        // The publicly visible token symbol. The token symbol is specified as a Unicode string.\n        // Its UTF-8 encoding cannot exceed 100 bytes, and cannot contain the 0 byte (NUL).\n        string symbol;\n\n        // The ID of the account which will act as a treasury for the token as a solidity address.\n        // This account will receive the specified initial supply or the newly minted NFTs in",
            "codeOnlyTokens": 810,
            "startLine": 75,
            "endLine": 145,
            "type": ".sol_part_2",
            "isOversized": false
          },
          {
            "originalText": "        // the case for NON_FUNGIBLE_UNIQUE Type\n        address treasury;\n\n        // The memo associated with the token (UTF-8 encoding max 100 bytes)\n        string memo;\n\n        // IWA compatibility. Specified the token supply type. Defaults to INFINITE\n        bool tokenSupplyType;\n\n        // IWA Compatibility. Depends on TokenSupplyType. For tokens of type FUNGIBLE_COMMON - the\n        // maximum number of tokens that can be in circulation. For tokens of type NON_FUNGIBLE_UNIQUE -\n        // the maximum number of NFTs (serial numbers) that can be minted. This field can never be changed!\n        int64 maxSupply;\n\n        // The default Freeze status (frozen or unfrozen) of Hedera accounts relative to this token. If\n        // true, an account must be unfrozen before it can receive the token\n        bool freezeDefault;\n\n        // list of keys to set to the token\n        TokenKey[] tokenKeys;\n\n        // expiry properties of a Hedera token - second, autoRenewAccount, autoRenewPeriod\n        Expiry expiry;\n    }\n\n    /// Additional post creation fungible and non fungible properties of a Hedera Token.\n    struct TokenInfo {\n        /// Basic properties of a Hedera Token\n        HederaToken token;\n\n        /// The number of tokens (fungible) or serials (non-fungible) of the token\n        int64 totalSupply;\n\n        /// Specifies whether the token is deleted or not\n        bool deleted;\n\n        /// Specifies whether the token kyc was defaulted with KycNotApplicable (true) or Revoked (false)\n        bool defaultKycStatus;\n\n        /// Specifies whether the token is currently paused or not\n        bool pauseStatus;\n\n        /// The fixed fees collected when transferring the token\n        FixedFee[] fixedFees;\n\n        /// The fractional fees collected when transferring the token\n        FractionalFee[] fractionalFees;\n\n        /// The royalty fees collected when transferring the token\n        RoyaltyFee[] royaltyFees;\n\n        /// The ID of the network ledger\n        string ledgerId;\n    }\n\n    /// Additional fungible properties of a Hedera Token.\n    struct FungibleTokenInfo {\n        /// The shared hedera token info\n        TokenInfo tokenInfo;\n\n        /// The number of decimal places a token is divisible by\n        int32 decimals;\n    }\n\n    /// Additional non fungible properties of a Hedera Token.\n    struct NonFungibleTokenInfo {\n        /// The shared hedera token info\n        TokenInfo tokenInfo;\n\n        /// The serial number of the nft\n        int64 serialNumber;\n\n        /// The account id specifying the owner of the non fungible token\n        address ownerId;\n\n        /// The epoch second at which the token was created.\n        int64 creationTime;\n\n        /// The unique metadata of the NFT\n        bytes metadata;\n\n        /// The account id specifying an account that has been granted spending permissions on this nft\n        address spenderId;\n    }\n\n    /// A fixed number of units (hbar or token) to assess as a fee during a transfer of\n    /// units of the token to which this fixed fee is attached. The denomination of\n    /// the fee depends on the values of tokenId, useHbarsForPayment and\n    /// useCurrentTokenForPayment. Exactly one of the values should be set.\n    struct FixedFee {\n\n        int64 amount;\n\n        // Specifies ID of token that should be used for fixed fee denomination\n        address tokenId;\n\n        // Specifies this fixed fee should be denominated in Hbar\n        bool useHbarsForPayment;\n\n        // Specifies this fixed fee should be denominated in the Token currently being created\n        bool useCurrentTokenForPayment;\n\n        // The ID of the account to receive the custom fee, expressed as a solidity address\n        address feeCollector;\n    }\n\n    /// A fraction of the transferred units of a token to assess as a fee. The amount assessed will never",
            "codeOnlyTokens": 817,
            "startLine": 146,
            "endLine": 252,
            "type": ".sol_part_3",
            "isOversized": false
          },
          {
            "originalText": "    /// be less than the given minimumAmount, and never greater than the given maximumAmount.  The\n    /// denomination is always units of the token to which this fractional fee is attached.\n    struct FractionalFee {\n        // A rational number's numerator, used to set the amount of a value transfer to collect as a custom fee\n        int64 numerator;\n\n        // A rational number's denominator, used to set the amount of a value transfer to collect as a custom fee\n        int64 denominator;\n\n        // The minimum amount to assess\n        int64 minimumAmount;\n\n        // The maximum amount to assess (zero implies no maximum)\n        int64 maximumAmount;\n        bool netOfTransfers;\n\n        // The ID of the account to receive the custom fee, expressed as a solidity address\n        address feeCollector;\n    }\n\n    /// A fee to assess during a transfer that changes ownership of an NFT. Defines the fraction of\n    /// the fungible value exchanged for an NFT that the ledger should collect as a royalty. (\"Fungible\n    /// value\" includes both ℏ and units of fungible HTS tokens.) When the NFT sender does not receive\n    /// any fungible value, the ledger will assess the fallback fee, if present, to the new NFT owner.\n    /// Royalty fees can only be added to tokens of type type NON_FUNGIBLE_UNIQUE.\n    struct RoyaltyFee {\n        // A fraction's numerator of fungible value exchanged for an NFT to collect as royalty\n        int64 numerator;\n\n        // A fraction's denominator of fungible value exchanged for an NFT to collect as royalty\n        int64 denominator;\n\n        // If present, the fee to assess to the NFT receiver when no fungible value\n        // is exchanged with the sender. Consists of:\n        // amount: the amount to charge for the fee\n        // tokenId: Specifies ID of token that should be used for fixed fee denomination\n        // useHbarsForPayment: Specifies this fee should be denominated in Hbar\n        int64 amount;\n        address tokenId;\n        bool useHbarsForPayment;\n\n        // The ID of the account to receive the custom fee, expressed as a solidity address\n        address feeCollector;\n    }\n\n    /// Represents a pending airdrop of a token or NFT to a receiver\n    /// @param sender The address of the account sending the airdrop\n    /// @param receiver The address of the account receiving the airdrop\n    /// @param token The address of the token being airdropped\n    /// @param serial For NFT airdrops, the serial number of the NFT. For fungible tokens, this should be 0\n    struct PendingAirdrop {\n        address sender;\n        address receiver;\n        address token;\n        int64 serial;\n    }\n\n    /// Represents a unique NFT by its token address and serial number\n    /// @param nft The address of the NFT token\n    /// @param serial The serial number that uniquely identifies this NFT within its token type\n    struct NftID {\n        address nft;\n        int64 serial;\n    }\n\n    /**********************\n     * Direct HTS Calls   *\n     **********************/\n\n    /// Performs transfers among combinations of tokens and hbars\n    /// @param transferList the list of hbar transfers to do\n    /// @param tokenTransfers the list of token transfers to do\n    /// @custom:version 0.3.0 the signature of the previous version was cryptoTransfer(TokenTransferList[] memory tokenTransfers)\n    function cryptoTransfer(TransferList memory transferList, TokenTransferList[] memory tokenTransfers)\n        external\n        returns (int64 responseCode);\n\n    /// Mints an amount of the token to the defined treasury account\n    /// @param token The token for which to mint tokens. If token does not exist, transaction results in\n    ///              INVALID_TOKEN_ID",
            "codeOnlyTokens": 801,
            "startLine": 253,
            "endLine": 332,
            "type": ".sol_part_4",
            "isOversized": false
          },
          {
            "originalText": "    /// @param amount Applicable to tokens of type FUNGIBLE_COMMON. The amount to mint to the Treasury Account.\n    ///               Amount must be a positive non-zero number represented in the lowest denomination of the\n    ///               token. The new supply must be lower than 2^63.\n    /// @param metadata Applicable to tokens of type NON_FUNGIBLE_UNIQUE. A list of metadata that are being created.\n    ///                 Maximum allowed size of each metadata is 100 bytes\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return newTotalSupply The new supply of tokens. For NFTs it is the total count of NFTs\n    /// @return serialNumbers If the token is an NFT the newly generate serial numbers, othersise empty.\n    function mintToken(\n        address token,\n        int64 amount,\n        bytes[] memory metadata\n    )\n        external\n        returns (\n            int64 responseCode,\n            int64 newTotalSupply,\n            int64[] memory serialNumbers\n        );\n\n    /// Burns an amount of the token from the defined treasury account\n    /// @param token The token for which to burn tokens. If token does not exist, transaction results in\n    ///              INVALID_TOKEN_ID\n    /// @param amount  Applicable to tokens of type FUNGIBLE_COMMON. The amount to burn from the Treasury Account.\n    ///                Amount must be a positive non-zero number, not bigger than the token balance of the treasury\n    ///                account (0; balance], represented in the lowest denomination.\n    /// @param serialNumbers Applicable to tokens of type NON_FUNGIBLE_UNIQUE. The list of serial numbers to be burned.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return newTotalSupply The new supply of tokens. For NFTs it is the total count of NFTs\n    function burnToken(\n        address token,\n        int64 amount,\n        int64[] memory serialNumbers\n    ) external returns (int64 responseCode, int64 newTotalSupply);\n\n    ///  Associates the provided account with the provided tokens. Must be signed by the provided\n    ///  Account's key or called from the accounts contract key\n    ///  If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.\n    ///  If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.\n    ///  If any of the provided tokens is not found, the transaction will resolve to INVALID_TOKEN_REF.\n    ///  If any of the provided tokens has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.\n    ///  If an association between the provided account and any of the tokens already exists, the\n    ///  transaction will resolve to TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT.\n    ///  If the provided account's associations count exceed the constraint of maximum token associations\n    ///    per account, the transaction will resolve to TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED.\n    ///  On success, associations between the provided account and tokens are made and the account is\n    ///    ready to interact with the tokens.\n    /// @param account The account to be associated with the provided tokens\n    /// @param tokens The tokens to be associated with the provided account. In the case of NON_FUNGIBLE_UNIQUE\n    ///               Type, once an account is associated, it can hold any number of NFTs (serial numbers) of that\n    ///               token type\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function associateTokens(address account, address[] memory tokens)\n        external\n        returns (int64 responseCode);\n\n    /// Single-token variant of associateTokens. Will be mapped to a single entry array call of associateTokens\n    /// @param account The account to be associated with the provided token",
            "codeOnlyTokens": 806,
            "startLine": 333,
            "endLine": 390,
            "type": ".sol_part_5",
            "isOversized": false
          },
          {
            "originalText": "    /// @param token The token to be associated with the provided account\n    function associateToken(address account, address token)\n        external\n        returns (int64 responseCode);\n\n    /// Dissociates the provided account with the provided tokens. Must be signed by the provided\n    /// Account's key.\n    /// If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.\n    /// If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.\n    /// If any of the provided tokens is not found, the transaction will resolve to INVALID_TOKEN_REF.\n    /// If any of the provided tokens has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.\n    /// If an association between the provided account and any of the tokens does not exist, the\n    /// transaction will resolve to TOKEN_NOT_ASSOCIATED_TO_ACCOUNT.\n    /// If a token has not been deleted and has not expired, and the user has a nonzero balance, the\n    /// transaction will resolve to TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES.\n    /// If a <b>fungible token</b> has expired, the user can disassociate even if their token balance is\n    /// not zero.\n    /// If a <b>non fungible token</b> has expired, the user can <b>not</b> disassociate if their token\n    /// balance is not zero. The transaction will resolve to TRANSACTION_REQUIRED_ZERO_TOKEN_BALANCES.\n    /// On success, associations between the provided account and tokens are removed.\n    /// @param account The account to be dissociated from the provided tokens\n    /// @param tokens The tokens to be dissociated from the provided account.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function dissociateTokens(address account, address[] memory tokens)\n        external\n        returns (int64 responseCode);\n\n    /// Single-token variant of dissociateTokens. Will be mapped to a single entry array call of dissociateTokens\n    /// @param account The account to be associated with the provided token\n    /// @param token The token to be associated with the provided account\n    function dissociateToken(address account, address token)\n        external\n        returns (int64 responseCode);\n\n    /// Creates a Fungible Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @param initialTotalSupply Specifies the initial supply of tokens to be put in circulation. The\n    /// initial supply is sent to the Treasury Account. The supply is in the lowest denomination possible.\n    /// @param decimals the number of decimal places a token is divisible by\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createFungibleToken(\n        HederaToken memory token,\n        int64 initialTotalSupply,\n        int32 decimals\n    ) external payable returns (int64 responseCode, address tokenAddress);\n\n    /// Creates a Fungible Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @param initialTotalSupply Specifies the initial supply of tokens to be put in circulation. The\n    /// initial supply is sent to the Treasury Account. The supply is in the lowest denomination possible.\n    /// @param decimals the number of decimal places a token is divisible by.\n    /// @param fixedFees list of fixed fees to apply to the token\n    /// @param fractionalFees list of fractional fees to apply to the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createFungibleTokenWithCustomFees(\n        HederaToken memory token,\n        int64 initialTotalSupply,",
            "codeOnlyTokens": 804,
            "startLine": 391,
            "endLine": 449,
            "type": ".sol_part_6",
            "isOversized": false
          },
          {
            "originalText": "        int32 decimals,\n        FixedFee[] memory fixedFees,\n        FractionalFee[] memory fractionalFees\n    ) external payable returns (int64 responseCode, address tokenAddress);\n\n    /// Creates an Non Fungible Unique Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createNonFungibleToken(HederaToken memory token)\n        external\n        payable\n        returns (int64 responseCode, address tokenAddress);\n\n    /// Creates an Non Fungible Unique Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @param fixedFees list of fixed fees to apply to the token\n    /// @param royaltyFees list of royalty fees to apply to the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createNonFungibleTokenWithCustomFees(\n        HederaToken memory token,\n        FixedFee[] memory fixedFees,\n        RoyaltyFee[] memory royaltyFees\n    ) external payable returns (int64 responseCode, address tokenAddress);\n\n    /**********************\n     * ABIV1 calls        *\n     **********************/\n\n    /// Initiates a Fungible Token Transfer\n    /// @param token The ID of the token as a solidity address\n    /// @param accountId account to do a transfer to/from\n    /// @param amount The amount from the accountId at the same index\n    function transferTokens(\n        address token,\n        address[] memory accountId,\n        int64[] memory amount\n    ) external returns (int64 responseCode);\n\n    /// Initiates a Non-Fungable Token Transfer\n    /// @param token The ID of the token as a solidity address\n    /// @param sender the sender of an nft\n    /// @param receiver the receiver of the nft sent by the same index at sender\n    /// @param serialNumber the serial number of the nft sent by the same index at sender\n    function transferNFTs(\n        address token,\n        address[] memory sender,\n        address[] memory receiver,\n        int64[] memory serialNumber\n    ) external returns (int64 responseCode);\n\n    /// Transfers tokens where the calling account/contract is implicitly the first entry in the token transfer list,\n    /// where the amount is the value needed to zero balance the transfers. Regular signing rules apply for sending\n    /// (positive amount) or receiving (negative amount)\n    /// @param token The token to transfer to/from\n    /// @param sender The sender for the transaction\n    /// @param recipient The receiver of the transaction\n    /// @param amount Non-negative value to send. a negative value will result in a failure.\n    function transferToken(\n        address token,\n        address sender,\n        address recipient,\n        int64 amount\n    ) external returns (int64 responseCode);\n\n    /// Transfers tokens where the calling account/contract is implicitly the first entry in the token transfer list,\n    /// where the amount is the value needed to zero balance the transfers. Regular signing rules apply for sending\n    /// (positive amount) or receiving (negative amount)\n    /// @param token The token to transfer to/from\n    /// @param sender The sender for the transaction\n    /// @param recipient The receiver of the transaction\n    /// @param serialNumber The serial number of the NFT to transfer.\n    function transferNFT(\n        address token,\n        address sender,\n        address recipient,\n        int64 serialNumber\n    ) external returns (int64 responseCode);\n\n    /// Allows spender to withdraw from your account multiple times, up to the value amount. If this function is called\n    /// again it overwrites the current allowance with value.",
            "codeOnlyTokens": 809,
            "startLine": 450,
            "endLine": 531,
            "type": ".sol_part_7",
            "isOversized": false
          },
          {
            "originalText": "    /// Only Applicable to Fungible Tokens\n    /// @param token The hedera token address to approve\n    /// @param spender the account address authorized to spend\n    /// @param amount the amount of tokens authorized to spend.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function approve(\n        address token,\n        address spender,\n        uint256 amount\n    ) external returns (int64 responseCode);\n\n    /// Transfers `amount` tokens from `from` to `to` using the\n    //  allowance mechanism. `amount` is then deducted from the caller's allowance.\n    /// Only applicable to fungible tokens\n    /// @param token The address of the fungible Hedera token to transfer\n    /// @param from The account address of the owner of the token, on the behalf of which to transfer `amount` tokens\n    /// @param to The account address of the receiver of the `amount` tokens\n    /// @param amount The amount of tokens to transfer from `from` to `to`\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function transferFrom(address token, address from, address to, uint256 amount) external returns (int64 responseCode);\n\n    /// Returns the amount which spender is still allowed to withdraw from owner.\n    /// Only Applicable to Fungible Tokens\n    /// @param token The Hedera token address to check the allowance of\n    /// @param owner the owner of the tokens to be spent\n    /// @param spender the spender of the tokens\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return allowance The amount which spender is still allowed to withdraw from owner.\n    function allowance(\n        address token,\n        address owner,\n        address spender\n    ) external returns (int64 responseCode, uint256 allowance);\n\n    /// Allow or reaffirm the approved address to transfer an NFT the approved address does not own.\n    /// Only Applicable to NFT Tokens\n    /// @param token The Hedera NFT token address to approve\n    /// @param approved The new approved NFT controller.  To revoke approvals pass in the zero address.\n    /// @param serialNumber The NFT serial number  to approve\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function approveNFT(\n        address token,\n        address approved,\n        uint256 serialNumber\n    ) external returns (int64 responseCode);\n\n    /// Transfers `serialNumber` of `token` from `from` to `to` using the allowance mechanism.\n    /// Only applicable to NFT tokens\n    /// @param token The address of the non-fungible Hedera token to transfer\n    /// @param from The account address of the owner of `serialNumber` of `token`\n    /// @param to The account address of the receiver of `serialNumber`\n    /// @param serialNumber The NFT serial number to transfer\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function transferFromNFT(address token, address from, address to, uint256 serialNumber) external returns (int64 responseCode);\n\n    /// Get the approved address for a single NFT\n    /// Only Applicable to NFT Tokens\n    /// @param token The Hedera NFT token address to check approval\n    /// @param serialNumber The NFT to find the approved address for\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return approved The approved address for this NFT, or the zero address if there is none\n    function getApproved(address token, uint256 serialNumber)\n        external\n        returns (int64 responseCode, address approved);\n\n    /// Enable or disable approval for a third party (\"operator\") to manage",
            "codeOnlyTokens": 806,
            "startLine": 532,
            "endLine": 597,
            "type": ".sol_part_8",
            "isOversized": false
          },
          {
            "originalText": "    ///  all of `msg.sender`'s assets\n    /// @param token The Hedera NFT token address to approve\n    /// @param operator Address to add to the set of authorized operators\n    /// @param approved True if the operator is approved, false to revoke approval\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function setApprovalForAll(\n        address token,\n        address operator,\n        bool approved\n    ) external returns (int64 responseCode);\n\n    /// Query if an address is an authorized operator for another address\n    /// Only Applicable to NFT Tokens\n    /// @param token The Hedera NFT token address to approve\n    /// @param owner The address that owns the NFTs\n    /// @param operator The address that acts on behalf of the owner\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return approved True if `operator` is an approved operator for `owner`, false otherwise\n    function isApprovedForAll(\n        address token,\n        address owner,\n        address operator\n    ) external returns (int64 responseCode, bool approved);\n\n    /// Query if token account is frozen\n    /// @param token The token address to check\n    /// @param account The account address associated with the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return frozen True if `account` is frozen for `token`\n    function isFrozen(address token, address account)\n        external\n        returns (int64 responseCode, bool frozen);\n\n    /// Query if token account has kyc granted\n    /// @param token The token address to check\n    /// @param account The account address associated with the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return kycGranted True if `account` has kyc granted for `token`\n    function isKyc(address token, address account)\n        external\n        returns (int64 responseCode, bool kycGranted);\n\n    /// Operation to delete token\n    /// @param token The token address to be deleted\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function deleteToken(address token) external returns (int64 responseCode);\n\n    /// Query token custom fees\n    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return fixedFees Set of fixed fees for `token`\n    /// @return fractionalFees Set of fractional fees for `token`\n    /// @return royaltyFees Set of royalty fees for `token`\n    function getTokenCustomFees(address token)\n        external\n        returns (int64 responseCode, FixedFee[] memory fixedFees, FractionalFee[] memory fractionalFees, RoyaltyFee[] memory royaltyFees);\n\n    /// Query token default freeze status\n    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return defaultFreezeStatus True if `token` default freeze status is frozen.\n    function getTokenDefaultFreezeStatus(address token)\n        external\n        returns (int64 responseCode, bool defaultFreezeStatus);\n\n    /// Query token default kyc status\n    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return defaultKycStatus True if `token` default kyc status is KycNotApplicable and false if Revoked.\n    function getTokenDefaultKycStatus(address token)\n        external\n        returns (int64 responseCode, bool defaultKycStatus);",
            "codeOnlyTokens": 803,
            "startLine": 598,
            "endLine": 669,
            "type": ".sol_part_9",
            "isOversized": false
          },
          {
            "originalText": "\n    /// Query token expiry info\n    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return expiry Expiry info for `token`\n    function getTokenExpiryInfo(address token)\n        external\n        returns (int64 responseCode, Expiry memory expiry);\n\n    /// Query fungible token info\n    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return fungibleTokenInfo FungibleTokenInfo info for `token`\n    function getFungibleTokenInfo(address token)\n        external\n        returns (int64 responseCode, FungibleTokenInfo memory fungibleTokenInfo);\n\n    /// Query token info\n    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenInfo TokenInfo info for `token`\n    function getTokenInfo(address token)\n        external\n        returns (int64 responseCode, TokenInfo memory tokenInfo);\n\n    /// Query token KeyValue\n    /// @param token The token address to check\n    /// @param keyType The keyType of the desired KeyValue\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return key KeyValue info for key of type `keyType`\n    function getTokenKey(address token, uint keyType)\n        external\n        returns (int64 responseCode, KeyValue memory key);\n\n    /// Query non fungible token info\n    /// @param token The token address to check\n    /// @param serialNumber The NFT serialNumber to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return nonFungibleTokenInfo NonFungibleTokenInfo info for `token` `serialNumber`\n    function getNonFungibleTokenInfo(address token, int64 serialNumber)\n        external\n        returns (int64 responseCode, NonFungibleTokenInfo memory nonFungibleTokenInfo);\n\n    /// Operation to freeze token account\n    /// @param token The token address\n    /// @param account The account address to be frozen\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function freezeToken(address token, address account)\n        external\n        returns (int64 responseCode);\n\n    /// Operation to unfreeze token account\n    /// @param token The token address\n    /// @param account The account address to be unfrozen\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function unfreezeToken(address token, address account)\n        external\n        returns (int64 responseCode);\n\n    /// Operation to grant kyc to token account\n    /// @param token The token address\n    /// @param account The account address to grant kyc\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function grantTokenKyc(address token, address account)\n        external\n        returns (int64 responseCode);\n\n    /// Operation to revoke kyc to token account\n    /// @param token The token address\n    /// @param account The account address to revoke kyc\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function revokeTokenKyc(address token, address account)\n        external\n        returns (int64 responseCode);\n\n    /// Operation to pause token\n    /// @param token The token address to be paused\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.",
            "codeOnlyTokens": 800,
            "startLine": 670,
            "endLine": 747,
            "type": ".sol_part_10",
            "isOversized": false
          },
          {
            "originalText": "    function pauseToken(address token) external returns (int64 responseCode);\n\n    /// Operation to unpause token\n    /// @param token The token address to be unpaused\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function unpauseToken(address token) external returns (int64 responseCode);\n\n    /// Operation to wipe fungible tokens from account\n    /// @param token The token address\n    /// @param account The account address to revoke kyc\n    /// @param amount The number of tokens to wipe\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function wipeTokenAccount(\n        address token,\n        address account,\n        int64 amount\n    ) external returns (int64 responseCode);\n\n    /// Operation to wipe non fungible tokens from account\n    /// @param token The token address\n    /// @param account The account address to revoke kyc\n    /// @param  serialNumbers The serial numbers of token to wipe\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function wipeTokenAccountNFT(\n        address token,\n        address account,\n        int64[] memory serialNumbers\n    ) external returns (int64 responseCode);\n\n    /// Operation to update token info\n    /// @param token The token address\n    /// @param tokenInfo The hedera token info to update token with\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateTokenInfo(address token, HederaToken memory tokenInfo)\n        external\n        returns (int64 responseCode);\n\n    /// Operation to update token expiry info\n    /// @param token The token address\n    /// @param expiryInfo The hedera token expiry info\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateTokenExpiryInfo(address token, Expiry memory expiryInfo)\n        external\n        returns (int64 responseCode);\n\n    /// Operation to update token expiry info\n    /// @param token The token address\n    /// @param keys The token keys\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateTokenKeys(address token, TokenKey[] memory keys)\n        external\n        returns (int64 responseCode);\n\n    /// Query if valid token found for the given address\n    /// @param token The token address\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return isToken True if valid token found for the given address\n    function isToken(address token)\n        external returns\n        (int64 responseCode, bool isToken);\n\n    /// Query to return the token type for a given address\n    /// @param token The token address\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenType the token type. 0 is FUNGIBLE_COMMON, 1 is NON_FUNGIBLE_UNIQUE, -1 is UNRECOGNIZED\n    function getTokenType(address token)\n        external returns\n        (int64 responseCode, int32 tokenType);\n\n    /// Initiates a Redirect For Token\n    /// @param token The token address\n    /// @param encodedFunctionSelector The function selector from the ERC20 interface + the bytes input for the function called\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return response The result of the call that had been encoded and sent for execution.\n    function redirectForToken(address token, bytes memory encodedFunctionSelector) external returns (int64 responseCode, bytes memory response);\n\n    /// Update the custom fees for a fungible token",
            "codeOnlyTokens": 805,
            "startLine": 748,
            "endLine": 824,
            "type": ".sol_part_11",
            "isOversized": false
          },
          {
            "originalText": "    /// @param token The token address\n    /// @param fixedFees Set of fixed fees for `token`\n    /// @param fractionalFees Set of fractional fees for `token`\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateFungibleTokenCustomFees(address token,  IHederaTokenService.FixedFee[] memory fixedFees, IHederaTokenService.FractionalFee[] memory fractionalFees) external returns (int64 responseCode);\n\n    /// Update the custom fees for a non-fungible token\n    /// @param token The token address\n    /// @param fixedFees Set of fixed fees for `token`\n    /// @param royaltyFees Set of royalty fees for `token`\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateNonFungibleTokenCustomFees(address token, IHederaTokenService.FixedFee[] memory fixedFees, IHederaTokenService.RoyaltyFee[] memory royaltyFees) external returns (int64 responseCode);\n\n    /// @notice Airdrop one or more tokens to one or more accounts\n    /// @notice Recipients will receive tokens in one of these ways:\n    /// @notice     - Immediately if already associated with the token\n    /// @notice     - Immediately with auto-association if they have available slots\n    /// @notice     - As a pending airdrop requiring claim if they have \"receiver signature required\" \n    /// @notice     - As a pending airdrop requiring claim if they have no available auto-association slots\n    /// @notice Immediate airdrops are irreversible, pending airdrops can be canceled\n    /// @notice All transfer fees and auto-renewal rent costs are charged to the transaction submitter\n    /// @param tokenTransfers Array of token transfer lists containing token addresses and recipient details\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function airdropTokens(TokenTransferList[] memory tokenTransfers) external returns (int64 responseCode);\n\n    /// @notice Cancels pending airdrops that have not yet been claimed\n    /// @param pendingAirdrops Array of pending airdrops to cancel\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function cancelAirdrops(PendingAirdrop[] memory pendingAirdrops) external returns (int64 responseCode);\n\n    /// @notice Claims pending airdrops that were sent to the calling account\n    /// @param pendingAirdrops Array of pending airdrops to claim\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function claimAirdrops(PendingAirdrop[] memory pendingAirdrops) external returns (int64 responseCode);\n\n    /// @notice Rejects one or more tokens by transferring their full balance from the requesting account to the treasury\n    /// @notice This transfer does not charge any custom fees or royalties defined for the tokens\n    /// @notice For fungible tokens, the requesting account's balance will become 0 and the treasury balance will increase by that amount\n    /// @notice For non-fungible tokens, the requesting account will no longer hold the rejected serial numbers and they will be transferred to the treasury\n    /// @param rejectingAddress The address rejecting the tokens\n    /// @param ftAddresses Array of fungible token addresses to reject\n    /// @param nftIDs Array of NFT IDs to reject\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function rejectTokens(address rejectingAddress, address[] memory ftAddresses, NftID[] memory nftIDs) external returns (int64 responseCode);\n}\n",
            "codeOnlyTokens": 791,
            "startLine": 825,
            "endLine": 870,
            "type": ".sol_part_12",
            "isOversized": false
          }
        ],
        "groupedChunks": [
          {
            "combinedText": "// File: contracts/system-contracts/hedera-token-service/IHederaTokenService.sol\n// Relevant file context:\n// Type: .sol\n\n\n// --- Next chunk ---\n\n// Lines 1-74 (.sol_part_1)\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.9 <0.9.0;\npragma experimental ABIEncoderV2;\n\ninterface IHederaTokenService {\n    /// Transfers cryptocurrency among two or more accounts by making the desired adjustments to their\n    /// balances. Each transfer list can specify up to 10 adjustments. Each negative amount is withdrawn\n    /// from the corresponding account (a sender), and each positive one is added to the corresponding\n    /// account (a receiver). The amounts list must sum to zero. Each amount is a number of tinybars\n    /// (there are 100,000,000 tinybars in one hbar).  If any sender account fails to have sufficient\n    /// hbars, then the entire transaction fails, and none of those transfers occur, though the\n    /// transaction fee is still charged. This transaction must be signed by the keys for all the sending\n    /// accounts, and for any receiving accounts that have receiverSigRequired == true. The signatures\n    /// are in the same order as the accounts, skipping those accounts that don't need a signature.\n    /// @custom:version 0.3.0 previous version did not include isApproval\n    struct AccountAmount {\n        // The Account ID, as a solidity address, that sends/receives cryptocurrency or tokens\n        address accountID;\n\n        // The amount of  the lowest denomination of the given token that\n        // the account sends(negative) or receives(positive)\n        int64 amount;\n\n        // If true then the transfer is expected to be an approved allowance and the\n        // accountID is expected to be the owner. The default is false (omitted).\n        bool isApproval;\n    }\n\n    /// A sender account, a receiver account, and the serial number of an NFT of a Token with\n    /// NON_FUNGIBLE_UNIQUE type. When minting NFTs the sender will be the default AccountID instance\n    /// (0.0.0 aka 0x0) and when burning NFTs, the receiver will be the default AccountID instance.\n    /// @custom:version 0.3.0 previous version did not include isApproval\n    struct NftTransfer {\n        // The solidity address of the sender\n        address senderAccountID;\n\n        // The solidity address of the receiver\n        address receiverAccountID;\n\n        // The serial number of the NFT\n        int64 serialNumber;\n\n        // If true then the transfer is expected to be an approved allowance and the\n        // accountID is expected to be the owner. The default is false (omitted).\n        bool isApproval;\n    }\n\n    struct TokenTransferList {\n        // The ID of the token as a solidity address\n        address token;\n\n        // Applicable to tokens of type FUNGIBLE_COMMON. Multiple list of AccountAmounts, each of which\n        // has an account and amount.\n        AccountAmount[] transfers;\n\n        // Applicable to tokens of type NON_FUNGIBLE_UNIQUE. Multiple list of NftTransfers, each of\n        // which has a sender and receiver account, including the serial number of the NFT\n        NftTransfer[] nftTransfers;\n    }\n\n    struct TransferList {\n        // Multiple list of AccountAmounts, each of which has an account and amount.\n        // Used to transfer hbars between the accounts in the list.\n        AccountAmount[] transfers;\n    }\n\n    /// Expiry properties of a Hedera token - second, autoRenewAccount, autoRenewPeriod\n    struct Expiry {\n        // The epoch second at which the token should expire; if an auto-renew account and period are\n        // specified, this is coerced to the current epoch second plus the autoRenewPeriod\n        int64 second;\n\n        // ID of an account which will be automatically charged to renew the token's expiration, at\n        // autoRenewPeriod interval, expressed as a solidity address\n\n// --- Next chunk ---\n\n// Lines 75-145 (.sol_part_2)\n        address autoRenewAccount;\n\n        // The interval at which the auto-renew account will be charged to extend the token's expiry\n        int64 autoRenewPeriod;\n    }\n\n    /// A Key can be a public key from either the Ed25519 or ECDSA(secp256k1) signature schemes, where\n    /// in the ECDSA(secp256k1) case we require the 33-byte compressed form of the public key. We call\n    /// these public keys <b>primitive keys</b>.\n    /// A Key can also be the ID of a smart contract instance, which is then authorized to perform any\n    /// precompiled contract action that requires this key to sign.\n    /// Note that when a Key is a smart contract ID, it <i>doesn't</i> mean the contract with that ID\n    /// will actually create a cryptographic signature. It only means that when the contract calls a\n    /// precompiled contract, the resulting \"child transaction\" will be authorized to perform any action\n    /// controlled by the Key.\n    /// Exactly one of the possible values should be populated in order for the Key to be valid.\n    struct KeyValue {\n\n        // if set to true, the key of the calling Hedera account will be inherited as the token key\n        bool inheritAccountKey;\n\n        // smart contract instance that is authorized as if it had signed with a key\n        address contractId;\n\n        // Ed25519 public key bytes\n        bytes ed25519;\n\n        // Compressed ECDSA(secp256k1) public key bytes\n        bytes ECDSA_secp256k1;\n\n        // A smart contract that, if the recipient of the active message frame, should be treated\n        // as having signed. (Note this does not mean the <i>code being executed in the frame</i>\n        // will belong to the given contract, since it could be running another contract's code via\n        // <tt>delegatecall</tt>. So setting this key is a more permissive version of setting the\n        // contractID key, which also requires the code in the active message frame belong to the\n        // the contract with the given id.)\n        address delegatableContractId;\n    }\n\n    /// A list of token key types the key should be applied to and the value of the key\n    struct TokenKey {\n\n        // bit field representing the key type. Keys of all types that have corresponding bits set to 1\n        // will be created for the token.\n        // 0th bit: adminKey\n        // 1st bit: kycKey\n        // 2nd bit: freezeKey\n        // 3rd bit: wipeKey\n        // 4th bit: supplyKey\n        // 5th bit: feeScheduleKey\n        // 6th bit: pauseKey\n        // 7th bit: ignored\n        uint keyType;\n\n        // the value that will be set to the key type\n        KeyValue key;\n    }\n\n    /// Basic properties of a Hedera Token - name, symbol, memo, tokenSupplyType, maxSupply,\n    /// treasury, freezeDefault. These properties are related both to Fungible and NFT token types.\n    struct HederaToken {\n        // The publicly visible name of the token. The token name is specified as a Unicode string.\n        // Its UTF-8 encoding cannot exceed 100 bytes, and cannot contain the 0 byte (NUL).\n        string name;\n\n        // The publicly visible token symbol. The token symbol is specified as a Unicode string.\n        // Its UTF-8 encoding cannot exceed 100 bytes, and cannot contain the 0 byte (NUL).\n        string symbol;\n\n        // The ID of the account which will act as a treasury for the token as a solidity address.\n        // This account will receive the specified initial supply or the newly minted NFTs in\n\n// --- Next chunk ---\n\n// Lines 146-252 (.sol_part_3)\n        // the case for NON_FUNGIBLE_UNIQUE Type\n        address treasury;\n\n        // The memo associated with the token (UTF-8 encoding max 100 bytes)\n        string memo;\n\n        // IWA compatibility. Specified the token supply type. Defaults to INFINITE\n        bool tokenSupplyType;\n\n        // IWA Compatibility. Depends on TokenSupplyType. For tokens of type FUNGIBLE_COMMON - the\n        // maximum number of tokens that can be in circulation. For tokens of type NON_FUNGIBLE_UNIQUE -\n        // the maximum number of NFTs (serial numbers) that can be minted. This field can never be changed!\n        int64 maxSupply;\n\n        // The default Freeze status (frozen or unfrozen) of Hedera accounts relative to this token. If\n        // true, an account must be unfrozen before it can receive the token\n        bool freezeDefault;\n\n        // list of keys to set to the token\n        TokenKey[] tokenKeys;\n\n        // expiry properties of a Hedera token - second, autoRenewAccount, autoRenewPeriod\n        Expiry expiry;\n    }\n\n    /// Additional post creation fungible and non fungible properties of a Hedera Token.\n    struct TokenInfo {\n        /// Basic properties of a Hedera Token\n        HederaToken token;\n\n        /// The number of tokens (fungible) or serials (non-fungible) of the token\n        int64 totalSupply;\n\n        /// Specifies whether the token is deleted or not\n        bool deleted;\n\n        /// Specifies whether the token kyc was defaulted with KycNotApplicable (true) or Revoked (false)\n        bool defaultKycStatus;\n\n        /// Specifies whether the token is currently paused or not\n        bool pauseStatus;\n\n        /// The fixed fees collected when transferring the token\n        FixedFee[] fixedFees;\n\n        /// The fractional fees collected when transferring the token\n        FractionalFee[] fractionalFees;\n\n        /// The royalty fees collected when transferring the token\n        RoyaltyFee[] royaltyFees;\n\n        /// The ID of the network ledger\n        string ledgerId;\n    }\n\n    /// Additional fungible properties of a Hedera Token.\n    struct FungibleTokenInfo {\n        /// The shared hedera token info\n        TokenInfo tokenInfo;\n\n        /// The number of decimal places a token is divisible by\n        int32 decimals;\n    }\n\n    /// Additional non fungible properties of a Hedera Token.\n    struct NonFungibleTokenInfo {\n        /// The shared hedera token info\n        TokenInfo tokenInfo;\n\n        /// The serial number of the nft\n        int64 serialNumber;\n\n        /// The account id specifying the owner of the non fungible token\n        address ownerId;\n\n        /// The epoch second at which the token was created.\n        int64 creationTime;\n\n        /// The unique metadata of the NFT\n        bytes metadata;\n\n        /// The account id specifying an account that has been granted spending permissions on this nft\n        address spenderId;\n    }\n\n    /// A fixed number of units (hbar or token) to assess as a fee during a transfer of\n    /// units of the token to which this fixed fee is attached. The denomination of\n    /// the fee depends on the values of tokenId, useHbarsForPayment and\n    /// useCurrentTokenForPayment. Exactly one of the values should be set.\n    struct FixedFee {\n\n        int64 amount;\n\n        // Specifies ID of token that should be used for fixed fee denomination\n        address tokenId;\n\n        // Specifies this fixed fee should be denominated in Hbar\n        bool useHbarsForPayment;\n\n        // Specifies this fixed fee should be denominated in the Token currently being created\n        bool useCurrentTokenForPayment;\n\n        // The ID of the account to receive the custom fee, expressed as a solidity address\n        address feeCollector;\n    }\n\n    /// A fraction of the transferred units of a token to assess as a fee. The amount assessed will never",
            "totalTokens": 2517,
            "chunks": [
              {
                "originalText": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.9 <0.9.0;\npragma experimental ABIEncoderV2;\n\ninterface IHederaTokenService {\n    /// Transfers cryptocurrency among two or more accounts by making the desired adjustments to their\n    /// balances. Each transfer list can specify up to 10 adjustments. Each negative amount is withdrawn\n    /// from the corresponding account (a sender), and each positive one is added to the corresponding\n    /// account (a receiver). The amounts list must sum to zero. Each amount is a number of tinybars\n    /// (there are 100,000,000 tinybars in one hbar).  If any sender account fails to have sufficient\n    /// hbars, then the entire transaction fails, and none of those transfers occur, though the\n    /// transaction fee is still charged. This transaction must be signed by the keys for all the sending\n    /// accounts, and for any receiving accounts that have receiverSigRequired == true. The signatures\n    /// are in the same order as the accounts, skipping those accounts that don't need a signature.\n    /// @custom:version 0.3.0 previous version did not include isApproval\n    struct AccountAmount {\n        // The Account ID, as a solidity address, that sends/receives cryptocurrency or tokens\n        address accountID;\n\n        // The amount of  the lowest denomination of the given token that\n        // the account sends(negative) or receives(positive)\n        int64 amount;\n\n        // If true then the transfer is expected to be an approved allowance and the\n        // accountID is expected to be the owner. The default is false (omitted).\n        bool isApproval;\n    }\n\n    /// A sender account, a receiver account, and the serial number of an NFT of a Token with\n    /// NON_FUNGIBLE_UNIQUE type. When minting NFTs the sender will be the default AccountID instance\n    /// (0.0.0 aka 0x0) and when burning NFTs, the receiver will be the default AccountID instance.\n    /// @custom:version 0.3.0 previous version did not include isApproval\n    struct NftTransfer {\n        // The solidity address of the sender\n        address senderAccountID;\n\n        // The solidity address of the receiver\n        address receiverAccountID;\n\n        // The serial number of the NFT\n        int64 serialNumber;\n\n        // If true then the transfer is expected to be an approved allowance and the\n        // accountID is expected to be the owner. The default is false (omitted).\n        bool isApproval;\n    }\n\n    struct TokenTransferList {\n        // The ID of the token as a solidity address\n        address token;\n\n        // Applicable to tokens of type FUNGIBLE_COMMON. Multiple list of AccountAmounts, each of which\n        // has an account and amount.\n        AccountAmount[] transfers;\n\n        // Applicable to tokens of type NON_FUNGIBLE_UNIQUE. Multiple list of NftTransfers, each of\n        // which has a sender and receiver account, including the serial number of the NFT\n        NftTransfer[] nftTransfers;\n    }\n\n    struct TransferList {\n        // Multiple list of AccountAmounts, each of which has an account and amount.\n        // Used to transfer hbars between the accounts in the list.\n        AccountAmount[] transfers;\n    }\n\n    /// Expiry properties of a Hedera token - second, autoRenewAccount, autoRenewPeriod\n    struct Expiry {\n        // The epoch second at which the token should expire; if an auto-renew account and period are\n        // specified, this is coerced to the current epoch second plus the autoRenewPeriod\n        int64 second;\n\n        // ID of an account which will be automatically charged to renew the token's expiration, at\n        // autoRenewPeriod interval, expressed as a solidity address",
                "codeOnlyTokens": 805,
                "startLine": 1,
                "endLine": 74,
                "type": ".sol_part_1",
                "isOversized": false
              },
              {
                "originalText": "        address autoRenewAccount;\n\n        // The interval at which the auto-renew account will be charged to extend the token's expiry\n        int64 autoRenewPeriod;\n    }\n\n    /// A Key can be a public key from either the Ed25519 or ECDSA(secp256k1) signature schemes, where\n    /// in the ECDSA(secp256k1) case we require the 33-byte compressed form of the public key. We call\n    /// these public keys <b>primitive keys</b>.\n    /// A Key can also be the ID of a smart contract instance, which is then authorized to perform any\n    /// precompiled contract action that requires this key to sign.\n    /// Note that when a Key is a smart contract ID, it <i>doesn't</i> mean the contract with that ID\n    /// will actually create a cryptographic signature. It only means that when the contract calls a\n    /// precompiled contract, the resulting \"child transaction\" will be authorized to perform any action\n    /// controlled by the Key.\n    /// Exactly one of the possible values should be populated in order for the Key to be valid.\n    struct KeyValue {\n\n        // if set to true, the key of the calling Hedera account will be inherited as the token key\n        bool inheritAccountKey;\n\n        // smart contract instance that is authorized as if it had signed with a key\n        address contractId;\n\n        // Ed25519 public key bytes\n        bytes ed25519;\n\n        // Compressed ECDSA(secp256k1) public key bytes\n        bytes ECDSA_secp256k1;\n\n        // A smart contract that, if the recipient of the active message frame, should be treated\n        // as having signed. (Note this does not mean the <i>code being executed in the frame</i>\n        // will belong to the given contract, since it could be running another contract's code via\n        // <tt>delegatecall</tt>. So setting this key is a more permissive version of setting the\n        // contractID key, which also requires the code in the active message frame belong to the\n        // the contract with the given id.)\n        address delegatableContractId;\n    }\n\n    /// A list of token key types the key should be applied to and the value of the key\n    struct TokenKey {\n\n        // bit field representing the key type. Keys of all types that have corresponding bits set to 1\n        // will be created for the token.\n        // 0th bit: adminKey\n        // 1st bit: kycKey\n        // 2nd bit: freezeKey\n        // 3rd bit: wipeKey\n        // 4th bit: supplyKey\n        // 5th bit: feeScheduleKey\n        // 6th bit: pauseKey\n        // 7th bit: ignored\n        uint keyType;\n\n        // the value that will be set to the key type\n        KeyValue key;\n    }\n\n    /// Basic properties of a Hedera Token - name, symbol, memo, tokenSupplyType, maxSupply,\n    /// treasury, freezeDefault. These properties are related both to Fungible and NFT token types.\n    struct HederaToken {\n        // The publicly visible name of the token. The token name is specified as a Unicode string.\n        // Its UTF-8 encoding cannot exceed 100 bytes, and cannot contain the 0 byte (NUL).\n        string name;\n\n        // The publicly visible token symbol. The token symbol is specified as a Unicode string.\n        // Its UTF-8 encoding cannot exceed 100 bytes, and cannot contain the 0 byte (NUL).\n        string symbol;\n\n        // The ID of the account which will act as a treasury for the token as a solidity address.\n        // This account will receive the specified initial supply or the newly minted NFTs in",
                "codeOnlyTokens": 810,
                "startLine": 75,
                "endLine": 145,
                "type": ".sol_part_2",
                "isOversized": false
              },
              {
                "originalText": "        // the case for NON_FUNGIBLE_UNIQUE Type\n        address treasury;\n\n        // The memo associated with the token (UTF-8 encoding max 100 bytes)\n        string memo;\n\n        // IWA compatibility. Specified the token supply type. Defaults to INFINITE\n        bool tokenSupplyType;\n\n        // IWA Compatibility. Depends on TokenSupplyType. For tokens of type FUNGIBLE_COMMON - the\n        // maximum number of tokens that can be in circulation. For tokens of type NON_FUNGIBLE_UNIQUE -\n        // the maximum number of NFTs (serial numbers) that can be minted. This field can never be changed!\n        int64 maxSupply;\n\n        // The default Freeze status (frozen or unfrozen) of Hedera accounts relative to this token. If\n        // true, an account must be unfrozen before it can receive the token\n        bool freezeDefault;\n\n        // list of keys to set to the token\n        TokenKey[] tokenKeys;\n\n        // expiry properties of a Hedera token - second, autoRenewAccount, autoRenewPeriod\n        Expiry expiry;\n    }\n\n    /// Additional post creation fungible and non fungible properties of a Hedera Token.\n    struct TokenInfo {\n        /// Basic properties of a Hedera Token\n        HederaToken token;\n\n        /// The number of tokens (fungible) or serials (non-fungible) of the token\n        int64 totalSupply;\n\n        /// Specifies whether the token is deleted or not\n        bool deleted;\n\n        /// Specifies whether the token kyc was defaulted with KycNotApplicable (true) or Revoked (false)\n        bool defaultKycStatus;\n\n        /// Specifies whether the token is currently paused or not\n        bool pauseStatus;\n\n        /// The fixed fees collected when transferring the token\n        FixedFee[] fixedFees;\n\n        /// The fractional fees collected when transferring the token\n        FractionalFee[] fractionalFees;\n\n        /// The royalty fees collected when transferring the token\n        RoyaltyFee[] royaltyFees;\n\n        /// The ID of the network ledger\n        string ledgerId;\n    }\n\n    /// Additional fungible properties of a Hedera Token.\n    struct FungibleTokenInfo {\n        /// The shared hedera token info\n        TokenInfo tokenInfo;\n\n        /// The number of decimal places a token is divisible by\n        int32 decimals;\n    }\n\n    /// Additional non fungible properties of a Hedera Token.\n    struct NonFungibleTokenInfo {\n        /// The shared hedera token info\n        TokenInfo tokenInfo;\n\n        /// The serial number of the nft\n        int64 serialNumber;\n\n        /// The account id specifying the owner of the non fungible token\n        address ownerId;\n\n        /// The epoch second at which the token was created.\n        int64 creationTime;\n\n        /// The unique metadata of the NFT\n        bytes metadata;\n\n        /// The account id specifying an account that has been granted spending permissions on this nft\n        address spenderId;\n    }\n\n    /// A fixed number of units (hbar or token) to assess as a fee during a transfer of\n    /// units of the token to which this fixed fee is attached. The denomination of\n    /// the fee depends on the values of tokenId, useHbarsForPayment and\n    /// useCurrentTokenForPayment. Exactly one of the values should be set.\n    struct FixedFee {\n\n        int64 amount;\n\n        // Specifies ID of token that should be used for fixed fee denomination\n        address tokenId;\n\n        // Specifies this fixed fee should be denominated in Hbar\n        bool useHbarsForPayment;\n\n        // Specifies this fixed fee should be denominated in the Token currently being created\n        bool useCurrentTokenForPayment;\n\n        // The ID of the account to receive the custom fee, expressed as a solidity address\n        address feeCollector;\n    }\n\n    /// A fraction of the transferred units of a token to assess as a fee. The amount assessed will never",
                "codeOnlyTokens": 817,
                "startLine": 146,
                "endLine": 252,
                "type": ".sol_part_3",
                "isOversized": false
              }
            ],
            "startLine": 1,
            "endLine": 252,
            "groupId": 1
          },
          {
            "combinedText": "// File: contracts/system-contracts/hedera-token-service/IHederaTokenService.sol\n// Relevant file context:\n// Type: .sol\n\n\n// --- Next chunk ---\n\n// Lines 253-332 (.sol_part_4)\n    /// be less than the given minimumAmount, and never greater than the given maximumAmount.  The\n    /// denomination is always units of the token to which this fractional fee is attached.\n    struct FractionalFee {\n        // A rational number's numerator, used to set the amount of a value transfer to collect as a custom fee\n        int64 numerator;\n\n        // A rational number's denominator, used to set the amount of a value transfer to collect as a custom fee\n        int64 denominator;\n\n        // The minimum amount to assess\n        int64 minimumAmount;\n\n        // The maximum amount to assess (zero implies no maximum)\n        int64 maximumAmount;\n        bool netOfTransfers;\n\n        // The ID of the account to receive the custom fee, expressed as a solidity address\n        address feeCollector;\n    }\n\n    /// A fee to assess during a transfer that changes ownership of an NFT. Defines the fraction of\n    /// the fungible value exchanged for an NFT that the ledger should collect as a royalty. (\"Fungible\n    /// value\" includes both ℏ and units of fungible HTS tokens.) When the NFT sender does not receive\n    /// any fungible value, the ledger will assess the fallback fee, if present, to the new NFT owner.\n    /// Royalty fees can only be added to tokens of type type NON_FUNGIBLE_UNIQUE.\n    struct RoyaltyFee {\n        // A fraction's numerator of fungible value exchanged for an NFT to collect as royalty\n        int64 numerator;\n\n        // A fraction's denominator of fungible value exchanged for an NFT to collect as royalty\n        int64 denominator;\n\n        // If present, the fee to assess to the NFT receiver when no fungible value\n        // is exchanged with the sender. Consists of:\n        // amount: the amount to charge for the fee\n        // tokenId: Specifies ID of token that should be used for fixed fee denomination\n        // useHbarsForPayment: Specifies this fee should be denominated in Hbar\n        int64 amount;\n        address tokenId;\n        bool useHbarsForPayment;\n\n        // The ID of the account to receive the custom fee, expressed as a solidity address\n        address feeCollector;\n    }\n\n    /// Represents a pending airdrop of a token or NFT to a receiver\n    /// @param sender The address of the account sending the airdrop\n    /// @param receiver The address of the account receiving the airdrop\n    /// @param token The address of the token being airdropped\n    /// @param serial For NFT airdrops, the serial number of the NFT. For fungible tokens, this should be 0\n    struct PendingAirdrop {\n        address sender;\n        address receiver;\n        address token;\n        int64 serial;\n    }\n\n    /// Represents a unique NFT by its token address and serial number\n    /// @param nft The address of the NFT token\n    /// @param serial The serial number that uniquely identifies this NFT within its token type\n    struct NftID {\n        address nft;\n        int64 serial;\n    }\n\n    /**********************\n     * Direct HTS Calls   *\n     **********************/\n\n    /// Performs transfers among combinations of tokens and hbars\n    /// @param transferList the list of hbar transfers to do\n    /// @param tokenTransfers the list of token transfers to do\n    /// @custom:version 0.3.0 the signature of the previous version was cryptoTransfer(TokenTransferList[] memory tokenTransfers)\n    function cryptoTransfer(TransferList memory transferList, TokenTransferList[] memory tokenTransfers)\n        external\n        returns (int64 responseCode);\n\n    /// Mints an amount of the token to the defined treasury account\n    /// @param token The token for which to mint tokens. If token does not exist, transaction results in\n    ///              INVALID_TOKEN_ID\n\n// --- Next chunk ---\n\n// Lines 333-390 (.sol_part_5)\n    /// @param amount Applicable to tokens of type FUNGIBLE_COMMON. The amount to mint to the Treasury Account.\n    ///               Amount must be a positive non-zero number represented in the lowest denomination of the\n    ///               token. The new supply must be lower than 2^63.\n    /// @param metadata Applicable to tokens of type NON_FUNGIBLE_UNIQUE. A list of metadata that are being created.\n    ///                 Maximum allowed size of each metadata is 100 bytes\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return newTotalSupply The new supply of tokens. For NFTs it is the total count of NFTs\n    /// @return serialNumbers If the token is an NFT the newly generate serial numbers, othersise empty.\n    function mintToken(\n        address token,\n        int64 amount,\n        bytes[] memory metadata\n    )\n        external\n        returns (\n            int64 responseCode,\n            int64 newTotalSupply,\n            int64[] memory serialNumbers\n        );\n\n    /// Burns an amount of the token from the defined treasury account\n    /// @param token The token for which to burn tokens. If token does not exist, transaction results in\n    ///              INVALID_TOKEN_ID\n    /// @param amount  Applicable to tokens of type FUNGIBLE_COMMON. The amount to burn from the Treasury Account.\n    ///                Amount must be a positive non-zero number, not bigger than the token balance of the treasury\n    ///                account (0; balance], represented in the lowest denomination.\n    /// @param serialNumbers Applicable to tokens of type NON_FUNGIBLE_UNIQUE. The list of serial numbers to be burned.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return newTotalSupply The new supply of tokens. For NFTs it is the total count of NFTs\n    function burnToken(\n        address token,\n        int64 amount,\n        int64[] memory serialNumbers\n    ) external returns (int64 responseCode, int64 newTotalSupply);\n\n    ///  Associates the provided account with the provided tokens. Must be signed by the provided\n    ///  Account's key or called from the accounts contract key\n    ///  If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.\n    ///  If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.\n    ///  If any of the provided tokens is not found, the transaction will resolve to INVALID_TOKEN_REF.\n    ///  If any of the provided tokens has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.\n    ///  If an association between the provided account and any of the tokens already exists, the\n    ///  transaction will resolve to TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT.\n    ///  If the provided account's associations count exceed the constraint of maximum token associations\n    ///    per account, the transaction will resolve to TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED.\n    ///  On success, associations between the provided account and tokens are made and the account is\n    ///    ready to interact with the tokens.\n    /// @param account The account to be associated with the provided tokens\n    /// @param tokens The tokens to be associated with the provided account. In the case of NON_FUNGIBLE_UNIQUE\n    ///               Type, once an account is associated, it can hold any number of NFTs (serial numbers) of that\n    ///               token type\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function associateTokens(address account, address[] memory tokens)\n        external\n        returns (int64 responseCode);\n\n    /// Single-token variant of associateTokens. Will be mapped to a single entry array call of associateTokens\n    /// @param account The account to be associated with the provided token\n\n// --- Next chunk ---\n\n// Lines 391-449 (.sol_part_6)\n    /// @param token The token to be associated with the provided account\n    function associateToken(address account, address token)\n        external\n        returns (int64 responseCode);\n\n    /// Dissociates the provided account with the provided tokens. Must be signed by the provided\n    /// Account's key.\n    /// If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.\n    /// If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.\n    /// If any of the provided tokens is not found, the transaction will resolve to INVALID_TOKEN_REF.\n    /// If any of the provided tokens has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.\n    /// If an association between the provided account and any of the tokens does not exist, the\n    /// transaction will resolve to TOKEN_NOT_ASSOCIATED_TO_ACCOUNT.\n    /// If a token has not been deleted and has not expired, and the user has a nonzero balance, the\n    /// transaction will resolve to TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES.\n    /// If a <b>fungible token</b> has expired, the user can disassociate even if their token balance is\n    /// not zero.\n    /// If a <b>non fungible token</b> has expired, the user can <b>not</b> disassociate if their token\n    /// balance is not zero. The transaction will resolve to TRANSACTION_REQUIRED_ZERO_TOKEN_BALANCES.\n    /// On success, associations between the provided account and tokens are removed.\n    /// @param account The account to be dissociated from the provided tokens\n    /// @param tokens The tokens to be dissociated from the provided account.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function dissociateTokens(address account, address[] memory tokens)\n        external\n        returns (int64 responseCode);\n\n    /// Single-token variant of dissociateTokens. Will be mapped to a single entry array call of dissociateTokens\n    /// @param account The account to be associated with the provided token\n    /// @param token The token to be associated with the provided account\n    function dissociateToken(address account, address token)\n        external\n        returns (int64 responseCode);\n\n    /// Creates a Fungible Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @param initialTotalSupply Specifies the initial supply of tokens to be put in circulation. The\n    /// initial supply is sent to the Treasury Account. The supply is in the lowest denomination possible.\n    /// @param decimals the number of decimal places a token is divisible by\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createFungibleToken(\n        HederaToken memory token,\n        int64 initialTotalSupply,\n        int32 decimals\n    ) external payable returns (int64 responseCode, address tokenAddress);\n\n    /// Creates a Fungible Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @param initialTotalSupply Specifies the initial supply of tokens to be put in circulation. The\n    /// initial supply is sent to the Treasury Account. The supply is in the lowest denomination possible.\n    /// @param decimals the number of decimal places a token is divisible by.\n    /// @param fixedFees list of fixed fees to apply to the token\n    /// @param fractionalFees list of fractional fees to apply to the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createFungibleTokenWithCustomFees(\n        HederaToken memory token,\n        int64 initialTotalSupply,",
            "totalTokens": 2497,
            "chunks": [
              {
                "originalText": "    /// be less than the given minimumAmount, and never greater than the given maximumAmount.  The\n    /// denomination is always units of the token to which this fractional fee is attached.\n    struct FractionalFee {\n        // A rational number's numerator, used to set the amount of a value transfer to collect as a custom fee\n        int64 numerator;\n\n        // A rational number's denominator, used to set the amount of a value transfer to collect as a custom fee\n        int64 denominator;\n\n        // The minimum amount to assess\n        int64 minimumAmount;\n\n        // The maximum amount to assess (zero implies no maximum)\n        int64 maximumAmount;\n        bool netOfTransfers;\n\n        // The ID of the account to receive the custom fee, expressed as a solidity address\n        address feeCollector;\n    }\n\n    /// A fee to assess during a transfer that changes ownership of an NFT. Defines the fraction of\n    /// the fungible value exchanged for an NFT that the ledger should collect as a royalty. (\"Fungible\n    /// value\" includes both ℏ and units of fungible HTS tokens.) When the NFT sender does not receive\n    /// any fungible value, the ledger will assess the fallback fee, if present, to the new NFT owner.\n    /// Royalty fees can only be added to tokens of type type NON_FUNGIBLE_UNIQUE.\n    struct RoyaltyFee {\n        // A fraction's numerator of fungible value exchanged for an NFT to collect as royalty\n        int64 numerator;\n\n        // A fraction's denominator of fungible value exchanged for an NFT to collect as royalty\n        int64 denominator;\n\n        // If present, the fee to assess to the NFT receiver when no fungible value\n        // is exchanged with the sender. Consists of:\n        // amount: the amount to charge for the fee\n        // tokenId: Specifies ID of token that should be used for fixed fee denomination\n        // useHbarsForPayment: Specifies this fee should be denominated in Hbar\n        int64 amount;\n        address tokenId;\n        bool useHbarsForPayment;\n\n        // The ID of the account to receive the custom fee, expressed as a solidity address\n        address feeCollector;\n    }\n\n    /// Represents a pending airdrop of a token or NFT to a receiver\n    /// @param sender The address of the account sending the airdrop\n    /// @param receiver The address of the account receiving the airdrop\n    /// @param token The address of the token being airdropped\n    /// @param serial For NFT airdrops, the serial number of the NFT. For fungible tokens, this should be 0\n    struct PendingAirdrop {\n        address sender;\n        address receiver;\n        address token;\n        int64 serial;\n    }\n\n    /// Represents a unique NFT by its token address and serial number\n    /// @param nft The address of the NFT token\n    /// @param serial The serial number that uniquely identifies this NFT within its token type\n    struct NftID {\n        address nft;\n        int64 serial;\n    }\n\n    /**********************\n     * Direct HTS Calls   *\n     **********************/\n\n    /// Performs transfers among combinations of tokens and hbars\n    /// @param transferList the list of hbar transfers to do\n    /// @param tokenTransfers the list of token transfers to do\n    /// @custom:version 0.3.0 the signature of the previous version was cryptoTransfer(TokenTransferList[] memory tokenTransfers)\n    function cryptoTransfer(TransferList memory transferList, TokenTransferList[] memory tokenTransfers)\n        external\n        returns (int64 responseCode);\n\n    /// Mints an amount of the token to the defined treasury account\n    /// @param token The token for which to mint tokens. If token does not exist, transaction results in\n    ///              INVALID_TOKEN_ID",
                "codeOnlyTokens": 801,
                "startLine": 253,
                "endLine": 332,
                "type": ".sol_part_4",
                "isOversized": false
              },
              {
                "originalText": "    /// @param amount Applicable to tokens of type FUNGIBLE_COMMON. The amount to mint to the Treasury Account.\n    ///               Amount must be a positive non-zero number represented in the lowest denomination of the\n    ///               token. The new supply must be lower than 2^63.\n    /// @param metadata Applicable to tokens of type NON_FUNGIBLE_UNIQUE. A list of metadata that are being created.\n    ///                 Maximum allowed size of each metadata is 100 bytes\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return newTotalSupply The new supply of tokens. For NFTs it is the total count of NFTs\n    /// @return serialNumbers If the token is an NFT the newly generate serial numbers, othersise empty.\n    function mintToken(\n        address token,\n        int64 amount,\n        bytes[] memory metadata\n    )\n        external\n        returns (\n            int64 responseCode,\n            int64 newTotalSupply,\n            int64[] memory serialNumbers\n        );\n\n    /// Burns an amount of the token from the defined treasury account\n    /// @param token The token for which to burn tokens. If token does not exist, transaction results in\n    ///              INVALID_TOKEN_ID\n    /// @param amount  Applicable to tokens of type FUNGIBLE_COMMON. The amount to burn from the Treasury Account.\n    ///                Amount must be a positive non-zero number, not bigger than the token balance of the treasury\n    ///                account (0; balance], represented in the lowest denomination.\n    /// @param serialNumbers Applicable to tokens of type NON_FUNGIBLE_UNIQUE. The list of serial numbers to be burned.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return newTotalSupply The new supply of tokens. For NFTs it is the total count of NFTs\n    function burnToken(\n        address token,\n        int64 amount,\n        int64[] memory serialNumbers\n    ) external returns (int64 responseCode, int64 newTotalSupply);\n\n    ///  Associates the provided account with the provided tokens. Must be signed by the provided\n    ///  Account's key or called from the accounts contract key\n    ///  If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.\n    ///  If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.\n    ///  If any of the provided tokens is not found, the transaction will resolve to INVALID_TOKEN_REF.\n    ///  If any of the provided tokens has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.\n    ///  If an association between the provided account and any of the tokens already exists, the\n    ///  transaction will resolve to TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT.\n    ///  If the provided account's associations count exceed the constraint of maximum token associations\n    ///    per account, the transaction will resolve to TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED.\n    ///  On success, associations between the provided account and tokens are made and the account is\n    ///    ready to interact with the tokens.\n    /// @param account The account to be associated with the provided tokens\n    /// @param tokens The tokens to be associated with the provided account. In the case of NON_FUNGIBLE_UNIQUE\n    ///               Type, once an account is associated, it can hold any number of NFTs (serial numbers) of that\n    ///               token type\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function associateTokens(address account, address[] memory tokens)\n        external\n        returns (int64 responseCode);\n\n    /// Single-token variant of associateTokens. Will be mapped to a single entry array call of associateTokens\n    /// @param account The account to be associated with the provided token",
                "codeOnlyTokens": 806,
                "startLine": 333,
                "endLine": 390,
                "type": ".sol_part_5",
                "isOversized": false
              },
              {
                "originalText": "    /// @param token The token to be associated with the provided account\n    function associateToken(address account, address token)\n        external\n        returns (int64 responseCode);\n\n    /// Dissociates the provided account with the provided tokens. Must be signed by the provided\n    /// Account's key.\n    /// If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.\n    /// If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.\n    /// If any of the provided tokens is not found, the transaction will resolve to INVALID_TOKEN_REF.\n    /// If any of the provided tokens has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.\n    /// If an association between the provided account and any of the tokens does not exist, the\n    /// transaction will resolve to TOKEN_NOT_ASSOCIATED_TO_ACCOUNT.\n    /// If a token has not been deleted and has not expired, and the user has a nonzero balance, the\n    /// transaction will resolve to TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES.\n    /// If a <b>fungible token</b> has expired, the user can disassociate even if their token balance is\n    /// not zero.\n    /// If a <b>non fungible token</b> has expired, the user can <b>not</b> disassociate if their token\n    /// balance is not zero. The transaction will resolve to TRANSACTION_REQUIRED_ZERO_TOKEN_BALANCES.\n    /// On success, associations between the provided account and tokens are removed.\n    /// @param account The account to be dissociated from the provided tokens\n    /// @param tokens The tokens to be dissociated from the provided account.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function dissociateTokens(address account, address[] memory tokens)\n        external\n        returns (int64 responseCode);\n\n    /// Single-token variant of dissociateTokens. Will be mapped to a single entry array call of dissociateTokens\n    /// @param account The account to be associated with the provided token\n    /// @param token The token to be associated with the provided account\n    function dissociateToken(address account, address token)\n        external\n        returns (int64 responseCode);\n\n    /// Creates a Fungible Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @param initialTotalSupply Specifies the initial supply of tokens to be put in circulation. The\n    /// initial supply is sent to the Treasury Account. The supply is in the lowest denomination possible.\n    /// @param decimals the number of decimal places a token is divisible by\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createFungibleToken(\n        HederaToken memory token,\n        int64 initialTotalSupply,\n        int32 decimals\n    ) external payable returns (int64 responseCode, address tokenAddress);\n\n    /// Creates a Fungible Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @param initialTotalSupply Specifies the initial supply of tokens to be put in circulation. The\n    /// initial supply is sent to the Treasury Account. The supply is in the lowest denomination possible.\n    /// @param decimals the number of decimal places a token is divisible by.\n    /// @param fixedFees list of fixed fees to apply to the token\n    /// @param fractionalFees list of fractional fees to apply to the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createFungibleTokenWithCustomFees(\n        HederaToken memory token,\n        int64 initialTotalSupply,",
                "codeOnlyTokens": 804,
                "startLine": 391,
                "endLine": 449,
                "type": ".sol_part_6",
                "isOversized": false
              }
            ],
            "startLine": 253,
            "endLine": 449,
            "groupId": 2
          },
          {
            "combinedText": "// File: contracts/system-contracts/hedera-token-service/IHederaTokenService.sol\n// Relevant file context:\n// Type: .sol\n\n\n// --- Next chunk ---\n\n// Lines 450-531 (.sol_part_7)\n        int32 decimals,\n        FixedFee[] memory fixedFees,\n        FractionalFee[] memory fractionalFees\n    ) external payable returns (int64 responseCode, address tokenAddress);\n\n    /// Creates an Non Fungible Unique Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createNonFungibleToken(HederaToken memory token)\n        external\n        payable\n        returns (int64 responseCode, address tokenAddress);\n\n    /// Creates an Non Fungible Unique Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @param fixedFees list of fixed fees to apply to the token\n    /// @param royaltyFees list of royalty fees to apply to the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createNonFungibleTokenWithCustomFees(\n        HederaToken memory token,\n        FixedFee[] memory fixedFees,\n        RoyaltyFee[] memory royaltyFees\n    ) external payable returns (int64 responseCode, address tokenAddress);\n\n    /**********************\n     * ABIV1 calls        *\n     **********************/\n\n    /// Initiates a Fungible Token Transfer\n    /// @param token The ID of the token as a solidity address\n    /// @param accountId account to do a transfer to/from\n    /// @param amount The amount from the accountId at the same index\n    function transferTokens(\n        address token,\n        address[] memory accountId,\n        int64[] memory amount\n    ) external returns (int64 responseCode);\n\n    /// Initiates a Non-Fungable Token Transfer\n    /// @param token The ID of the token as a solidity address\n    /// @param sender the sender of an nft\n    /// @param receiver the receiver of the nft sent by the same index at sender\n    /// @param serialNumber the serial number of the nft sent by the same index at sender\n    function transferNFTs(\n        address token,\n        address[] memory sender,\n        address[] memory receiver,\n        int64[] memory serialNumber\n    ) external returns (int64 responseCode);\n\n    /// Transfers tokens where the calling account/contract is implicitly the first entry in the token transfer list,\n    /// where the amount is the value needed to zero balance the transfers. Regular signing rules apply for sending\n    /// (positive amount) or receiving (negative amount)\n    /// @param token The token to transfer to/from\n    /// @param sender The sender for the transaction\n    /// @param recipient The receiver of the transaction\n    /// @param amount Non-negative value to send. a negative value will result in a failure.\n    function transferToken(\n        address token,\n        address sender,\n        address recipient,\n        int64 amount\n    ) external returns (int64 responseCode);\n\n    /// Transfers tokens where the calling account/contract is implicitly the first entry in the token transfer list,\n    /// where the amount is the value needed to zero balance the transfers. Regular signing rules apply for sending\n    /// (positive amount) or receiving (negative amount)\n    /// @param token The token to transfer to/from\n    /// @param sender The sender for the transaction\n    /// @param recipient The receiver of the transaction\n    /// @param serialNumber The serial number of the NFT to transfer.\n    function transferNFT(\n        address token,\n        address sender,\n        address recipient,\n        int64 serialNumber\n    ) external returns (int64 responseCode);\n\n    /// Allows spender to withdraw from your account multiple times, up to the value amount. If this function is called\n    /// again it overwrites the current allowance with value.\n\n// --- Next chunk ---\n\n// Lines 532-597 (.sol_part_8)\n    /// Only Applicable to Fungible Tokens\n    /// @param token The hedera token address to approve\n    /// @param spender the account address authorized to spend\n    /// @param amount the amount of tokens authorized to spend.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function approve(\n        address token,\n        address spender,\n        uint256 amount\n    ) external returns (int64 responseCode);\n\n    /// Transfers `amount` tokens from `from` to `to` using the\n    //  allowance mechanism. `amount` is then deducted from the caller's allowance.\n    /// Only applicable to fungible tokens\n    /// @param token The address of the fungible Hedera token to transfer\n    /// @param from The account address of the owner of the token, on the behalf of which to transfer `amount` tokens\n    /// @param to The account address of the receiver of the `amount` tokens\n    /// @param amount The amount of tokens to transfer from `from` to `to`\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function transferFrom(address token, address from, address to, uint256 amount) external returns (int64 responseCode);\n\n    /// Returns the amount which spender is still allowed to withdraw from owner.\n    /// Only Applicable to Fungible Tokens\n    /// @param token The Hedera token address to check the allowance of\n    /// @param owner the owner of the tokens to be spent\n    /// @param spender the spender of the tokens\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return allowance The amount which spender is still allowed to withdraw from owner.\n    function allowance(\n        address token,\n        address owner,\n        address spender\n    ) external returns (int64 responseCode, uint256 allowance);\n\n    /// Allow or reaffirm the approved address to transfer an NFT the approved address does not own.\n    /// Only Applicable to NFT Tokens\n    /// @param token The Hedera NFT token address to approve\n    /// @param approved The new approved NFT controller.  To revoke approvals pass in the zero address.\n    /// @param serialNumber The NFT serial number  to approve\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function approveNFT(\n        address token,\n        address approved,\n        uint256 serialNumber\n    ) external returns (int64 responseCode);\n\n    /// Transfers `serialNumber` of `token` from `from` to `to` using the allowance mechanism.\n    /// Only applicable to NFT tokens\n    /// @param token The address of the non-fungible Hedera token to transfer\n    /// @param from The account address of the owner of `serialNumber` of `token`\n    /// @param to The account address of the receiver of `serialNumber`\n    /// @param serialNumber The NFT serial number to transfer\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function transferFromNFT(address token, address from, address to, uint256 serialNumber) external returns (int64 responseCode);\n\n    /// Get the approved address for a single NFT\n    /// Only Applicable to NFT Tokens\n    /// @param token The Hedera NFT token address to check approval\n    /// @param serialNumber The NFT to find the approved address for\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return approved The approved address for this NFT, or the zero address if there is none\n    function getApproved(address token, uint256 serialNumber)\n        external\n        returns (int64 responseCode, address approved);\n\n    /// Enable or disable approval for a third party (\"operator\") to manage\n\n// --- Next chunk ---\n\n// Lines 598-669 (.sol_part_9)\n    ///  all of `msg.sender`'s assets\n    /// @param token The Hedera NFT token address to approve\n    /// @param operator Address to add to the set of authorized operators\n    /// @param approved True if the operator is approved, false to revoke approval\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function setApprovalForAll(\n        address token,\n        address operator,\n        bool approved\n    ) external returns (int64 responseCode);\n\n    /// Query if an address is an authorized operator for another address\n    /// Only Applicable to NFT Tokens\n    /// @param token The Hedera NFT token address to approve\n    /// @param owner The address that owns the NFTs\n    /// @param operator The address that acts on behalf of the owner\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return approved True if `operator` is an approved operator for `owner`, false otherwise\n    function isApprovedForAll(\n        address token,\n        address owner,\n        address operator\n    ) external returns (int64 responseCode, bool approved);\n\n    /// Query if token account is frozen\n    /// @param token The token address to check\n    /// @param account The account address associated with the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return frozen True if `account` is frozen for `token`\n    function isFrozen(address token, address account)\n        external\n        returns (int64 responseCode, bool frozen);\n\n    /// Query if token account has kyc granted\n    /// @param token The token address to check\n    /// @param account The account address associated with the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return kycGranted True if `account` has kyc granted for `token`\n    function isKyc(address token, address account)\n        external\n        returns (int64 responseCode, bool kycGranted);\n\n    /// Operation to delete token\n    /// @param token The token address to be deleted\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function deleteToken(address token) external returns (int64 responseCode);\n\n    /// Query token custom fees\n    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return fixedFees Set of fixed fees for `token`\n    /// @return fractionalFees Set of fractional fees for `token`\n    /// @return royaltyFees Set of royalty fees for `token`\n    function getTokenCustomFees(address token)\n        external\n        returns (int64 responseCode, FixedFee[] memory fixedFees, FractionalFee[] memory fractionalFees, RoyaltyFee[] memory royaltyFees);\n\n    /// Query token default freeze status\n    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return defaultFreezeStatus True if `token` default freeze status is frozen.\n    function getTokenDefaultFreezeStatus(address token)\n        external\n        returns (int64 responseCode, bool defaultFreezeStatus);\n\n    /// Query token default kyc status\n    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return defaultKycStatus True if `token` default kyc status is KycNotApplicable and false if Revoked.\n    function getTokenDefaultKycStatus(address token)\n        external\n        returns (int64 responseCode, bool defaultKycStatus);",
            "totalTokens": 2502,
            "chunks": [
              {
                "originalText": "        int32 decimals,\n        FixedFee[] memory fixedFees,\n        FractionalFee[] memory fractionalFees\n    ) external payable returns (int64 responseCode, address tokenAddress);\n\n    /// Creates an Non Fungible Unique Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createNonFungibleToken(HederaToken memory token)\n        external\n        payable\n        returns (int64 responseCode, address tokenAddress);\n\n    /// Creates an Non Fungible Unique Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @param fixedFees list of fixed fees to apply to the token\n    /// @param royaltyFees list of royalty fees to apply to the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createNonFungibleTokenWithCustomFees(\n        HederaToken memory token,\n        FixedFee[] memory fixedFees,\n        RoyaltyFee[] memory royaltyFees\n    ) external payable returns (int64 responseCode, address tokenAddress);\n\n    /**********************\n     * ABIV1 calls        *\n     **********************/\n\n    /// Initiates a Fungible Token Transfer\n    /// @param token The ID of the token as a solidity address\n    /// @param accountId account to do a transfer to/from\n    /// @param amount The amount from the accountId at the same index\n    function transferTokens(\n        address token,\n        address[] memory accountId,\n        int64[] memory amount\n    ) external returns (int64 responseCode);\n\n    /// Initiates a Non-Fungable Token Transfer\n    /// @param token The ID of the token as a solidity address\n    /// @param sender the sender of an nft\n    /// @param receiver the receiver of the nft sent by the same index at sender\n    /// @param serialNumber the serial number of the nft sent by the same index at sender\n    function transferNFTs(\n        address token,\n        address[] memory sender,\n        address[] memory receiver,\n        int64[] memory serialNumber\n    ) external returns (int64 responseCode);\n\n    /// Transfers tokens where the calling account/contract is implicitly the first entry in the token transfer list,\n    /// where the amount is the value needed to zero balance the transfers. Regular signing rules apply for sending\n    /// (positive amount) or receiving (negative amount)\n    /// @param token The token to transfer to/from\n    /// @param sender The sender for the transaction\n    /// @param recipient The receiver of the transaction\n    /// @param amount Non-negative value to send. a negative value will result in a failure.\n    function transferToken(\n        address token,\n        address sender,\n        address recipient,\n        int64 amount\n    ) external returns (int64 responseCode);\n\n    /// Transfers tokens where the calling account/contract is implicitly the first entry in the token transfer list,\n    /// where the amount is the value needed to zero balance the transfers. Regular signing rules apply for sending\n    /// (positive amount) or receiving (negative amount)\n    /// @param token The token to transfer to/from\n    /// @param sender The sender for the transaction\n    /// @param recipient The receiver of the transaction\n    /// @param serialNumber The serial number of the NFT to transfer.\n    function transferNFT(\n        address token,\n        address sender,\n        address recipient,\n        int64 serialNumber\n    ) external returns (int64 responseCode);\n\n    /// Allows spender to withdraw from your account multiple times, up to the value amount. If this function is called\n    /// again it overwrites the current allowance with value.",
                "codeOnlyTokens": 809,
                "startLine": 450,
                "endLine": 531,
                "type": ".sol_part_7",
                "isOversized": false
              },
              {
                "originalText": "    /// Only Applicable to Fungible Tokens\n    /// @param token The hedera token address to approve\n    /// @param spender the account address authorized to spend\n    /// @param amount the amount of tokens authorized to spend.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function approve(\n        address token,\n        address spender,\n        uint256 amount\n    ) external returns (int64 responseCode);\n\n    /// Transfers `amount` tokens from `from` to `to` using the\n    //  allowance mechanism. `amount` is then deducted from the caller's allowance.\n    /// Only applicable to fungible tokens\n    /// @param token The address of the fungible Hedera token to transfer\n    /// @param from The account address of the owner of the token, on the behalf of which to transfer `amount` tokens\n    /// @param to The account address of the receiver of the `amount` tokens\n    /// @param amount The amount of tokens to transfer from `from` to `to`\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function transferFrom(address token, address from, address to, uint256 amount) external returns (int64 responseCode);\n\n    /// Returns the amount which spender is still allowed to withdraw from owner.\n    /// Only Applicable to Fungible Tokens\n    /// @param token The Hedera token address to check the allowance of\n    /// @param owner the owner of the tokens to be spent\n    /// @param spender the spender of the tokens\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return allowance The amount which spender is still allowed to withdraw from owner.\n    function allowance(\n        address token,\n        address owner,\n        address spender\n    ) external returns (int64 responseCode, uint256 allowance);\n\n    /// Allow or reaffirm the approved address to transfer an NFT the approved address does not own.\n    /// Only Applicable to NFT Tokens\n    /// @param token The Hedera NFT token address to approve\n    /// @param approved The new approved NFT controller.  To revoke approvals pass in the zero address.\n    /// @param serialNumber The NFT serial number  to approve\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function approveNFT(\n        address token,\n        address approved,\n        uint256 serialNumber\n    ) external returns (int64 responseCode);\n\n    /// Transfers `serialNumber` of `token` from `from` to `to` using the allowance mechanism.\n    /// Only applicable to NFT tokens\n    /// @param token The address of the non-fungible Hedera token to transfer\n    /// @param from The account address of the owner of `serialNumber` of `token`\n    /// @param to The account address of the receiver of `serialNumber`\n    /// @param serialNumber The NFT serial number to transfer\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function transferFromNFT(address token, address from, address to, uint256 serialNumber) external returns (int64 responseCode);\n\n    /// Get the approved address for a single NFT\n    /// Only Applicable to NFT Tokens\n    /// @param token The Hedera NFT token address to check approval\n    /// @param serialNumber The NFT to find the approved address for\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return approved The approved address for this NFT, or the zero address if there is none\n    function getApproved(address token, uint256 serialNumber)\n        external\n        returns (int64 responseCode, address approved);\n\n    /// Enable or disable approval for a third party (\"operator\") to manage",
                "codeOnlyTokens": 806,
                "startLine": 532,
                "endLine": 597,
                "type": ".sol_part_8",
                "isOversized": false
              },
              {
                "originalText": "    ///  all of `msg.sender`'s assets\n    /// @param token The Hedera NFT token address to approve\n    /// @param operator Address to add to the set of authorized operators\n    /// @param approved True if the operator is approved, false to revoke approval\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function setApprovalForAll(\n        address token,\n        address operator,\n        bool approved\n    ) external returns (int64 responseCode);\n\n    /// Query if an address is an authorized operator for another address\n    /// Only Applicable to NFT Tokens\n    /// @param token The Hedera NFT token address to approve\n    /// @param owner The address that owns the NFTs\n    /// @param operator The address that acts on behalf of the owner\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return approved True if `operator` is an approved operator for `owner`, false otherwise\n    function isApprovedForAll(\n        address token,\n        address owner,\n        address operator\n    ) external returns (int64 responseCode, bool approved);\n\n    /// Query if token account is frozen\n    /// @param token The token address to check\n    /// @param account The account address associated with the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return frozen True if `account` is frozen for `token`\n    function isFrozen(address token, address account)\n        external\n        returns (int64 responseCode, bool frozen);\n\n    /// Query if token account has kyc granted\n    /// @param token The token address to check\n    /// @param account The account address associated with the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return kycGranted True if `account` has kyc granted for `token`\n    function isKyc(address token, address account)\n        external\n        returns (int64 responseCode, bool kycGranted);\n\n    /// Operation to delete token\n    /// @param token The token address to be deleted\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function deleteToken(address token) external returns (int64 responseCode);\n\n    /// Query token custom fees\n    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return fixedFees Set of fixed fees for `token`\n    /// @return fractionalFees Set of fractional fees for `token`\n    /// @return royaltyFees Set of royalty fees for `token`\n    function getTokenCustomFees(address token)\n        external\n        returns (int64 responseCode, FixedFee[] memory fixedFees, FractionalFee[] memory fractionalFees, RoyaltyFee[] memory royaltyFees);\n\n    /// Query token default freeze status\n    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return defaultFreezeStatus True if `token` default freeze status is frozen.\n    function getTokenDefaultFreezeStatus(address token)\n        external\n        returns (int64 responseCode, bool defaultFreezeStatus);\n\n    /// Query token default kyc status\n    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return defaultKycStatus True if `token` default kyc status is KycNotApplicable and false if Revoked.\n    function getTokenDefaultKycStatus(address token)\n        external\n        returns (int64 responseCode, bool defaultKycStatus);",
                "codeOnlyTokens": 803,
                "startLine": 598,
                "endLine": 669,
                "type": ".sol_part_9",
                "isOversized": false
              }
            ],
            "startLine": 450,
            "endLine": 669,
            "groupId": 3
          },
          {
            "combinedText": "// File: contracts/system-contracts/hedera-token-service/IHederaTokenService.sol\n// Relevant file context:\n// Type: .sol\n\n\n// --- Next chunk ---\n\n// Lines 670-747 (.sol_part_10)\n\n    /// Query token expiry info\n    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return expiry Expiry info for `token`\n    function getTokenExpiryInfo(address token)\n        external\n        returns (int64 responseCode, Expiry memory expiry);\n\n    /// Query fungible token info\n    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return fungibleTokenInfo FungibleTokenInfo info for `token`\n    function getFungibleTokenInfo(address token)\n        external\n        returns (int64 responseCode, FungibleTokenInfo memory fungibleTokenInfo);\n\n    /// Query token info\n    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenInfo TokenInfo info for `token`\n    function getTokenInfo(address token)\n        external\n        returns (int64 responseCode, TokenInfo memory tokenInfo);\n\n    /// Query token KeyValue\n    /// @param token The token address to check\n    /// @param keyType The keyType of the desired KeyValue\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return key KeyValue info for key of type `keyType`\n    function getTokenKey(address token, uint keyType)\n        external\n        returns (int64 responseCode, KeyValue memory key);\n\n    /// Query non fungible token info\n    /// @param token The token address to check\n    /// @param serialNumber The NFT serialNumber to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return nonFungibleTokenInfo NonFungibleTokenInfo info for `token` `serialNumber`\n    function getNonFungibleTokenInfo(address token, int64 serialNumber)\n        external\n        returns (int64 responseCode, NonFungibleTokenInfo memory nonFungibleTokenInfo);\n\n    /// Operation to freeze token account\n    /// @param token The token address\n    /// @param account The account address to be frozen\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function freezeToken(address token, address account)\n        external\n        returns (int64 responseCode);\n\n    /// Operation to unfreeze token account\n    /// @param token The token address\n    /// @param account The account address to be unfrozen\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function unfreezeToken(address token, address account)\n        external\n        returns (int64 responseCode);\n\n    /// Operation to grant kyc to token account\n    /// @param token The token address\n    /// @param account The account address to grant kyc\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function grantTokenKyc(address token, address account)\n        external\n        returns (int64 responseCode);\n\n    /// Operation to revoke kyc to token account\n    /// @param token The token address\n    /// @param account The account address to revoke kyc\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function revokeTokenKyc(address token, address account)\n        external\n        returns (int64 responseCode);\n\n    /// Operation to pause token\n    /// @param token The token address to be paused\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n\n// --- Next chunk ---\n\n// Lines 748-824 (.sol_part_11)\n    function pauseToken(address token) external returns (int64 responseCode);\n\n    /// Operation to unpause token\n    /// @param token The token address to be unpaused\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function unpauseToken(address token) external returns (int64 responseCode);\n\n    /// Operation to wipe fungible tokens from account\n    /// @param token The token address\n    /// @param account The account address to revoke kyc\n    /// @param amount The number of tokens to wipe\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function wipeTokenAccount(\n        address token,\n        address account,\n        int64 amount\n    ) external returns (int64 responseCode);\n\n    /// Operation to wipe non fungible tokens from account\n    /// @param token The token address\n    /// @param account The account address to revoke kyc\n    /// @param  serialNumbers The serial numbers of token to wipe\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function wipeTokenAccountNFT(\n        address token,\n        address account,\n        int64[] memory serialNumbers\n    ) external returns (int64 responseCode);\n\n    /// Operation to update token info\n    /// @param token The token address\n    /// @param tokenInfo The hedera token info to update token with\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateTokenInfo(address token, HederaToken memory tokenInfo)\n        external\n        returns (int64 responseCode);\n\n    /// Operation to update token expiry info\n    /// @param token The token address\n    /// @param expiryInfo The hedera token expiry info\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateTokenExpiryInfo(address token, Expiry memory expiryInfo)\n        external\n        returns (int64 responseCode);\n\n    /// Operation to update token expiry info\n    /// @param token The token address\n    /// @param keys The token keys\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateTokenKeys(address token, TokenKey[] memory keys)\n        external\n        returns (int64 responseCode);\n\n    /// Query if valid token found for the given address\n    /// @param token The token address\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return isToken True if valid token found for the given address\n    function isToken(address token)\n        external returns\n        (int64 responseCode, bool isToken);\n\n    /// Query to return the token type for a given address\n    /// @param token The token address\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenType the token type. 0 is FUNGIBLE_COMMON, 1 is NON_FUNGIBLE_UNIQUE, -1 is UNRECOGNIZED\n    function getTokenType(address token)\n        external returns\n        (int64 responseCode, int32 tokenType);\n\n    /// Initiates a Redirect For Token\n    /// @param token The token address\n    /// @param encodedFunctionSelector The function selector from the ERC20 interface + the bytes input for the function called\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return response The result of the call that had been encoded and sent for execution.\n    function redirectForToken(address token, bytes memory encodedFunctionSelector) external returns (int64 responseCode, bytes memory response);\n\n    /// Update the custom fees for a fungible token\n\n// --- Next chunk ---\n\n// Lines 825-870 (.sol_part_12)\n    /// @param token The token address\n    /// @param fixedFees Set of fixed fees for `token`\n    /// @param fractionalFees Set of fractional fees for `token`\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateFungibleTokenCustomFees(address token,  IHederaTokenService.FixedFee[] memory fixedFees, IHederaTokenService.FractionalFee[] memory fractionalFees) external returns (int64 responseCode);\n\n    /// Update the custom fees for a non-fungible token\n    /// @param token The token address\n    /// @param fixedFees Set of fixed fees for `token`\n    /// @param royaltyFees Set of royalty fees for `token`\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateNonFungibleTokenCustomFees(address token, IHederaTokenService.FixedFee[] memory fixedFees, IHederaTokenService.RoyaltyFee[] memory royaltyFees) external returns (int64 responseCode);\n\n    /// @notice Airdrop one or more tokens to one or more accounts\n    /// @notice Recipients will receive tokens in one of these ways:\n    /// @notice     - Immediately if already associated with the token\n    /// @notice     - Immediately with auto-association if they have available slots\n    /// @notice     - As a pending airdrop requiring claim if they have \"receiver signature required\" \n    /// @notice     - As a pending airdrop requiring claim if they have no available auto-association slots\n    /// @notice Immediate airdrops are irreversible, pending airdrops can be canceled\n    /// @notice All transfer fees and auto-renewal rent costs are charged to the transaction submitter\n    /// @param tokenTransfers Array of token transfer lists containing token addresses and recipient details\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function airdropTokens(TokenTransferList[] memory tokenTransfers) external returns (int64 responseCode);\n\n    /// @notice Cancels pending airdrops that have not yet been claimed\n    /// @param pendingAirdrops Array of pending airdrops to cancel\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function cancelAirdrops(PendingAirdrop[] memory pendingAirdrops) external returns (int64 responseCode);\n\n    /// @notice Claims pending airdrops that were sent to the calling account\n    /// @param pendingAirdrops Array of pending airdrops to claim\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function claimAirdrops(PendingAirdrop[] memory pendingAirdrops) external returns (int64 responseCode);\n\n    /// @notice Rejects one or more tokens by transferring their full balance from the requesting account to the treasury\n    /// @notice This transfer does not charge any custom fees or royalties defined for the tokens\n    /// @notice For fungible tokens, the requesting account's balance will become 0 and the treasury balance will increase by that amount\n    /// @notice For non-fungible tokens, the requesting account will no longer hold the rejected serial numbers and they will be transferred to the treasury\n    /// @param rejectingAddress The address rejecting the tokens\n    /// @param ftAddresses Array of fungible token addresses to reject\n    /// @param nftIDs Array of NFT IDs to reject\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function rejectTokens(address rejectingAddress, address[] memory ftAddresses, NftID[] memory nftIDs) external returns (int64 responseCode);\n}\n",
            "totalTokens": 2479,
            "chunks": [
              {
                "originalText": "\n    /// Query token expiry info\n    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return expiry Expiry info for `token`\n    function getTokenExpiryInfo(address token)\n        external\n        returns (int64 responseCode, Expiry memory expiry);\n\n    /// Query fungible token info\n    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return fungibleTokenInfo FungibleTokenInfo info for `token`\n    function getFungibleTokenInfo(address token)\n        external\n        returns (int64 responseCode, FungibleTokenInfo memory fungibleTokenInfo);\n\n    /// Query token info\n    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenInfo TokenInfo info for `token`\n    function getTokenInfo(address token)\n        external\n        returns (int64 responseCode, TokenInfo memory tokenInfo);\n\n    /// Query token KeyValue\n    /// @param token The token address to check\n    /// @param keyType The keyType of the desired KeyValue\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return key KeyValue info for key of type `keyType`\n    function getTokenKey(address token, uint keyType)\n        external\n        returns (int64 responseCode, KeyValue memory key);\n\n    /// Query non fungible token info\n    /// @param token The token address to check\n    /// @param serialNumber The NFT serialNumber to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return nonFungibleTokenInfo NonFungibleTokenInfo info for `token` `serialNumber`\n    function getNonFungibleTokenInfo(address token, int64 serialNumber)\n        external\n        returns (int64 responseCode, NonFungibleTokenInfo memory nonFungibleTokenInfo);\n\n    /// Operation to freeze token account\n    /// @param token The token address\n    /// @param account The account address to be frozen\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function freezeToken(address token, address account)\n        external\n        returns (int64 responseCode);\n\n    /// Operation to unfreeze token account\n    /// @param token The token address\n    /// @param account The account address to be unfrozen\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function unfreezeToken(address token, address account)\n        external\n        returns (int64 responseCode);\n\n    /// Operation to grant kyc to token account\n    /// @param token The token address\n    /// @param account The account address to grant kyc\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function grantTokenKyc(address token, address account)\n        external\n        returns (int64 responseCode);\n\n    /// Operation to revoke kyc to token account\n    /// @param token The token address\n    /// @param account The account address to revoke kyc\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function revokeTokenKyc(address token, address account)\n        external\n        returns (int64 responseCode);\n\n    /// Operation to pause token\n    /// @param token The token address to be paused\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.",
                "codeOnlyTokens": 800,
                "startLine": 670,
                "endLine": 747,
                "type": ".sol_part_10",
                "isOversized": false
              },
              {
                "originalText": "    function pauseToken(address token) external returns (int64 responseCode);\n\n    /// Operation to unpause token\n    /// @param token The token address to be unpaused\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function unpauseToken(address token) external returns (int64 responseCode);\n\n    /// Operation to wipe fungible tokens from account\n    /// @param token The token address\n    /// @param account The account address to revoke kyc\n    /// @param amount The number of tokens to wipe\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function wipeTokenAccount(\n        address token,\n        address account,\n        int64 amount\n    ) external returns (int64 responseCode);\n\n    /// Operation to wipe non fungible tokens from account\n    /// @param token The token address\n    /// @param account The account address to revoke kyc\n    /// @param  serialNumbers The serial numbers of token to wipe\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function wipeTokenAccountNFT(\n        address token,\n        address account,\n        int64[] memory serialNumbers\n    ) external returns (int64 responseCode);\n\n    /// Operation to update token info\n    /// @param token The token address\n    /// @param tokenInfo The hedera token info to update token with\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateTokenInfo(address token, HederaToken memory tokenInfo)\n        external\n        returns (int64 responseCode);\n\n    /// Operation to update token expiry info\n    /// @param token The token address\n    /// @param expiryInfo The hedera token expiry info\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateTokenExpiryInfo(address token, Expiry memory expiryInfo)\n        external\n        returns (int64 responseCode);\n\n    /// Operation to update token expiry info\n    /// @param token The token address\n    /// @param keys The token keys\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateTokenKeys(address token, TokenKey[] memory keys)\n        external\n        returns (int64 responseCode);\n\n    /// Query if valid token found for the given address\n    /// @param token The token address\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return isToken True if valid token found for the given address\n    function isToken(address token)\n        external returns\n        (int64 responseCode, bool isToken);\n\n    /// Query to return the token type for a given address\n    /// @param token The token address\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenType the token type. 0 is FUNGIBLE_COMMON, 1 is NON_FUNGIBLE_UNIQUE, -1 is UNRECOGNIZED\n    function getTokenType(address token)\n        external returns\n        (int64 responseCode, int32 tokenType);\n\n    /// Initiates a Redirect For Token\n    /// @param token The token address\n    /// @param encodedFunctionSelector The function selector from the ERC20 interface + the bytes input for the function called\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return response The result of the call that had been encoded and sent for execution.\n    function redirectForToken(address token, bytes memory encodedFunctionSelector) external returns (int64 responseCode, bytes memory response);\n\n    /// Update the custom fees for a fungible token",
                "codeOnlyTokens": 805,
                "startLine": 748,
                "endLine": 824,
                "type": ".sol_part_11",
                "isOversized": false
              },
              {
                "originalText": "    /// @param token The token address\n    /// @param fixedFees Set of fixed fees for `token`\n    /// @param fractionalFees Set of fractional fees for `token`\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateFungibleTokenCustomFees(address token,  IHederaTokenService.FixedFee[] memory fixedFees, IHederaTokenService.FractionalFee[] memory fractionalFees) external returns (int64 responseCode);\n\n    /// Update the custom fees for a non-fungible token\n    /// @param token The token address\n    /// @param fixedFees Set of fixed fees for `token`\n    /// @param royaltyFees Set of royalty fees for `token`\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateNonFungibleTokenCustomFees(address token, IHederaTokenService.FixedFee[] memory fixedFees, IHederaTokenService.RoyaltyFee[] memory royaltyFees) external returns (int64 responseCode);\n\n    /// @notice Airdrop one or more tokens to one or more accounts\n    /// @notice Recipients will receive tokens in one of these ways:\n    /// @notice     - Immediately if already associated with the token\n    /// @notice     - Immediately with auto-association if they have available slots\n    /// @notice     - As a pending airdrop requiring claim if they have \"receiver signature required\" \n    /// @notice     - As a pending airdrop requiring claim if they have no available auto-association slots\n    /// @notice Immediate airdrops are irreversible, pending airdrops can be canceled\n    /// @notice All transfer fees and auto-renewal rent costs are charged to the transaction submitter\n    /// @param tokenTransfers Array of token transfer lists containing token addresses and recipient details\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function airdropTokens(TokenTransferList[] memory tokenTransfers) external returns (int64 responseCode);\n\n    /// @notice Cancels pending airdrops that have not yet been claimed\n    /// @param pendingAirdrops Array of pending airdrops to cancel\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function cancelAirdrops(PendingAirdrop[] memory pendingAirdrops) external returns (int64 responseCode);\n\n    /// @notice Claims pending airdrops that were sent to the calling account\n    /// @param pendingAirdrops Array of pending airdrops to claim\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function claimAirdrops(PendingAirdrop[] memory pendingAirdrops) external returns (int64 responseCode);\n\n    /// @notice Rejects one or more tokens by transferring their full balance from the requesting account to the treasury\n    /// @notice This transfer does not charge any custom fees or royalties defined for the tokens\n    /// @notice For fungible tokens, the requesting account's balance will become 0 and the treasury balance will increase by that amount\n    /// @notice For non-fungible tokens, the requesting account will no longer hold the rejected serial numbers and they will be transferred to the treasury\n    /// @param rejectingAddress The address rejecting the tokens\n    /// @param ftAddresses Array of fungible token addresses to reject\n    /// @param nftIDs Array of NFT IDs to reject\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function rejectTokens(address rejectingAddress, address[] memory ftAddresses, NftID[] memory nftIDs) external returns (int64 responseCode);\n}\n",
                "codeOnlyTokens": 791,
                "startLine": 825,
                "endLine": 870,
                "type": ".sol_part_12",
                "isOversized": false
              }
            ],
            "startLine": 670,
            "endLine": 870,
            "groupId": 4
          }
        ],
        "oversizedChunks": [],
        "sendStrategy": "multiple_groups",
        "finalTokenCount": 9995,
        "skippedContent": [],
        "contextHeader": "// File: contracts/system-contracts/hedera-token-service/IHederaTokenService.sol\n// Relevant file context:\n// Type: .sol\n",
        "tokenBreakdown": {
          "originalFile": 9663,
          "finalSent": 9995,
          "codeTokensInGroups": 9657,
          "fileHeaderTokensInGroups": 120,
          "shellContextTokensInGroups": 0,
          "separatorTokensInGroups": 218,
          "skippedCodeTokens": 0,
          "unprocessedOversizedTokens": 0,
          "totalSavings": -332,
          "savingsPercentage": -3.4357859877884716,
          "fileHeaderCount": 4,
          "fileHeaderAvgSize": 30,
          "shellContextCount": 0,
          "shellContextAvgSize": 0,
          "separatorCount": 12,
          "separatorAvgSize": 18
        }
      }
    },
    {
      "filePath": "repo_cache/hedera-smart-contracts/system-contract-dapp-playground/src/api/hedera/hts-interactions/tokenQuery-interactions/index.ts",
      "totalOriginalTokens": 4341,
      "finalTokenCount": 4517,
      "impactScore": 53.66666666666667,
      "averageComplexity": 7,
      "averageQuality": 8,
      "usage": {
        "prompt_tokens": 6212,
        "completion_tokens": 244,
        "total_tokens": 6456
      },
      "retries": 0,
      "hadError": false,
      "scoredChunkGroups": [
        {
          "groupId": 1,
          "score": {
            "complexity_score": 7,
            "code_quality_score": 8,
            "maintainability_score": 7,
            "best_practices_adherence": 8,
            "positive_feedback": "The dynamic gas estimation functionality enhances user experience by optimizing transaction fees, addressing a common pain point in the Hedera ecosystem.",
            "improvement_suggestion": "Refactor to reduce code duplication in gas limit estimation; abstract gas estimation into a reusable function to streamline processes across methods.",
            "group_summary": "This code queries token validity and general information from the Hedera Token Service using adaptable methods."
          },
          "totalTokens": 2512,
          "usage": {
            "prompt_tokens": 3355,
            "completion_tokens": 128,
            "total_tokens": 3483,
            "prompt_tokens_details": {
              "cached_tokens": 0,
              "audio_tokens": 0
            },
            "completion_tokens_details": {
              "reasoning_tokens": 0,
              "audio_tokens": 0,
              "accepted_prediction_tokens": 0,
              "rejected_prediction_tokens": 0
            }
          }
        },
        {
          "groupId": 2,
          "score": {
            "complexity_score": 7,
            "code_quality_score": 8,
            "maintainability_score": 7,
            "best_practices_adherence": 8,
            "positive_feedback": "The implementation elegantly manages varying API calls while ensuring appropriate handling of gas estimation for Hedera transactions.",
            "improvement_suggestion": "Consider adding more robust error handling and logging mechanisms to improve debugging processes for transaction failures.",
            "group_summary": "This code queries and manages permission and status information for Hedera tokens with dynamic API handling."
          },
          "totalTokens": 2005,
          "usage": {
            "prompt_tokens": 2857,
            "completion_tokens": 116,
            "total_tokens": 2973,
            "prompt_tokens_details": {
              "cached_tokens": 0,
              "audio_tokens": 0
            },
            "completion_tokens_details": {
              "reasoning_tokens": 0,
              "audio_tokens": 0,
              "accepted_prediction_tokens": 0,
              "rejected_prediction_tokens": 0
            }
          }
        }
      ],
      "chunkingDetails": {
        "filePath": "repo_cache/hedera-smart-contracts/system-contract-dapp-playground/src/api/hedera/hts-interactions/tokenQuery-interactions/index.ts",
        "totalFileTokens": 4341,
        "chunks": [
          {
            "originalText": "// SPDX-License-Identifier: Apache-2.0\n\nimport { Contract, ethers, isAddress } from 'ethers';\nimport { ISmartContractExecutionResult } from '@/types/contract-interactions/shared';\nimport { KEY_TYPE_MAP } from '@/utils/contract-interactions/HTS/token-create-custom/constant';\nimport {\n  convertsArgsProxyToHTSSpecificInfo,\n  convertsArgsProxyToHTSTokenInfo,\n  handleContractResponseWithDynamicEventNames,\n} from '@/utils/contract-interactions/HTS/helpers';\nimport { TNetworkName } from '@/types/common';\nimport { handleEstimateGas } from '@/utils/common/helpers';\n\n/**\n * @dev queries token validity\n *\n * @dev integrates TokenQueryContract.isTokenPublic()\n *\n * @param baseContract: ethers.Contract\n *\n * @param signerAddress: ethers.AddressLike\n *\n * @param network: TNetworkName\n *\n * @param hederaTokenAddress: ethers.AddressLike\n *\n * @param gasLimit: number\n *\n * @return Promise<ISmartContractExecutionResult>\n */\nexport const queryTokenValidity = async (\n  baseContract: Contract,\n  signerAddress: ethers.AddressLike,\n  network: TNetworkName,\n  hederaTokenAddress: ethers.AddressLike,\n  gasLimit: number\n): Promise<ISmartContractExecutionResult> => {\n  // sanitize param\n  if (!isAddress(hederaTokenAddress)) {\n    console.error('Invalid token address');\n    return { err: 'Invalid token address' };\n  }\n\n  try {\n    if (gasLimit === 0) {\n      const estimateGasResult = await handleEstimateGas(\n        baseContract,\n        signerAddress,\n        network,\n        'isTokenPublic',\n        [hederaTokenAddress]\n      );\n      if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n      gasLimit = estimateGasResult.gasLimit;\n    }\n\n    const transactionResult = await baseContract.isTokenPublic(hederaTokenAddress, { gasLimit });\n    // get transaction receipt\n    const txReceipt = await transactionResult.wait();\n\n    // retrieve information from event\n    const { data } = txReceipt.logs.filter((event: any) => event.fragment.name === 'IsToken')[0];\n    return { IsToken: data, transactionHash: txReceipt.hash };\n  } catch (err: any) {\n    console.error(err);\n    return { err, transactionHash: err.receipt && err.receipt.hash };\n  }\n};\n\n/**\n * @dev queries token general information\n *\n * @dev integrates TokenQueryContract.getTokenInfoPublic()\n *\n * @dev integrates TokenQueryContract.getFungibleTokenInfoPublic()\n *\n * @dev integrates TokenQueryContract.getNonFungibleTokenInfoPublic()\n *\n * @param baseContract: ethers.Contract\n *\n * @param signerAddress: ethers.AddressLike\n *\n * @param network: TNetworkName\n *\n * @param API: \"TOKEN_INFO\" | \"FUNGIBLE_INFO\" | \"NON_FUNFIBLE_INFO\"\n *\n * @param hederaTokenAddress: ethers.AddressLike\n *\n * @param gasLimit: number\n *\n * @param serialNumber?: number\n *\n * @return Promise<ISmartContractExecutionResult>\n */\nexport const queryTokenGeneralInfomation = async (\n  baseContract: Contract,\n  signerAddress: ethers.AddressLike,\n  network: TNetworkName,\n  API: 'TOKEN' | 'FUNGIBLE' | 'NON_FUNFIBLE',\n  hederaTokenAddress: ethers.AddressLike,\n  gasLimit: number,\n  serialNumber?: number\n): Promise<ISmartContractExecutionResult> => {\n  // sanitize param\n  if (!isAddress(hederaTokenAddress)) {\n    console.error('Invalid token address');\n    return { err: 'Invalid token address' };\n  } else if (serialNumber && serialNumber < 0) {",
            "codeOnlyTokens": 801,
            "startLine": 1,
            "endLine": 108,
            "type": ".ts_part_1",
            "isOversized": false
          },
          {
            "originalText": "    console.error('Invalid serial number');\n    return { err: 'Invalid serial number' };\n  }\n\n  // prepare events map\n  const eventMaps = {\n    TOKEN: 'TokenInfo',\n    FUNGIBLE: 'FungibleTokenInfo',\n    NON_FUNFIBLE: 'NonFungibleTokenInfo',\n  };\n\n  // prepare function signagure and arguments\n  const selector = {\n    funcSig: '',\n    args: [] as any,\n  };\n  switch (API) {\n    case 'TOKEN':\n      selector.funcSig = 'getTokenInfoPublic';\n      selector.args = [hederaTokenAddress];\n      break;\n    case 'FUNGIBLE':\n      selector.funcSig = 'getFungibleTokenInfoPublic';\n      selector.args = [hederaTokenAddress];\n      break;\n    case 'NON_FUNFIBLE':\n      if (!serialNumber) {\n        console.error('Serial number is needed for querying NON_FUNGIBLE');\n        return { err: 'Serial number is needed for querying NON_FUNGIBLE' };\n      }\n      selector.funcSig = 'getNonFungibleTokenInfoPublic';\n      selector.args = [hederaTokenAddress, serialNumber];\n      break;\n  }\n\n  // prepare gasLimit\n  if (gasLimit === 0) {\n    const estimateGasResult = await handleEstimateGas(\n      baseContract,\n      signerAddress,\n      network,\n      selector.funcSig,\n      selector.args\n    );\n    if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n    gasLimit = estimateGasResult.gasLimit;\n  }\n\n  // invoking contract methods\n  try {\n    let transactionResult;\n    switch (API) {\n      case 'TOKEN':\n        // prepare transaction\n        transactionResult = await baseContract.getTokenInfoPublic(hederaTokenAddress, { gasLimit });\n        break;\n      case 'FUNGIBLE':\n        // prepare transaction\n        transactionResult = await baseContract.getFungibleTokenInfoPublic(hederaTokenAddress, { gasLimit });\n        break;\n      case 'NON_FUNFIBLE':\n        if (!serialNumber) {\n          console.error('Serial number is needed for querying NON_FUNGIBLE');\n          return { err: 'Serial number is needed for querying NON_FUNGIBLE' };\n        } else {\n          // prepare transaction\n          transactionResult = await baseContract.getNonFungibleTokenInfoPublic(\n            hederaTokenAddress,\n            serialNumber,\n            { gasLimit }\n          );\n        }\n        break;\n    }\n\n    // get transaction receipt\n    const txReceipt = await transactionResult.wait();\n\n    // retrieve information from event\n    const { args } = txReceipt.logs.filter((event: any) => event.fragment.name === eventMaps[API])[0];\n\n    return {\n      [eventMaps[API]]: convertsArgsProxyToHTSTokenInfo(args.tokenInfo, API),\n      transactionHash: txReceipt.hash,\n    };\n  } catch (err: any) {\n    console.error(err);\n    return { err, transactionHash: err.receipt && err.receipt.hash };\n  }\n};\n\n/**\n * @dev queries token's certain information fields\n *\n * @dev integrates TokenQueryContract.getTokenDefaultFreezeStatusPublic()\n *\n * @dev integrates TokenQueryContract.getTokenDefaultKycStatusPublic()\n *\n * @dev integrates TokenQueryContract.getTokenCustomFeesPublic()\n *\n * @dev integrates TokenQueryContract.getTokenExpiryInfoPublic()\n *\n * @dev integrates TokenQueryContract.getTokenTypePublic()\n *\n * @dev integrates TokenQueryContract.getTokenKeyPublic()\n *\n * @param baseContract: ethers.Contract\n *\n * @param signerAddress: ethers.AddressLike\n *\n * @param network: TNetworkName\n *\n * @param network: TNetworkName\n *\n * @param API: \"DEFAULT_FREEZE_STATUS\" | \"DEFAULT_KYC_STATUS\" | \"CUSTOM_FEES\" | \"TOKEN_EXPIRY\" | \"TOKEN_TYPE\" | \"TOKEN_KEYS\"",
            "codeOnlyTokens": 823,
            "startLine": 109,
            "endLine": 223,
            "type": ".ts_part_2",
            "isOversized": false
          },
          {
            "originalText": " *\n * @param hederaTokenAddress: ethers.AddressLike,\n *\n * @param gasLimit: number\n *\n * @param keyType?: IHederaTokenServiceKeyType\n *\n * @return Promise<ISmartContractExecutionResult>\n */\nexport const queryTokenSpecificInfomation = async (\n  baseContract: Contract,\n  signerAddress: ethers.AddressLike,\n  network: TNetworkName,\n  API:\n    | 'TOKEN_TYPE'\n    | 'TOKEN_KEYS'\n    | 'CUSTOM_FEES'\n    | 'TOKEN_EXPIRY'\n    | 'DEFAULT_KYC_STATUS'\n    | 'DEFAULT_FREEZE_STATUS',\n  hederaTokenAddress: ethers.AddressLike,\n  gasLimit: number,\n  keyType?: IHederaTokenServiceKeyType\n): Promise<ISmartContractExecutionResult> => {\n  // sanitize param\n  if (!isAddress(hederaTokenAddress)) {\n    console.error('Invalid token address');\n    return { err: 'Invalid token address' };\n  }\n\n  // prepare events map\n  const eventMaps = {\n    TOKEN_TYPE: 'TokenType',\n    TOKEN_KEYS: 'TokenKey',\n    CUSTOM_FEES: 'TokenCustomFees',\n    TOKEN_EXPIRY: 'TokenExpiryInfo',\n    DEFAULT_KYC_STATUS: 'TokenDefaultKycStatus',\n    DEFAULT_FREEZE_STATUS: 'TokenDefaultFreezeStatus',\n  };\n\n  // prepare function signagure and arguments\n  const selector = {\n    funcSig: '',\n    args: [hederaTokenAddress] as any,\n  };\n  switch (API) {\n    case 'DEFAULT_FREEZE_STATUS':\n      selector.funcSig = 'getTokenDefaultFreezeStatusPublic';\n      break;\n    case 'DEFAULT_KYC_STATUS':\n      selector.funcSig = 'getTokenDefaultKycStatusPublic';\n      break;\n    case 'CUSTOM_FEES':\n      selector.funcSig = 'getTokenCustomFeesPublic';\n      break;\n    case 'TOKEN_EXPIRY':\n      selector.funcSig = 'getTokenExpiryInfoPublic';\n      break;\n    case 'TOKEN_TYPE':\n      selector.funcSig = 'getTokenTypePublic';\n      break;\n    case 'TOKEN_KEYS':\n      if (!keyType) {\n        console.error('Key Type is needed for querying NON_FUNGIBLE');\n        return { err: 'Key Type is needed for querying NON_FUNGIBLE' };\n      }\n      selector.funcSig = 'getTokenKeyPublic';\n      selector.args = [hederaTokenAddress, KEY_TYPE_MAP[keyType]];\n      break;\n  }\n\n  // prepare gasLimit\n  if (gasLimit === 0) {\n    const estimateGasResult = await handleEstimateGas(\n      baseContract,\n      signerAddress,\n      network,\n      selector.funcSig,\n      selector.args\n    );\n    if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n    gasLimit = estimateGasResult.gasLimit;\n  }\n\n  // invoking contract methods\n  try {\n    let transactionResult;\n    switch (API) {\n      case 'DEFAULT_FREEZE_STATUS':\n        transactionResult = await baseContract.getTokenDefaultFreezeStatusPublic(hederaTokenAddress, {\n          gasLimit,\n        });\n        break;\n\n      case 'DEFAULT_KYC_STATUS':\n        transactionResult = await baseContract.getTokenDefaultKycStatusPublic(hederaTokenAddress, {\n          gasLimit,\n        });\n        break;\n\n      case 'CUSTOM_FEES':\n        transactionResult = await baseContract.getTokenCustomFeesPublic(hederaTokenAddress, { gasLimit });\n        break;\n\n      case 'TOKEN_EXPIRY':\n        transactionResult = await baseContract.getTokenExpiryInfoPublic(hederaTokenAddress, { gasLimit });\n        break;\n      case 'TOKEN_TYPE':\n        transactionResult = await baseContract.getTokenTypePublic(hederaTokenAddress, { gasLimit });\n        break;\n      case 'TOKEN_KEYS':\n        if (!keyType) {",
            "codeOnlyTokens": 801,
            "startLine": 224,
            "endLine": 335,
            "type": ".ts_part_3",
            "isOversized": false
          },
          {
            "originalText": "          console.error('Key Type is needed for querying NON_FUNGIBLE');\n          return { err: 'Key Type is needed for querying NON_FUNGIBLE' };\n        } else {\n          transactionResult = await baseContract.getTokenKeyPublic(\n            hederaTokenAddress,\n            KEY_TYPE_MAP[keyType],\n            { gasLimit }\n          );\n        }\n        break;\n    }\n\n    // get transaction receipt\n    const txReceipt = await transactionResult.wait();\n\n    // retrieve information from event\n    const tokenInfoResult = txReceipt.logs.filter((event: any) => event.fragment.name === eventMaps[API])[0];\n\n    if (API === 'DEFAULT_FREEZE_STATUS' || API === 'DEFAULT_KYC_STATUS' || API === 'TOKEN_TYPE') {\n      return { [eventMaps[API]]: tokenInfoResult.data, transactionHash: txReceipt.hash };\n    } else {\n      const tokenInfo = convertsArgsProxyToHTSSpecificInfo(tokenInfoResult.args, API);\n      return { [eventMaps[API]]: tokenInfo, transactionHash: txReceipt.hash };\n    }\n  } catch (err: any) {\n    console.error(err);\n    return { err, transactionHash: err.receipt && err.receipt.hash };\n  }\n};\n\n/**\n * @dev queries token's permission information\n *\n * @dev integrates TokenQueryContract.allowancePublic()\n *\n * @dev integrates TokenQueryContract.getApprovedPublic()\n *\n * @dev integrates TokenQueryContract.isApprovedForAllPublic()\n *\n * @param baseContract: ethers.Contract\n *\n * @param signerAddress: ethers.AddressLike\n *\n * @param network: TNetworkName\n *\n * @param API: \"ALLOWANCE\" | \"GET_APPROVED\" | \"IS_APPROVAL\"\n *\n * @param hederaTokenAddress: ethers.AddressLike\n *\n * @param gasLimit: number\n *\n * @param ownerAddress?: ethers.AddressLike\n *\n * @param spenderAddress?: ethers.AddressLike\n *\n * @param serialNumber?: number\n *\n * @return Promise<ISmartContractExecutionResult>\n */\nexport const queryTokenPermissionInformation = async (\n  baseContract: Contract,\n  signerAddress: ethers.AddressLike,\n  network: TNetworkName,\n  API: 'ALLOWANCE' | 'GET_APPROVED' | 'IS_APPROVAL',\n  hederaTokenAddress: ethers.AddressLike,\n  gasLimit: number,\n  ownerAddress?: ethers.AddressLike,\n  spenderAddress?: ethers.AddressLike,\n  serialNumber?: number\n): Promise<ISmartContractExecutionResult> => {\n  // sanitize param\n  if (!isAddress(hederaTokenAddress)) {\n    console.error('Invalid token address');\n    return { err: 'Invalid token address' };\n  } else if (ownerAddress && !isAddress(ownerAddress)) {\n    console.error('Invalid owner address');\n    return { err: 'Invalid owner address' };\n  } else if (spenderAddress && !isAddress(spenderAddress)) {\n    console.error('Invalid spender address');\n    return { err: 'Invalid spender address' };\n  } else if (serialNumber && serialNumber < 0) {\n    console.error('Invalid serial number');\n    return { err: 'Invalid serial number' };\n  }\n\n  // prepare events map\n  const eventMaps = {\n    IS_APPROVAL: 'Approved',\n    ALLOWANCE: 'AllowanceValue',\n    GET_APPROVED: 'ApprovedAddress',\n  };\n\n  let transactionResult, errMsg;\n  // invoking contract methods\n  try {\n    switch (API) {\n      case 'ALLOWANCE':\n        if (!ownerAddress) {\n          errMsg = 'Owner address is needed for ALLOWANCE API';\n        } else if (!spenderAddress) {\n          errMsg = 'Spender address is needed for ALLOWANCE API';\n        } else {\n          if (gasLimit === 0) {\n            const estimateGasResult = await handleEstimateGas(",
            "codeOnlyTokens": 801,
            "startLine": 336,
            "endLine": 439,
            "type": ".ts_part_4",
            "isOversized": false
          },
          {
            "originalText": "              baseContract,\n              signerAddress,\n              network,\n              'allowancePublic',\n              [hederaTokenAddress, ownerAddress, spenderAddress]\n            );\n            if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n            gasLimit = estimateGasResult.gasLimit;\n          }\n          transactionResult = await baseContract.allowancePublic(\n            hederaTokenAddress,\n            ownerAddress,\n            spenderAddress,\n            { gasLimit }\n          );\n        }\n        break;\n      case 'GET_APPROVED':\n        if (!serialNumber) {\n          errMsg = 'Serial number is needed for GET_APPROVED API';\n        } else {\n          if (gasLimit === 0) {\n            const estimateGasResult = await handleEstimateGas(\n              baseContract,\n              signerAddress,\n              network,\n              'getApprovedPublic',\n              [hederaTokenAddress, serialNumber]\n            );\n            if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n            gasLimit = estimateGasResult.gasLimit;\n          }\n          transactionResult = await baseContract.getApprovedPublic(hederaTokenAddress, serialNumber, {\n            gasLimit,\n          });\n        }\n        break;\n      case 'IS_APPROVAL':\n        if (!ownerAddress) {\n          errMsg = 'Owner address is needed for IS_APPROVAL API';\n        } else if (!spenderAddress) {\n          errMsg = 'Spender address is needed for IS_APPROVAL API';\n        } else {\n          if (gasLimit === 0) {\n            const estimateGasResult = await handleEstimateGas(\n              baseContract,\n              signerAddress,\n              network,\n              'isApprovedForAllPublic',\n              [hederaTokenAddress, ownerAddress, spenderAddress]\n            );\n            if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n            gasLimit = estimateGasResult.gasLimit;\n          }\n          transactionResult = await baseContract.isApprovedForAllPublic(\n            hederaTokenAddress,\n            ownerAddress,\n            spenderAddress\n          );\n        }\n        break;\n    }\n\n    // return err if any\n    if (errMsg) {\n      console.error(errMsg);\n      return { err: errMsg };\n    } else if (!transactionResult) {\n      console.error('Cannot execute contract methods');\n      return { err: 'Cannot execute contract methods' };\n    }\n\n    return await handleContractResponseWithDynamicEventNames(transactionResult, eventMaps, API);\n  } catch (err: any) {\n    console.error(err);\n    return { err, transactionHash: err.receipt && err.receipt.hash };\n  }\n};\n\n/**\n * @dev queries token's relation information\n *\n * @dev integrates TokenQueryContract.isKycPublic()\n *\n * @dev integrates TokenQueryContract.isFrozenPublic()\n *\n * @param baseContract: ethers.Contract\n *\n * @param signerAddress: ethers.AddressLike\n *\n * @param network: TNetworkName\n *\n * @param API: \"IS_KYC\" | \"IS_FROZEN\"\n *\n * @param hederaTokenAddress: ethers.AddressLike\n *\n * @param accountAddress: ethers.AddressLike\n *\n * @param gasLimit: number\n *\n * @return Promise<ISmartContractExecutionResult>\n */\nexport const queryTokenStatusInformation = async (\n  baseContract: Contract,\n  signerAddress: ethers.AddressLike,\n  network: TNetworkName,\n  API: 'IS_KYC' | 'IS_FROZEN',\n  hederaTokenAddress: ethers.AddressLike,\n  accountAddress: ethers.AddressLike,\n  gasLimit: number\n): Promise<ISmartContractExecutionResult> => {\n  // sanitize param\n  if (!isAddress(hederaTokenAddress)) {\n    console.error('Invalid token address');\n    return { err: 'Invalid token address' };\n  } else if (accountAddress && !isAddress(accountAddress)) {",
            "codeOnlyTokens": 814,
            "startLine": 440,
            "endLine": 555,
            "type": ".ts_part_5",
            "isOversized": false
          },
          {
            "originalText": "    console.error('Invalid owner address');\n    return { err: 'Invalid owner address' };\n  }\n\n  // prepare events map\n  const eventMaps = {\n    IS_KYC: 'KycGranted',\n    IS_FROZEN: 'Frozen',\n  };\n\n  if (gasLimit === 0) {\n    const estimateGasResult = await handleEstimateGas(\n      baseContract,\n      signerAddress,\n      network,\n      API === 'IS_KYC' ? 'isKycPublic' : 'isFrozenPublic',\n      [hederaTokenAddress, accountAddress]\n    );\n    if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n    gasLimit = estimateGasResult.gasLimit;\n  }\n\n  // invoking contract methods\n  try {\n    let transactionResult;\n    switch (API) {\n      case 'IS_KYC':\n        transactionResult = await baseContract.isKycPublic(hederaTokenAddress, accountAddress, { gasLimit });\n        break;\n\n      case 'IS_FROZEN':\n        transactionResult = await baseContract.isFrozenPublic(hederaTokenAddress, accountAddress, {\n          gasLimit,\n        });\n        break;\n    }\n\n    return await handleContractResponseWithDynamicEventNames(transactionResult, eventMaps, API);\n  } catch (err: any) {\n    console.error(err);\n    return { err, transactionHash: err.receipt && err.receipt.hash };\n  }\n};\n",
            "codeOnlyTokens": 301,
            "startLine": 556,
            "endLine": 599,
            "type": ".ts_part_6",
            "isOversized": false
          }
        ],
        "groupedChunks": [
          {
            "combinedText": "// File: system-contract-dapp-playground/src/api/hedera/hts-interactions/tokenQuery-interactions/index.ts\n// Relevant file context:\n// Type: .ts\n\n\n// --- Next chunk ---\n\n// Lines 1-108 (.ts_part_1)\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Contract, ethers, isAddress } from 'ethers';\nimport { ISmartContractExecutionResult } from '@/types/contract-interactions/shared';\nimport { KEY_TYPE_MAP } from '@/utils/contract-interactions/HTS/token-create-custom/constant';\nimport {\n  convertsArgsProxyToHTSSpecificInfo,\n  convertsArgsProxyToHTSTokenInfo,\n  handleContractResponseWithDynamicEventNames,\n} from '@/utils/contract-interactions/HTS/helpers';\nimport { TNetworkName } from '@/types/common';\nimport { handleEstimateGas } from '@/utils/common/helpers';\n\n/**\n * @dev queries token validity\n *\n * @dev integrates TokenQueryContract.isTokenPublic()\n *\n * @param baseContract: ethers.Contract\n *\n * @param signerAddress: ethers.AddressLike\n *\n * @param network: TNetworkName\n *\n * @param hederaTokenAddress: ethers.AddressLike\n *\n * @param gasLimit: number\n *\n * @return Promise<ISmartContractExecutionResult>\n */\nexport const queryTokenValidity = async (\n  baseContract: Contract,\n  signerAddress: ethers.AddressLike,\n  network: TNetworkName,\n  hederaTokenAddress: ethers.AddressLike,\n  gasLimit: number\n): Promise<ISmartContractExecutionResult> => {\n  // sanitize param\n  if (!isAddress(hederaTokenAddress)) {\n    console.error('Invalid token address');\n    return { err: 'Invalid token address' };\n  }\n\n  try {\n    if (gasLimit === 0) {\n      const estimateGasResult = await handleEstimateGas(\n        baseContract,\n        signerAddress,\n        network,\n        'isTokenPublic',\n        [hederaTokenAddress]\n      );\n      if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n      gasLimit = estimateGasResult.gasLimit;\n    }\n\n    const transactionResult = await baseContract.isTokenPublic(hederaTokenAddress, { gasLimit });\n    // get transaction receipt\n    const txReceipt = await transactionResult.wait();\n\n    // retrieve information from event\n    const { data } = txReceipt.logs.filter((event: any) => event.fragment.name === 'IsToken')[0];\n    return { IsToken: data, transactionHash: txReceipt.hash };\n  } catch (err: any) {\n    console.error(err);\n    return { err, transactionHash: err.receipt && err.receipt.hash };\n  }\n};\n\n/**\n * @dev queries token general information\n *\n * @dev integrates TokenQueryContract.getTokenInfoPublic()\n *\n * @dev integrates TokenQueryContract.getFungibleTokenInfoPublic()\n *\n * @dev integrates TokenQueryContract.getNonFungibleTokenInfoPublic()\n *\n * @param baseContract: ethers.Contract\n *\n * @param signerAddress: ethers.AddressLike\n *\n * @param network: TNetworkName\n *\n * @param API: \"TOKEN_INFO\" | \"FUNGIBLE_INFO\" | \"NON_FUNFIBLE_INFO\"\n *\n * @param hederaTokenAddress: ethers.AddressLike\n *\n * @param gasLimit: number\n *\n * @param serialNumber?: number\n *\n * @return Promise<ISmartContractExecutionResult>\n */\nexport const queryTokenGeneralInfomation = async (\n  baseContract: Contract,\n  signerAddress: ethers.AddressLike,\n  network: TNetworkName,\n  API: 'TOKEN' | 'FUNGIBLE' | 'NON_FUNFIBLE',\n  hederaTokenAddress: ethers.AddressLike,\n  gasLimit: number,\n  serialNumber?: number\n): Promise<ISmartContractExecutionResult> => {\n  // sanitize param\n  if (!isAddress(hederaTokenAddress)) {\n    console.error('Invalid token address');\n    return { err: 'Invalid token address' };\n  } else if (serialNumber && serialNumber < 0) {\n\n// --- Next chunk ---\n\n// Lines 109-223 (.ts_part_2)\n    console.error('Invalid serial number');\n    return { err: 'Invalid serial number' };\n  }\n\n  // prepare events map\n  const eventMaps = {\n    TOKEN: 'TokenInfo',\n    FUNGIBLE: 'FungibleTokenInfo',\n    NON_FUNFIBLE: 'NonFungibleTokenInfo',\n  };\n\n  // prepare function signagure and arguments\n  const selector = {\n    funcSig: '',\n    args: [] as any,\n  };\n  switch (API) {\n    case 'TOKEN':\n      selector.funcSig = 'getTokenInfoPublic';\n      selector.args = [hederaTokenAddress];\n      break;\n    case 'FUNGIBLE':\n      selector.funcSig = 'getFungibleTokenInfoPublic';\n      selector.args = [hederaTokenAddress];\n      break;\n    case 'NON_FUNFIBLE':\n      if (!serialNumber) {\n        console.error('Serial number is needed for querying NON_FUNGIBLE');\n        return { err: 'Serial number is needed for querying NON_FUNGIBLE' };\n      }\n      selector.funcSig = 'getNonFungibleTokenInfoPublic';\n      selector.args = [hederaTokenAddress, serialNumber];\n      break;\n  }\n\n  // prepare gasLimit\n  if (gasLimit === 0) {\n    const estimateGasResult = await handleEstimateGas(\n      baseContract,\n      signerAddress,\n      network,\n      selector.funcSig,\n      selector.args\n    );\n    if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n    gasLimit = estimateGasResult.gasLimit;\n  }\n\n  // invoking contract methods\n  try {\n    let transactionResult;\n    switch (API) {\n      case 'TOKEN':\n        // prepare transaction\n        transactionResult = await baseContract.getTokenInfoPublic(hederaTokenAddress, { gasLimit });\n        break;\n      case 'FUNGIBLE':\n        // prepare transaction\n        transactionResult = await baseContract.getFungibleTokenInfoPublic(hederaTokenAddress, { gasLimit });\n        break;\n      case 'NON_FUNFIBLE':\n        if (!serialNumber) {\n          console.error('Serial number is needed for querying NON_FUNGIBLE');\n          return { err: 'Serial number is needed for querying NON_FUNGIBLE' };\n        } else {\n          // prepare transaction\n          transactionResult = await baseContract.getNonFungibleTokenInfoPublic(\n            hederaTokenAddress,\n            serialNumber,\n            { gasLimit }\n          );\n        }\n        break;\n    }\n\n    // get transaction receipt\n    const txReceipt = await transactionResult.wait();\n\n    // retrieve information from event\n    const { args } = txReceipt.logs.filter((event: any) => event.fragment.name === eventMaps[API])[0];\n\n    return {\n      [eventMaps[API]]: convertsArgsProxyToHTSTokenInfo(args.tokenInfo, API),\n      transactionHash: txReceipt.hash,\n    };\n  } catch (err: any) {\n    console.error(err);\n    return { err, transactionHash: err.receipt && err.receipt.hash };\n  }\n};\n\n/**\n * @dev queries token's certain information fields\n *\n * @dev integrates TokenQueryContract.getTokenDefaultFreezeStatusPublic()\n *\n * @dev integrates TokenQueryContract.getTokenDefaultKycStatusPublic()\n *\n * @dev integrates TokenQueryContract.getTokenCustomFeesPublic()\n *\n * @dev integrates TokenQueryContract.getTokenExpiryInfoPublic()\n *\n * @dev integrates TokenQueryContract.getTokenTypePublic()\n *\n * @dev integrates TokenQueryContract.getTokenKeyPublic()\n *\n * @param baseContract: ethers.Contract\n *\n * @param signerAddress: ethers.AddressLike\n *\n * @param network: TNetworkName\n *\n * @param network: TNetworkName\n *\n * @param API: \"DEFAULT_FREEZE_STATUS\" | \"DEFAULT_KYC_STATUS\" | \"CUSTOM_FEES\" | \"TOKEN_EXPIRY\" | \"TOKEN_TYPE\" | \"TOKEN_KEYS\"\n\n// --- Next chunk ---\n\n// Lines 224-335 (.ts_part_3)\n *\n * @param hederaTokenAddress: ethers.AddressLike,\n *\n * @param gasLimit: number\n *\n * @param keyType?: IHederaTokenServiceKeyType\n *\n * @return Promise<ISmartContractExecutionResult>\n */\nexport const queryTokenSpecificInfomation = async (\n  baseContract: Contract,\n  signerAddress: ethers.AddressLike,\n  network: TNetworkName,\n  API:\n    | 'TOKEN_TYPE'\n    | 'TOKEN_KEYS'\n    | 'CUSTOM_FEES'\n    | 'TOKEN_EXPIRY'\n    | 'DEFAULT_KYC_STATUS'\n    | 'DEFAULT_FREEZE_STATUS',\n  hederaTokenAddress: ethers.AddressLike,\n  gasLimit: number,\n  keyType?: IHederaTokenServiceKeyType\n): Promise<ISmartContractExecutionResult> => {\n  // sanitize param\n  if (!isAddress(hederaTokenAddress)) {\n    console.error('Invalid token address');\n    return { err: 'Invalid token address' };\n  }\n\n  // prepare events map\n  const eventMaps = {\n    TOKEN_TYPE: 'TokenType',\n    TOKEN_KEYS: 'TokenKey',\n    CUSTOM_FEES: 'TokenCustomFees',\n    TOKEN_EXPIRY: 'TokenExpiryInfo',\n    DEFAULT_KYC_STATUS: 'TokenDefaultKycStatus',\n    DEFAULT_FREEZE_STATUS: 'TokenDefaultFreezeStatus',\n  };\n\n  // prepare function signagure and arguments\n  const selector = {\n    funcSig: '',\n    args: [hederaTokenAddress] as any,\n  };\n  switch (API) {\n    case 'DEFAULT_FREEZE_STATUS':\n      selector.funcSig = 'getTokenDefaultFreezeStatusPublic';\n      break;\n    case 'DEFAULT_KYC_STATUS':\n      selector.funcSig = 'getTokenDefaultKycStatusPublic';\n      break;\n    case 'CUSTOM_FEES':\n      selector.funcSig = 'getTokenCustomFeesPublic';\n      break;\n    case 'TOKEN_EXPIRY':\n      selector.funcSig = 'getTokenExpiryInfoPublic';\n      break;\n    case 'TOKEN_TYPE':\n      selector.funcSig = 'getTokenTypePublic';\n      break;\n    case 'TOKEN_KEYS':\n      if (!keyType) {\n        console.error('Key Type is needed for querying NON_FUNGIBLE');\n        return { err: 'Key Type is needed for querying NON_FUNGIBLE' };\n      }\n      selector.funcSig = 'getTokenKeyPublic';\n      selector.args = [hederaTokenAddress, KEY_TYPE_MAP[keyType]];\n      break;\n  }\n\n  // prepare gasLimit\n  if (gasLimit === 0) {\n    const estimateGasResult = await handleEstimateGas(\n      baseContract,\n      signerAddress,\n      network,\n      selector.funcSig,\n      selector.args\n    );\n    if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n    gasLimit = estimateGasResult.gasLimit;\n  }\n\n  // invoking contract methods\n  try {\n    let transactionResult;\n    switch (API) {\n      case 'DEFAULT_FREEZE_STATUS':\n        transactionResult = await baseContract.getTokenDefaultFreezeStatusPublic(hederaTokenAddress, {\n          gasLimit,\n        });\n        break;\n\n      case 'DEFAULT_KYC_STATUS':\n        transactionResult = await baseContract.getTokenDefaultKycStatusPublic(hederaTokenAddress, {\n          gasLimit,\n        });\n        break;\n\n      case 'CUSTOM_FEES':\n        transactionResult = await baseContract.getTokenCustomFeesPublic(hederaTokenAddress, { gasLimit });\n        break;\n\n      case 'TOKEN_EXPIRY':\n        transactionResult = await baseContract.getTokenExpiryInfoPublic(hederaTokenAddress, { gasLimit });\n        break;\n      case 'TOKEN_TYPE':\n        transactionResult = await baseContract.getTokenTypePublic(hederaTokenAddress, { gasLimit });\n        break;\n      case 'TOKEN_KEYS':\n        if (!keyType) {",
            "totalTokens": 2512,
            "chunks": [
              {
                "originalText": "// SPDX-License-Identifier: Apache-2.0\n\nimport { Contract, ethers, isAddress } from 'ethers';\nimport { ISmartContractExecutionResult } from '@/types/contract-interactions/shared';\nimport { KEY_TYPE_MAP } from '@/utils/contract-interactions/HTS/token-create-custom/constant';\nimport {\n  convertsArgsProxyToHTSSpecificInfo,\n  convertsArgsProxyToHTSTokenInfo,\n  handleContractResponseWithDynamicEventNames,\n} from '@/utils/contract-interactions/HTS/helpers';\nimport { TNetworkName } from '@/types/common';\nimport { handleEstimateGas } from '@/utils/common/helpers';\n\n/**\n * @dev queries token validity\n *\n * @dev integrates TokenQueryContract.isTokenPublic()\n *\n * @param baseContract: ethers.Contract\n *\n * @param signerAddress: ethers.AddressLike\n *\n * @param network: TNetworkName\n *\n * @param hederaTokenAddress: ethers.AddressLike\n *\n * @param gasLimit: number\n *\n * @return Promise<ISmartContractExecutionResult>\n */\nexport const queryTokenValidity = async (\n  baseContract: Contract,\n  signerAddress: ethers.AddressLike,\n  network: TNetworkName,\n  hederaTokenAddress: ethers.AddressLike,\n  gasLimit: number\n): Promise<ISmartContractExecutionResult> => {\n  // sanitize param\n  if (!isAddress(hederaTokenAddress)) {\n    console.error('Invalid token address');\n    return { err: 'Invalid token address' };\n  }\n\n  try {\n    if (gasLimit === 0) {\n      const estimateGasResult = await handleEstimateGas(\n        baseContract,\n        signerAddress,\n        network,\n        'isTokenPublic',\n        [hederaTokenAddress]\n      );\n      if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n      gasLimit = estimateGasResult.gasLimit;\n    }\n\n    const transactionResult = await baseContract.isTokenPublic(hederaTokenAddress, { gasLimit });\n    // get transaction receipt\n    const txReceipt = await transactionResult.wait();\n\n    // retrieve information from event\n    const { data } = txReceipt.logs.filter((event: any) => event.fragment.name === 'IsToken')[0];\n    return { IsToken: data, transactionHash: txReceipt.hash };\n  } catch (err: any) {\n    console.error(err);\n    return { err, transactionHash: err.receipt && err.receipt.hash };\n  }\n};\n\n/**\n * @dev queries token general information\n *\n * @dev integrates TokenQueryContract.getTokenInfoPublic()\n *\n * @dev integrates TokenQueryContract.getFungibleTokenInfoPublic()\n *\n * @dev integrates TokenQueryContract.getNonFungibleTokenInfoPublic()\n *\n * @param baseContract: ethers.Contract\n *\n * @param signerAddress: ethers.AddressLike\n *\n * @param network: TNetworkName\n *\n * @param API: \"TOKEN_INFO\" | \"FUNGIBLE_INFO\" | \"NON_FUNFIBLE_INFO\"\n *\n * @param hederaTokenAddress: ethers.AddressLike\n *\n * @param gasLimit: number\n *\n * @param serialNumber?: number\n *\n * @return Promise<ISmartContractExecutionResult>\n */\nexport const queryTokenGeneralInfomation = async (\n  baseContract: Contract,\n  signerAddress: ethers.AddressLike,\n  network: TNetworkName,\n  API: 'TOKEN' | 'FUNGIBLE' | 'NON_FUNFIBLE',\n  hederaTokenAddress: ethers.AddressLike,\n  gasLimit: number,\n  serialNumber?: number\n): Promise<ISmartContractExecutionResult> => {\n  // sanitize param\n  if (!isAddress(hederaTokenAddress)) {\n    console.error('Invalid token address');\n    return { err: 'Invalid token address' };\n  } else if (serialNumber && serialNumber < 0) {",
                "codeOnlyTokens": 801,
                "startLine": 1,
                "endLine": 108,
                "type": ".ts_part_1",
                "isOversized": false
              },
              {
                "originalText": "    console.error('Invalid serial number');\n    return { err: 'Invalid serial number' };\n  }\n\n  // prepare events map\n  const eventMaps = {\n    TOKEN: 'TokenInfo',\n    FUNGIBLE: 'FungibleTokenInfo',\n    NON_FUNFIBLE: 'NonFungibleTokenInfo',\n  };\n\n  // prepare function signagure and arguments\n  const selector = {\n    funcSig: '',\n    args: [] as any,\n  };\n  switch (API) {\n    case 'TOKEN':\n      selector.funcSig = 'getTokenInfoPublic';\n      selector.args = [hederaTokenAddress];\n      break;\n    case 'FUNGIBLE':\n      selector.funcSig = 'getFungibleTokenInfoPublic';\n      selector.args = [hederaTokenAddress];\n      break;\n    case 'NON_FUNFIBLE':\n      if (!serialNumber) {\n        console.error('Serial number is needed for querying NON_FUNGIBLE');\n        return { err: 'Serial number is needed for querying NON_FUNGIBLE' };\n      }\n      selector.funcSig = 'getNonFungibleTokenInfoPublic';\n      selector.args = [hederaTokenAddress, serialNumber];\n      break;\n  }\n\n  // prepare gasLimit\n  if (gasLimit === 0) {\n    const estimateGasResult = await handleEstimateGas(\n      baseContract,\n      signerAddress,\n      network,\n      selector.funcSig,\n      selector.args\n    );\n    if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n    gasLimit = estimateGasResult.gasLimit;\n  }\n\n  // invoking contract methods\n  try {\n    let transactionResult;\n    switch (API) {\n      case 'TOKEN':\n        // prepare transaction\n        transactionResult = await baseContract.getTokenInfoPublic(hederaTokenAddress, { gasLimit });\n        break;\n      case 'FUNGIBLE':\n        // prepare transaction\n        transactionResult = await baseContract.getFungibleTokenInfoPublic(hederaTokenAddress, { gasLimit });\n        break;\n      case 'NON_FUNFIBLE':\n        if (!serialNumber) {\n          console.error('Serial number is needed for querying NON_FUNGIBLE');\n          return { err: 'Serial number is needed for querying NON_FUNGIBLE' };\n        } else {\n          // prepare transaction\n          transactionResult = await baseContract.getNonFungibleTokenInfoPublic(\n            hederaTokenAddress,\n            serialNumber,\n            { gasLimit }\n          );\n        }\n        break;\n    }\n\n    // get transaction receipt\n    const txReceipt = await transactionResult.wait();\n\n    // retrieve information from event\n    const { args } = txReceipt.logs.filter((event: any) => event.fragment.name === eventMaps[API])[0];\n\n    return {\n      [eventMaps[API]]: convertsArgsProxyToHTSTokenInfo(args.tokenInfo, API),\n      transactionHash: txReceipt.hash,\n    };\n  } catch (err: any) {\n    console.error(err);\n    return { err, transactionHash: err.receipt && err.receipt.hash };\n  }\n};\n\n/**\n * @dev queries token's certain information fields\n *\n * @dev integrates TokenQueryContract.getTokenDefaultFreezeStatusPublic()\n *\n * @dev integrates TokenQueryContract.getTokenDefaultKycStatusPublic()\n *\n * @dev integrates TokenQueryContract.getTokenCustomFeesPublic()\n *\n * @dev integrates TokenQueryContract.getTokenExpiryInfoPublic()\n *\n * @dev integrates TokenQueryContract.getTokenTypePublic()\n *\n * @dev integrates TokenQueryContract.getTokenKeyPublic()\n *\n * @param baseContract: ethers.Contract\n *\n * @param signerAddress: ethers.AddressLike\n *\n * @param network: TNetworkName\n *\n * @param network: TNetworkName\n *\n * @param API: \"DEFAULT_FREEZE_STATUS\" | \"DEFAULT_KYC_STATUS\" | \"CUSTOM_FEES\" | \"TOKEN_EXPIRY\" | \"TOKEN_TYPE\" | \"TOKEN_KEYS\"",
                "codeOnlyTokens": 823,
                "startLine": 109,
                "endLine": 223,
                "type": ".ts_part_2",
                "isOversized": false
              },
              {
                "originalText": " *\n * @param hederaTokenAddress: ethers.AddressLike,\n *\n * @param gasLimit: number\n *\n * @param keyType?: IHederaTokenServiceKeyType\n *\n * @return Promise<ISmartContractExecutionResult>\n */\nexport const queryTokenSpecificInfomation = async (\n  baseContract: Contract,\n  signerAddress: ethers.AddressLike,\n  network: TNetworkName,\n  API:\n    | 'TOKEN_TYPE'\n    | 'TOKEN_KEYS'\n    | 'CUSTOM_FEES'\n    | 'TOKEN_EXPIRY'\n    | 'DEFAULT_KYC_STATUS'\n    | 'DEFAULT_FREEZE_STATUS',\n  hederaTokenAddress: ethers.AddressLike,\n  gasLimit: number,\n  keyType?: IHederaTokenServiceKeyType\n): Promise<ISmartContractExecutionResult> => {\n  // sanitize param\n  if (!isAddress(hederaTokenAddress)) {\n    console.error('Invalid token address');\n    return { err: 'Invalid token address' };\n  }\n\n  // prepare events map\n  const eventMaps = {\n    TOKEN_TYPE: 'TokenType',\n    TOKEN_KEYS: 'TokenKey',\n    CUSTOM_FEES: 'TokenCustomFees',\n    TOKEN_EXPIRY: 'TokenExpiryInfo',\n    DEFAULT_KYC_STATUS: 'TokenDefaultKycStatus',\n    DEFAULT_FREEZE_STATUS: 'TokenDefaultFreezeStatus',\n  };\n\n  // prepare function signagure and arguments\n  const selector = {\n    funcSig: '',\n    args: [hederaTokenAddress] as any,\n  };\n  switch (API) {\n    case 'DEFAULT_FREEZE_STATUS':\n      selector.funcSig = 'getTokenDefaultFreezeStatusPublic';\n      break;\n    case 'DEFAULT_KYC_STATUS':\n      selector.funcSig = 'getTokenDefaultKycStatusPublic';\n      break;\n    case 'CUSTOM_FEES':\n      selector.funcSig = 'getTokenCustomFeesPublic';\n      break;\n    case 'TOKEN_EXPIRY':\n      selector.funcSig = 'getTokenExpiryInfoPublic';\n      break;\n    case 'TOKEN_TYPE':\n      selector.funcSig = 'getTokenTypePublic';\n      break;\n    case 'TOKEN_KEYS':\n      if (!keyType) {\n        console.error('Key Type is needed for querying NON_FUNGIBLE');\n        return { err: 'Key Type is needed for querying NON_FUNGIBLE' };\n      }\n      selector.funcSig = 'getTokenKeyPublic';\n      selector.args = [hederaTokenAddress, KEY_TYPE_MAP[keyType]];\n      break;\n  }\n\n  // prepare gasLimit\n  if (gasLimit === 0) {\n    const estimateGasResult = await handleEstimateGas(\n      baseContract,\n      signerAddress,\n      network,\n      selector.funcSig,\n      selector.args\n    );\n    if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n    gasLimit = estimateGasResult.gasLimit;\n  }\n\n  // invoking contract methods\n  try {\n    let transactionResult;\n    switch (API) {\n      case 'DEFAULT_FREEZE_STATUS':\n        transactionResult = await baseContract.getTokenDefaultFreezeStatusPublic(hederaTokenAddress, {\n          gasLimit,\n        });\n        break;\n\n      case 'DEFAULT_KYC_STATUS':\n        transactionResult = await baseContract.getTokenDefaultKycStatusPublic(hederaTokenAddress, {\n          gasLimit,\n        });\n        break;\n\n      case 'CUSTOM_FEES':\n        transactionResult = await baseContract.getTokenCustomFeesPublic(hederaTokenAddress, { gasLimit });\n        break;\n\n      case 'TOKEN_EXPIRY':\n        transactionResult = await baseContract.getTokenExpiryInfoPublic(hederaTokenAddress, { gasLimit });\n        break;\n      case 'TOKEN_TYPE':\n        transactionResult = await baseContract.getTokenTypePublic(hederaTokenAddress, { gasLimit });\n        break;\n      case 'TOKEN_KEYS':\n        if (!keyType) {",
                "codeOnlyTokens": 801,
                "startLine": 224,
                "endLine": 335,
                "type": ".ts_part_3",
                "isOversized": false
              }
            ],
            "startLine": 1,
            "endLine": 335,
            "groupId": 1
          },
          {
            "combinedText": "// File: system-contract-dapp-playground/src/api/hedera/hts-interactions/tokenQuery-interactions/index.ts\n// Relevant file context:\n// Type: .ts\n\n\n// --- Next chunk ---\n\n// Lines 336-439 (.ts_part_4)\n          console.error('Key Type is needed for querying NON_FUNGIBLE');\n          return { err: 'Key Type is needed for querying NON_FUNGIBLE' };\n        } else {\n          transactionResult = await baseContract.getTokenKeyPublic(\n            hederaTokenAddress,\n            KEY_TYPE_MAP[keyType],\n            { gasLimit }\n          );\n        }\n        break;\n    }\n\n    // get transaction receipt\n    const txReceipt = await transactionResult.wait();\n\n    // retrieve information from event\n    const tokenInfoResult = txReceipt.logs.filter((event: any) => event.fragment.name === eventMaps[API])[0];\n\n    if (API === 'DEFAULT_FREEZE_STATUS' || API === 'DEFAULT_KYC_STATUS' || API === 'TOKEN_TYPE') {\n      return { [eventMaps[API]]: tokenInfoResult.data, transactionHash: txReceipt.hash };\n    } else {\n      const tokenInfo = convertsArgsProxyToHTSSpecificInfo(tokenInfoResult.args, API);\n      return { [eventMaps[API]]: tokenInfo, transactionHash: txReceipt.hash };\n    }\n  } catch (err: any) {\n    console.error(err);\n    return { err, transactionHash: err.receipt && err.receipt.hash };\n  }\n};\n\n/**\n * @dev queries token's permission information\n *\n * @dev integrates TokenQueryContract.allowancePublic()\n *\n * @dev integrates TokenQueryContract.getApprovedPublic()\n *\n * @dev integrates TokenQueryContract.isApprovedForAllPublic()\n *\n * @param baseContract: ethers.Contract\n *\n * @param signerAddress: ethers.AddressLike\n *\n * @param network: TNetworkName\n *\n * @param API: \"ALLOWANCE\" | \"GET_APPROVED\" | \"IS_APPROVAL\"\n *\n * @param hederaTokenAddress: ethers.AddressLike\n *\n * @param gasLimit: number\n *\n * @param ownerAddress?: ethers.AddressLike\n *\n * @param spenderAddress?: ethers.AddressLike\n *\n * @param serialNumber?: number\n *\n * @return Promise<ISmartContractExecutionResult>\n */\nexport const queryTokenPermissionInformation = async (\n  baseContract: Contract,\n  signerAddress: ethers.AddressLike,\n  network: TNetworkName,\n  API: 'ALLOWANCE' | 'GET_APPROVED' | 'IS_APPROVAL',\n  hederaTokenAddress: ethers.AddressLike,\n  gasLimit: number,\n  ownerAddress?: ethers.AddressLike,\n  spenderAddress?: ethers.AddressLike,\n  serialNumber?: number\n): Promise<ISmartContractExecutionResult> => {\n  // sanitize param\n  if (!isAddress(hederaTokenAddress)) {\n    console.error('Invalid token address');\n    return { err: 'Invalid token address' };\n  } else if (ownerAddress && !isAddress(ownerAddress)) {\n    console.error('Invalid owner address');\n    return { err: 'Invalid owner address' };\n  } else if (spenderAddress && !isAddress(spenderAddress)) {\n    console.error('Invalid spender address');\n    return { err: 'Invalid spender address' };\n  } else if (serialNumber && serialNumber < 0) {\n    console.error('Invalid serial number');\n    return { err: 'Invalid serial number' };\n  }\n\n  // prepare events map\n  const eventMaps = {\n    IS_APPROVAL: 'Approved',\n    ALLOWANCE: 'AllowanceValue',\n    GET_APPROVED: 'ApprovedAddress',\n  };\n\n  let transactionResult, errMsg;\n  // invoking contract methods\n  try {\n    switch (API) {\n      case 'ALLOWANCE':\n        if (!ownerAddress) {\n          errMsg = 'Owner address is needed for ALLOWANCE API';\n        } else if (!spenderAddress) {\n          errMsg = 'Spender address is needed for ALLOWANCE API';\n        } else {\n          if (gasLimit === 0) {\n            const estimateGasResult = await handleEstimateGas(\n\n// --- Next chunk ---\n\n// Lines 440-555 (.ts_part_5)\n              baseContract,\n              signerAddress,\n              network,\n              'allowancePublic',\n              [hederaTokenAddress, ownerAddress, spenderAddress]\n            );\n            if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n            gasLimit = estimateGasResult.gasLimit;\n          }\n          transactionResult = await baseContract.allowancePublic(\n            hederaTokenAddress,\n            ownerAddress,\n            spenderAddress,\n            { gasLimit }\n          );\n        }\n        break;\n      case 'GET_APPROVED':\n        if (!serialNumber) {\n          errMsg = 'Serial number is needed for GET_APPROVED API';\n        } else {\n          if (gasLimit === 0) {\n            const estimateGasResult = await handleEstimateGas(\n              baseContract,\n              signerAddress,\n              network,\n              'getApprovedPublic',\n              [hederaTokenAddress, serialNumber]\n            );\n            if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n            gasLimit = estimateGasResult.gasLimit;\n          }\n          transactionResult = await baseContract.getApprovedPublic(hederaTokenAddress, serialNumber, {\n            gasLimit,\n          });\n        }\n        break;\n      case 'IS_APPROVAL':\n        if (!ownerAddress) {\n          errMsg = 'Owner address is needed for IS_APPROVAL API';\n        } else if (!spenderAddress) {\n          errMsg = 'Spender address is needed for IS_APPROVAL API';\n        } else {\n          if (gasLimit === 0) {\n            const estimateGasResult = await handleEstimateGas(\n              baseContract,\n              signerAddress,\n              network,\n              'isApprovedForAllPublic',\n              [hederaTokenAddress, ownerAddress, spenderAddress]\n            );\n            if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n            gasLimit = estimateGasResult.gasLimit;\n          }\n          transactionResult = await baseContract.isApprovedForAllPublic(\n            hederaTokenAddress,\n            ownerAddress,\n            spenderAddress\n          );\n        }\n        break;\n    }\n\n    // return err if any\n    if (errMsg) {\n      console.error(errMsg);\n      return { err: errMsg };\n    } else if (!transactionResult) {\n      console.error('Cannot execute contract methods');\n      return { err: 'Cannot execute contract methods' };\n    }\n\n    return await handleContractResponseWithDynamicEventNames(transactionResult, eventMaps, API);\n  } catch (err: any) {\n    console.error(err);\n    return { err, transactionHash: err.receipt && err.receipt.hash };\n  }\n};\n\n/**\n * @dev queries token's relation information\n *\n * @dev integrates TokenQueryContract.isKycPublic()\n *\n * @dev integrates TokenQueryContract.isFrozenPublic()\n *\n * @param baseContract: ethers.Contract\n *\n * @param signerAddress: ethers.AddressLike\n *\n * @param network: TNetworkName\n *\n * @param API: \"IS_KYC\" | \"IS_FROZEN\"\n *\n * @param hederaTokenAddress: ethers.AddressLike\n *\n * @param accountAddress: ethers.AddressLike\n *\n * @param gasLimit: number\n *\n * @return Promise<ISmartContractExecutionResult>\n */\nexport const queryTokenStatusInformation = async (\n  baseContract: Contract,\n  signerAddress: ethers.AddressLike,\n  network: TNetworkName,\n  API: 'IS_KYC' | 'IS_FROZEN',\n  hederaTokenAddress: ethers.AddressLike,\n  accountAddress: ethers.AddressLike,\n  gasLimit: number\n): Promise<ISmartContractExecutionResult> => {\n  // sanitize param\n  if (!isAddress(hederaTokenAddress)) {\n    console.error('Invalid token address');\n    return { err: 'Invalid token address' };\n  } else if (accountAddress && !isAddress(accountAddress)) {\n\n// --- Next chunk ---\n\n// Lines 556-599 (.ts_part_6)\n    console.error('Invalid owner address');\n    return { err: 'Invalid owner address' };\n  }\n\n  // prepare events map\n  const eventMaps = {\n    IS_KYC: 'KycGranted',\n    IS_FROZEN: 'Frozen',\n  };\n\n  if (gasLimit === 0) {\n    const estimateGasResult = await handleEstimateGas(\n      baseContract,\n      signerAddress,\n      network,\n      API === 'IS_KYC' ? 'isKycPublic' : 'isFrozenPublic',\n      [hederaTokenAddress, accountAddress]\n    );\n    if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n    gasLimit = estimateGasResult.gasLimit;\n  }\n\n  // invoking contract methods\n  try {\n    let transactionResult;\n    switch (API) {\n      case 'IS_KYC':\n        transactionResult = await baseContract.isKycPublic(hederaTokenAddress, accountAddress, { gasLimit });\n        break;\n\n      case 'IS_FROZEN':\n        transactionResult = await baseContract.isFrozenPublic(hederaTokenAddress, accountAddress, {\n          gasLimit,\n        });\n        break;\n    }\n\n    return await handleContractResponseWithDynamicEventNames(transactionResult, eventMaps, API);\n  } catch (err: any) {\n    console.error(err);\n    return { err, transactionHash: err.receipt && err.receipt.hash };\n  }\n};\n",
            "totalTokens": 2005,
            "chunks": [
              {
                "originalText": "          console.error('Key Type is needed for querying NON_FUNGIBLE');\n          return { err: 'Key Type is needed for querying NON_FUNGIBLE' };\n        } else {\n          transactionResult = await baseContract.getTokenKeyPublic(\n            hederaTokenAddress,\n            KEY_TYPE_MAP[keyType],\n            { gasLimit }\n          );\n        }\n        break;\n    }\n\n    // get transaction receipt\n    const txReceipt = await transactionResult.wait();\n\n    // retrieve information from event\n    const tokenInfoResult = txReceipt.logs.filter((event: any) => event.fragment.name === eventMaps[API])[0];\n\n    if (API === 'DEFAULT_FREEZE_STATUS' || API === 'DEFAULT_KYC_STATUS' || API === 'TOKEN_TYPE') {\n      return { [eventMaps[API]]: tokenInfoResult.data, transactionHash: txReceipt.hash };\n    } else {\n      const tokenInfo = convertsArgsProxyToHTSSpecificInfo(tokenInfoResult.args, API);\n      return { [eventMaps[API]]: tokenInfo, transactionHash: txReceipt.hash };\n    }\n  } catch (err: any) {\n    console.error(err);\n    return { err, transactionHash: err.receipt && err.receipt.hash };\n  }\n};\n\n/**\n * @dev queries token's permission information\n *\n * @dev integrates TokenQueryContract.allowancePublic()\n *\n * @dev integrates TokenQueryContract.getApprovedPublic()\n *\n * @dev integrates TokenQueryContract.isApprovedForAllPublic()\n *\n * @param baseContract: ethers.Contract\n *\n * @param signerAddress: ethers.AddressLike\n *\n * @param network: TNetworkName\n *\n * @param API: \"ALLOWANCE\" | \"GET_APPROVED\" | \"IS_APPROVAL\"\n *\n * @param hederaTokenAddress: ethers.AddressLike\n *\n * @param gasLimit: number\n *\n * @param ownerAddress?: ethers.AddressLike\n *\n * @param spenderAddress?: ethers.AddressLike\n *\n * @param serialNumber?: number\n *\n * @return Promise<ISmartContractExecutionResult>\n */\nexport const queryTokenPermissionInformation = async (\n  baseContract: Contract,\n  signerAddress: ethers.AddressLike,\n  network: TNetworkName,\n  API: 'ALLOWANCE' | 'GET_APPROVED' | 'IS_APPROVAL',\n  hederaTokenAddress: ethers.AddressLike,\n  gasLimit: number,\n  ownerAddress?: ethers.AddressLike,\n  spenderAddress?: ethers.AddressLike,\n  serialNumber?: number\n): Promise<ISmartContractExecutionResult> => {\n  // sanitize param\n  if (!isAddress(hederaTokenAddress)) {\n    console.error('Invalid token address');\n    return { err: 'Invalid token address' };\n  } else if (ownerAddress && !isAddress(ownerAddress)) {\n    console.error('Invalid owner address');\n    return { err: 'Invalid owner address' };\n  } else if (spenderAddress && !isAddress(spenderAddress)) {\n    console.error('Invalid spender address');\n    return { err: 'Invalid spender address' };\n  } else if (serialNumber && serialNumber < 0) {\n    console.error('Invalid serial number');\n    return { err: 'Invalid serial number' };\n  }\n\n  // prepare events map\n  const eventMaps = {\n    IS_APPROVAL: 'Approved',\n    ALLOWANCE: 'AllowanceValue',\n    GET_APPROVED: 'ApprovedAddress',\n  };\n\n  let transactionResult, errMsg;\n  // invoking contract methods\n  try {\n    switch (API) {\n      case 'ALLOWANCE':\n        if (!ownerAddress) {\n          errMsg = 'Owner address is needed for ALLOWANCE API';\n        } else if (!spenderAddress) {\n          errMsg = 'Spender address is needed for ALLOWANCE API';\n        } else {\n          if (gasLimit === 0) {\n            const estimateGasResult = await handleEstimateGas(",
                "codeOnlyTokens": 801,
                "startLine": 336,
                "endLine": 439,
                "type": ".ts_part_4",
                "isOversized": false
              },
              {
                "originalText": "              baseContract,\n              signerAddress,\n              network,\n              'allowancePublic',\n              [hederaTokenAddress, ownerAddress, spenderAddress]\n            );\n            if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n            gasLimit = estimateGasResult.gasLimit;\n          }\n          transactionResult = await baseContract.allowancePublic(\n            hederaTokenAddress,\n            ownerAddress,\n            spenderAddress,\n            { gasLimit }\n          );\n        }\n        break;\n      case 'GET_APPROVED':\n        if (!serialNumber) {\n          errMsg = 'Serial number is needed for GET_APPROVED API';\n        } else {\n          if (gasLimit === 0) {\n            const estimateGasResult = await handleEstimateGas(\n              baseContract,\n              signerAddress,\n              network,\n              'getApprovedPublic',\n              [hederaTokenAddress, serialNumber]\n            );\n            if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n            gasLimit = estimateGasResult.gasLimit;\n          }\n          transactionResult = await baseContract.getApprovedPublic(hederaTokenAddress, serialNumber, {\n            gasLimit,\n          });\n        }\n        break;\n      case 'IS_APPROVAL':\n        if (!ownerAddress) {\n          errMsg = 'Owner address is needed for IS_APPROVAL API';\n        } else if (!spenderAddress) {\n          errMsg = 'Spender address is needed for IS_APPROVAL API';\n        } else {\n          if (gasLimit === 0) {\n            const estimateGasResult = await handleEstimateGas(\n              baseContract,\n              signerAddress,\n              network,\n              'isApprovedForAllPublic',\n              [hederaTokenAddress, ownerAddress, spenderAddress]\n            );\n            if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n            gasLimit = estimateGasResult.gasLimit;\n          }\n          transactionResult = await baseContract.isApprovedForAllPublic(\n            hederaTokenAddress,\n            ownerAddress,\n            spenderAddress\n          );\n        }\n        break;\n    }\n\n    // return err if any\n    if (errMsg) {\n      console.error(errMsg);\n      return { err: errMsg };\n    } else if (!transactionResult) {\n      console.error('Cannot execute contract methods');\n      return { err: 'Cannot execute contract methods' };\n    }\n\n    return await handleContractResponseWithDynamicEventNames(transactionResult, eventMaps, API);\n  } catch (err: any) {\n    console.error(err);\n    return { err, transactionHash: err.receipt && err.receipt.hash };\n  }\n};\n\n/**\n * @dev queries token's relation information\n *\n * @dev integrates TokenQueryContract.isKycPublic()\n *\n * @dev integrates TokenQueryContract.isFrozenPublic()\n *\n * @param baseContract: ethers.Contract\n *\n * @param signerAddress: ethers.AddressLike\n *\n * @param network: TNetworkName\n *\n * @param API: \"IS_KYC\" | \"IS_FROZEN\"\n *\n * @param hederaTokenAddress: ethers.AddressLike\n *\n * @param accountAddress: ethers.AddressLike\n *\n * @param gasLimit: number\n *\n * @return Promise<ISmartContractExecutionResult>\n */\nexport const queryTokenStatusInformation = async (\n  baseContract: Contract,\n  signerAddress: ethers.AddressLike,\n  network: TNetworkName,\n  API: 'IS_KYC' | 'IS_FROZEN',\n  hederaTokenAddress: ethers.AddressLike,\n  accountAddress: ethers.AddressLike,\n  gasLimit: number\n): Promise<ISmartContractExecutionResult> => {\n  // sanitize param\n  if (!isAddress(hederaTokenAddress)) {\n    console.error('Invalid token address');\n    return { err: 'Invalid token address' };\n  } else if (accountAddress && !isAddress(accountAddress)) {",
                "codeOnlyTokens": 814,
                "startLine": 440,
                "endLine": 555,
                "type": ".ts_part_5",
                "isOversized": false
              },
              {
                "originalText": "    console.error('Invalid owner address');\n    return { err: 'Invalid owner address' };\n  }\n\n  // prepare events map\n  const eventMaps = {\n    IS_KYC: 'KycGranted',\n    IS_FROZEN: 'Frozen',\n  };\n\n  if (gasLimit === 0) {\n    const estimateGasResult = await handleEstimateGas(\n      baseContract,\n      signerAddress,\n      network,\n      API === 'IS_KYC' ? 'isKycPublic' : 'isFrozenPublic',\n      [hederaTokenAddress, accountAddress]\n    );\n    if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n    gasLimit = estimateGasResult.gasLimit;\n  }\n\n  // invoking contract methods\n  try {\n    let transactionResult;\n    switch (API) {\n      case 'IS_KYC':\n        transactionResult = await baseContract.isKycPublic(hederaTokenAddress, accountAddress, { gasLimit });\n        break;\n\n      case 'IS_FROZEN':\n        transactionResult = await baseContract.isFrozenPublic(hederaTokenAddress, accountAddress, {\n          gasLimit,\n        });\n        break;\n    }\n\n    return await handleContractResponseWithDynamicEventNames(transactionResult, eventMaps, API);\n  } catch (err: any) {\n    console.error(err);\n    return { err, transactionHash: err.receipt && err.receipt.hash };\n  }\n};\n",
                "codeOnlyTokens": 301,
                "startLine": 556,
                "endLine": 599,
                "type": ".ts_part_6",
                "isOversized": false
              }
            ],
            "startLine": 336,
            "endLine": 599,
            "groupId": 2
          }
        ],
        "oversizedChunks": [],
        "sendStrategy": "multiple_groups",
        "finalTokenCount": 4517,
        "skippedContent": [],
        "contextHeader": "// File: system-contract-dapp-playground/src/api/hedera/hts-interactions/tokenQuery-interactions/index.ts\n// Relevant file context:\n// Type: .ts\n",
        "tokenBreakdown": {
          "originalFile": 4341,
          "finalSent": 4517,
          "codeTokensInGroups": 4341,
          "fileHeaderTokensInGroups": 72,
          "shellContextTokensInGroups": 0,
          "separatorTokensInGroups": 104,
          "skippedCodeTokens": 0,
          "unprocessedOversizedTokens": 0,
          "totalSavings": -176,
          "savingsPercentage": -4.05436535360516,
          "fileHeaderCount": 2,
          "fileHeaderAvgSize": 36,
          "shellContextCount": 0,
          "shellContextAvgSize": 0,
          "separatorCount": 6,
          "separatorAvgSize": 17
        }
      }
    },
    {
      "filePath": "repo_cache/hedera-smart-contracts/contracts/system-contracts/hedera-token-service/HederaTokenService.sol",
      "totalOriginalTokens": 10352,
      "finalTokenCount": 10724,
      "impactScore": 52.8,
      "averageComplexity": 7.2,
      "averageQuality": 7.4,
      "usage": {
        "prompt_tokens": 14956,
        "completion_tokens": 619,
        "total_tokens": 15575
      },
      "retries": 0,
      "hadError": false,
      "scoredChunkGroups": [
        {
          "groupId": 1,
          "score": {
            "complexity_score": 8,
            "code_quality_score": 7,
            "maintainability_score": 6,
            "best_practices_adherence": 8,
            "positive_feedback": "The use of precompile addresses for efficient HTS interactions demonstrates a strong understanding of Hedera's architecture.",
            "improvement_suggestion": "Consider implementing checks for token existence before processing mint or burn functions to prevent unnecessary transactions.",
            "group_summary": "This code handles token transfers, minting, and association using Hedera's Token Service."
          },
          "totalTokens": 2491,
          "usage": {
            "prompt_tokens": 3327,
            "completion_tokens": 118,
            "total_tokens": 3445,
            "prompt_tokens_details": {
              "cached_tokens": 0,
              "audio_tokens": 0
            },
            "completion_tokens_details": {
              "reasoning_tokens": 0,
              "audio_tokens": 0,
              "accepted_prediction_tokens": 0,
              "rejected_prediction_tokens": 0
            }
          }
        },
        {
          "groupId": 2,
          "score": {
            "complexity_score": 8,
            "code_quality_score": 7,
            "maintainability_score": 6,
            "best_practices_adherence": 8,
            "positive_feedback": "The interaction with the Hedera precompile allows for seamless custom fee handling, showcasing an advanced use of the platform.",
            "improvement_suggestion": "Consider implementing more extensive error handling to provide clearer feedback during failed calls, enhancing debugging and user experience.",
            "group_summary": "This code manages various token operations using Hedera's Token Service, including creation, transfers, and fee management."
          },
          "totalTokens": 2513,
          "usage": {
            "prompt_tokens": 3359,
            "completion_tokens": 127,
            "total_tokens": 3486,
            "prompt_tokens_details": {
              "cached_tokens": 0,
              "audio_tokens": 0
            },
            "completion_tokens_details": {
              "reasoning_tokens": 0,
              "audio_tokens": 0,
              "accepted_prediction_tokens": 0,
              "rejected_prediction_tokens": 0
            }
          }
        },
        {
          "groupId": 3,
          "score": {
            "complexity_score": 7,
            "code_quality_score": 8,
            "maintainability_score": 7,
            "best_practices_adherence": 8,
            "positive_feedback": "The use of precompile calls to interact with the Hedera Token Service is clean and effective, showcasing a good understanding of Hedera's architecture.",
            "improvement_suggestion": "Consider implementing event emissions for state changes, such as KYC approvals or account freezes, to enhance transparency and tracking.",
            "group_summary": "This code manages back-end operations for NFT and token approval, KYC, and freeze/unfreeze states using the Hedera Token Service."
          },
          "totalTokens": 2504,
          "usage": {
            "prompt_tokens": 3353,
            "completion_tokens": 141,
            "total_tokens": 3494,
            "prompt_tokens_details": {
              "cached_tokens": 0,
              "audio_tokens": 0
            },
            "completion_tokens_details": {
              "reasoning_tokens": 0,
              "audio_tokens": 0,
              "accepted_prediction_tokens": 0,
              "rejected_prediction_tokens": 0
            }
          }
        },
        {
          "groupId": 4,
          "score": {
            "complexity_score": 7,
            "code_quality_score": 8,
            "maintainability_score": 7,
            "best_practices_adherence": 8,
            "positive_feedback": "The use of precompile calls for token operations efficiently interacts with the Hedera Token Service, making the contract operations streamlined.",
            "improvement_suggestion": "Consider implementing detailed revert reasons for failed transactions to enhance debugging and user experience.",
            "group_summary": "This code manages various token operations, including transfers, pauses, and updates within the Hedera ecosystem."
          },
          "totalTokens": 2513,
          "usage": {
            "prompt_tokens": 3367,
            "completion_tokens": 121,
            "total_tokens": 3488,
            "prompt_tokens_details": {
              "cached_tokens": 0,
              "audio_tokens": 0
            },
            "completion_tokens_details": {
              "reasoning_tokens": 0,
              "audio_tokens": 0,
              "accepted_prediction_tokens": 0,
              "rejected_prediction_tokens": 0
            }
          }
        },
        {
          "groupId": 5,
          "score": {
            "complexity_score": 6,
            "code_quality_score": 7,
            "maintainability_score": 7,
            "best_practices_adherence": 8,
            "positive_feedback": "The use of abi.decode for handling responses showcases a good understanding of smart contract interaction in Hedera.",
            "improvement_suggestion": "Consider implementing event logging for each operation to improve traceability and debugging capabilities.",
            "group_summary": "Manages token airdrop operations and rejection within the Hedera ecosystem."
          },
          "totalTokens": 703,
          "usage": {
            "prompt_tokens": 1550,
            "completion_tokens": 112,
            "total_tokens": 1662,
            "prompt_tokens_details": {
              "cached_tokens": 0,
              "audio_tokens": 0
            },
            "completion_tokens_details": {
              "reasoning_tokens": 0,
              "audio_tokens": 0,
              "accepted_prediction_tokens": 0,
              "rejected_prediction_tokens": 0
            }
          }
        }
      ],
      "chunkingDetails": {
        "filePath": "repo_cache/hedera-smart-contracts/contracts/system-contracts/hedera-token-service/HederaTokenService.sol",
        "totalFileTokens": 10352,
        "chunks": [
          {
            "originalText": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.5.0 <0.9.0;\npragma experimental ABIEncoderV2;\n\nimport \"../HederaResponseCodes.sol\";\nimport \"./IHederaTokenService.sol\";\n\nabstract contract HederaTokenService {\n    address constant precompileAddress = address(0x167);\n    // 90 days in seconds\n    int32 constant defaultAutoRenewPeriod = 7776000;\n\n    modifier nonEmptyExpiry(IHederaTokenService.HederaToken memory token)\n    {\n        if (token.expiry.second == 0 && token.expiry.autoRenewPeriod == 0) {\n            token.expiry.autoRenewPeriod = defaultAutoRenewPeriod;\n        }\n        _;\n    }\n\n    /// Generic event\n    event CallResponseEvent(bool, bytes);\n\n    /// Performs transfers among combinations of tokens and hbars\n    /// @param transferList the list of hbar transfers to do\n    /// @param tokenTransfers the list of transfers to do\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @custom:version 0.3.0 the signature of the previous version was cryptoTransfer(TokenTransferList[] memory tokenTransfers)\n    function cryptoTransfer(IHederaTokenService.TransferList memory transferList, IHederaTokenService.TokenTransferList[] memory tokenTransfers) internal\n    returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.cryptoTransfer.selector, transferList, tokenTransfers));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Mints an amount of the token to the defined treasury account\n    /// @param token The token for which to mint tokens. If token does not exist, transaction results in\n    ///              INVALID_TOKEN_ID\n    /// @param amount Applicable to tokens of type FUNGIBLE_COMMON. The amount to mint to the Treasury Account.\n    ///               Amount must be a positive non-zero number represented in the lowest denomination of the\n    ///               token. The new supply must be lower than 2^63.\n    /// @param metadata Applicable to tokens of type NON_FUNGIBLE_UNIQUE. A list of metadata that are being created.\n    ///                 Maximum allowed size of each metadata is 100 bytes\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return newTotalSupply The new supply of tokens. For NFTs it is the total count of NFTs\n    /// @return serialNumbers If the token is an NFT the newly generate serial numbers, otherwise empty.\n    function mintToken(address token, int64 amount, bytes[] memory metadata) internal\n    returns (int responseCode, int64 newTotalSupply, int64[] memory serialNumbers)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.mintToken.selector,\n            token, amount, metadata));\n        (responseCode, newTotalSupply, serialNumbers) =\n        success\n        ? abi.decode(result, (int32, int64, int64[]))\n        : (HederaResponseCodes.UNKNOWN, int64(0), new int64[](0));\n    }\n\n    /// Burns an amount of the token from the defined treasury account\n    /// @param token The token for which to burn tokens. If token does not exist, transaction results in\n    ///              INVALID_TOKEN_ID\n    /// @param amount  Applicable to tokens of type FUNGIBLE_COMMON. The amount to burn from the Treasury Account.\n    ///                Amount must be a positive non-zero number, not bigger than the token balance of the treasury\n    ///                account (0; balance], represented in the lowest denomination.",
            "codeOnlyTokens": 807,
            "startLine": 1,
            "endLine": 65,
            "type": ".sol_part_1",
            "isOversized": false
          },
          {
            "originalText": "    /// @param serialNumbers Applicable to tokens of type NON_FUNGIBLE_UNIQUE. The list of serial numbers to be burned.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return newTotalSupply The new supply of tokens. For NFTs it is the total count of NFTs\n    function burnToken(address token, int64 amount, int64[] memory serialNumbers) internal\n    returns (int responseCode, int64 newTotalSupply)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.burnToken.selector,\n            token, amount, serialNumbers));\n        (responseCode, newTotalSupply) =\n        success\n        ? abi.decode(result, (int32, int64))\n        : (HederaResponseCodes.UNKNOWN, int64(0));\n    }\n\n    ///  Associates the provided account with the provided tokens. Must be signed by the provided\n    ///  Account's key or called from the accounts contract key\n    ///  If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.\n    ///  If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.\n    ///  If any of the provided tokens is not found, the transaction will resolve to INVALID_TOKEN_REF.\n    ///  If any of the provided tokens has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.\n    ///  If an association between the provided account and any of the tokens already exists, the\n    ///  transaction will resolve to TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT.\n    ///  If the provided account's associations count exceed the constraint of maximum token associations\n    ///    per account, the transaction will resolve to TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED.\n    ///  On success, associations between the provided account and tokens are made and the account is\n    ///    ready to interact with the tokens.\n    /// @param account The account to be associated with the provided tokens\n    /// @param tokens The tokens to be associated with the provided account. In the case of NON_FUNGIBLE_UNIQUE\n    ///               Type, once an account is associated, it can hold any number of NFTs (serial numbers) of that\n    ///               token type\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function associateTokens(address account, address[] memory tokens) internal returns (int responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.associateTokens.selector,\n            account, tokens));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    function associateToken(address account, address token) internal returns (int responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.associateToken.selector,\n            account, token));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Dissociates the provided account with the provided tokens. Must be signed by the provided\n    /// Account's key.\n    /// If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.\n    /// If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.\n    /// If any of the provided tokens is not found, the transaction will resolve to INVALID_TOKEN_REF.\n    /// If any of the provided tokens has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.\n    /// If an association between the provided account and any of the tokens does not exist, the\n    /// transaction will resolve to TOKEN_NOT_ASSOCIATED_TO_ACCOUNT.",
            "codeOnlyTokens": 801,
            "startLine": 66,
            "endLine": 119,
            "type": ".sol_part_2",
            "isOversized": false
          },
          {
            "originalText": "    /// If a token has not been deleted and has not expired, and the user has a nonzero balance, the\n    /// transaction will resolve to TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES.\n    /// If a <b>fungible token</b> has expired, the user can disassociate even if their token balance is\n    /// not zero.\n    /// If a <b>non fungible token</b> has expired, the user can <b>not</b> disassociate if their token\n    /// balance is not zero. The transaction will resolve to TRANSACTION_REQUIRED_ZERO_TOKEN_BALANCES.\n    /// On success, associations between the provided account and tokens are removed.\n    /// @param account The account to be dissociated from the provided tokens\n    /// @param tokens The tokens to be dissociated from the provided account.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function dissociateTokens(address account, address[] memory tokens) internal returns (int responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.dissociateTokens.selector,\n            account, tokens));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    function dissociateToken(address account, address token) internal returns (int responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.dissociateToken.selector,\n            account, token));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Creates a Fungible Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @param initialTotalSupply Specifies the initial supply of tokens to be put in circulation. The\n    /// initial supply is sent to the Treasury Account. The supply is in the lowest denomination possible.\n    /// @param decimals the number of decimal places a token is divisible by\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createFungibleToken(\n        IHederaTokenService.HederaToken memory token,\n        int64 initialTotalSupply,\n        int32 decimals) nonEmptyExpiry(token)\n    internal returns (int responseCode, address tokenAddress) {\n        (bool success, bytes memory result) = precompileAddress.call{value : msg.value}(\n            abi.encodeWithSelector(IHederaTokenService.createFungibleToken.selector,\n            token, initialTotalSupply, decimals));\n\n\n        (responseCode, tokenAddress) = success ? abi.decode(result, (int32, address)) : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Creates a Fungible Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @param initialTotalSupply Specifies the initial supply of tokens to be put in circulation. The\n    /// initial supply is sent to the Treasury Account. The supply is in the lowest denomination possible.\n    /// @param decimals the number of decimal places a token is divisible by\n    /// @param fixedFees list of fixed fees to apply to the token\n    /// @param fractionalFees list of fractional fees to apply to the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createFungibleTokenWithCustomFees(\n        IHederaTokenService.HederaToken memory token,\n        int64 initialTotalSupply,\n        int32 decimals,\n        IHederaTokenService.FixedFee[] memory fixedFees,",
            "codeOnlyTokens": 803,
            "startLine": 120,
            "endLine": 177,
            "type": ".sol_part_3",
            "isOversized": false
          },
          {
            "originalText": "        IHederaTokenService.FractionalFee[] memory fractionalFees) nonEmptyExpiry(token)\n    internal returns (int responseCode, address tokenAddress) {\n        (bool success, bytes memory result) = precompileAddress.call{value : msg.value}(\n            abi.encodeWithSelector(IHederaTokenService.createFungibleTokenWithCustomFees.selector,\n            token, initialTotalSupply, decimals, fixedFees, fractionalFees));\n        (responseCode, tokenAddress) = success ? abi.decode(result, (int32, address)) : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Creates an Non Fungible Unique Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createNonFungibleToken(IHederaTokenService.HederaToken memory token) nonEmptyExpiry(token)\n    internal returns (int responseCode, address tokenAddress) {\n        (bool success, bytes memory result) = precompileAddress.call{value : msg.value}(\n            abi.encodeWithSelector(IHederaTokenService.createNonFungibleToken.selector, token));\n        (responseCode, tokenAddress) = success ? abi.decode(result, (int32, address)) : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Creates an Non Fungible Unique Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @param fixedFees list of fixed fees to apply to the token\n    /// @param royaltyFees list of royalty fees to apply to the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createNonFungibleTokenWithCustomFees(\n        IHederaTokenService.HederaToken memory token,\n        IHederaTokenService.FixedFee[] memory fixedFees,\n        IHederaTokenService.RoyaltyFee[] memory royaltyFees) nonEmptyExpiry(token)\n    internal returns (int responseCode, address tokenAddress) {\n        (bool success, bytes memory result) = precompileAddress.call{value : msg.value}(\n            abi.encodeWithSelector(IHederaTokenService.createNonFungibleTokenWithCustomFees.selector,\n            token, fixedFees, royaltyFees));\n        (responseCode, tokenAddress) = success ? abi.decode(result, (int32, address)) : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Retrieves fungible specific token info for a fungible token\n    /// @param token The ID of the token as a solidity address\n    /// @dev This function reverts if the call is not successful\n    function getFungibleTokenInfo(address token) internal returns (int responseCode, IHederaTokenService.FungibleTokenInfo memory tokenInfo) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getFungibleTokenInfo.selector, token));\n        IHederaTokenService.FungibleTokenInfo memory defaultTokenInfo;\n        (responseCode, tokenInfo) = success ? abi.decode(result, (int32, IHederaTokenService.FungibleTokenInfo)) : (HederaResponseCodes.UNKNOWN, defaultTokenInfo);\n    }\n\n    /// Retrieves general token info for a given token\n    /// @param token The ID of the token as a solidity address\n    /// @dev This function reverts if the call is not successful\n    function getTokenInfo(address token) internal returns (int responseCode, IHederaTokenService.TokenInfo memory tokenInfo) {\n        (bool success, bytes memory result) = precompileAddress.call(",
            "codeOnlyTokens": 813,
            "startLine": 178,
            "endLine": 228,
            "type": ".sol_part_4",
            "isOversized": false
          },
          {
            "originalText": "            abi.encodeWithSelector(IHederaTokenService.getTokenInfo.selector, token));\n        IHederaTokenService.TokenInfo memory defaultTokenInfo;\n        (responseCode, tokenInfo) = success ? abi.decode(result, (int32, IHederaTokenService.TokenInfo)) : (HederaResponseCodes.UNKNOWN, defaultTokenInfo);\n    }\n\n    /// Retrieves non-fungible specific token info for a given NFT\n    /// @param token The ID of the token as a solidity address\n    /// @dev This function reverts if the call is not successful\n    function getNonFungibleTokenInfo(address token, int64 serialNumber) internal returns (int responseCode, IHederaTokenService.NonFungibleTokenInfo memory tokenInfo) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getNonFungibleTokenInfo.selector, token, serialNumber));\n        IHederaTokenService.NonFungibleTokenInfo memory defaultTokenInfo;\n        (responseCode, tokenInfo) = success ? abi.decode(result, (int32, IHederaTokenService.NonFungibleTokenInfo)) : (HederaResponseCodes.UNKNOWN, defaultTokenInfo);\n    }\n\n    /// Query token custom fees\n    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return fixedFees Set of fixed fees for `token`\n    /// @return fractionalFees Set of fractional fees for `token`\n    /// @return royaltyFees Set of royalty fees for `token`\n    /// @dev This function reverts if the call is not successful\n    function getTokenCustomFees(address token) internal returns (int64 responseCode,\n        IHederaTokenService.FixedFee[] memory fixedFees,\n        IHederaTokenService.FractionalFee[] memory fractionalFees,\n        IHederaTokenService.RoyaltyFee[] memory royaltyFees) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getTokenCustomFees.selector, token));\n        IHederaTokenService.FixedFee[] memory defaultFixedFees;\n        IHederaTokenService.FractionalFee[] memory defaultFractionalFees;\n        IHederaTokenService.RoyaltyFee[] memory defaultRoyaltyFees;\n        (responseCode, fixedFees, fractionalFees, royaltyFees) =\n        success ? abi.decode\n        (result, (int32, IHederaTokenService.FixedFee[], IHederaTokenService.FractionalFee[], IHederaTokenService.RoyaltyFee[]))\n        : (HederaResponseCodes.UNKNOWN, defaultFixedFees, defaultFractionalFees, defaultRoyaltyFees);\n    }\n\n    /// Allows spender to withdraw from your account multiple times, up to the value amount. If this function is called\n    /// again it overwrites the current allowance with value.\n    /// Only Applicable to Fungible Tokens\n    /// @param token The hedera token address to approve\n    /// @param spender the account authorized to spend\n    /// @param amount the amount of tokens authorized to spend.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function approve(address token, address spender, uint256 amount) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.approve.selector,\n            token, spender, amount));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Transfers `amount` tokens from `from` to `to` using the\n    //  allowance mechanism. `amount` is then deducted from the caller's allowance.",
            "codeOnlyTokens": 805,
            "startLine": 229,
            "endLine": 282,
            "type": ".sol_part_5",
            "isOversized": false
          },
          {
            "originalText": "    /// Only applicable to fungible tokens\n    /// @param token The address of the fungible Hedera token to transfer\n    /// @param from The account address of the owner of the token, on the behalf of which to transfer `amount` tokens\n    /// @param to The account address of the receiver of the `amount` tokens\n    /// @param amount The amount of tokens to transfer from `from` to `to`\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function transferFrom(address token, address from, address to, uint256 amount) external returns (int64 responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.transferFrom.selector,\n            token, from, to, amount));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Transfers `serialNumber` of `token` from `from` to `to` using the allowance mechanism.\n    /// Only applicable to NFT tokens\n    /// @param token The address of the non-fungible Hedera token to transfer\n    /// @param from The account address of the owner of `serialNumber` of `token`\n    /// @param to The account address of the receiver of `serialNumber`\n    /// @param serialNumber The NFT serial number to transfer\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function transferFromNFT(address token, address from, address to, uint256 serialNumber) external returns (int64 responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.transferFromNFT.selector,\n            token, from, to, serialNumber));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Returns the amount which spender is still allowed to withdraw from owner.\n    /// Only Applicable to Fungible Tokens\n    /// @param token The Hedera token address to check the allowance of\n    /// @param owner the owner of the tokens to be spent\n    /// @param spender the spender of the tokens\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function allowance(address token, address owner, address spender) internal returns (int responseCode, uint256 amount)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.allowance.selector,\n            token, owner, spender));\n        (responseCode, amount) = success ? abi.decode(result, (int32, uint256)) : (HederaResponseCodes.UNKNOWN, 0);\n    }\n\n    /// Allow or reaffirm the approved address to transfer an NFT the approved address does not own.\n    /// Only Applicable to NFT Tokens\n    /// @param token The Hedera NFT token address to approve\n    /// @param approved The new approved NFT controller.  To revoke approvals pass in the zero address.\n    /// @param serialNumber The NFT serial number  to approve\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function approveNFT(address token, address approved, uint256 serialNumber) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.approveNFT.selector,\n            token, approved, serialNumber));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Get the approved address for a single NFT\n    /// Only Applicable to NFT Tokens\n    /// @param token The Hedera NFT token address to check approval",
            "codeOnlyTokens": 813,
            "startLine": 283,
            "endLine": 342,
            "type": ".sol_part_6",
            "isOversized": false
          },
          {
            "originalText": "    /// @param serialNumber The NFT to find the approved address for\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return approved The approved address for this NFT, or the zero address if there is none\n    function getApproved(address token, uint256 serialNumber) internal returns (int responseCode, address approved)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getApproved.selector,\n            token, serialNumber));\n        (responseCode, approved) =\n        success\n        ? abi.decode(result, (int32, address))\n        : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Query if token account is frozen\n    /// @param token The token address to check\n    /// @param account The account address associated with the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return frozen True if `account` is frozen for `token`\n    /// @dev This function reverts if the call is not successful\n    function isFrozen(address token, address account) internal returns (int64 responseCode, bool frozen){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.isFrozen.selector, token, account));\n        (responseCode, frozen) = success ? abi.decode(result, (int32, bool)) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Query if token account has kyc granted\n    /// @param token The token address to check\n    /// @param account The account address associated with the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return kycGranted True if `account` has kyc granted for `token`\n    /// @dev This function reverts if the call is not successful\n    function isKyc(address token, address account) internal returns (int64 responseCode, bool kycGranted){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.isKyc.selector, token, account));\n        (responseCode, kycGranted) = success ? abi.decode(result, (int32, bool)) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Operation to freeze token account\n    /// @param token The token address\n    /// @param account The account address to be frozen\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function freezeToken(address token, address account) internal returns (int64 responseCode){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.freezeToken.selector, token, account));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to unfreeze token account\n    /// @param token The token address\n    /// @param account The account address to be unfrozen\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function unfreezeToken(address token, address account) internal returns (int64 responseCode){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.unfreezeToken.selector, token, account));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to grant kyc to token account\n    /// @param token The token address\n    /// @param account The account address to grant kyc",
            "codeOnlyTokens": 804,
            "startLine": 343,
            "endLine": 403,
            "type": ".sol_part_7",
            "isOversized": false
          },
          {
            "originalText": "    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function grantTokenKyc(address token, address account) internal returns (int64 responseCode){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.grantTokenKyc.selector, token, account));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to revoke kyc to token account\n    /// @param token The token address\n    /// @param account The account address to revoke kyc\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function revokeTokenKyc(address token, address account) internal returns (int64 responseCode){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.revokeTokenKyc.selector, token, account));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Enable or disable approval for a third party (\"operator\") to manage\n    ///  all of `msg.sender`'s assets\n    /// @param token The Hedera NFT token address to approve\n    /// @param operator Address to add to the set of authorized operators\n    /// @param approved True if the operator is approved, false to revoke approval\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function setApprovalForAll(address token, address operator, bool approved) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.setApprovalForAll.selector,\n            token, operator, approved));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Query if an address is an authorized operator for another address\n    /// Only Applicable to NFT Tokens\n    /// @param token The Hedera NFT token address to approve\n    /// @param owner The address that owns the NFTs\n    /// @param operator The address that acts on behalf of the owner\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return approved True if `operator` is an approved operator for `owner`, false otherwise\n    function isApprovedForAll(address token, address owner, address operator) internal returns (int responseCode, bool approved)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.isApprovedForAll.selector,\n            token, owner, operator));\n        (responseCode, approved) =\n        success\n        ? abi.decode(result, (int32, bool))\n        : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Query token default freeze status\n    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return defaultFreezeStatus True if `token` default freeze status is frozen.\n    /// @dev This function reverts if the call is not successful\n    function getTokenDefaultFreezeStatus(address token) internal returns (int responseCode, bool defaultFreezeStatus) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getTokenDefaultFreezeStatus.selector, token));\n        (responseCode, defaultFreezeStatus) = success ? abi.decode(result, (int32, bool)) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Query token default kyc status",
            "codeOnlyTokens": 803,
            "startLine": 404,
            "endLine": 464,
            "type": ".sol_part_8",
            "isOversized": false
          },
          {
            "originalText": "    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return defaultKycStatus True if `token` default kyc status is KycNotApplicable and false if Revoked.\n    /// @dev This function reverts if the call is not successful\n    function getTokenDefaultKycStatus(address token) internal returns (int responseCode, bool defaultKycStatus) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getTokenDefaultKycStatus.selector, token));\n        (responseCode, defaultKycStatus) = success ? abi.decode(result, (int32, bool)) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /**********************\n     * ABI v1 calls       *\n     **********************/\n\n    /// Initiates a Fungible Token Transfer\n    /// @param token The ID of the token as a solidity address\n    /// @param accountIds account to do a transfer to/from\n    /// @param amounts The amount from the accountId at the same index\n    function transferTokens(address token, address[] memory accountIds, int64[] memory amounts) internal\n    returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.transferTokens.selector,\n            token, accountIds, amounts));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Initiates a Non-Fungable Token Transfer\n    /// @param token The ID of the token as a solidity address\n    /// @param sender the sender of an nft\n    /// @param receiver the receiver of the nft sent by the same index at sender\n    /// @param serialNumber the serial number of the nft sent by the same index at sender\n    function transferNFTs(address token, address[] memory sender, address[] memory receiver, int64[] memory serialNumber)\n    internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.transferNFTs.selector,\n            token, sender, receiver, serialNumber));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Transfers tokens where the calling account/contract is implicitly the first entry in the token transfer list,\n    /// where the amount is the value needed to zero balance the transfers. Regular signing rules apply for sending\n    /// (positive amount) or receiving (negative amount)\n    /// @param token The token to transfer to/from\n    /// @param sender The sender for the transaction\n    /// @param receiver The receiver of the transaction\n    /// @param amount Non-negative value to send. a negative value will result in a failure.\n    function transferToken(address token, address sender, address receiver, int64 amount) internal\n    returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.transferToken.selector,\n            token, sender, receiver, amount));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Transfers tokens where the calling account/contract is implicitly the first entry in the token transfer list,\n    /// where the amount is the value needed to zero balance the transfers. Regular signing rules apply for sending\n    /// (positive amount) or receiving (negative amount)\n    /// @param token The token to transfer to/from\n    /// @param sender The sender for the transaction\n    /// @param receiver The receiver of the transaction\n    /// @param serialNumber The serial number of the NFT to transfer.",
            "codeOnlyTokens": 812,
            "startLine": 465,
            "endLine": 528,
            "type": ".sol_part_9",
            "isOversized": false
          },
          {
            "originalText": "    function transferNFT(address token, address sender, address receiver, int64 serialNumber) internal\n    returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.transferNFT.selector,\n            token, sender, receiver, serialNumber));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to pause token\n    /// @param token The token address to be paused\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function pauseToken(address token) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.pauseToken.selector, token));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to unpause token\n    /// @param token The token address to be unpaused\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function unpauseToken(address token) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.unpauseToken.selector, token));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to wipe fungible tokens from account\n    /// @param token The token address\n    /// @param account The account address to revoke kyc\n    /// @param amount The number of tokens to wipe\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function wipeTokenAccount(address token, address account, int64 amount) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.wipeTokenAccount.selector, token, account, amount));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to wipe non fungible tokens from account\n    /// @param token The token address\n    /// @param account The account address to revoke kyc\n    /// @param  serialNumbers The serial numbers of token to wipe\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function wipeTokenAccountNFT(address token, address account, int64[] memory serialNumbers) internal\n    returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.wipeTokenAccountNFT.selector, token, account, serialNumbers));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to delete token\n    /// @param token The token address\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function deleteToken(address token) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.deleteToken.selector, token));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to update token keys\n    /// @param token The token address\n    /// @param keys The token keys\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateTokenKeys(address token, IHederaTokenService.TokenKey[] memory keys)",
            "codeOnlyTokens": 816,
            "startLine": 529,
            "endLine": 597,
            "type": ".sol_part_10",
            "isOversized": false
          },
          {
            "originalText": "    internal returns (int64 responseCode){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.updateTokenKeys.selector, token, keys));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Query token KeyValue\n    /// @param token The token address to check\n    /// @param keyType The keyType of the desired KeyValue\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return key KeyValue info for key of type `keyType`\n    /// @dev This function reverts if the call is not successful\n    function getTokenKey(address token, uint keyType)\n    internal returns (int64 responseCode, IHederaTokenService.KeyValue memory key){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getTokenKey.selector, token, keyType));\n        IHederaTokenService.KeyValue memory defaultKeyValueInfo;\n        (responseCode, key) = success ? abi.decode(result, (int32,IHederaTokenService.KeyValue) ) : (HederaResponseCodes.UNKNOWN, defaultKeyValueInfo);\n    }\n\n\n    /// Query if valid token found for the given address\n    /// @param token The token address\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return isTokenFlag True if valid token found for the given address\n    /// @dev This function reverts if the call is not successful\n    function isToken(address token) internal returns (int64 responseCode, bool isTokenFlag) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.isToken.selector, token));\n        (responseCode, isTokenFlag) = success ? abi.decode(result, (int32, bool)) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Query to return the token type for a given address\n    /// @param token The token address\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenType the token type. 0 is FUNGIBLE_COMMON, 1 is NON_FUNGIBLE_UNIQUE, -1 is UNRECOGNIZED\n    /// @dev This function reverts if the call is not successful\n    function getTokenType(address token) internal returns (int64 responseCode, int32 tokenType) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getTokenType.selector, token));\n        (responseCode, tokenType) = success ? abi.decode(result, (int32, int32)) : (HederaResponseCodes.UNKNOWN, - 1);\n    }\n\n    /// Operation to get token expiry info\n    /// @param token The token address\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return expiryInfo The expiry info of the token\n    /// @dev This function reverts if the call is not successful\n    function getTokenExpiryInfo(address token) internal returns (int responseCode, IHederaTokenService.Expiry memory expiryInfo){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getTokenExpiryInfo.selector, token));\n        IHederaTokenService.Expiry memory defaultExpiryInfo;\n        (responseCode, expiryInfo) = success ? abi.decode(result, (int32, IHederaTokenService.Expiry)) : (HederaResponseCodes.UNKNOWN, defaultExpiryInfo);",
            "codeOnlyTokens": 808,
            "startLine": 598,
            "endLine": 650,
            "type": ".sol_part_11",
            "isOversized": false
          },
          {
            "originalText": "    }\n\n    /// Operation to update token expiry info\n    /// @param token The token address\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateTokenExpiryInfo(address token, IHederaTokenService.Expiry memory expiryInfo) internal returns (int responseCode){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.updateTokenExpiryInfo.selector, token, expiryInfo));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to update token info\n    /// @param token The token address\n    /// @param tokenInfo The hedera token info to update token with\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateTokenInfo(address token, IHederaTokenService.HederaToken memory tokenInfo) internal returns (int responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.updateTokenInfo.selector, token, tokenInfo));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Redirect for token\n    /// @param token The token address\n    /// @param encodedFunctionSelector The function selector from the ERC20 interface + the bytes input for the function called\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return response The result of the call that had been encoded and sent for execution.\n    function redirectForToken(address token, bytes memory encodedFunctionSelector) external returns (int responseCode, bytes memory response) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.redirectForToken.selector, token, encodedFunctionSelector)\n        );\n\n        emit CallResponseEvent(success, result);\n        (responseCode, response) = success ? (HederaResponseCodes.SUCCESS, result) : (HederaResponseCodes.UNKNOWN, bytes(\"\"));\n    }\n\n    /// Update the custom fees for a fungible token\n    /// @param token The token address\n    /// @param fixedFees Set of fixed fees for `token`\n    /// @param fractionalFees Set of fractional fees for `token`\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateFungibleTokenCustomFees(address token,  IHederaTokenService.FixedFee[] memory fixedFees, IHederaTokenService.FractionalFee[] memory fractionalFees) internal returns (int64 responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.updateFungibleTokenCustomFees.selector, token, fixedFees, fractionalFees));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Update the custom fees for a non-fungible token\n    /// @param token The token address\n    /// @param fixedFees Set of fixed fees for `token`\n    /// @param royaltyFees Set of royalty fees for `token`\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateNonFungibleTokenCustomFees(address token, IHederaTokenService.FixedFee[] memory fixedFees, IHederaTokenService.RoyaltyFee[] memory royaltyFees) internal returns (int64 responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.updateNonFungibleTokenCustomFees.selector, token, fixedFees, royaltyFees));",
            "codeOnlyTokens": 808,
            "startLine": 651,
            "endLine": 704,
            "type": ".sol_part_12",
            "isOversized": false
          },
          {
            "originalText": "        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// @notice Airdrop one or more tokens to one or more accounts\n    /// @param tokenTransfers Array of token transfer lists containing token addresses and recipient details\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function airdropTokens(IHederaTokenService.TokenTransferList[] memory tokenTransfers) internal returns (int64 responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.airdropTokens.selector, tokenTransfers));\n\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// @notice Cancels pending airdrops that have not yet been claimed\n    /// @param pendingAirdrops Array of pending airdrops to cancel\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function cancelAirdrops(IHederaTokenService.PendingAirdrop[] memory pendingAirdrops) internal returns (int64 responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.cancelAirdrops.selector, pendingAirdrops)\n        );\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// @notice Claims pending airdrops that were sent to the calling account\n    /// @param pendingAirdrops Array of pending airdrops to claim\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function claimAirdrops(IHederaTokenService.PendingAirdrop[] memory pendingAirdrops) internal returns (int64 responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.claimAirdrops.selector, pendingAirdrops)\n        );\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// @notice Rejects one or more tokens by transferring their full balance from the requesting account to the treasury\n    /// @param rejectingAddress The address rejecting the tokens\n    /// @param ftAddresses Array of fungible token addresses to reject\n    /// @param nftIds Array of NFT IDs to reject\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function rejectTokens(address rejectingAddress, address[] memory ftAddresses, IHederaTokenService.NftID[] memory nftIds) internal returns (int64 responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.rejectTokens.selector, rejectingAddress, ftAddresses, nftIds)\n        );\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n}\n",
            "codeOnlyTokens": 656,
            "startLine": 705,
            "endLine": 750,
            "type": ".sol_part_13",
            "isOversized": false
          }
        ],
        "groupedChunks": [
          {
            "combinedText": "// File: contracts/system-contracts/hedera-token-service/HederaTokenService.sol\n// Relevant file context:\n// Type: .sol\n\n\n// --- Next chunk ---\n\n// Lines 1-65 (.sol_part_1)\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.5.0 <0.9.0;\npragma experimental ABIEncoderV2;\n\nimport \"../HederaResponseCodes.sol\";\nimport \"./IHederaTokenService.sol\";\n\nabstract contract HederaTokenService {\n    address constant precompileAddress = address(0x167);\n    // 90 days in seconds\n    int32 constant defaultAutoRenewPeriod = 7776000;\n\n    modifier nonEmptyExpiry(IHederaTokenService.HederaToken memory token)\n    {\n        if (token.expiry.second == 0 && token.expiry.autoRenewPeriod == 0) {\n            token.expiry.autoRenewPeriod = defaultAutoRenewPeriod;\n        }\n        _;\n    }\n\n    /// Generic event\n    event CallResponseEvent(bool, bytes);\n\n    /// Performs transfers among combinations of tokens and hbars\n    /// @param transferList the list of hbar transfers to do\n    /// @param tokenTransfers the list of transfers to do\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @custom:version 0.3.0 the signature of the previous version was cryptoTransfer(TokenTransferList[] memory tokenTransfers)\n    function cryptoTransfer(IHederaTokenService.TransferList memory transferList, IHederaTokenService.TokenTransferList[] memory tokenTransfers) internal\n    returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.cryptoTransfer.selector, transferList, tokenTransfers));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Mints an amount of the token to the defined treasury account\n    /// @param token The token for which to mint tokens. If token does not exist, transaction results in\n    ///              INVALID_TOKEN_ID\n    /// @param amount Applicable to tokens of type FUNGIBLE_COMMON. The amount to mint to the Treasury Account.\n    ///               Amount must be a positive non-zero number represented in the lowest denomination of the\n    ///               token. The new supply must be lower than 2^63.\n    /// @param metadata Applicable to tokens of type NON_FUNGIBLE_UNIQUE. A list of metadata that are being created.\n    ///                 Maximum allowed size of each metadata is 100 bytes\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return newTotalSupply The new supply of tokens. For NFTs it is the total count of NFTs\n    /// @return serialNumbers If the token is an NFT the newly generate serial numbers, otherwise empty.\n    function mintToken(address token, int64 amount, bytes[] memory metadata) internal\n    returns (int responseCode, int64 newTotalSupply, int64[] memory serialNumbers)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.mintToken.selector,\n            token, amount, metadata));\n        (responseCode, newTotalSupply, serialNumbers) =\n        success\n        ? abi.decode(result, (int32, int64, int64[]))\n        : (HederaResponseCodes.UNKNOWN, int64(0), new int64[](0));\n    }\n\n    /// Burns an amount of the token from the defined treasury account\n    /// @param token The token for which to burn tokens. If token does not exist, transaction results in\n    ///              INVALID_TOKEN_ID\n    /// @param amount  Applicable to tokens of type FUNGIBLE_COMMON. The amount to burn from the Treasury Account.\n    ///                Amount must be a positive non-zero number, not bigger than the token balance of the treasury\n    ///                account (0; balance], represented in the lowest denomination.\n\n// --- Next chunk ---\n\n// Lines 66-119 (.sol_part_2)\n    /// @param serialNumbers Applicable to tokens of type NON_FUNGIBLE_UNIQUE. The list of serial numbers to be burned.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return newTotalSupply The new supply of tokens. For NFTs it is the total count of NFTs\n    function burnToken(address token, int64 amount, int64[] memory serialNumbers) internal\n    returns (int responseCode, int64 newTotalSupply)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.burnToken.selector,\n            token, amount, serialNumbers));\n        (responseCode, newTotalSupply) =\n        success\n        ? abi.decode(result, (int32, int64))\n        : (HederaResponseCodes.UNKNOWN, int64(0));\n    }\n\n    ///  Associates the provided account with the provided tokens. Must be signed by the provided\n    ///  Account's key or called from the accounts contract key\n    ///  If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.\n    ///  If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.\n    ///  If any of the provided tokens is not found, the transaction will resolve to INVALID_TOKEN_REF.\n    ///  If any of the provided tokens has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.\n    ///  If an association between the provided account and any of the tokens already exists, the\n    ///  transaction will resolve to TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT.\n    ///  If the provided account's associations count exceed the constraint of maximum token associations\n    ///    per account, the transaction will resolve to TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED.\n    ///  On success, associations between the provided account and tokens are made and the account is\n    ///    ready to interact with the tokens.\n    /// @param account The account to be associated with the provided tokens\n    /// @param tokens The tokens to be associated with the provided account. In the case of NON_FUNGIBLE_UNIQUE\n    ///               Type, once an account is associated, it can hold any number of NFTs (serial numbers) of that\n    ///               token type\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function associateTokens(address account, address[] memory tokens) internal returns (int responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.associateTokens.selector,\n            account, tokens));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    function associateToken(address account, address token) internal returns (int responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.associateToken.selector,\n            account, token));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Dissociates the provided account with the provided tokens. Must be signed by the provided\n    /// Account's key.\n    /// If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.\n    /// If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.\n    /// If any of the provided tokens is not found, the transaction will resolve to INVALID_TOKEN_REF.\n    /// If any of the provided tokens has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.\n    /// If an association between the provided account and any of the tokens does not exist, the\n    /// transaction will resolve to TOKEN_NOT_ASSOCIATED_TO_ACCOUNT.\n\n// --- Next chunk ---\n\n// Lines 120-177 (.sol_part_3)\n    /// If a token has not been deleted and has not expired, and the user has a nonzero balance, the\n    /// transaction will resolve to TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES.\n    /// If a <b>fungible token</b> has expired, the user can disassociate even if their token balance is\n    /// not zero.\n    /// If a <b>non fungible token</b> has expired, the user can <b>not</b> disassociate if their token\n    /// balance is not zero. The transaction will resolve to TRANSACTION_REQUIRED_ZERO_TOKEN_BALANCES.\n    /// On success, associations between the provided account and tokens are removed.\n    /// @param account The account to be dissociated from the provided tokens\n    /// @param tokens The tokens to be dissociated from the provided account.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function dissociateTokens(address account, address[] memory tokens) internal returns (int responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.dissociateTokens.selector,\n            account, tokens));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    function dissociateToken(address account, address token) internal returns (int responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.dissociateToken.selector,\n            account, token));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Creates a Fungible Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @param initialTotalSupply Specifies the initial supply of tokens to be put in circulation. The\n    /// initial supply is sent to the Treasury Account. The supply is in the lowest denomination possible.\n    /// @param decimals the number of decimal places a token is divisible by\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createFungibleToken(\n        IHederaTokenService.HederaToken memory token,\n        int64 initialTotalSupply,\n        int32 decimals) nonEmptyExpiry(token)\n    internal returns (int responseCode, address tokenAddress) {\n        (bool success, bytes memory result) = precompileAddress.call{value : msg.value}(\n            abi.encodeWithSelector(IHederaTokenService.createFungibleToken.selector,\n            token, initialTotalSupply, decimals));\n\n\n        (responseCode, tokenAddress) = success ? abi.decode(result, (int32, address)) : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Creates a Fungible Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @param initialTotalSupply Specifies the initial supply of tokens to be put in circulation. The\n    /// initial supply is sent to the Treasury Account. The supply is in the lowest denomination possible.\n    /// @param decimals the number of decimal places a token is divisible by\n    /// @param fixedFees list of fixed fees to apply to the token\n    /// @param fractionalFees list of fractional fees to apply to the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createFungibleTokenWithCustomFees(\n        IHederaTokenService.HederaToken memory token,\n        int64 initialTotalSupply,\n        int32 decimals,\n        IHederaTokenService.FixedFee[] memory fixedFees,",
            "totalTokens": 2491,
            "chunks": [
              {
                "originalText": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.5.0 <0.9.0;\npragma experimental ABIEncoderV2;\n\nimport \"../HederaResponseCodes.sol\";\nimport \"./IHederaTokenService.sol\";\n\nabstract contract HederaTokenService {\n    address constant precompileAddress = address(0x167);\n    // 90 days in seconds\n    int32 constant defaultAutoRenewPeriod = 7776000;\n\n    modifier nonEmptyExpiry(IHederaTokenService.HederaToken memory token)\n    {\n        if (token.expiry.second == 0 && token.expiry.autoRenewPeriod == 0) {\n            token.expiry.autoRenewPeriod = defaultAutoRenewPeriod;\n        }\n        _;\n    }\n\n    /// Generic event\n    event CallResponseEvent(bool, bytes);\n\n    /// Performs transfers among combinations of tokens and hbars\n    /// @param transferList the list of hbar transfers to do\n    /// @param tokenTransfers the list of transfers to do\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @custom:version 0.3.0 the signature of the previous version was cryptoTransfer(TokenTransferList[] memory tokenTransfers)\n    function cryptoTransfer(IHederaTokenService.TransferList memory transferList, IHederaTokenService.TokenTransferList[] memory tokenTransfers) internal\n    returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.cryptoTransfer.selector, transferList, tokenTransfers));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Mints an amount of the token to the defined treasury account\n    /// @param token The token for which to mint tokens. If token does not exist, transaction results in\n    ///              INVALID_TOKEN_ID\n    /// @param amount Applicable to tokens of type FUNGIBLE_COMMON. The amount to mint to the Treasury Account.\n    ///               Amount must be a positive non-zero number represented in the lowest denomination of the\n    ///               token. The new supply must be lower than 2^63.\n    /// @param metadata Applicable to tokens of type NON_FUNGIBLE_UNIQUE. A list of metadata that are being created.\n    ///                 Maximum allowed size of each metadata is 100 bytes\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return newTotalSupply The new supply of tokens. For NFTs it is the total count of NFTs\n    /// @return serialNumbers If the token is an NFT the newly generate serial numbers, otherwise empty.\n    function mintToken(address token, int64 amount, bytes[] memory metadata) internal\n    returns (int responseCode, int64 newTotalSupply, int64[] memory serialNumbers)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.mintToken.selector,\n            token, amount, metadata));\n        (responseCode, newTotalSupply, serialNumbers) =\n        success\n        ? abi.decode(result, (int32, int64, int64[]))\n        : (HederaResponseCodes.UNKNOWN, int64(0), new int64[](0));\n    }\n\n    /// Burns an amount of the token from the defined treasury account\n    /// @param token The token for which to burn tokens. If token does not exist, transaction results in\n    ///              INVALID_TOKEN_ID\n    /// @param amount  Applicable to tokens of type FUNGIBLE_COMMON. The amount to burn from the Treasury Account.\n    ///                Amount must be a positive non-zero number, not bigger than the token balance of the treasury\n    ///                account (0; balance], represented in the lowest denomination.",
                "codeOnlyTokens": 807,
                "startLine": 1,
                "endLine": 65,
                "type": ".sol_part_1",
                "isOversized": false
              },
              {
                "originalText": "    /// @param serialNumbers Applicable to tokens of type NON_FUNGIBLE_UNIQUE. The list of serial numbers to be burned.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return newTotalSupply The new supply of tokens. For NFTs it is the total count of NFTs\n    function burnToken(address token, int64 amount, int64[] memory serialNumbers) internal\n    returns (int responseCode, int64 newTotalSupply)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.burnToken.selector,\n            token, amount, serialNumbers));\n        (responseCode, newTotalSupply) =\n        success\n        ? abi.decode(result, (int32, int64))\n        : (HederaResponseCodes.UNKNOWN, int64(0));\n    }\n\n    ///  Associates the provided account with the provided tokens. Must be signed by the provided\n    ///  Account's key or called from the accounts contract key\n    ///  If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.\n    ///  If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.\n    ///  If any of the provided tokens is not found, the transaction will resolve to INVALID_TOKEN_REF.\n    ///  If any of the provided tokens has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.\n    ///  If an association between the provided account and any of the tokens already exists, the\n    ///  transaction will resolve to TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT.\n    ///  If the provided account's associations count exceed the constraint of maximum token associations\n    ///    per account, the transaction will resolve to TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED.\n    ///  On success, associations between the provided account and tokens are made and the account is\n    ///    ready to interact with the tokens.\n    /// @param account The account to be associated with the provided tokens\n    /// @param tokens The tokens to be associated with the provided account. In the case of NON_FUNGIBLE_UNIQUE\n    ///               Type, once an account is associated, it can hold any number of NFTs (serial numbers) of that\n    ///               token type\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function associateTokens(address account, address[] memory tokens) internal returns (int responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.associateTokens.selector,\n            account, tokens));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    function associateToken(address account, address token) internal returns (int responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.associateToken.selector,\n            account, token));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Dissociates the provided account with the provided tokens. Must be signed by the provided\n    /// Account's key.\n    /// If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.\n    /// If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.\n    /// If any of the provided tokens is not found, the transaction will resolve to INVALID_TOKEN_REF.\n    /// If any of the provided tokens has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.\n    /// If an association between the provided account and any of the tokens does not exist, the\n    /// transaction will resolve to TOKEN_NOT_ASSOCIATED_TO_ACCOUNT.",
                "codeOnlyTokens": 801,
                "startLine": 66,
                "endLine": 119,
                "type": ".sol_part_2",
                "isOversized": false
              },
              {
                "originalText": "    /// If a token has not been deleted and has not expired, and the user has a nonzero balance, the\n    /// transaction will resolve to TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES.\n    /// If a <b>fungible token</b> has expired, the user can disassociate even if their token balance is\n    /// not zero.\n    /// If a <b>non fungible token</b> has expired, the user can <b>not</b> disassociate if their token\n    /// balance is not zero. The transaction will resolve to TRANSACTION_REQUIRED_ZERO_TOKEN_BALANCES.\n    /// On success, associations between the provided account and tokens are removed.\n    /// @param account The account to be dissociated from the provided tokens\n    /// @param tokens The tokens to be dissociated from the provided account.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function dissociateTokens(address account, address[] memory tokens) internal returns (int responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.dissociateTokens.selector,\n            account, tokens));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    function dissociateToken(address account, address token) internal returns (int responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.dissociateToken.selector,\n            account, token));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Creates a Fungible Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @param initialTotalSupply Specifies the initial supply of tokens to be put in circulation. The\n    /// initial supply is sent to the Treasury Account. The supply is in the lowest denomination possible.\n    /// @param decimals the number of decimal places a token is divisible by\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createFungibleToken(\n        IHederaTokenService.HederaToken memory token,\n        int64 initialTotalSupply,\n        int32 decimals) nonEmptyExpiry(token)\n    internal returns (int responseCode, address tokenAddress) {\n        (bool success, bytes memory result) = precompileAddress.call{value : msg.value}(\n            abi.encodeWithSelector(IHederaTokenService.createFungibleToken.selector,\n            token, initialTotalSupply, decimals));\n\n\n        (responseCode, tokenAddress) = success ? abi.decode(result, (int32, address)) : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Creates a Fungible Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @param initialTotalSupply Specifies the initial supply of tokens to be put in circulation. The\n    /// initial supply is sent to the Treasury Account. The supply is in the lowest denomination possible.\n    /// @param decimals the number of decimal places a token is divisible by\n    /// @param fixedFees list of fixed fees to apply to the token\n    /// @param fractionalFees list of fractional fees to apply to the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createFungibleTokenWithCustomFees(\n        IHederaTokenService.HederaToken memory token,\n        int64 initialTotalSupply,\n        int32 decimals,\n        IHederaTokenService.FixedFee[] memory fixedFees,",
                "codeOnlyTokens": 803,
                "startLine": 120,
                "endLine": 177,
                "type": ".sol_part_3",
                "isOversized": false
              }
            ],
            "startLine": 1,
            "endLine": 177,
            "groupId": 1
          },
          {
            "combinedText": "// File: contracts/system-contracts/hedera-token-service/HederaTokenService.sol\n// Relevant file context:\n// Type: .sol\n\n\n// --- Next chunk ---\n\n// Lines 178-228 (.sol_part_4)\n        IHederaTokenService.FractionalFee[] memory fractionalFees) nonEmptyExpiry(token)\n    internal returns (int responseCode, address tokenAddress) {\n        (bool success, bytes memory result) = precompileAddress.call{value : msg.value}(\n            abi.encodeWithSelector(IHederaTokenService.createFungibleTokenWithCustomFees.selector,\n            token, initialTotalSupply, decimals, fixedFees, fractionalFees));\n        (responseCode, tokenAddress) = success ? abi.decode(result, (int32, address)) : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Creates an Non Fungible Unique Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createNonFungibleToken(IHederaTokenService.HederaToken memory token) nonEmptyExpiry(token)\n    internal returns (int responseCode, address tokenAddress) {\n        (bool success, bytes memory result) = precompileAddress.call{value : msg.value}(\n            abi.encodeWithSelector(IHederaTokenService.createNonFungibleToken.selector, token));\n        (responseCode, tokenAddress) = success ? abi.decode(result, (int32, address)) : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Creates an Non Fungible Unique Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @param fixedFees list of fixed fees to apply to the token\n    /// @param royaltyFees list of royalty fees to apply to the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createNonFungibleTokenWithCustomFees(\n        IHederaTokenService.HederaToken memory token,\n        IHederaTokenService.FixedFee[] memory fixedFees,\n        IHederaTokenService.RoyaltyFee[] memory royaltyFees) nonEmptyExpiry(token)\n    internal returns (int responseCode, address tokenAddress) {\n        (bool success, bytes memory result) = precompileAddress.call{value : msg.value}(\n            abi.encodeWithSelector(IHederaTokenService.createNonFungibleTokenWithCustomFees.selector,\n            token, fixedFees, royaltyFees));\n        (responseCode, tokenAddress) = success ? abi.decode(result, (int32, address)) : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Retrieves fungible specific token info for a fungible token\n    /// @param token The ID of the token as a solidity address\n    /// @dev This function reverts if the call is not successful\n    function getFungibleTokenInfo(address token) internal returns (int responseCode, IHederaTokenService.FungibleTokenInfo memory tokenInfo) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getFungibleTokenInfo.selector, token));\n        IHederaTokenService.FungibleTokenInfo memory defaultTokenInfo;\n        (responseCode, tokenInfo) = success ? abi.decode(result, (int32, IHederaTokenService.FungibleTokenInfo)) : (HederaResponseCodes.UNKNOWN, defaultTokenInfo);\n    }\n\n    /// Retrieves general token info for a given token\n    /// @param token The ID of the token as a solidity address\n    /// @dev This function reverts if the call is not successful\n    function getTokenInfo(address token) internal returns (int responseCode, IHederaTokenService.TokenInfo memory tokenInfo) {\n        (bool success, bytes memory result) = precompileAddress.call(\n\n// --- Next chunk ---\n\n// Lines 229-282 (.sol_part_5)\n            abi.encodeWithSelector(IHederaTokenService.getTokenInfo.selector, token));\n        IHederaTokenService.TokenInfo memory defaultTokenInfo;\n        (responseCode, tokenInfo) = success ? abi.decode(result, (int32, IHederaTokenService.TokenInfo)) : (HederaResponseCodes.UNKNOWN, defaultTokenInfo);\n    }\n\n    /// Retrieves non-fungible specific token info for a given NFT\n    /// @param token The ID of the token as a solidity address\n    /// @dev This function reverts if the call is not successful\n    function getNonFungibleTokenInfo(address token, int64 serialNumber) internal returns (int responseCode, IHederaTokenService.NonFungibleTokenInfo memory tokenInfo) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getNonFungibleTokenInfo.selector, token, serialNumber));\n        IHederaTokenService.NonFungibleTokenInfo memory defaultTokenInfo;\n        (responseCode, tokenInfo) = success ? abi.decode(result, (int32, IHederaTokenService.NonFungibleTokenInfo)) : (HederaResponseCodes.UNKNOWN, defaultTokenInfo);\n    }\n\n    /// Query token custom fees\n    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return fixedFees Set of fixed fees for `token`\n    /// @return fractionalFees Set of fractional fees for `token`\n    /// @return royaltyFees Set of royalty fees for `token`\n    /// @dev This function reverts if the call is not successful\n    function getTokenCustomFees(address token) internal returns (int64 responseCode,\n        IHederaTokenService.FixedFee[] memory fixedFees,\n        IHederaTokenService.FractionalFee[] memory fractionalFees,\n        IHederaTokenService.RoyaltyFee[] memory royaltyFees) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getTokenCustomFees.selector, token));\n        IHederaTokenService.FixedFee[] memory defaultFixedFees;\n        IHederaTokenService.FractionalFee[] memory defaultFractionalFees;\n        IHederaTokenService.RoyaltyFee[] memory defaultRoyaltyFees;\n        (responseCode, fixedFees, fractionalFees, royaltyFees) =\n        success ? abi.decode\n        (result, (int32, IHederaTokenService.FixedFee[], IHederaTokenService.FractionalFee[], IHederaTokenService.RoyaltyFee[]))\n        : (HederaResponseCodes.UNKNOWN, defaultFixedFees, defaultFractionalFees, defaultRoyaltyFees);\n    }\n\n    /// Allows spender to withdraw from your account multiple times, up to the value amount. If this function is called\n    /// again it overwrites the current allowance with value.\n    /// Only Applicable to Fungible Tokens\n    /// @param token The hedera token address to approve\n    /// @param spender the account authorized to spend\n    /// @param amount the amount of tokens authorized to spend.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function approve(address token, address spender, uint256 amount) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.approve.selector,\n            token, spender, amount));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Transfers `amount` tokens from `from` to `to` using the\n    //  allowance mechanism. `amount` is then deducted from the caller's allowance.\n\n// --- Next chunk ---\n\n// Lines 283-342 (.sol_part_6)\n    /// Only applicable to fungible tokens\n    /// @param token The address of the fungible Hedera token to transfer\n    /// @param from The account address of the owner of the token, on the behalf of which to transfer `amount` tokens\n    /// @param to The account address of the receiver of the `amount` tokens\n    /// @param amount The amount of tokens to transfer from `from` to `to`\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function transferFrom(address token, address from, address to, uint256 amount) external returns (int64 responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.transferFrom.selector,\n            token, from, to, amount));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Transfers `serialNumber` of `token` from `from` to `to` using the allowance mechanism.\n    /// Only applicable to NFT tokens\n    /// @param token The address of the non-fungible Hedera token to transfer\n    /// @param from The account address of the owner of `serialNumber` of `token`\n    /// @param to The account address of the receiver of `serialNumber`\n    /// @param serialNumber The NFT serial number to transfer\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function transferFromNFT(address token, address from, address to, uint256 serialNumber) external returns (int64 responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.transferFromNFT.selector,\n            token, from, to, serialNumber));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Returns the amount which spender is still allowed to withdraw from owner.\n    /// Only Applicable to Fungible Tokens\n    /// @param token The Hedera token address to check the allowance of\n    /// @param owner the owner of the tokens to be spent\n    /// @param spender the spender of the tokens\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function allowance(address token, address owner, address spender) internal returns (int responseCode, uint256 amount)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.allowance.selector,\n            token, owner, spender));\n        (responseCode, amount) = success ? abi.decode(result, (int32, uint256)) : (HederaResponseCodes.UNKNOWN, 0);\n    }\n\n    /// Allow or reaffirm the approved address to transfer an NFT the approved address does not own.\n    /// Only Applicable to NFT Tokens\n    /// @param token The Hedera NFT token address to approve\n    /// @param approved The new approved NFT controller.  To revoke approvals pass in the zero address.\n    /// @param serialNumber The NFT serial number  to approve\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function approveNFT(address token, address approved, uint256 serialNumber) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.approveNFT.selector,\n            token, approved, serialNumber));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Get the approved address for a single NFT\n    /// Only Applicable to NFT Tokens\n    /// @param token The Hedera NFT token address to check approval",
            "totalTokens": 2513,
            "chunks": [
              {
                "originalText": "        IHederaTokenService.FractionalFee[] memory fractionalFees) nonEmptyExpiry(token)\n    internal returns (int responseCode, address tokenAddress) {\n        (bool success, bytes memory result) = precompileAddress.call{value : msg.value}(\n            abi.encodeWithSelector(IHederaTokenService.createFungibleTokenWithCustomFees.selector,\n            token, initialTotalSupply, decimals, fixedFees, fractionalFees));\n        (responseCode, tokenAddress) = success ? abi.decode(result, (int32, address)) : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Creates an Non Fungible Unique Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createNonFungibleToken(IHederaTokenService.HederaToken memory token) nonEmptyExpiry(token)\n    internal returns (int responseCode, address tokenAddress) {\n        (bool success, bytes memory result) = precompileAddress.call{value : msg.value}(\n            abi.encodeWithSelector(IHederaTokenService.createNonFungibleToken.selector, token));\n        (responseCode, tokenAddress) = success ? abi.decode(result, (int32, address)) : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Creates an Non Fungible Unique Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @param fixedFees list of fixed fees to apply to the token\n    /// @param royaltyFees list of royalty fees to apply to the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createNonFungibleTokenWithCustomFees(\n        IHederaTokenService.HederaToken memory token,\n        IHederaTokenService.FixedFee[] memory fixedFees,\n        IHederaTokenService.RoyaltyFee[] memory royaltyFees) nonEmptyExpiry(token)\n    internal returns (int responseCode, address tokenAddress) {\n        (bool success, bytes memory result) = precompileAddress.call{value : msg.value}(\n            abi.encodeWithSelector(IHederaTokenService.createNonFungibleTokenWithCustomFees.selector,\n            token, fixedFees, royaltyFees));\n        (responseCode, tokenAddress) = success ? abi.decode(result, (int32, address)) : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Retrieves fungible specific token info for a fungible token\n    /// @param token The ID of the token as a solidity address\n    /// @dev This function reverts if the call is not successful\n    function getFungibleTokenInfo(address token) internal returns (int responseCode, IHederaTokenService.FungibleTokenInfo memory tokenInfo) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getFungibleTokenInfo.selector, token));\n        IHederaTokenService.FungibleTokenInfo memory defaultTokenInfo;\n        (responseCode, tokenInfo) = success ? abi.decode(result, (int32, IHederaTokenService.FungibleTokenInfo)) : (HederaResponseCodes.UNKNOWN, defaultTokenInfo);\n    }\n\n    /// Retrieves general token info for a given token\n    /// @param token The ID of the token as a solidity address\n    /// @dev This function reverts if the call is not successful\n    function getTokenInfo(address token) internal returns (int responseCode, IHederaTokenService.TokenInfo memory tokenInfo) {\n        (bool success, bytes memory result) = precompileAddress.call(",
                "codeOnlyTokens": 813,
                "startLine": 178,
                "endLine": 228,
                "type": ".sol_part_4",
                "isOversized": false
              },
              {
                "originalText": "            abi.encodeWithSelector(IHederaTokenService.getTokenInfo.selector, token));\n        IHederaTokenService.TokenInfo memory defaultTokenInfo;\n        (responseCode, tokenInfo) = success ? abi.decode(result, (int32, IHederaTokenService.TokenInfo)) : (HederaResponseCodes.UNKNOWN, defaultTokenInfo);\n    }\n\n    /// Retrieves non-fungible specific token info for a given NFT\n    /// @param token The ID of the token as a solidity address\n    /// @dev This function reverts if the call is not successful\n    function getNonFungibleTokenInfo(address token, int64 serialNumber) internal returns (int responseCode, IHederaTokenService.NonFungibleTokenInfo memory tokenInfo) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getNonFungibleTokenInfo.selector, token, serialNumber));\n        IHederaTokenService.NonFungibleTokenInfo memory defaultTokenInfo;\n        (responseCode, tokenInfo) = success ? abi.decode(result, (int32, IHederaTokenService.NonFungibleTokenInfo)) : (HederaResponseCodes.UNKNOWN, defaultTokenInfo);\n    }\n\n    /// Query token custom fees\n    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return fixedFees Set of fixed fees for `token`\n    /// @return fractionalFees Set of fractional fees for `token`\n    /// @return royaltyFees Set of royalty fees for `token`\n    /// @dev This function reverts if the call is not successful\n    function getTokenCustomFees(address token) internal returns (int64 responseCode,\n        IHederaTokenService.FixedFee[] memory fixedFees,\n        IHederaTokenService.FractionalFee[] memory fractionalFees,\n        IHederaTokenService.RoyaltyFee[] memory royaltyFees) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getTokenCustomFees.selector, token));\n        IHederaTokenService.FixedFee[] memory defaultFixedFees;\n        IHederaTokenService.FractionalFee[] memory defaultFractionalFees;\n        IHederaTokenService.RoyaltyFee[] memory defaultRoyaltyFees;\n        (responseCode, fixedFees, fractionalFees, royaltyFees) =\n        success ? abi.decode\n        (result, (int32, IHederaTokenService.FixedFee[], IHederaTokenService.FractionalFee[], IHederaTokenService.RoyaltyFee[]))\n        : (HederaResponseCodes.UNKNOWN, defaultFixedFees, defaultFractionalFees, defaultRoyaltyFees);\n    }\n\n    /// Allows spender to withdraw from your account multiple times, up to the value amount. If this function is called\n    /// again it overwrites the current allowance with value.\n    /// Only Applicable to Fungible Tokens\n    /// @param token The hedera token address to approve\n    /// @param spender the account authorized to spend\n    /// @param amount the amount of tokens authorized to spend.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function approve(address token, address spender, uint256 amount) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.approve.selector,\n            token, spender, amount));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Transfers `amount` tokens from `from` to `to` using the\n    //  allowance mechanism. `amount` is then deducted from the caller's allowance.",
                "codeOnlyTokens": 805,
                "startLine": 229,
                "endLine": 282,
                "type": ".sol_part_5",
                "isOversized": false
              },
              {
                "originalText": "    /// Only applicable to fungible tokens\n    /// @param token The address of the fungible Hedera token to transfer\n    /// @param from The account address of the owner of the token, on the behalf of which to transfer `amount` tokens\n    /// @param to The account address of the receiver of the `amount` tokens\n    /// @param amount The amount of tokens to transfer from `from` to `to`\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function transferFrom(address token, address from, address to, uint256 amount) external returns (int64 responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.transferFrom.selector,\n            token, from, to, amount));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Transfers `serialNumber` of `token` from `from` to `to` using the allowance mechanism.\n    /// Only applicable to NFT tokens\n    /// @param token The address of the non-fungible Hedera token to transfer\n    /// @param from The account address of the owner of `serialNumber` of `token`\n    /// @param to The account address of the receiver of `serialNumber`\n    /// @param serialNumber The NFT serial number to transfer\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function transferFromNFT(address token, address from, address to, uint256 serialNumber) external returns (int64 responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.transferFromNFT.selector,\n            token, from, to, serialNumber));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Returns the amount which spender is still allowed to withdraw from owner.\n    /// Only Applicable to Fungible Tokens\n    /// @param token The Hedera token address to check the allowance of\n    /// @param owner the owner of the tokens to be spent\n    /// @param spender the spender of the tokens\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function allowance(address token, address owner, address spender) internal returns (int responseCode, uint256 amount)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.allowance.selector,\n            token, owner, spender));\n        (responseCode, amount) = success ? abi.decode(result, (int32, uint256)) : (HederaResponseCodes.UNKNOWN, 0);\n    }\n\n    /// Allow or reaffirm the approved address to transfer an NFT the approved address does not own.\n    /// Only Applicable to NFT Tokens\n    /// @param token The Hedera NFT token address to approve\n    /// @param approved The new approved NFT controller.  To revoke approvals pass in the zero address.\n    /// @param serialNumber The NFT serial number  to approve\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function approveNFT(address token, address approved, uint256 serialNumber) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.approveNFT.selector,\n            token, approved, serialNumber));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Get the approved address for a single NFT\n    /// Only Applicable to NFT Tokens\n    /// @param token The Hedera NFT token address to check approval",
                "codeOnlyTokens": 813,
                "startLine": 283,
                "endLine": 342,
                "type": ".sol_part_6",
                "isOversized": false
              }
            ],
            "startLine": 178,
            "endLine": 342,
            "groupId": 2
          },
          {
            "combinedText": "// File: contracts/system-contracts/hedera-token-service/HederaTokenService.sol\n// Relevant file context:\n// Type: .sol\n\n\n// --- Next chunk ---\n\n// Lines 343-403 (.sol_part_7)\n    /// @param serialNumber The NFT to find the approved address for\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return approved The approved address for this NFT, or the zero address if there is none\n    function getApproved(address token, uint256 serialNumber) internal returns (int responseCode, address approved)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getApproved.selector,\n            token, serialNumber));\n        (responseCode, approved) =\n        success\n        ? abi.decode(result, (int32, address))\n        : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Query if token account is frozen\n    /// @param token The token address to check\n    /// @param account The account address associated with the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return frozen True if `account` is frozen for `token`\n    /// @dev This function reverts if the call is not successful\n    function isFrozen(address token, address account) internal returns (int64 responseCode, bool frozen){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.isFrozen.selector, token, account));\n        (responseCode, frozen) = success ? abi.decode(result, (int32, bool)) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Query if token account has kyc granted\n    /// @param token The token address to check\n    /// @param account The account address associated with the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return kycGranted True if `account` has kyc granted for `token`\n    /// @dev This function reverts if the call is not successful\n    function isKyc(address token, address account) internal returns (int64 responseCode, bool kycGranted){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.isKyc.selector, token, account));\n        (responseCode, kycGranted) = success ? abi.decode(result, (int32, bool)) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Operation to freeze token account\n    /// @param token The token address\n    /// @param account The account address to be frozen\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function freezeToken(address token, address account) internal returns (int64 responseCode){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.freezeToken.selector, token, account));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to unfreeze token account\n    /// @param token The token address\n    /// @param account The account address to be unfrozen\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function unfreezeToken(address token, address account) internal returns (int64 responseCode){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.unfreezeToken.selector, token, account));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to grant kyc to token account\n    /// @param token The token address\n    /// @param account The account address to grant kyc\n\n// --- Next chunk ---\n\n// Lines 404-464 (.sol_part_8)\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function grantTokenKyc(address token, address account) internal returns (int64 responseCode){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.grantTokenKyc.selector, token, account));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to revoke kyc to token account\n    /// @param token The token address\n    /// @param account The account address to revoke kyc\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function revokeTokenKyc(address token, address account) internal returns (int64 responseCode){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.revokeTokenKyc.selector, token, account));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Enable or disable approval for a third party (\"operator\") to manage\n    ///  all of `msg.sender`'s assets\n    /// @param token The Hedera NFT token address to approve\n    /// @param operator Address to add to the set of authorized operators\n    /// @param approved True if the operator is approved, false to revoke approval\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function setApprovalForAll(address token, address operator, bool approved) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.setApprovalForAll.selector,\n            token, operator, approved));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Query if an address is an authorized operator for another address\n    /// Only Applicable to NFT Tokens\n    /// @param token The Hedera NFT token address to approve\n    /// @param owner The address that owns the NFTs\n    /// @param operator The address that acts on behalf of the owner\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return approved True if `operator` is an approved operator for `owner`, false otherwise\n    function isApprovedForAll(address token, address owner, address operator) internal returns (int responseCode, bool approved)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.isApprovedForAll.selector,\n            token, owner, operator));\n        (responseCode, approved) =\n        success\n        ? abi.decode(result, (int32, bool))\n        : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Query token default freeze status\n    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return defaultFreezeStatus True if `token` default freeze status is frozen.\n    /// @dev This function reverts if the call is not successful\n    function getTokenDefaultFreezeStatus(address token) internal returns (int responseCode, bool defaultFreezeStatus) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getTokenDefaultFreezeStatus.selector, token));\n        (responseCode, defaultFreezeStatus) = success ? abi.decode(result, (int32, bool)) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Query token default kyc status\n\n// --- Next chunk ---\n\n// Lines 465-528 (.sol_part_9)\n    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return defaultKycStatus True if `token` default kyc status is KycNotApplicable and false if Revoked.\n    /// @dev This function reverts if the call is not successful\n    function getTokenDefaultKycStatus(address token) internal returns (int responseCode, bool defaultKycStatus) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getTokenDefaultKycStatus.selector, token));\n        (responseCode, defaultKycStatus) = success ? abi.decode(result, (int32, bool)) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /**********************\n     * ABI v1 calls       *\n     **********************/\n\n    /// Initiates a Fungible Token Transfer\n    /// @param token The ID of the token as a solidity address\n    /// @param accountIds account to do a transfer to/from\n    /// @param amounts The amount from the accountId at the same index\n    function transferTokens(address token, address[] memory accountIds, int64[] memory amounts) internal\n    returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.transferTokens.selector,\n            token, accountIds, amounts));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Initiates a Non-Fungable Token Transfer\n    /// @param token The ID of the token as a solidity address\n    /// @param sender the sender of an nft\n    /// @param receiver the receiver of the nft sent by the same index at sender\n    /// @param serialNumber the serial number of the nft sent by the same index at sender\n    function transferNFTs(address token, address[] memory sender, address[] memory receiver, int64[] memory serialNumber)\n    internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.transferNFTs.selector,\n            token, sender, receiver, serialNumber));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Transfers tokens where the calling account/contract is implicitly the first entry in the token transfer list,\n    /// where the amount is the value needed to zero balance the transfers. Regular signing rules apply for sending\n    /// (positive amount) or receiving (negative amount)\n    /// @param token The token to transfer to/from\n    /// @param sender The sender for the transaction\n    /// @param receiver The receiver of the transaction\n    /// @param amount Non-negative value to send. a negative value will result in a failure.\n    function transferToken(address token, address sender, address receiver, int64 amount) internal\n    returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.transferToken.selector,\n            token, sender, receiver, amount));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Transfers tokens where the calling account/contract is implicitly the first entry in the token transfer list,\n    /// where the amount is the value needed to zero balance the transfers. Regular signing rules apply for sending\n    /// (positive amount) or receiving (negative amount)\n    /// @param token The token to transfer to/from\n    /// @param sender The sender for the transaction\n    /// @param receiver The receiver of the transaction\n    /// @param serialNumber The serial number of the NFT to transfer.",
            "totalTokens": 2504,
            "chunks": [
              {
                "originalText": "    /// @param serialNumber The NFT to find the approved address for\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return approved The approved address for this NFT, or the zero address if there is none\n    function getApproved(address token, uint256 serialNumber) internal returns (int responseCode, address approved)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getApproved.selector,\n            token, serialNumber));\n        (responseCode, approved) =\n        success\n        ? abi.decode(result, (int32, address))\n        : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Query if token account is frozen\n    /// @param token The token address to check\n    /// @param account The account address associated with the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return frozen True if `account` is frozen for `token`\n    /// @dev This function reverts if the call is not successful\n    function isFrozen(address token, address account) internal returns (int64 responseCode, bool frozen){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.isFrozen.selector, token, account));\n        (responseCode, frozen) = success ? abi.decode(result, (int32, bool)) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Query if token account has kyc granted\n    /// @param token The token address to check\n    /// @param account The account address associated with the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return kycGranted True if `account` has kyc granted for `token`\n    /// @dev This function reverts if the call is not successful\n    function isKyc(address token, address account) internal returns (int64 responseCode, bool kycGranted){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.isKyc.selector, token, account));\n        (responseCode, kycGranted) = success ? abi.decode(result, (int32, bool)) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Operation to freeze token account\n    /// @param token The token address\n    /// @param account The account address to be frozen\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function freezeToken(address token, address account) internal returns (int64 responseCode){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.freezeToken.selector, token, account));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to unfreeze token account\n    /// @param token The token address\n    /// @param account The account address to be unfrozen\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function unfreezeToken(address token, address account) internal returns (int64 responseCode){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.unfreezeToken.selector, token, account));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to grant kyc to token account\n    /// @param token The token address\n    /// @param account The account address to grant kyc",
                "codeOnlyTokens": 804,
                "startLine": 343,
                "endLine": 403,
                "type": ".sol_part_7",
                "isOversized": false
              },
              {
                "originalText": "    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function grantTokenKyc(address token, address account) internal returns (int64 responseCode){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.grantTokenKyc.selector, token, account));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to revoke kyc to token account\n    /// @param token The token address\n    /// @param account The account address to revoke kyc\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function revokeTokenKyc(address token, address account) internal returns (int64 responseCode){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.revokeTokenKyc.selector, token, account));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Enable or disable approval for a third party (\"operator\") to manage\n    ///  all of `msg.sender`'s assets\n    /// @param token The Hedera NFT token address to approve\n    /// @param operator Address to add to the set of authorized operators\n    /// @param approved True if the operator is approved, false to revoke approval\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function setApprovalForAll(address token, address operator, bool approved) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.setApprovalForAll.selector,\n            token, operator, approved));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Query if an address is an authorized operator for another address\n    /// Only Applicable to NFT Tokens\n    /// @param token The Hedera NFT token address to approve\n    /// @param owner The address that owns the NFTs\n    /// @param operator The address that acts on behalf of the owner\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return approved True if `operator` is an approved operator for `owner`, false otherwise\n    function isApprovedForAll(address token, address owner, address operator) internal returns (int responseCode, bool approved)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.isApprovedForAll.selector,\n            token, owner, operator));\n        (responseCode, approved) =\n        success\n        ? abi.decode(result, (int32, bool))\n        : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Query token default freeze status\n    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return defaultFreezeStatus True if `token` default freeze status is frozen.\n    /// @dev This function reverts if the call is not successful\n    function getTokenDefaultFreezeStatus(address token) internal returns (int responseCode, bool defaultFreezeStatus) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getTokenDefaultFreezeStatus.selector, token));\n        (responseCode, defaultFreezeStatus) = success ? abi.decode(result, (int32, bool)) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Query token default kyc status",
                "codeOnlyTokens": 803,
                "startLine": 404,
                "endLine": 464,
                "type": ".sol_part_8",
                "isOversized": false
              },
              {
                "originalText": "    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return defaultKycStatus True if `token` default kyc status is KycNotApplicable and false if Revoked.\n    /// @dev This function reverts if the call is not successful\n    function getTokenDefaultKycStatus(address token) internal returns (int responseCode, bool defaultKycStatus) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getTokenDefaultKycStatus.selector, token));\n        (responseCode, defaultKycStatus) = success ? abi.decode(result, (int32, bool)) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /**********************\n     * ABI v1 calls       *\n     **********************/\n\n    /// Initiates a Fungible Token Transfer\n    /// @param token The ID of the token as a solidity address\n    /// @param accountIds account to do a transfer to/from\n    /// @param amounts The amount from the accountId at the same index\n    function transferTokens(address token, address[] memory accountIds, int64[] memory amounts) internal\n    returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.transferTokens.selector,\n            token, accountIds, amounts));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Initiates a Non-Fungable Token Transfer\n    /// @param token The ID of the token as a solidity address\n    /// @param sender the sender of an nft\n    /// @param receiver the receiver of the nft sent by the same index at sender\n    /// @param serialNumber the serial number of the nft sent by the same index at sender\n    function transferNFTs(address token, address[] memory sender, address[] memory receiver, int64[] memory serialNumber)\n    internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.transferNFTs.selector,\n            token, sender, receiver, serialNumber));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Transfers tokens where the calling account/contract is implicitly the first entry in the token transfer list,\n    /// where the amount is the value needed to zero balance the transfers. Regular signing rules apply for sending\n    /// (positive amount) or receiving (negative amount)\n    /// @param token The token to transfer to/from\n    /// @param sender The sender for the transaction\n    /// @param receiver The receiver of the transaction\n    /// @param amount Non-negative value to send. a negative value will result in a failure.\n    function transferToken(address token, address sender, address receiver, int64 amount) internal\n    returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.transferToken.selector,\n            token, sender, receiver, amount));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Transfers tokens where the calling account/contract is implicitly the first entry in the token transfer list,\n    /// where the amount is the value needed to zero balance the transfers. Regular signing rules apply for sending\n    /// (positive amount) or receiving (negative amount)\n    /// @param token The token to transfer to/from\n    /// @param sender The sender for the transaction\n    /// @param receiver The receiver of the transaction\n    /// @param serialNumber The serial number of the NFT to transfer.",
                "codeOnlyTokens": 812,
                "startLine": 465,
                "endLine": 528,
                "type": ".sol_part_9",
                "isOversized": false
              }
            ],
            "startLine": 343,
            "endLine": 528,
            "groupId": 3
          },
          {
            "combinedText": "// File: contracts/system-contracts/hedera-token-service/HederaTokenService.sol\n// Relevant file context:\n// Type: .sol\n\n\n// --- Next chunk ---\n\n// Lines 529-597 (.sol_part_10)\n    function transferNFT(address token, address sender, address receiver, int64 serialNumber) internal\n    returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.transferNFT.selector,\n            token, sender, receiver, serialNumber));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to pause token\n    /// @param token The token address to be paused\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function pauseToken(address token) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.pauseToken.selector, token));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to unpause token\n    /// @param token The token address to be unpaused\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function unpauseToken(address token) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.unpauseToken.selector, token));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to wipe fungible tokens from account\n    /// @param token The token address\n    /// @param account The account address to revoke kyc\n    /// @param amount The number of tokens to wipe\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function wipeTokenAccount(address token, address account, int64 amount) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.wipeTokenAccount.selector, token, account, amount));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to wipe non fungible tokens from account\n    /// @param token The token address\n    /// @param account The account address to revoke kyc\n    /// @param  serialNumbers The serial numbers of token to wipe\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function wipeTokenAccountNFT(address token, address account, int64[] memory serialNumbers) internal\n    returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.wipeTokenAccountNFT.selector, token, account, serialNumbers));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to delete token\n    /// @param token The token address\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function deleteToken(address token) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.deleteToken.selector, token));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to update token keys\n    /// @param token The token address\n    /// @param keys The token keys\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateTokenKeys(address token, IHederaTokenService.TokenKey[] memory keys)\n\n// --- Next chunk ---\n\n// Lines 598-650 (.sol_part_11)\n    internal returns (int64 responseCode){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.updateTokenKeys.selector, token, keys));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Query token KeyValue\n    /// @param token The token address to check\n    /// @param keyType The keyType of the desired KeyValue\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return key KeyValue info for key of type `keyType`\n    /// @dev This function reverts if the call is not successful\n    function getTokenKey(address token, uint keyType)\n    internal returns (int64 responseCode, IHederaTokenService.KeyValue memory key){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getTokenKey.selector, token, keyType));\n        IHederaTokenService.KeyValue memory defaultKeyValueInfo;\n        (responseCode, key) = success ? abi.decode(result, (int32,IHederaTokenService.KeyValue) ) : (HederaResponseCodes.UNKNOWN, defaultKeyValueInfo);\n    }\n\n\n    /// Query if valid token found for the given address\n    /// @param token The token address\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return isTokenFlag True if valid token found for the given address\n    /// @dev This function reverts if the call is not successful\n    function isToken(address token) internal returns (int64 responseCode, bool isTokenFlag) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.isToken.selector, token));\n        (responseCode, isTokenFlag) = success ? abi.decode(result, (int32, bool)) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Query to return the token type for a given address\n    /// @param token The token address\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenType the token type. 0 is FUNGIBLE_COMMON, 1 is NON_FUNGIBLE_UNIQUE, -1 is UNRECOGNIZED\n    /// @dev This function reverts if the call is not successful\n    function getTokenType(address token) internal returns (int64 responseCode, int32 tokenType) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getTokenType.selector, token));\n        (responseCode, tokenType) = success ? abi.decode(result, (int32, int32)) : (HederaResponseCodes.UNKNOWN, - 1);\n    }\n\n    /// Operation to get token expiry info\n    /// @param token The token address\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return expiryInfo The expiry info of the token\n    /// @dev This function reverts if the call is not successful\n    function getTokenExpiryInfo(address token) internal returns (int responseCode, IHederaTokenService.Expiry memory expiryInfo){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getTokenExpiryInfo.selector, token));\n        IHederaTokenService.Expiry memory defaultExpiryInfo;\n        (responseCode, expiryInfo) = success ? abi.decode(result, (int32, IHederaTokenService.Expiry)) : (HederaResponseCodes.UNKNOWN, defaultExpiryInfo);\n\n// --- Next chunk ---\n\n// Lines 651-704 (.sol_part_12)\n    }\n\n    /// Operation to update token expiry info\n    /// @param token The token address\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateTokenExpiryInfo(address token, IHederaTokenService.Expiry memory expiryInfo) internal returns (int responseCode){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.updateTokenExpiryInfo.selector, token, expiryInfo));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to update token info\n    /// @param token The token address\n    /// @param tokenInfo The hedera token info to update token with\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateTokenInfo(address token, IHederaTokenService.HederaToken memory tokenInfo) internal returns (int responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.updateTokenInfo.selector, token, tokenInfo));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Redirect for token\n    /// @param token The token address\n    /// @param encodedFunctionSelector The function selector from the ERC20 interface + the bytes input for the function called\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return response The result of the call that had been encoded and sent for execution.\n    function redirectForToken(address token, bytes memory encodedFunctionSelector) external returns (int responseCode, bytes memory response) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.redirectForToken.selector, token, encodedFunctionSelector)\n        );\n\n        emit CallResponseEvent(success, result);\n        (responseCode, response) = success ? (HederaResponseCodes.SUCCESS, result) : (HederaResponseCodes.UNKNOWN, bytes(\"\"));\n    }\n\n    /// Update the custom fees for a fungible token\n    /// @param token The token address\n    /// @param fixedFees Set of fixed fees for `token`\n    /// @param fractionalFees Set of fractional fees for `token`\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateFungibleTokenCustomFees(address token,  IHederaTokenService.FixedFee[] memory fixedFees, IHederaTokenService.FractionalFee[] memory fractionalFees) internal returns (int64 responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.updateFungibleTokenCustomFees.selector, token, fixedFees, fractionalFees));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Update the custom fees for a non-fungible token\n    /// @param token The token address\n    /// @param fixedFees Set of fixed fees for `token`\n    /// @param royaltyFees Set of royalty fees for `token`\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateNonFungibleTokenCustomFees(address token, IHederaTokenService.FixedFee[] memory fixedFees, IHederaTokenService.RoyaltyFee[] memory royaltyFees) internal returns (int64 responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.updateNonFungibleTokenCustomFees.selector, token, fixedFees, royaltyFees));",
            "totalTokens": 2513,
            "chunks": [
              {
                "originalText": "    function transferNFT(address token, address sender, address receiver, int64 serialNumber) internal\n    returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.transferNFT.selector,\n            token, sender, receiver, serialNumber));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to pause token\n    /// @param token The token address to be paused\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function pauseToken(address token) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.pauseToken.selector, token));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to unpause token\n    /// @param token The token address to be unpaused\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function unpauseToken(address token) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.unpauseToken.selector, token));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to wipe fungible tokens from account\n    /// @param token The token address\n    /// @param account The account address to revoke kyc\n    /// @param amount The number of tokens to wipe\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function wipeTokenAccount(address token, address account, int64 amount) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.wipeTokenAccount.selector, token, account, amount));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to wipe non fungible tokens from account\n    /// @param token The token address\n    /// @param account The account address to revoke kyc\n    /// @param  serialNumbers The serial numbers of token to wipe\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function wipeTokenAccountNFT(address token, address account, int64[] memory serialNumbers) internal\n    returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.wipeTokenAccountNFT.selector, token, account, serialNumbers));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to delete token\n    /// @param token The token address\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function deleteToken(address token) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.deleteToken.selector, token));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to update token keys\n    /// @param token The token address\n    /// @param keys The token keys\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateTokenKeys(address token, IHederaTokenService.TokenKey[] memory keys)",
                "codeOnlyTokens": 816,
                "startLine": 529,
                "endLine": 597,
                "type": ".sol_part_10",
                "isOversized": false
              },
              {
                "originalText": "    internal returns (int64 responseCode){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.updateTokenKeys.selector, token, keys));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Query token KeyValue\n    /// @param token The token address to check\n    /// @param keyType The keyType of the desired KeyValue\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return key KeyValue info for key of type `keyType`\n    /// @dev This function reverts if the call is not successful\n    function getTokenKey(address token, uint keyType)\n    internal returns (int64 responseCode, IHederaTokenService.KeyValue memory key){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getTokenKey.selector, token, keyType));\n        IHederaTokenService.KeyValue memory defaultKeyValueInfo;\n        (responseCode, key) = success ? abi.decode(result, (int32,IHederaTokenService.KeyValue) ) : (HederaResponseCodes.UNKNOWN, defaultKeyValueInfo);\n    }\n\n\n    /// Query if valid token found for the given address\n    /// @param token The token address\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return isTokenFlag True if valid token found for the given address\n    /// @dev This function reverts if the call is not successful\n    function isToken(address token) internal returns (int64 responseCode, bool isTokenFlag) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.isToken.selector, token));\n        (responseCode, isTokenFlag) = success ? abi.decode(result, (int32, bool)) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Query to return the token type for a given address\n    /// @param token The token address\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenType the token type. 0 is FUNGIBLE_COMMON, 1 is NON_FUNGIBLE_UNIQUE, -1 is UNRECOGNIZED\n    /// @dev This function reverts if the call is not successful\n    function getTokenType(address token) internal returns (int64 responseCode, int32 tokenType) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getTokenType.selector, token));\n        (responseCode, tokenType) = success ? abi.decode(result, (int32, int32)) : (HederaResponseCodes.UNKNOWN, - 1);\n    }\n\n    /// Operation to get token expiry info\n    /// @param token The token address\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return expiryInfo The expiry info of the token\n    /// @dev This function reverts if the call is not successful\n    function getTokenExpiryInfo(address token) internal returns (int responseCode, IHederaTokenService.Expiry memory expiryInfo){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getTokenExpiryInfo.selector, token));\n        IHederaTokenService.Expiry memory defaultExpiryInfo;\n        (responseCode, expiryInfo) = success ? abi.decode(result, (int32, IHederaTokenService.Expiry)) : (HederaResponseCodes.UNKNOWN, defaultExpiryInfo);",
                "codeOnlyTokens": 808,
                "startLine": 598,
                "endLine": 650,
                "type": ".sol_part_11",
                "isOversized": false
              },
              {
                "originalText": "    }\n\n    /// Operation to update token expiry info\n    /// @param token The token address\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateTokenExpiryInfo(address token, IHederaTokenService.Expiry memory expiryInfo) internal returns (int responseCode){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.updateTokenExpiryInfo.selector, token, expiryInfo));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to update token info\n    /// @param token The token address\n    /// @param tokenInfo The hedera token info to update token with\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateTokenInfo(address token, IHederaTokenService.HederaToken memory tokenInfo) internal returns (int responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.updateTokenInfo.selector, token, tokenInfo));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Redirect for token\n    /// @param token The token address\n    /// @param encodedFunctionSelector The function selector from the ERC20 interface + the bytes input for the function called\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return response The result of the call that had been encoded and sent for execution.\n    function redirectForToken(address token, bytes memory encodedFunctionSelector) external returns (int responseCode, bytes memory response) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.redirectForToken.selector, token, encodedFunctionSelector)\n        );\n\n        emit CallResponseEvent(success, result);\n        (responseCode, response) = success ? (HederaResponseCodes.SUCCESS, result) : (HederaResponseCodes.UNKNOWN, bytes(\"\"));\n    }\n\n    /// Update the custom fees for a fungible token\n    /// @param token The token address\n    /// @param fixedFees Set of fixed fees for `token`\n    /// @param fractionalFees Set of fractional fees for `token`\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateFungibleTokenCustomFees(address token,  IHederaTokenService.FixedFee[] memory fixedFees, IHederaTokenService.FractionalFee[] memory fractionalFees) internal returns (int64 responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.updateFungibleTokenCustomFees.selector, token, fixedFees, fractionalFees));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Update the custom fees for a non-fungible token\n    /// @param token The token address\n    /// @param fixedFees Set of fixed fees for `token`\n    /// @param royaltyFees Set of royalty fees for `token`\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateNonFungibleTokenCustomFees(address token, IHederaTokenService.FixedFee[] memory fixedFees, IHederaTokenService.RoyaltyFee[] memory royaltyFees) internal returns (int64 responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.updateNonFungibleTokenCustomFees.selector, token, fixedFees, royaltyFees));",
                "codeOnlyTokens": 808,
                "startLine": 651,
                "endLine": 704,
                "type": ".sol_part_12",
                "isOversized": false
              }
            ],
            "startLine": 529,
            "endLine": 704,
            "groupId": 4
          },
          {
            "combinedText": "// File: contracts/system-contracts/hedera-token-service/HederaTokenService.sol\n// Relevant file context:\n// Type: .sol\n\n\n// --- Next chunk ---\n\n// Lines 705-750 (.sol_part_13)\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// @notice Airdrop one or more tokens to one or more accounts\n    /// @param tokenTransfers Array of token transfer lists containing token addresses and recipient details\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function airdropTokens(IHederaTokenService.TokenTransferList[] memory tokenTransfers) internal returns (int64 responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.airdropTokens.selector, tokenTransfers));\n\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// @notice Cancels pending airdrops that have not yet been claimed\n    /// @param pendingAirdrops Array of pending airdrops to cancel\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function cancelAirdrops(IHederaTokenService.PendingAirdrop[] memory pendingAirdrops) internal returns (int64 responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.cancelAirdrops.selector, pendingAirdrops)\n        );\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// @notice Claims pending airdrops that were sent to the calling account\n    /// @param pendingAirdrops Array of pending airdrops to claim\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function claimAirdrops(IHederaTokenService.PendingAirdrop[] memory pendingAirdrops) internal returns (int64 responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.claimAirdrops.selector, pendingAirdrops)\n        );\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// @notice Rejects one or more tokens by transferring their full balance from the requesting account to the treasury\n    /// @param rejectingAddress The address rejecting the tokens\n    /// @param ftAddresses Array of fungible token addresses to reject\n    /// @param nftIds Array of NFT IDs to reject\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function rejectTokens(address rejectingAddress, address[] memory ftAddresses, IHederaTokenService.NftID[] memory nftIds) internal returns (int64 responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.rejectTokens.selector, rejectingAddress, ftAddresses, nftIds)\n        );\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n}\n",
            "totalTokens": 703,
            "chunks": [
              {
                "originalText": "        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// @notice Airdrop one or more tokens to one or more accounts\n    /// @param tokenTransfers Array of token transfer lists containing token addresses and recipient details\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function airdropTokens(IHederaTokenService.TokenTransferList[] memory tokenTransfers) internal returns (int64 responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.airdropTokens.selector, tokenTransfers));\n\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// @notice Cancels pending airdrops that have not yet been claimed\n    /// @param pendingAirdrops Array of pending airdrops to cancel\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function cancelAirdrops(IHederaTokenService.PendingAirdrop[] memory pendingAirdrops) internal returns (int64 responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.cancelAirdrops.selector, pendingAirdrops)\n        );\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// @notice Claims pending airdrops that were sent to the calling account\n    /// @param pendingAirdrops Array of pending airdrops to claim\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function claimAirdrops(IHederaTokenService.PendingAirdrop[] memory pendingAirdrops) internal returns (int64 responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.claimAirdrops.selector, pendingAirdrops)\n        );\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// @notice Rejects one or more tokens by transferring their full balance from the requesting account to the treasury\n    /// @param rejectingAddress The address rejecting the tokens\n    /// @param ftAddresses Array of fungible token addresses to reject\n    /// @param nftIds Array of NFT IDs to reject\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function rejectTokens(address rejectingAddress, address[] memory ftAddresses, IHederaTokenService.NftID[] memory nftIds) internal returns (int64 responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.rejectTokens.selector, rejectingAddress, ftAddresses, nftIds)\n        );\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n}\n",
                "codeOnlyTokens": 656,
                "startLine": 705,
                "endLine": 750,
                "type": ".sol_part_13",
                "isOversized": false
              }
            ],
            "startLine": 705,
            "endLine": 750,
            "groupId": 5
          }
        ],
        "oversizedChunks": [],
        "sendStrategy": "multiple_groups",
        "finalTokenCount": 10724,
        "skippedContent": [],
        "contextHeader": "// File: contracts/system-contracts/hedera-token-service/HederaTokenService.sol\n// Relevant file context:\n// Type: .sol\n",
        "tokenBreakdown": {
          "originalFile": 10352,
          "finalSent": 10724,
          "codeTokensInGroups": 10349,
          "fileHeaderTokensInGroups": 145,
          "shellContextTokensInGroups": 0,
          "separatorTokensInGroups": 230,
          "skippedCodeTokens": 0,
          "unprocessedOversizedTokens": 0,
          "totalSavings": -372,
          "savingsPercentage": -3.593508500772798,
          "fileHeaderCount": 5,
          "fileHeaderAvgSize": 29,
          "shellContextCount": 0,
          "shellContextAvgSize": 0,
          "separatorCount": 13,
          "separatorAvgSize": 18
        }
      }
    },
    {
      "filePath": "repo_cache/hedera-smart-contracts/system-contract-dapp-playground/src/api/hedera/index.ts",
      "totalOriginalTokens": 565,
      "finalTokenCount": 592,
      "impactScore": 49,
      "averageComplexity": 7,
      "averageQuality": 7,
      "usage": {
        "prompt_tokens": 721,
        "completion_tokens": 128,
        "total_tokens": 849
      },
      "retries": 0,
      "hadError": false,
      "scoredChunkGroups": [
        {
          "groupId": 1,
          "score": {
            "file_path": "system-contract-dapp-playground/src/api/hedera/index.ts",
            "complexity_score": 7,
            "code_quality_score": 7,
            "maintainability_score": 7,
            "best_practices_adherence": 7,
            "positive_feedback": "The deployment and transaction caching logic enhances user experience through improved performance.",
            "improvement_suggestion": "Implement better error handling and user feedback for transaction failures during deployment.",
            "group_summary": "API methods for deploying smart contracts on the Hedera network with transaction caching."
          },
          "totalTokens": 592,
          "usage": {
            "prompt_tokens": 721,
            "completion_tokens": 128,
            "total_tokens": 849
          }
        }
      ],
      "chunkingDetails": {
        "filePath": "repo_cache/hedera-smart-contracts/system-contract-dapp-playground/src/api/hedera/index.ts",
        "totalFileTokens": 565,
        "chunks": [
          {
            "originalText": "// SPDX-License-Identifier: Apache-2.0\n\nimport { ContractFactory } from 'ethers';\nimport { getWalletProvider } from '../wallet';\nimport { ITransactionResult } from '@/types/contract-interactions/shared';\nimport { IContractABI, IHederaSmartContractResult } from '@/types/common';\nimport { HEDERA_TRANSACTION_RESULT_STORAGE_KEYS } from '@/utils/common/constants';\n\n/**\n * @dev deploys smart contract to Hedera network\n *\n * @params contractABI: IContractABI\n *\n * @params contractBytecode: string\n *\n * @return Promise<IHederaSmartContractResult>\n *\n * @resource https://github.com/ed-marquez/hedera-example-metamask-counter-dapp/blob/master/src/components/hedera/contractDeploy.js\n */\nexport const deploySmartContract = async (\n  contractABI: IContractABI[],\n  contractBytecode: string,\n  params: any[]\n): Promise<IHederaSmartContractResult> => {\n  // states\n  const transactionResultStorageKey = HEDERA_TRANSACTION_RESULT_STORAGE_KEYS['CONTRACT-CREATE'];\n\n  // get contract create transactions from localStorage\n  const cachedCreateTransactions = localStorage.getItem(transactionResultStorageKey);\n  const contractCreateTransactions = cachedCreateTransactions ? JSON.parse(cachedCreateTransactions) : [];\n\n  // get signer\n  const walletProvider = getWalletProvider();\n  if (walletProvider.err || !walletProvider.walletProvider) {\n    return { err: walletProvider.err };\n  }\n  const walletSigner = await walletProvider.walletProvider.getSigner();\n\n  // Deploy smart contract\n  try {\n    // prepare gaslimit\n    const gasLimit = 4_000_000;\n\n    // get contract from contract factory\n    const contract = new ContractFactory(JSON.stringify(contractABI), contractBytecode, walletSigner);\n\n    // execute deploy transaction\n    const contractDeployTx = await contract.deploy(...params, {\n      gasLimit,\n    });\n\n    // get contractAddress\n    const contractAddress = await contractDeployTx.getAddress();\n\n    // retrieve transaction receipt\n    const txReceipt = contractDeployTx.deploymentTransaction();\n\n    // prepare create transaction result\n    if (txReceipt) {\n      const createTransactionResult: ITransactionResult = {\n        status: 'success',\n        transactionResultStorageKey,\n        transactionTimeStamp: Date.now(),\n        txHash: txReceipt.hash as string,\n        transactionType: 'CONTRACT-CREATE',\n        sessionedContractAddress: contractAddress,\n      };\n      contractCreateTransactions.push(createTransactionResult);\n      localStorage.setItem(transactionResultStorageKey, JSON.stringify(contractCreateTransactions));\n    }\n\n    return { contractAddress };\n  } catch (err) {\n    console.error(err);\n    return { err };\n  }\n};\n",
            "codeOnlyTokens": 565,
            "startLine": 1,
            "endLine": 78,
            "type": ".ts",
            "isOversized": false
          }
        ],
        "groupedChunks": [
          {
            "combinedText": "// File: system-contract-dapp-playground/src/api/hedera/index.ts\n// Relevant file context:\n// Type: .ts\n// SPDX-License-Identifier: Apache-2.0\n\nimport { ContractFactory } from 'ethers';\nimport { getWalletProvider } from '../wallet';\nimport { ITransactionResult } from '@/types/contract-interactions/shared';\nimport { IContractABI, IHederaSmartContractResult } from '@/types/common';\nimport { HEDERA_TRANSACTION_RESULT_STORAGE_KEYS } from '@/utils/common/constants';\n\n/**\n * @dev deploys smart contract to Hedera network\n *\n * @params contractABI: IContractABI\n *\n * @params contractBytecode: string\n *\n * @return Promise<IHederaSmartContractResult>\n *\n * @resource https://github.com/ed-marquez/hedera-example-metamask-counter-dapp/blob/master/src/components/hedera/contractDeploy.js\n */\nexport const deploySmartContract = async (\n  contractABI: IContractABI[],\n  contractBytecode: string,\n  params: any[]\n): Promise<IHederaSmartContractResult> => {\n  // states\n  const transactionResultStorageKey = HEDERA_TRANSACTION_RESULT_STORAGE_KEYS['CONTRACT-CREATE'];\n\n  // get contract create transactions from localStorage\n  const cachedCreateTransactions = localStorage.getItem(transactionResultStorageKey);\n  const contractCreateTransactions = cachedCreateTransactions ? JSON.parse(cachedCreateTransactions) : [];\n\n  // get signer\n  const walletProvider = getWalletProvider();\n  if (walletProvider.err || !walletProvider.walletProvider) {\n    return { err: walletProvider.err };\n  }\n  const walletSigner = await walletProvider.walletProvider.getSigner();\n\n  // Deploy smart contract\n  try {\n    // prepare gaslimit\n    const gasLimit = 4_000_000;\n\n    // get contract from contract factory\n    const contract = new ContractFactory(JSON.stringify(contractABI), contractBytecode, walletSigner);\n\n    // execute deploy transaction\n    const contractDeployTx = await contract.deploy(...params, {\n      gasLimit,\n    });\n\n    // get contractAddress\n    const contractAddress = await contractDeployTx.getAddress();\n\n    // retrieve transaction receipt\n    const txReceipt = contractDeployTx.deploymentTransaction();\n\n    // prepare create transaction result\n    if (txReceipt) {\n      const createTransactionResult: ITransactionResult = {\n        status: 'success',\n        transactionResultStorageKey,\n        transactionTimeStamp: Date.now(),\n        txHash: txReceipt.hash as string,\n        transactionType: 'CONTRACT-CREATE',\n        sessionedContractAddress: contractAddress,\n      };\n      contractCreateTransactions.push(createTransactionResult);\n      localStorage.setItem(transactionResultStorageKey, JSON.stringify(contractCreateTransactions));\n    }\n\n    return { contractAddress };\n  } catch (err) {\n    console.error(err);\n    return { err };\n  }\n};\n",
            "totalTokens": 592,
            "chunks": [
              {
                "originalText": "// SPDX-License-Identifier: Apache-2.0\n\nimport { ContractFactory } from 'ethers';\nimport { getWalletProvider } from '../wallet';\nimport { ITransactionResult } from '@/types/contract-interactions/shared';\nimport { IContractABI, IHederaSmartContractResult } from '@/types/common';\nimport { HEDERA_TRANSACTION_RESULT_STORAGE_KEYS } from '@/utils/common/constants';\n\n/**\n * @dev deploys smart contract to Hedera network\n *\n * @params contractABI: IContractABI\n *\n * @params contractBytecode: string\n *\n * @return Promise<IHederaSmartContractResult>\n *\n * @resource https://github.com/ed-marquez/hedera-example-metamask-counter-dapp/blob/master/src/components/hedera/contractDeploy.js\n */\nexport const deploySmartContract = async (\n  contractABI: IContractABI[],\n  contractBytecode: string,\n  params: any[]\n): Promise<IHederaSmartContractResult> => {\n  // states\n  const transactionResultStorageKey = HEDERA_TRANSACTION_RESULT_STORAGE_KEYS['CONTRACT-CREATE'];\n\n  // get contract create transactions from localStorage\n  const cachedCreateTransactions = localStorage.getItem(transactionResultStorageKey);\n  const contractCreateTransactions = cachedCreateTransactions ? JSON.parse(cachedCreateTransactions) : [];\n\n  // get signer\n  const walletProvider = getWalletProvider();\n  if (walletProvider.err || !walletProvider.walletProvider) {\n    return { err: walletProvider.err };\n  }\n  const walletSigner = await walletProvider.walletProvider.getSigner();\n\n  // Deploy smart contract\n  try {\n    // prepare gaslimit\n    const gasLimit = 4_000_000;\n\n    // get contract from contract factory\n    const contract = new ContractFactory(JSON.stringify(contractABI), contractBytecode, walletSigner);\n\n    // execute deploy transaction\n    const contractDeployTx = await contract.deploy(...params, {\n      gasLimit,\n    });\n\n    // get contractAddress\n    const contractAddress = await contractDeployTx.getAddress();\n\n    // retrieve transaction receipt\n    const txReceipt = contractDeployTx.deploymentTransaction();\n\n    // prepare create transaction result\n    if (txReceipt) {\n      const createTransactionResult: ITransactionResult = {\n        status: 'success',\n        transactionResultStorageKey,\n        transactionTimeStamp: Date.now(),\n        txHash: txReceipt.hash as string,\n        transactionType: 'CONTRACT-CREATE',\n        sessionedContractAddress: contractAddress,\n      };\n      contractCreateTransactions.push(createTransactionResult);\n      localStorage.setItem(transactionResultStorageKey, JSON.stringify(contractCreateTransactions));\n    }\n\n    return { contractAddress };\n  } catch (err) {\n    console.error(err);\n    return { err };\n  }\n};\n",
                "codeOnlyTokens": 565,
                "startLine": 1,
                "endLine": 78,
                "type": "full_file",
                "isOversized": false
              }
            ],
            "startLine": 1,
            "endLine": 78,
            "groupId": 1
          }
        ],
        "oversizedChunks": [],
        "sendStrategy": "full_file",
        "finalTokenCount": 592,
        "skippedContent": [],
        "contextHeader": "// File: system-contract-dapp-playground/src/api/hedera/index.ts\n// Relevant file context:\n// Type: .ts\n",
        "tokenBreakdown": {
          "originalFile": 565,
          "finalSent": 592,
          "codeTokensInGroups": 565,
          "fileHeaderTokensInGroups": 27,
          "shellContextTokensInGroups": 0,
          "separatorTokensInGroups": 0,
          "skippedCodeTokens": 0,
          "unprocessedOversizedTokens": 0,
          "totalSavings": -27,
          "savingsPercentage": -4.778761061946903,
          "fileHeaderCount": 1,
          "fileHeaderAvgSize": 27,
          "shellContextCount": 0,
          "shellContextAvgSize": 0,
          "separatorCount": 1,
          "separatorAvgSize": 0
        }
      }
    },
    {
      "filePath": "repo_cache/hedera-smart-contracts/system-contract-dapp-playground/src/api/hedera/hts-interactions/tokenCreateCustom-interactions/index.ts",
      "totalOriginalTokens": 4111,
      "finalTokenCount": 4290,
      "impactScore": 48.75,
      "averageComplexity": 6.5,
      "averageQuality": 7.5,
      "usage": {
        "prompt_tokens": 5989,
        "completion_tokens": 229,
        "total_tokens": 6218
      },
      "retries": 0,
      "hadError": false,
      "scoredChunkGroups": [
        {
          "groupId": 1,
          "score": {
            "complexity_score": 7,
            "code_quality_score": 8,
            "maintainability_score": 8,
            "best_practices_adherence": 7,
            "positive_feedback": "The use of sanitization and error handling for input parameters enhances robustness in token creation processes.",
            "improvement_suggestion": "Consider leveraging asynchronous transaction batching to improve efficiency in minting multiple tokens at once.",
            "group_summary": "This code provides functions for creating fungible and non-fungible tokens on the Hedera network."
          },
          "totalTokens": 2500,
          "usage": {
            "prompt_tokens": 3344,
            "completion_tokens": 116,
            "total_tokens": 3460,
            "prompt_tokens_details": {
              "cached_tokens": 0,
              "audio_tokens": 0
            },
            "completion_tokens_details": {
              "reasoning_tokens": 0,
              "audio_tokens": 0,
              "accepted_prediction_tokens": 0,
              "rejected_prediction_tokens": 0
            }
          }
        },
        {
          "groupId": 2,
          "score": {
            "complexity_score": 6,
            "code_quality_score": 7,
            "maintainability_score": 7,
            "best_practices_adherence": 8,
            "positive_feedback": "The use of parameter sanitization greatly enhances the robustness of the token creation process.",
            "improvement_suggestion": "Consider implementing more descriptive error handling for better debugging and user experience in case of failure.",
            "group_summary": "This code handles token minting, association, and KYC granting for Hedera tokens."
          },
          "totalTokens": 1790,
          "usage": {
            "prompt_tokens": 2645,
            "completion_tokens": 113,
            "total_tokens": 2758,
            "prompt_tokens_details": {
              "cached_tokens": 0,
              "audio_tokens": 0
            },
            "completion_tokens_details": {
              "reasoning_tokens": 0,
              "audio_tokens": 0,
              "accepted_prediction_tokens": 0,
              "rejected_prediction_tokens": 0
            }
          }
        }
      ],
      "chunkingDetails": {
        "filePath": "repo_cache/hedera-smart-contracts/system-contract-dapp-playground/src/api/hedera/hts-interactions/tokenCreateCustom-interactions/index.ts",
        "totalFileTokens": 4111,
        "chunks": [
          {
            "originalText": "// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  handleContractResponse,\n  prepareHederaTokenKeyArray,\n} from '@/utils/contract-interactions/HTS/helpers';\nimport { Contract, ethers, isAddress } from 'ethers';\nimport { ISmartContractExecutionResult } from '@/types/contract-interactions/shared';\nimport { handleEstimateGas } from '@/utils/common/helpers';\nimport { TNetworkName } from '@/types/common';\n\n/**\n * @dev creates a Hedera fungible token\n *\n * @dev integrates tokenCreateCustomContract.createFungibleTokenPublic() and tokenCreateCustomContract.createFungibleTokenWithCustomFeesPublic()\n *\n * @param baseContract: ethers.Contract\n *\n * @param name: string\n *\n * @param symbol: string\n *\n * @param memo: string\n *\n * @param initialTotalSupply: number\n *\n * @param maxSupply: number\n *\n * @param decimals: number\n *\n * @param freezeDefaultStatus: boolean\n *\n * @param treasury: string\n *\n * @param inputKeys: ICommonKeyObject[],\n *\n * @param msgValue: string\n *\n * @param feeTokenAddress?: string\n *\n * @param feeAmount?: number\n *\n * @return Promise<ISmartContractExecutionResult>\n *\n * @see https://github.com/hashgraph/hedera-smart-contracts/blob/main/contracts/system-contracts/hedera-token-service/IHederaTokenService.sol#L136\n *      for more information on the purposes of the params\n */\nexport const createHederaFungibleToken = async (\n  baseContract: Contract,\n  name: string,\n  symbol: string,\n  memo: string,\n  initialTotalSupply: number,\n  maxSupply: number,\n  decimals: number,\n  freezeDefaultStatus: boolean,\n  treasury: string,\n  inputKeys: ICommonKeyObject[],\n  msgValue: string,\n  feeTokenAddress?: string,\n  feeAmount?: number\n): Promise<ISmartContractExecutionResult> => {\n  // sanitize params\n  let sanitizeErr;\n  if (initialTotalSupply < 0) {\n    sanitizeErr = 'initial total supply cannot be negative';\n  } else if (maxSupply < 0) {\n    sanitizeErr = 'max supply cannot be negative';\n  } else if (decimals < 0) {\n    sanitizeErr = 'decimals cannot be negative';\n  } else if (!isAddress(treasury)) {\n    sanitizeErr = 'invalid treasury address';\n  } else if (feeTokenAddress && !isAddress(feeTokenAddress)) {\n    sanitizeErr = 'invalid fee token address';\n  }\n  if (sanitizeErr) {\n    console.error(sanitizeErr);\n    return { err: sanitizeErr };\n  }\n\n  // prepare keys array\n  const keyRes = prepareHederaTokenKeyArray(inputKeys);\n\n  // handle error\n  if (keyRes.err) {\n    console.error(keyRes.err);\n    return { err: keyRes.err };\n  }\n\n  try {\n    let tokenCreateTx;\n    if (feeTokenAddress) {\n      tokenCreateTx = await baseContract.createFungibleTokenWithCustomFeesPublic(\n        treasury,\n        feeTokenAddress,\n        name,\n        symbol,\n        memo,\n        initialTotalSupply,\n        maxSupply,\n        decimals,\n        feeAmount,\n        keyRes.hederaTokenKeys,\n        {\n          value: ethers.parseEther(msgValue),\n          gasLimit: 1_000_000,\n        }\n      );\n    } else {\n      tokenCreateTx = await baseContract.createFungibleTokenPublic(\n        name,\n        symbol,\n        memo,\n        initialTotalSupply,\n        maxSupply,\n        decimals,\n        freezeDefaultStatus,\n        treasury,\n        keyRes.hederaTokenKeys,\n        {\n          value: ethers.parseEther(msgValue),\n          gasLimit: 1_000_000,",
            "codeOnlyTokens": 805,
            "startLine": 1,
            "endLine": 122,
            "type": ".ts_part_1",
            "isOversized": false
          },
          {
            "originalText": "        }\n      );\n    }\n\n    const txReceipt = await tokenCreateTx.wait();\n\n    const { data } = txReceipt.logs.filter((event: any) => event.fragment.name === 'CreatedToken')[0];\n\n    // @notice since the returned `data` is 32 byte, convert it to the public 20-byte address standard\n    const tokenAddress = `0x${data.slice(-40)}`;\n\n    return { tokenAddress, transactionHash: txReceipt.hash };\n  } catch (err: any) {\n    console.error(err);\n    return { err, transactionHash: err.receipt && err.receipt.hash };\n  }\n};\n\n/**\n * @dev creates a Hedera non fungible token\n *\n * @dev integrates tokenCreateCustomContract.createNonFungibleTokenPublic() and tokenCreateCustomContract.createNonFungibleTokenWithCustomFeesPublic()\n *\n * @param baseContract: ethers.Contract\n *\n * @param name: string\n *\n * @param symbol: string\n *\n * @param memo: string\n *\n * @param maxSupply: number\n *\n * @param treasury: ethers.AddressLike\n *\n * @param inputKeys: ICommonKeyObject[],\n *\n * @param msgValue: string\n *\n * @param feeTokenAddress?: ethers.AddressLike\n *\n * @param feeAmount?: number\n *\n * @return Promise<ISmartContractExecutionResult>\n *\n * @see https://github.com/hashgraph/hedera-smart-contracts/blob/main/contracts/system-contracts/hedera-token-service/IHederaTokenService.sol#L136\n *      for more information on the purposes of the params\n */\nexport const createHederaNonFungibleToken = async (\n  baseContract: Contract,\n  name: string,\n  symbol: string,\n  memo: string,\n  maxSupply: number,\n  treasury: ethers.AddressLike,\n  inputKeys: ICommonKeyObject[],\n  msgValue: string,\n  feeTokenAddress?: ethers.AddressLike,\n  feeAmount?: number\n): Promise<ISmartContractExecutionResult> => {\n  // sanitize params\n  let sanitizeErr;\n  if (maxSupply < 0) {\n    sanitizeErr = 'max supply cannot be negative';\n  } else if (!isAddress(treasury)) {\n    sanitizeErr = 'invalid treasury address';\n  } else if (feeTokenAddress && !isAddress(feeTokenAddress)) {\n    sanitizeErr = 'invalid fee token address';\n  }\n\n  if (sanitizeErr) {\n    console.error(sanitizeErr);\n    return { err: sanitizeErr };\n  }\n\n  // prepare keys array\n  const keyRes = prepareHederaTokenKeyArray(inputKeys);\n\n  // handle error\n  if (keyRes.err) {\n    return { err: keyRes.err };\n  }\n\n  try {\n    let tokenCreateTx;\n    if (feeTokenAddress) {\n      tokenCreateTx = await baseContract.createNonFungibleTokenWithCustomFeesPublic(\n        treasury,\n        feeTokenAddress,\n        name,\n        symbol,\n        memo,\n        maxSupply,\n        feeAmount,\n        keyRes.hederaTokenKeys,\n        {\n          value: ethers.parseEther(msgValue),\n          gasLimit: 1_000_000,\n        }\n      );\n    } else {\n      tokenCreateTx = await baseContract.createNonFungibleTokenPublic(\n        name,\n        symbol,\n        memo,\n        maxSupply,\n        treasury,\n        keyRes.hederaTokenKeys,\n        {\n          value: ethers.parseEther(msgValue),\n          gasLimit: 1_000_000,\n        }\n      );\n    }\n\n    const txReceipt = await tokenCreateTx.wait();\n\n    const { data } = txReceipt.logs.filter((event: any) => event.fragment.name === 'CreatedToken')[0];\n\n    // @notice since the returned `data` is 32 byte, convert it to the public 20-byte address standard",
            "codeOnlyTokens": 802,
            "startLine": 123,
            "endLine": 242,
            "type": ".ts_part_2",
            "isOversized": false
          },
          {
            "originalText": "    const tokenAddress = `0x${data.slice(-40)}`;\n\n    return { tokenAddress, transactionHash: txReceipt.hash };\n  } catch (err: any) {\n    console.error(err);\n    return { err, transactionHash: err.receipt && err.receipt.hash };\n  }\n};\n\n/**\n * @dev mints Hedera tokens\n *\n * @dev integrates tokenCreateCustomContract.mintTokenPublic()\n *\n * @param baseContract: ethers.Contract\n *\n * @param signerAddress: ethers.AddressLike\n *\n * @param network: TNetworkName\n *\n * @param tokenType: 'FUNGIBLE' | 'NON_FUNGIBLE'\n *\n * @param hederaTokenAddress: ethers.AddressLike\n *\n * @param amountToMint: number\n *\n * @param metadata: string[]\n *\n * @param gasLimit: number\n *\n * @return Promise<ISmartContractExecutionResult>\n */\nexport const mintHederaToken = async (\n  baseContract: Contract,\n  signerAddress: ethers.AddressLike,\n  network: TNetworkName,\n  tokenType: 'FUNGIBLE' | 'NON_FUNGIBLE',\n  hederaTokenAddress: ethers.AddressLike,\n  amountToMint: number,\n  metadata: string[],\n  gasLimit: number\n): Promise<ISmartContractExecutionResult> => {\n  // sanitize params\n  let sanitizeErr;\n  if (!isAddress(hederaTokenAddress)) {\n    sanitizeErr = 'invalid Hedera token address';\n  } else if (tokenType === 'FUNGIBLE' && amountToMint < 0) {\n    sanitizeErr = 'amount to mint cannot be negative when minting a fungible token';\n  } else if (tokenType === 'NON_FUNGIBLE' && amountToMint !== 0) {\n    sanitizeErr = 'amount to mint must be 0 when minting a non-fungible token';\n  }\n\n  if (sanitizeErr) {\n    console.error(sanitizeErr);\n    return { err: sanitizeErr };\n  }\n\n  // convert metadata to Buffer[]\n  const bufferedMetadata = metadata.map((meta) => Buffer.from(meta));\n\n  // execute .mintTokenPublic() method\n  try {\n    if (gasLimit === 0) {\n      const estimateGasResult = await handleEstimateGas(\n        baseContract,\n        signerAddress,\n        network,\n        'mintTokenPublic',\n        [hederaTokenAddress, amountToMint, bufferedMetadata]\n      );\n      if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n      gasLimit = estimateGasResult.gasLimit;\n    }\n    const tx = await baseContract.mintTokenPublic(hederaTokenAddress, amountToMint, bufferedMetadata, {\n      gasLimit,\n    });\n\n    // handle contract responses\n    return await handleContractResponse(tx);\n  } catch (err: any) {\n    console.error(err);\n    return { err, transactionHash: err.receipt && err.receipt.hash };\n  }\n};\n\n/**\n * @dev mints Hedera tokens and transfer it to another address\n *\n * @dev integrates tokenCreateCustomContract.mintTokenToAddressPublic() & tokenCreateCustomContract.mintNonFungibleTokenToAddressPublic()\n *\n * @param baseContract: ethers.Contract\n *\n * @param signerAddress: ethers.AddressLike\n *\n * @param network: TNetworkName\n *\n * @param tokenType: 'FUNGIBLE' | 'NON_FUNGIBLE'\n *\n * @param hederaTokenAddress: ethers.AddressLike\n *\n * @param recipientAddress: ethers.AddressLike\n *\n * @param amountToMint: number\n *\n * @param metadata: string[]\n *\n * @param gasLimit: number\n *\n * @return Promise<ISmartContractExecutionResult>\n */\nexport const mintHederaTokenToAddress = async (\n  baseContract: Contract,",
            "codeOnlyTokens": 802,
            "startLine": 243,
            "endLine": 354,
            "type": ".ts_part_3",
            "isOversized": false
          },
          {
            "originalText": "  signerAddress: ethers.AddressLike,\n  network: TNetworkName,\n  tokenType: 'FUNGIBLE' | 'NON_FUNGIBLE',\n  hederaTokenAddress: ethers.AddressLike,\n  recipientAddress: ethers.AddressLike,\n  amountToMint: number,\n  metadata: string[],\n  gasLimit: number\n): Promise<ISmartContractExecutionResult> => {\n  // sanitize params\n  let sanitizeErr;\n  if (!isAddress(hederaTokenAddress)) {\n    sanitizeErr = 'invalid Hedera token address';\n  } else if (!isAddress(recipientAddress)) {\n    sanitizeErr = 'invalid recipient address';\n  } else if (tokenType === 'FUNGIBLE' && amountToMint < 0) {\n    sanitizeErr = 'amount to mint cannot be negative when minting a fungible token';\n  } else if (tokenType === 'NON_FUNGIBLE' && amountToMint !== 0) {\n    sanitizeErr = 'amount to mint must be 0 when minting a non-fungible token';\n  }\n\n  if (sanitizeErr) {\n    console.error(sanitizeErr);\n    return { err: sanitizeErr };\n  }\n\n  // convert metadata to Buffer[]\n  const bufferedMetadata = metadata.map((meta) => Buffer.from(meta));\n\n  try {\n    let tx;\n    if (tokenType === 'FUNGIBLE') {\n      if (gasLimit === 0) {\n        const estimateGasResult = await handleEstimateGas(\n          baseContract,\n          signerAddress,\n          network,\n          'mintTokenToAddressPublic',\n          [hederaTokenAddress, recipientAddress, amountToMint, bufferedMetadata]\n        );\n        if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n        gasLimit = estimateGasResult.gasLimit;\n      }\n      tx = await baseContract.mintTokenToAddressPublic(\n        hederaTokenAddress,\n        recipientAddress,\n        amountToMint,\n        bufferedMetadata,\n        {\n          gasLimit,\n        }\n      );\n    } else {\n      if (gasLimit === 0) {\n        const estimateGasResult = await handleEstimateGas(\n          baseContract,\n          signerAddress,\n          network,\n          'mintNonFungibleTokenToAddressPublic',\n          [hederaTokenAddress, recipientAddress, amountToMint, bufferedMetadata]\n        );\n        if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n        gasLimit = estimateGasResult.gasLimit;\n      }\n      tx = await baseContract.mintNonFungibleTokenToAddressPublic(\n        hederaTokenAddress,\n        recipientAddress,\n        amountToMint,\n        bufferedMetadata,\n        {\n          gasLimit,\n        }\n      );\n    }\n\n    // handle contract responses\n    return await handleContractResponse(tx);\n  } catch (err: any) {\n    console.error(err);\n    return { err, transactionHash: err.receipt && err.receipt.hash };\n  }\n};\n\n/**\n * @dev associates Hedera tokens to accounts\n *\n * @dev integrates tokenCreateCustomContract.associateTokensPublic() and tokenCreateCustomContract.associateTokenPublic()\n *\n * @param baseContract: ethers.Contract\n *\n * @param signerAddress: ethers.AddressLike\n *\n * @param network: TNetworkName\n *\n * @param hederaTokenAddresses: string[]\n *\n * @param associtingAccountAddress: ethers.AddressLike\n *\n * @param gasLimit: number\n *\n * @return Promise<ISmartContractExecutionResult>\n */\nexport const associateHederaTokensToAccounts = async (\n  baseContract: Contract,\n  signerAddress: ethers.AddressLike,\n  network: TNetworkName,\n  hederaTokenAddresses: string[],\n  associtingAccountAddress: ethers.AddressLike,\n  gasLimit: number\n): Promise<ISmartContractExecutionResult> => {",
            "codeOnlyTokens": 800,
            "startLine": 355,
            "endLine": 464,
            "type": ".ts_part_4",
            "isOversized": false
          },
          {
            "originalText": "  // sanitize params\n  let sanitizeErr;\n  if (hederaTokenAddresses.length === 0) {\n    sanitizeErr = 'must have at least one token address to associate';\n  } else if (!isAddress(associtingAccountAddress)) {\n    sanitizeErr = 'associating account address is invalid';\n  }\n  let invalidTokens = [] as any;\n  hederaTokenAddresses.forEach((address) => {\n    if (!isAddress(address.trim())) {\n      invalidTokens.push(address);\n    }\n  });\n\n  if (invalidTokens.length > 0) {\n    sanitizeErr = { invalidTokens };\n  }\n\n  if (sanitizeErr) {\n    console.error(sanitizeErr);\n    return { err: sanitizeErr };\n  }\n\n  try {\n    let tx;\n    if (hederaTokenAddresses.length === 1) {\n      if (gasLimit === 0) {\n        const estimateGasResult = await handleEstimateGas(\n          baseContract,\n          signerAddress,\n          network,\n          'associateTokenPublic',\n          [associtingAccountAddress, hederaTokenAddresses[0]]\n        );\n        if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n        gasLimit = estimateGasResult.gasLimit;\n      }\n\n      tx = await baseContract.associateTokenPublic(associtingAccountAddress, hederaTokenAddresses[0], {\n        gasLimit,\n      });\n    } else {\n      if (gasLimit === 0) {\n        const estimateGasResult = await handleEstimateGas(\n          baseContract,\n          signerAddress,\n          network,\n          'associateTokensPublic',\n          [associtingAccountAddress, hederaTokenAddresses]\n        );\n        if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n        gasLimit = estimateGasResult.gasLimit;\n      }\n      tx = await baseContract.associateTokensPublic(associtingAccountAddress, hederaTokenAddresses, {\n        gasLimit,\n      });\n    }\n\n    // handle contract responses\n    return await handleContractResponse(tx);\n  } catch (err: any) {\n    console.error(err);\n    return { err, transactionHash: err.receipt && err.receipt.hash };\n  }\n};\n\n/**\n * @dev grants token KYC to an account\n *\n * @dev integrates tokenCreateCustomContract.grantTokenKycPublic()\n *\n * @param baseContract: ethers.Contract\n *\n * @param signerAddress: ethers.AddressLike\n *\n * @param network: TNetworkName\n *\n * @param hederaTokenAddress: ethers.AddressLike\n *\n * @param grantingKYCAccountAddress: ethers.AddressLike\n *\n * @param gasLimit: number\n *\n * @return Promise<ISmartContractExecutionResult>\n */\nexport const grantTokenKYCToAccount = async (\n  baseContract: Contract,\n  signerAddress: ethers.AddressLike,\n  network: TNetworkName,\n  hederaTokenAddress: ethers.AddressLike,\n  grantingKYCAccountAddress: ethers.AddressLike,\n  gasLimit: number\n): Promise<ISmartContractExecutionResult> => {\n  // sanitize params\n  let sanitizeErr;\n  if (!isAddress(hederaTokenAddress)) {\n    sanitizeErr = 'invalid Hedera token address';\n  } else if (!isAddress(grantingKYCAccountAddress)) {\n    sanitizeErr = 'invalid associating account address';\n  }\n\n  if (sanitizeErr) {\n    console.error(sanitizeErr);\n    return { err: sanitizeErr };\n  }\n\n  try {\n    if (gasLimit === 0) {\n      const estimateGasResult = await handleEstimateGas(\n        baseContract,\n        signerAddress,\n        network,\n        'grantTokenKycPublic',\n        [hederaTokenAddress, grantingKYCAccountAddress]\n      );\n      if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };",
            "codeOnlyTokens": 808,
            "startLine": 465,
            "endLine": 580,
            "type": ".ts_part_5",
            "isOversized": false
          },
          {
            "originalText": "      gasLimit = estimateGasResult.gasLimit;\n    }\n    const tx = await baseContract.grantTokenKycPublic(hederaTokenAddress, grantingKYCAccountAddress, {\n      gasLimit,\n    });\n\n    // handle contract responses\n    return await handleContractResponse(tx);\n  } catch (err: any) {\n    console.error(err);\n    return { err, transactionHash: err.receipt && err.receipt.hash };\n  }\n};\n",
            "codeOnlyTokens": 93,
            "startLine": 581,
            "endLine": 594,
            "type": ".ts_part_6",
            "isOversized": false
          }
        ],
        "groupedChunks": [
          {
            "combinedText": "// File: system-contract-dapp-playground/src/api/hedera/hts-interactions/tokenCreateCustom-interactions/index.ts\n// Relevant file context:\n// Type: .ts\n\n\n// --- Next chunk ---\n\n// Lines 1-122 (.ts_part_1)\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  handleContractResponse,\n  prepareHederaTokenKeyArray,\n} from '@/utils/contract-interactions/HTS/helpers';\nimport { Contract, ethers, isAddress } from 'ethers';\nimport { ISmartContractExecutionResult } from '@/types/contract-interactions/shared';\nimport { handleEstimateGas } from '@/utils/common/helpers';\nimport { TNetworkName } from '@/types/common';\n\n/**\n * @dev creates a Hedera fungible token\n *\n * @dev integrates tokenCreateCustomContract.createFungibleTokenPublic() and tokenCreateCustomContract.createFungibleTokenWithCustomFeesPublic()\n *\n * @param baseContract: ethers.Contract\n *\n * @param name: string\n *\n * @param symbol: string\n *\n * @param memo: string\n *\n * @param initialTotalSupply: number\n *\n * @param maxSupply: number\n *\n * @param decimals: number\n *\n * @param freezeDefaultStatus: boolean\n *\n * @param treasury: string\n *\n * @param inputKeys: ICommonKeyObject[],\n *\n * @param msgValue: string\n *\n * @param feeTokenAddress?: string\n *\n * @param feeAmount?: number\n *\n * @return Promise<ISmartContractExecutionResult>\n *\n * @see https://github.com/hashgraph/hedera-smart-contracts/blob/main/contracts/system-contracts/hedera-token-service/IHederaTokenService.sol#L136\n *      for more information on the purposes of the params\n */\nexport const createHederaFungibleToken = async (\n  baseContract: Contract,\n  name: string,\n  symbol: string,\n  memo: string,\n  initialTotalSupply: number,\n  maxSupply: number,\n  decimals: number,\n  freezeDefaultStatus: boolean,\n  treasury: string,\n  inputKeys: ICommonKeyObject[],\n  msgValue: string,\n  feeTokenAddress?: string,\n  feeAmount?: number\n): Promise<ISmartContractExecutionResult> => {\n  // sanitize params\n  let sanitizeErr;\n  if (initialTotalSupply < 0) {\n    sanitizeErr = 'initial total supply cannot be negative';\n  } else if (maxSupply < 0) {\n    sanitizeErr = 'max supply cannot be negative';\n  } else if (decimals < 0) {\n    sanitizeErr = 'decimals cannot be negative';\n  } else if (!isAddress(treasury)) {\n    sanitizeErr = 'invalid treasury address';\n  } else if (feeTokenAddress && !isAddress(feeTokenAddress)) {\n    sanitizeErr = 'invalid fee token address';\n  }\n  if (sanitizeErr) {\n    console.error(sanitizeErr);\n    return { err: sanitizeErr };\n  }\n\n  // prepare keys array\n  const keyRes = prepareHederaTokenKeyArray(inputKeys);\n\n  // handle error\n  if (keyRes.err) {\n    console.error(keyRes.err);\n    return { err: keyRes.err };\n  }\n\n  try {\n    let tokenCreateTx;\n    if (feeTokenAddress) {\n      tokenCreateTx = await baseContract.createFungibleTokenWithCustomFeesPublic(\n        treasury,\n        feeTokenAddress,\n        name,\n        symbol,\n        memo,\n        initialTotalSupply,\n        maxSupply,\n        decimals,\n        feeAmount,\n        keyRes.hederaTokenKeys,\n        {\n          value: ethers.parseEther(msgValue),\n          gasLimit: 1_000_000,\n        }\n      );\n    } else {\n      tokenCreateTx = await baseContract.createFungibleTokenPublic(\n        name,\n        symbol,\n        memo,\n        initialTotalSupply,\n        maxSupply,\n        decimals,\n        freezeDefaultStatus,\n        treasury,\n        keyRes.hederaTokenKeys,\n        {\n          value: ethers.parseEther(msgValue),\n          gasLimit: 1_000_000,\n\n// --- Next chunk ---\n\n// Lines 123-242 (.ts_part_2)\n        }\n      );\n    }\n\n    const txReceipt = await tokenCreateTx.wait();\n\n    const { data } = txReceipt.logs.filter((event: any) => event.fragment.name === 'CreatedToken')[0];\n\n    // @notice since the returned `data` is 32 byte, convert it to the public 20-byte address standard\n    const tokenAddress = `0x${data.slice(-40)}`;\n\n    return { tokenAddress, transactionHash: txReceipt.hash };\n  } catch (err: any) {\n    console.error(err);\n    return { err, transactionHash: err.receipt && err.receipt.hash };\n  }\n};\n\n/**\n * @dev creates a Hedera non fungible token\n *\n * @dev integrates tokenCreateCustomContract.createNonFungibleTokenPublic() and tokenCreateCustomContract.createNonFungibleTokenWithCustomFeesPublic()\n *\n * @param baseContract: ethers.Contract\n *\n * @param name: string\n *\n * @param symbol: string\n *\n * @param memo: string\n *\n * @param maxSupply: number\n *\n * @param treasury: ethers.AddressLike\n *\n * @param inputKeys: ICommonKeyObject[],\n *\n * @param msgValue: string\n *\n * @param feeTokenAddress?: ethers.AddressLike\n *\n * @param feeAmount?: number\n *\n * @return Promise<ISmartContractExecutionResult>\n *\n * @see https://github.com/hashgraph/hedera-smart-contracts/blob/main/contracts/system-contracts/hedera-token-service/IHederaTokenService.sol#L136\n *      for more information on the purposes of the params\n */\nexport const createHederaNonFungibleToken = async (\n  baseContract: Contract,\n  name: string,\n  symbol: string,\n  memo: string,\n  maxSupply: number,\n  treasury: ethers.AddressLike,\n  inputKeys: ICommonKeyObject[],\n  msgValue: string,\n  feeTokenAddress?: ethers.AddressLike,\n  feeAmount?: number\n): Promise<ISmartContractExecutionResult> => {\n  // sanitize params\n  let sanitizeErr;\n  if (maxSupply < 0) {\n    sanitizeErr = 'max supply cannot be negative';\n  } else if (!isAddress(treasury)) {\n    sanitizeErr = 'invalid treasury address';\n  } else if (feeTokenAddress && !isAddress(feeTokenAddress)) {\n    sanitizeErr = 'invalid fee token address';\n  }\n\n  if (sanitizeErr) {\n    console.error(sanitizeErr);\n    return { err: sanitizeErr };\n  }\n\n  // prepare keys array\n  const keyRes = prepareHederaTokenKeyArray(inputKeys);\n\n  // handle error\n  if (keyRes.err) {\n    return { err: keyRes.err };\n  }\n\n  try {\n    let tokenCreateTx;\n    if (feeTokenAddress) {\n      tokenCreateTx = await baseContract.createNonFungibleTokenWithCustomFeesPublic(\n        treasury,\n        feeTokenAddress,\n        name,\n        symbol,\n        memo,\n        maxSupply,\n        feeAmount,\n        keyRes.hederaTokenKeys,\n        {\n          value: ethers.parseEther(msgValue),\n          gasLimit: 1_000_000,\n        }\n      );\n    } else {\n      tokenCreateTx = await baseContract.createNonFungibleTokenPublic(\n        name,\n        symbol,\n        memo,\n        maxSupply,\n        treasury,\n        keyRes.hederaTokenKeys,\n        {\n          value: ethers.parseEther(msgValue),\n          gasLimit: 1_000_000,\n        }\n      );\n    }\n\n    const txReceipt = await tokenCreateTx.wait();\n\n    const { data } = txReceipt.logs.filter((event: any) => event.fragment.name === 'CreatedToken')[0];\n\n    // @notice since the returned `data` is 32 byte, convert it to the public 20-byte address standard\n\n// --- Next chunk ---\n\n// Lines 243-354 (.ts_part_3)\n    const tokenAddress = `0x${data.slice(-40)}`;\n\n    return { tokenAddress, transactionHash: txReceipt.hash };\n  } catch (err: any) {\n    console.error(err);\n    return { err, transactionHash: err.receipt && err.receipt.hash };\n  }\n};\n\n/**\n * @dev mints Hedera tokens\n *\n * @dev integrates tokenCreateCustomContract.mintTokenPublic()\n *\n * @param baseContract: ethers.Contract\n *\n * @param signerAddress: ethers.AddressLike\n *\n * @param network: TNetworkName\n *\n * @param tokenType: 'FUNGIBLE' | 'NON_FUNGIBLE'\n *\n * @param hederaTokenAddress: ethers.AddressLike\n *\n * @param amountToMint: number\n *\n * @param metadata: string[]\n *\n * @param gasLimit: number\n *\n * @return Promise<ISmartContractExecutionResult>\n */\nexport const mintHederaToken = async (\n  baseContract: Contract,\n  signerAddress: ethers.AddressLike,\n  network: TNetworkName,\n  tokenType: 'FUNGIBLE' | 'NON_FUNGIBLE',\n  hederaTokenAddress: ethers.AddressLike,\n  amountToMint: number,\n  metadata: string[],\n  gasLimit: number\n): Promise<ISmartContractExecutionResult> => {\n  // sanitize params\n  let sanitizeErr;\n  if (!isAddress(hederaTokenAddress)) {\n    sanitizeErr = 'invalid Hedera token address';\n  } else if (tokenType === 'FUNGIBLE' && amountToMint < 0) {\n    sanitizeErr = 'amount to mint cannot be negative when minting a fungible token';\n  } else if (tokenType === 'NON_FUNGIBLE' && amountToMint !== 0) {\n    sanitizeErr = 'amount to mint must be 0 when minting a non-fungible token';\n  }\n\n  if (sanitizeErr) {\n    console.error(sanitizeErr);\n    return { err: sanitizeErr };\n  }\n\n  // convert metadata to Buffer[]\n  const bufferedMetadata = metadata.map((meta) => Buffer.from(meta));\n\n  // execute .mintTokenPublic() method\n  try {\n    if (gasLimit === 0) {\n      const estimateGasResult = await handleEstimateGas(\n        baseContract,\n        signerAddress,\n        network,\n        'mintTokenPublic',\n        [hederaTokenAddress, amountToMint, bufferedMetadata]\n      );\n      if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n      gasLimit = estimateGasResult.gasLimit;\n    }\n    const tx = await baseContract.mintTokenPublic(hederaTokenAddress, amountToMint, bufferedMetadata, {\n      gasLimit,\n    });\n\n    // handle contract responses\n    return await handleContractResponse(tx);\n  } catch (err: any) {\n    console.error(err);\n    return { err, transactionHash: err.receipt && err.receipt.hash };\n  }\n};\n\n/**\n * @dev mints Hedera tokens and transfer it to another address\n *\n * @dev integrates tokenCreateCustomContract.mintTokenToAddressPublic() & tokenCreateCustomContract.mintNonFungibleTokenToAddressPublic()\n *\n * @param baseContract: ethers.Contract\n *\n * @param signerAddress: ethers.AddressLike\n *\n * @param network: TNetworkName\n *\n * @param tokenType: 'FUNGIBLE' | 'NON_FUNGIBLE'\n *\n * @param hederaTokenAddress: ethers.AddressLike\n *\n * @param recipientAddress: ethers.AddressLike\n *\n * @param amountToMint: number\n *\n * @param metadata: string[]\n *\n * @param gasLimit: number\n *\n * @return Promise<ISmartContractExecutionResult>\n */\nexport const mintHederaTokenToAddress = async (\n  baseContract: Contract,",
            "totalTokens": 2500,
            "chunks": [
              {
                "originalText": "// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  handleContractResponse,\n  prepareHederaTokenKeyArray,\n} from '@/utils/contract-interactions/HTS/helpers';\nimport { Contract, ethers, isAddress } from 'ethers';\nimport { ISmartContractExecutionResult } from '@/types/contract-interactions/shared';\nimport { handleEstimateGas } from '@/utils/common/helpers';\nimport { TNetworkName } from '@/types/common';\n\n/**\n * @dev creates a Hedera fungible token\n *\n * @dev integrates tokenCreateCustomContract.createFungibleTokenPublic() and tokenCreateCustomContract.createFungibleTokenWithCustomFeesPublic()\n *\n * @param baseContract: ethers.Contract\n *\n * @param name: string\n *\n * @param symbol: string\n *\n * @param memo: string\n *\n * @param initialTotalSupply: number\n *\n * @param maxSupply: number\n *\n * @param decimals: number\n *\n * @param freezeDefaultStatus: boolean\n *\n * @param treasury: string\n *\n * @param inputKeys: ICommonKeyObject[],\n *\n * @param msgValue: string\n *\n * @param feeTokenAddress?: string\n *\n * @param feeAmount?: number\n *\n * @return Promise<ISmartContractExecutionResult>\n *\n * @see https://github.com/hashgraph/hedera-smart-contracts/blob/main/contracts/system-contracts/hedera-token-service/IHederaTokenService.sol#L136\n *      for more information on the purposes of the params\n */\nexport const createHederaFungibleToken = async (\n  baseContract: Contract,\n  name: string,\n  symbol: string,\n  memo: string,\n  initialTotalSupply: number,\n  maxSupply: number,\n  decimals: number,\n  freezeDefaultStatus: boolean,\n  treasury: string,\n  inputKeys: ICommonKeyObject[],\n  msgValue: string,\n  feeTokenAddress?: string,\n  feeAmount?: number\n): Promise<ISmartContractExecutionResult> => {\n  // sanitize params\n  let sanitizeErr;\n  if (initialTotalSupply < 0) {\n    sanitizeErr = 'initial total supply cannot be negative';\n  } else if (maxSupply < 0) {\n    sanitizeErr = 'max supply cannot be negative';\n  } else if (decimals < 0) {\n    sanitizeErr = 'decimals cannot be negative';\n  } else if (!isAddress(treasury)) {\n    sanitizeErr = 'invalid treasury address';\n  } else if (feeTokenAddress && !isAddress(feeTokenAddress)) {\n    sanitizeErr = 'invalid fee token address';\n  }\n  if (sanitizeErr) {\n    console.error(sanitizeErr);\n    return { err: sanitizeErr };\n  }\n\n  // prepare keys array\n  const keyRes = prepareHederaTokenKeyArray(inputKeys);\n\n  // handle error\n  if (keyRes.err) {\n    console.error(keyRes.err);\n    return { err: keyRes.err };\n  }\n\n  try {\n    let tokenCreateTx;\n    if (feeTokenAddress) {\n      tokenCreateTx = await baseContract.createFungibleTokenWithCustomFeesPublic(\n        treasury,\n        feeTokenAddress,\n        name,\n        symbol,\n        memo,\n        initialTotalSupply,\n        maxSupply,\n        decimals,\n        feeAmount,\n        keyRes.hederaTokenKeys,\n        {\n          value: ethers.parseEther(msgValue),\n          gasLimit: 1_000_000,\n        }\n      );\n    } else {\n      tokenCreateTx = await baseContract.createFungibleTokenPublic(\n        name,\n        symbol,\n        memo,\n        initialTotalSupply,\n        maxSupply,\n        decimals,\n        freezeDefaultStatus,\n        treasury,\n        keyRes.hederaTokenKeys,\n        {\n          value: ethers.parseEther(msgValue),\n          gasLimit: 1_000_000,",
                "codeOnlyTokens": 805,
                "startLine": 1,
                "endLine": 122,
                "type": ".ts_part_1",
                "isOversized": false
              },
              {
                "originalText": "        }\n      );\n    }\n\n    const txReceipt = await tokenCreateTx.wait();\n\n    const { data } = txReceipt.logs.filter((event: any) => event.fragment.name === 'CreatedToken')[0];\n\n    // @notice since the returned `data` is 32 byte, convert it to the public 20-byte address standard\n    const tokenAddress = `0x${data.slice(-40)}`;\n\n    return { tokenAddress, transactionHash: txReceipt.hash };\n  } catch (err: any) {\n    console.error(err);\n    return { err, transactionHash: err.receipt && err.receipt.hash };\n  }\n};\n\n/**\n * @dev creates a Hedera non fungible token\n *\n * @dev integrates tokenCreateCustomContract.createNonFungibleTokenPublic() and tokenCreateCustomContract.createNonFungibleTokenWithCustomFeesPublic()\n *\n * @param baseContract: ethers.Contract\n *\n * @param name: string\n *\n * @param symbol: string\n *\n * @param memo: string\n *\n * @param maxSupply: number\n *\n * @param treasury: ethers.AddressLike\n *\n * @param inputKeys: ICommonKeyObject[],\n *\n * @param msgValue: string\n *\n * @param feeTokenAddress?: ethers.AddressLike\n *\n * @param feeAmount?: number\n *\n * @return Promise<ISmartContractExecutionResult>\n *\n * @see https://github.com/hashgraph/hedera-smart-contracts/blob/main/contracts/system-contracts/hedera-token-service/IHederaTokenService.sol#L136\n *      for more information on the purposes of the params\n */\nexport const createHederaNonFungibleToken = async (\n  baseContract: Contract,\n  name: string,\n  symbol: string,\n  memo: string,\n  maxSupply: number,\n  treasury: ethers.AddressLike,\n  inputKeys: ICommonKeyObject[],\n  msgValue: string,\n  feeTokenAddress?: ethers.AddressLike,\n  feeAmount?: number\n): Promise<ISmartContractExecutionResult> => {\n  // sanitize params\n  let sanitizeErr;\n  if (maxSupply < 0) {\n    sanitizeErr = 'max supply cannot be negative';\n  } else if (!isAddress(treasury)) {\n    sanitizeErr = 'invalid treasury address';\n  } else if (feeTokenAddress && !isAddress(feeTokenAddress)) {\n    sanitizeErr = 'invalid fee token address';\n  }\n\n  if (sanitizeErr) {\n    console.error(sanitizeErr);\n    return { err: sanitizeErr };\n  }\n\n  // prepare keys array\n  const keyRes = prepareHederaTokenKeyArray(inputKeys);\n\n  // handle error\n  if (keyRes.err) {\n    return { err: keyRes.err };\n  }\n\n  try {\n    let tokenCreateTx;\n    if (feeTokenAddress) {\n      tokenCreateTx = await baseContract.createNonFungibleTokenWithCustomFeesPublic(\n        treasury,\n        feeTokenAddress,\n        name,\n        symbol,\n        memo,\n        maxSupply,\n        feeAmount,\n        keyRes.hederaTokenKeys,\n        {\n          value: ethers.parseEther(msgValue),\n          gasLimit: 1_000_000,\n        }\n      );\n    } else {\n      tokenCreateTx = await baseContract.createNonFungibleTokenPublic(\n        name,\n        symbol,\n        memo,\n        maxSupply,\n        treasury,\n        keyRes.hederaTokenKeys,\n        {\n          value: ethers.parseEther(msgValue),\n          gasLimit: 1_000_000,\n        }\n      );\n    }\n\n    const txReceipt = await tokenCreateTx.wait();\n\n    const { data } = txReceipt.logs.filter((event: any) => event.fragment.name === 'CreatedToken')[0];\n\n    // @notice since the returned `data` is 32 byte, convert it to the public 20-byte address standard",
                "codeOnlyTokens": 802,
                "startLine": 123,
                "endLine": 242,
                "type": ".ts_part_2",
                "isOversized": false
              },
              {
                "originalText": "    const tokenAddress = `0x${data.slice(-40)}`;\n\n    return { tokenAddress, transactionHash: txReceipt.hash };\n  } catch (err: any) {\n    console.error(err);\n    return { err, transactionHash: err.receipt && err.receipt.hash };\n  }\n};\n\n/**\n * @dev mints Hedera tokens\n *\n * @dev integrates tokenCreateCustomContract.mintTokenPublic()\n *\n * @param baseContract: ethers.Contract\n *\n * @param signerAddress: ethers.AddressLike\n *\n * @param network: TNetworkName\n *\n * @param tokenType: 'FUNGIBLE' | 'NON_FUNGIBLE'\n *\n * @param hederaTokenAddress: ethers.AddressLike\n *\n * @param amountToMint: number\n *\n * @param metadata: string[]\n *\n * @param gasLimit: number\n *\n * @return Promise<ISmartContractExecutionResult>\n */\nexport const mintHederaToken = async (\n  baseContract: Contract,\n  signerAddress: ethers.AddressLike,\n  network: TNetworkName,\n  tokenType: 'FUNGIBLE' | 'NON_FUNGIBLE',\n  hederaTokenAddress: ethers.AddressLike,\n  amountToMint: number,\n  metadata: string[],\n  gasLimit: number\n): Promise<ISmartContractExecutionResult> => {\n  // sanitize params\n  let sanitizeErr;\n  if (!isAddress(hederaTokenAddress)) {\n    sanitizeErr = 'invalid Hedera token address';\n  } else if (tokenType === 'FUNGIBLE' && amountToMint < 0) {\n    sanitizeErr = 'amount to mint cannot be negative when minting a fungible token';\n  } else if (tokenType === 'NON_FUNGIBLE' && amountToMint !== 0) {\n    sanitizeErr = 'amount to mint must be 0 when minting a non-fungible token';\n  }\n\n  if (sanitizeErr) {\n    console.error(sanitizeErr);\n    return { err: sanitizeErr };\n  }\n\n  // convert metadata to Buffer[]\n  const bufferedMetadata = metadata.map((meta) => Buffer.from(meta));\n\n  // execute .mintTokenPublic() method\n  try {\n    if (gasLimit === 0) {\n      const estimateGasResult = await handleEstimateGas(\n        baseContract,\n        signerAddress,\n        network,\n        'mintTokenPublic',\n        [hederaTokenAddress, amountToMint, bufferedMetadata]\n      );\n      if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n      gasLimit = estimateGasResult.gasLimit;\n    }\n    const tx = await baseContract.mintTokenPublic(hederaTokenAddress, amountToMint, bufferedMetadata, {\n      gasLimit,\n    });\n\n    // handle contract responses\n    return await handleContractResponse(tx);\n  } catch (err: any) {\n    console.error(err);\n    return { err, transactionHash: err.receipt && err.receipt.hash };\n  }\n};\n\n/**\n * @dev mints Hedera tokens and transfer it to another address\n *\n * @dev integrates tokenCreateCustomContract.mintTokenToAddressPublic() & tokenCreateCustomContract.mintNonFungibleTokenToAddressPublic()\n *\n * @param baseContract: ethers.Contract\n *\n * @param signerAddress: ethers.AddressLike\n *\n * @param network: TNetworkName\n *\n * @param tokenType: 'FUNGIBLE' | 'NON_FUNGIBLE'\n *\n * @param hederaTokenAddress: ethers.AddressLike\n *\n * @param recipientAddress: ethers.AddressLike\n *\n * @param amountToMint: number\n *\n * @param metadata: string[]\n *\n * @param gasLimit: number\n *\n * @return Promise<ISmartContractExecutionResult>\n */\nexport const mintHederaTokenToAddress = async (\n  baseContract: Contract,",
                "codeOnlyTokens": 802,
                "startLine": 243,
                "endLine": 354,
                "type": ".ts_part_3",
                "isOversized": false
              }
            ],
            "startLine": 1,
            "endLine": 354,
            "groupId": 1
          },
          {
            "combinedText": "// File: system-contract-dapp-playground/src/api/hedera/hts-interactions/tokenCreateCustom-interactions/index.ts\n// Relevant file context:\n// Type: .ts\n\n\n// --- Next chunk ---\n\n// Lines 355-464 (.ts_part_4)\n  signerAddress: ethers.AddressLike,\n  network: TNetworkName,\n  tokenType: 'FUNGIBLE' | 'NON_FUNGIBLE',\n  hederaTokenAddress: ethers.AddressLike,\n  recipientAddress: ethers.AddressLike,\n  amountToMint: number,\n  metadata: string[],\n  gasLimit: number\n): Promise<ISmartContractExecutionResult> => {\n  // sanitize params\n  let sanitizeErr;\n  if (!isAddress(hederaTokenAddress)) {\n    sanitizeErr = 'invalid Hedera token address';\n  } else if (!isAddress(recipientAddress)) {\n    sanitizeErr = 'invalid recipient address';\n  } else if (tokenType === 'FUNGIBLE' && amountToMint < 0) {\n    sanitizeErr = 'amount to mint cannot be negative when minting a fungible token';\n  } else if (tokenType === 'NON_FUNGIBLE' && amountToMint !== 0) {\n    sanitizeErr = 'amount to mint must be 0 when minting a non-fungible token';\n  }\n\n  if (sanitizeErr) {\n    console.error(sanitizeErr);\n    return { err: sanitizeErr };\n  }\n\n  // convert metadata to Buffer[]\n  const bufferedMetadata = metadata.map((meta) => Buffer.from(meta));\n\n  try {\n    let tx;\n    if (tokenType === 'FUNGIBLE') {\n      if (gasLimit === 0) {\n        const estimateGasResult = await handleEstimateGas(\n          baseContract,\n          signerAddress,\n          network,\n          'mintTokenToAddressPublic',\n          [hederaTokenAddress, recipientAddress, amountToMint, bufferedMetadata]\n        );\n        if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n        gasLimit = estimateGasResult.gasLimit;\n      }\n      tx = await baseContract.mintTokenToAddressPublic(\n        hederaTokenAddress,\n        recipientAddress,\n        amountToMint,\n        bufferedMetadata,\n        {\n          gasLimit,\n        }\n      );\n    } else {\n      if (gasLimit === 0) {\n        const estimateGasResult = await handleEstimateGas(\n          baseContract,\n          signerAddress,\n          network,\n          'mintNonFungibleTokenToAddressPublic',\n          [hederaTokenAddress, recipientAddress, amountToMint, bufferedMetadata]\n        );\n        if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n        gasLimit = estimateGasResult.gasLimit;\n      }\n      tx = await baseContract.mintNonFungibleTokenToAddressPublic(\n        hederaTokenAddress,\n        recipientAddress,\n        amountToMint,\n        bufferedMetadata,\n        {\n          gasLimit,\n        }\n      );\n    }\n\n    // handle contract responses\n    return await handleContractResponse(tx);\n  } catch (err: any) {\n    console.error(err);\n    return { err, transactionHash: err.receipt && err.receipt.hash };\n  }\n};\n\n/**\n * @dev associates Hedera tokens to accounts\n *\n * @dev integrates tokenCreateCustomContract.associateTokensPublic() and tokenCreateCustomContract.associateTokenPublic()\n *\n * @param baseContract: ethers.Contract\n *\n * @param signerAddress: ethers.AddressLike\n *\n * @param network: TNetworkName\n *\n * @param hederaTokenAddresses: string[]\n *\n * @param associtingAccountAddress: ethers.AddressLike\n *\n * @param gasLimit: number\n *\n * @return Promise<ISmartContractExecutionResult>\n */\nexport const associateHederaTokensToAccounts = async (\n  baseContract: Contract,\n  signerAddress: ethers.AddressLike,\n  network: TNetworkName,\n  hederaTokenAddresses: string[],\n  associtingAccountAddress: ethers.AddressLike,\n  gasLimit: number\n): Promise<ISmartContractExecutionResult> => {\n\n// --- Next chunk ---\n\n// Lines 465-580 (.ts_part_5)\n  // sanitize params\n  let sanitizeErr;\n  if (hederaTokenAddresses.length === 0) {\n    sanitizeErr = 'must have at least one token address to associate';\n  } else if (!isAddress(associtingAccountAddress)) {\n    sanitizeErr = 'associating account address is invalid';\n  }\n  let invalidTokens = [] as any;\n  hederaTokenAddresses.forEach((address) => {\n    if (!isAddress(address.trim())) {\n      invalidTokens.push(address);\n    }\n  });\n\n  if (invalidTokens.length > 0) {\n    sanitizeErr = { invalidTokens };\n  }\n\n  if (sanitizeErr) {\n    console.error(sanitizeErr);\n    return { err: sanitizeErr };\n  }\n\n  try {\n    let tx;\n    if (hederaTokenAddresses.length === 1) {\n      if (gasLimit === 0) {\n        const estimateGasResult = await handleEstimateGas(\n          baseContract,\n          signerAddress,\n          network,\n          'associateTokenPublic',\n          [associtingAccountAddress, hederaTokenAddresses[0]]\n        );\n        if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n        gasLimit = estimateGasResult.gasLimit;\n      }\n\n      tx = await baseContract.associateTokenPublic(associtingAccountAddress, hederaTokenAddresses[0], {\n        gasLimit,\n      });\n    } else {\n      if (gasLimit === 0) {\n        const estimateGasResult = await handleEstimateGas(\n          baseContract,\n          signerAddress,\n          network,\n          'associateTokensPublic',\n          [associtingAccountAddress, hederaTokenAddresses]\n        );\n        if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n        gasLimit = estimateGasResult.gasLimit;\n      }\n      tx = await baseContract.associateTokensPublic(associtingAccountAddress, hederaTokenAddresses, {\n        gasLimit,\n      });\n    }\n\n    // handle contract responses\n    return await handleContractResponse(tx);\n  } catch (err: any) {\n    console.error(err);\n    return { err, transactionHash: err.receipt && err.receipt.hash };\n  }\n};\n\n/**\n * @dev grants token KYC to an account\n *\n * @dev integrates tokenCreateCustomContract.grantTokenKycPublic()\n *\n * @param baseContract: ethers.Contract\n *\n * @param signerAddress: ethers.AddressLike\n *\n * @param network: TNetworkName\n *\n * @param hederaTokenAddress: ethers.AddressLike\n *\n * @param grantingKYCAccountAddress: ethers.AddressLike\n *\n * @param gasLimit: number\n *\n * @return Promise<ISmartContractExecutionResult>\n */\nexport const grantTokenKYCToAccount = async (\n  baseContract: Contract,\n  signerAddress: ethers.AddressLike,\n  network: TNetworkName,\n  hederaTokenAddress: ethers.AddressLike,\n  grantingKYCAccountAddress: ethers.AddressLike,\n  gasLimit: number\n): Promise<ISmartContractExecutionResult> => {\n  // sanitize params\n  let sanitizeErr;\n  if (!isAddress(hederaTokenAddress)) {\n    sanitizeErr = 'invalid Hedera token address';\n  } else if (!isAddress(grantingKYCAccountAddress)) {\n    sanitizeErr = 'invalid associating account address';\n  }\n\n  if (sanitizeErr) {\n    console.error(sanitizeErr);\n    return { err: sanitizeErr };\n  }\n\n  try {\n    if (gasLimit === 0) {\n      const estimateGasResult = await handleEstimateGas(\n        baseContract,\n        signerAddress,\n        network,\n        'grantTokenKycPublic',\n        [hederaTokenAddress, grantingKYCAccountAddress]\n      );\n      if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n\n// --- Next chunk ---\n\n// Lines 581-594 (.ts_part_6)\n      gasLimit = estimateGasResult.gasLimit;\n    }\n    const tx = await baseContract.grantTokenKycPublic(hederaTokenAddress, grantingKYCAccountAddress, {\n      gasLimit,\n    });\n\n    // handle contract responses\n    return await handleContractResponse(tx);\n  } catch (err: any) {\n    console.error(err);\n    return { err, transactionHash: err.receipt && err.receipt.hash };\n  }\n};\n",
            "totalTokens": 1790,
            "chunks": [
              {
                "originalText": "  signerAddress: ethers.AddressLike,\n  network: TNetworkName,\n  tokenType: 'FUNGIBLE' | 'NON_FUNGIBLE',\n  hederaTokenAddress: ethers.AddressLike,\n  recipientAddress: ethers.AddressLike,\n  amountToMint: number,\n  metadata: string[],\n  gasLimit: number\n): Promise<ISmartContractExecutionResult> => {\n  // sanitize params\n  let sanitizeErr;\n  if (!isAddress(hederaTokenAddress)) {\n    sanitizeErr = 'invalid Hedera token address';\n  } else if (!isAddress(recipientAddress)) {\n    sanitizeErr = 'invalid recipient address';\n  } else if (tokenType === 'FUNGIBLE' && amountToMint < 0) {\n    sanitizeErr = 'amount to mint cannot be negative when minting a fungible token';\n  } else if (tokenType === 'NON_FUNGIBLE' && amountToMint !== 0) {\n    sanitizeErr = 'amount to mint must be 0 when minting a non-fungible token';\n  }\n\n  if (sanitizeErr) {\n    console.error(sanitizeErr);\n    return { err: sanitizeErr };\n  }\n\n  // convert metadata to Buffer[]\n  const bufferedMetadata = metadata.map((meta) => Buffer.from(meta));\n\n  try {\n    let tx;\n    if (tokenType === 'FUNGIBLE') {\n      if (gasLimit === 0) {\n        const estimateGasResult = await handleEstimateGas(\n          baseContract,\n          signerAddress,\n          network,\n          'mintTokenToAddressPublic',\n          [hederaTokenAddress, recipientAddress, amountToMint, bufferedMetadata]\n        );\n        if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n        gasLimit = estimateGasResult.gasLimit;\n      }\n      tx = await baseContract.mintTokenToAddressPublic(\n        hederaTokenAddress,\n        recipientAddress,\n        amountToMint,\n        bufferedMetadata,\n        {\n          gasLimit,\n        }\n      );\n    } else {\n      if (gasLimit === 0) {\n        const estimateGasResult = await handleEstimateGas(\n          baseContract,\n          signerAddress,\n          network,\n          'mintNonFungibleTokenToAddressPublic',\n          [hederaTokenAddress, recipientAddress, amountToMint, bufferedMetadata]\n        );\n        if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n        gasLimit = estimateGasResult.gasLimit;\n      }\n      tx = await baseContract.mintNonFungibleTokenToAddressPublic(\n        hederaTokenAddress,\n        recipientAddress,\n        amountToMint,\n        bufferedMetadata,\n        {\n          gasLimit,\n        }\n      );\n    }\n\n    // handle contract responses\n    return await handleContractResponse(tx);\n  } catch (err: any) {\n    console.error(err);\n    return { err, transactionHash: err.receipt && err.receipt.hash };\n  }\n};\n\n/**\n * @dev associates Hedera tokens to accounts\n *\n * @dev integrates tokenCreateCustomContract.associateTokensPublic() and tokenCreateCustomContract.associateTokenPublic()\n *\n * @param baseContract: ethers.Contract\n *\n * @param signerAddress: ethers.AddressLike\n *\n * @param network: TNetworkName\n *\n * @param hederaTokenAddresses: string[]\n *\n * @param associtingAccountAddress: ethers.AddressLike\n *\n * @param gasLimit: number\n *\n * @return Promise<ISmartContractExecutionResult>\n */\nexport const associateHederaTokensToAccounts = async (\n  baseContract: Contract,\n  signerAddress: ethers.AddressLike,\n  network: TNetworkName,\n  hederaTokenAddresses: string[],\n  associtingAccountAddress: ethers.AddressLike,\n  gasLimit: number\n): Promise<ISmartContractExecutionResult> => {",
                "codeOnlyTokens": 800,
                "startLine": 355,
                "endLine": 464,
                "type": ".ts_part_4",
                "isOversized": false
              },
              {
                "originalText": "  // sanitize params\n  let sanitizeErr;\n  if (hederaTokenAddresses.length === 0) {\n    sanitizeErr = 'must have at least one token address to associate';\n  } else if (!isAddress(associtingAccountAddress)) {\n    sanitizeErr = 'associating account address is invalid';\n  }\n  let invalidTokens = [] as any;\n  hederaTokenAddresses.forEach((address) => {\n    if (!isAddress(address.trim())) {\n      invalidTokens.push(address);\n    }\n  });\n\n  if (invalidTokens.length > 0) {\n    sanitizeErr = { invalidTokens };\n  }\n\n  if (sanitizeErr) {\n    console.error(sanitizeErr);\n    return { err: sanitizeErr };\n  }\n\n  try {\n    let tx;\n    if (hederaTokenAddresses.length === 1) {\n      if (gasLimit === 0) {\n        const estimateGasResult = await handleEstimateGas(\n          baseContract,\n          signerAddress,\n          network,\n          'associateTokenPublic',\n          [associtingAccountAddress, hederaTokenAddresses[0]]\n        );\n        if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n        gasLimit = estimateGasResult.gasLimit;\n      }\n\n      tx = await baseContract.associateTokenPublic(associtingAccountAddress, hederaTokenAddresses[0], {\n        gasLimit,\n      });\n    } else {\n      if (gasLimit === 0) {\n        const estimateGasResult = await handleEstimateGas(\n          baseContract,\n          signerAddress,\n          network,\n          'associateTokensPublic',\n          [associtingAccountAddress, hederaTokenAddresses]\n        );\n        if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n        gasLimit = estimateGasResult.gasLimit;\n      }\n      tx = await baseContract.associateTokensPublic(associtingAccountAddress, hederaTokenAddresses, {\n        gasLimit,\n      });\n    }\n\n    // handle contract responses\n    return await handleContractResponse(tx);\n  } catch (err: any) {\n    console.error(err);\n    return { err, transactionHash: err.receipt && err.receipt.hash };\n  }\n};\n\n/**\n * @dev grants token KYC to an account\n *\n * @dev integrates tokenCreateCustomContract.grantTokenKycPublic()\n *\n * @param baseContract: ethers.Contract\n *\n * @param signerAddress: ethers.AddressLike\n *\n * @param network: TNetworkName\n *\n * @param hederaTokenAddress: ethers.AddressLike\n *\n * @param grantingKYCAccountAddress: ethers.AddressLike\n *\n * @param gasLimit: number\n *\n * @return Promise<ISmartContractExecutionResult>\n */\nexport const grantTokenKYCToAccount = async (\n  baseContract: Contract,\n  signerAddress: ethers.AddressLike,\n  network: TNetworkName,\n  hederaTokenAddress: ethers.AddressLike,\n  grantingKYCAccountAddress: ethers.AddressLike,\n  gasLimit: number\n): Promise<ISmartContractExecutionResult> => {\n  // sanitize params\n  let sanitizeErr;\n  if (!isAddress(hederaTokenAddress)) {\n    sanitizeErr = 'invalid Hedera token address';\n  } else if (!isAddress(grantingKYCAccountAddress)) {\n    sanitizeErr = 'invalid associating account address';\n  }\n\n  if (sanitizeErr) {\n    console.error(sanitizeErr);\n    return { err: sanitizeErr };\n  }\n\n  try {\n    if (gasLimit === 0) {\n      const estimateGasResult = await handleEstimateGas(\n        baseContract,\n        signerAddress,\n        network,\n        'grantTokenKycPublic',\n        [hederaTokenAddress, grantingKYCAccountAddress]\n      );\n      if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };",
                "codeOnlyTokens": 808,
                "startLine": 465,
                "endLine": 580,
                "type": ".ts_part_5",
                "isOversized": false
              },
              {
                "originalText": "      gasLimit = estimateGasResult.gasLimit;\n    }\n    const tx = await baseContract.grantTokenKycPublic(hederaTokenAddress, grantingKYCAccountAddress, {\n      gasLimit,\n    });\n\n    // handle contract responses\n    return await handleContractResponse(tx);\n  } catch (err: any) {\n    console.error(err);\n    return { err, transactionHash: err.receipt && err.receipt.hash };\n  }\n};\n",
                "codeOnlyTokens": 93,
                "startLine": 581,
                "endLine": 594,
                "type": ".ts_part_6",
                "isOversized": false
              }
            ],
            "startLine": 355,
            "endLine": 594,
            "groupId": 2
          }
        ],
        "oversizedChunks": [],
        "sendStrategy": "multiple_groups",
        "finalTokenCount": 4290,
        "skippedContent": [],
        "contextHeader": "// File: system-contract-dapp-playground/src/api/hedera/hts-interactions/tokenCreateCustom-interactions/index.ts\n// Relevant file context:\n// Type: .ts\n",
        "tokenBreakdown": {
          "originalFile": 4111,
          "finalSent": 4290,
          "codeTokensInGroups": 4110,
          "fileHeaderTokensInGroups": 74,
          "shellContextTokensInGroups": 0,
          "separatorTokensInGroups": 106,
          "skippedCodeTokens": 0,
          "unprocessedOversizedTokens": 0,
          "totalSavings": -179,
          "savingsPercentage": -4.354171734371199,
          "fileHeaderCount": 2,
          "fileHeaderAvgSize": 37,
          "shellContextCount": 0,
          "shellContextAvgSize": 0,
          "separatorCount": 6,
          "separatorAvgSize": 18
        }
      }
    },
    {
      "filePath": "repo_cache/hedera-smart-contracts/contracts/system-contracts/hedera-account-service/IHederaAccountService.sol",
      "totalOriginalTokens": 894,
      "finalTokenCount": 924,
      "impactScore": 46,
      "averageComplexity": 6,
      "averageQuality": 7.666666666666667,
      "usage": {
        "prompt_tokens": 1126,
        "completion_tokens": 128,
        "total_tokens": 1254
      },
      "retries": 0,
      "hadError": false,
      "scoredChunkGroups": [
        {
          "groupId": 1,
          "score": {
            "file_path": "contracts/system-contracts/hedera-account-service/IHederaAccountService.sol",
            "complexity_score": 6,
            "code_quality_score": 8,
            "maintainability_score": 7,
            "best_practices_adherence": 8,
            "positive_feedback": "The contract effectively defines essential account management functions critical for Hedera integration.",
            "improvement_suggestion": "Add events for significant actions like approvals to enhance transparency and tracking.",
            "group_summary": "An interface defining functions for managing Hedera account allowances and validity."
          },
          "totalTokens": 924,
          "usage": {
            "prompt_tokens": 1126,
            "completion_tokens": 128,
            "total_tokens": 1254
          }
        }
      ],
      "chunkingDetails": {
        "filePath": "repo_cache/hedera-smart-contracts/contracts/system-contracts/hedera-account-service/IHederaAccountService.sol",
        "totalFileTokens": 894,
        "chunks": [
          {
            "originalText": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.9 <0.9.0;\npragma experimental ABIEncoderV2;\n\ninterface IHederaAccountService {\n\n    /// Returns the amount of hbars that the spender has been authorized to spend on behalf of the owner.\n    /// @param owner The account that has authorized the spender\n    /// @param spender The account that has been authorized by the owner\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return amount The amount of hbar that the spender has been authorized to spend on behalf of the owner.\n    function hbarAllowance(address owner, address spender)\n    external\n    returns (int64 responseCode, int256 amount);\n\n    /// Allows spender to withdraw hbars from the owner account multiple times, up to the value amount. If this function is called\n    /// again it overwrites the current allowance with the new amount.\n    /// @param owner The owner of the hbars\n    /// @param spender the account address authorized to spend\n    /// @param amount the amount of hbars authorized to spend.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function hbarApprove(\n        address owner,\n        address spender,\n        int256 amount\n    ) external returns (int64 responseCode);\n\n    // Returns the EVM address alias for the given Hedera account.\n    /// @param accountNumAlias The Hedera account to get the EVM address alias for.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return evmAddressAlias The EVM address alias for the given Hedera account.\n    function getEvmAddressAlias(address accountNumAlias) external\n        returns (int64 responseCode, address evmAddressAlias);\n\n    /// Returns the Hedera Account ID (as account num alias) for the given EVM address alias\n    /// @param evmAddressAlias The EVM address alias to get the Hedera account for.\n    /// @return responseCode The response code for the status of the request.  SUCCESS is 22.\n    /// @return accountNumAlias The Hedera account's num for the given EVM address alias.\n    function getHederaAccountNumAlias(address evmAddressAlias) external\n        returns (int64 responseCode, address accountNumAlias);\n\n    /// Returns true iff a Hedera account num alias or EVM address alias.\n    /// @param addr Some 20-byte address.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return response true iff addr is a Hedera account num alias or an EVM address alias (and false otherwise).\n    function isValidAlias(address addr) external returns (int64 responseCode, bool response);\n\n    /// Determines if the signature is valid for the given message hash and account.\n    /// It is assumed that the signature is composed of a single EDCSA or ED25519 key.\n    /// @param account The account to check the signature against.\n    /// @param messageHash The hash of the message to check the signature against.\n    /// @param signature The signature to check.\n    /// @return responseCode The response code for the status of the request.  SUCCESS is 22.\n    /// @return authorized True if the signature is valid, false otherwise.\n    function isAuthorizedRaw(\n        address account,\n        bytes memory messageHash,\n        bytes memory signature\n    ) external returns (int64 responseCode, bool authorized);\n\n    /// Determines if the signature is valid for the given message and account.\n    /// It is assumed that the signature is composed of a possibly complex cryptographic key.\n    /// @param account The account to check the signature against.\n    /// @param message The message to check the signature against.",
            "codeOnlyTokens": 811,
            "startLine": 1,
            "endLine": 64,
            "type": ".sol_part_1",
            "isOversized": false
          },
          {
            "originalText": "    /// @param signature The signature to check encoded as bytes.\n    /// @return responseCode The response code for the status of the request.  SUCCESS is 22.\n    /// @return authorized True if the signature is valid, false otherwise.\n    function isAuthorized(\n        address account,\n        bytes memory message,\n        bytes memory signature\n    ) external returns (int64 responseCode, bool authorized);\n}\n",
            "codeOnlyTokens": 83,
            "startLine": 65,
            "endLine": 74,
            "type": ".sol_part_2",
            "isOversized": false
          }
        ],
        "groupedChunks": [
          {
            "combinedText": "// File: contracts/system-contracts/hedera-account-service/IHederaAccountService.sol\n// Relevant file context:\n// Type: .sol\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.9 <0.9.0;\npragma experimental ABIEncoderV2;\n\ninterface IHederaAccountService {\n\n    /// Returns the amount of hbars that the spender has been authorized to spend on behalf of the owner.\n    /// @param owner The account that has authorized the spender\n    /// @param spender The account that has been authorized by the owner\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return amount The amount of hbar that the spender has been authorized to spend on behalf of the owner.\n    function hbarAllowance(address owner, address spender)\n    external\n    returns (int64 responseCode, int256 amount);\n\n    /// Allows spender to withdraw hbars from the owner account multiple times, up to the value amount. If this function is called\n    /// again it overwrites the current allowance with the new amount.\n    /// @param owner The owner of the hbars\n    /// @param spender the account address authorized to spend\n    /// @param amount the amount of hbars authorized to spend.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function hbarApprove(\n        address owner,\n        address spender,\n        int256 amount\n    ) external returns (int64 responseCode);\n\n    // Returns the EVM address alias for the given Hedera account.\n    /// @param accountNumAlias The Hedera account to get the EVM address alias for.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return evmAddressAlias The EVM address alias for the given Hedera account.\n    function getEvmAddressAlias(address accountNumAlias) external\n        returns (int64 responseCode, address evmAddressAlias);\n\n    /// Returns the Hedera Account ID (as account num alias) for the given EVM address alias\n    /// @param evmAddressAlias The EVM address alias to get the Hedera account for.\n    /// @return responseCode The response code for the status of the request.  SUCCESS is 22.\n    /// @return accountNumAlias The Hedera account's num for the given EVM address alias.\n    function getHederaAccountNumAlias(address evmAddressAlias) external\n        returns (int64 responseCode, address accountNumAlias);\n\n    /// Returns true iff a Hedera account num alias or EVM address alias.\n    /// @param addr Some 20-byte address.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return response true iff addr is a Hedera account num alias or an EVM address alias (and false otherwise).\n    function isValidAlias(address addr) external returns (int64 responseCode, bool response);\n\n    /// Determines if the signature is valid for the given message hash and account.\n    /// It is assumed that the signature is composed of a single EDCSA or ED25519 key.\n    /// @param account The account to check the signature against.\n    /// @param messageHash The hash of the message to check the signature against.\n    /// @param signature The signature to check.\n    /// @return responseCode The response code for the status of the request.  SUCCESS is 22.\n    /// @return authorized True if the signature is valid, false otherwise.\n    function isAuthorizedRaw(\n        address account,\n        bytes memory messageHash,\n        bytes memory signature\n    ) external returns (int64 responseCode, bool authorized);\n\n    /// Determines if the signature is valid for the given message and account.\n    /// It is assumed that the signature is composed of a possibly complex cryptographic key.\n    /// @param account The account to check the signature against.\n    /// @param message The message to check the signature against.\n    /// @param signature The signature to check encoded as bytes.\n    /// @return responseCode The response code for the status of the request.  SUCCESS is 22.\n    /// @return authorized True if the signature is valid, false otherwise.\n    function isAuthorized(\n        address account,\n        bytes memory message,\n        bytes memory signature\n    ) external returns (int64 responseCode, bool authorized);\n}\n",
            "totalTokens": 924,
            "chunks": [
              {
                "originalText": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.9 <0.9.0;\npragma experimental ABIEncoderV2;\n\ninterface IHederaAccountService {\n\n    /// Returns the amount of hbars that the spender has been authorized to spend on behalf of the owner.\n    /// @param owner The account that has authorized the spender\n    /// @param spender The account that has been authorized by the owner\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return amount The amount of hbar that the spender has been authorized to spend on behalf of the owner.\n    function hbarAllowance(address owner, address spender)\n    external\n    returns (int64 responseCode, int256 amount);\n\n    /// Allows spender to withdraw hbars from the owner account multiple times, up to the value amount. If this function is called\n    /// again it overwrites the current allowance with the new amount.\n    /// @param owner The owner of the hbars\n    /// @param spender the account address authorized to spend\n    /// @param amount the amount of hbars authorized to spend.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function hbarApprove(\n        address owner,\n        address spender,\n        int256 amount\n    ) external returns (int64 responseCode);\n\n    // Returns the EVM address alias for the given Hedera account.\n    /// @param accountNumAlias The Hedera account to get the EVM address alias for.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return evmAddressAlias The EVM address alias for the given Hedera account.\n    function getEvmAddressAlias(address accountNumAlias) external\n        returns (int64 responseCode, address evmAddressAlias);\n\n    /// Returns the Hedera Account ID (as account num alias) for the given EVM address alias\n    /// @param evmAddressAlias The EVM address alias to get the Hedera account for.\n    /// @return responseCode The response code for the status of the request.  SUCCESS is 22.\n    /// @return accountNumAlias The Hedera account's num for the given EVM address alias.\n    function getHederaAccountNumAlias(address evmAddressAlias) external\n        returns (int64 responseCode, address accountNumAlias);\n\n    /// Returns true iff a Hedera account num alias or EVM address alias.\n    /// @param addr Some 20-byte address.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return response true iff addr is a Hedera account num alias or an EVM address alias (and false otherwise).\n    function isValidAlias(address addr) external returns (int64 responseCode, bool response);\n\n    /// Determines if the signature is valid for the given message hash and account.\n    /// It is assumed that the signature is composed of a single EDCSA or ED25519 key.\n    /// @param account The account to check the signature against.\n    /// @param messageHash The hash of the message to check the signature against.\n    /// @param signature The signature to check.\n    /// @return responseCode The response code for the status of the request.  SUCCESS is 22.\n    /// @return authorized True if the signature is valid, false otherwise.\n    function isAuthorizedRaw(\n        address account,\n        bytes memory messageHash,\n        bytes memory signature\n    ) external returns (int64 responseCode, bool authorized);\n\n    /// Determines if the signature is valid for the given message and account.\n    /// It is assumed that the signature is composed of a possibly complex cryptographic key.\n    /// @param account The account to check the signature against.\n    /// @param message The message to check the signature against.\n    /// @param signature The signature to check encoded as bytes.\n    /// @return responseCode The response code for the status of the request.  SUCCESS is 22.\n    /// @return authorized True if the signature is valid, false otherwise.\n    function isAuthorized(\n        address account,\n        bytes memory message,\n        bytes memory signature\n    ) external returns (int64 responseCode, bool authorized);\n}\n",
                "codeOnlyTokens": 894,
                "startLine": 1,
                "endLine": 74,
                "type": "full_file",
                "isOversized": false
              }
            ],
            "startLine": 1,
            "endLine": 74,
            "groupId": 1
          }
        ],
        "oversizedChunks": [],
        "sendStrategy": "full_file",
        "finalTokenCount": 924,
        "skippedContent": [],
        "contextHeader": "// File: contracts/system-contracts/hedera-account-service/IHederaAccountService.sol\n// Relevant file context:\n// Type: .sol\n",
        "tokenBreakdown": {
          "originalFile": 894,
          "finalSent": 924,
          "codeTokensInGroups": 894,
          "fileHeaderTokensInGroups": 30,
          "shellContextTokensInGroups": 0,
          "separatorTokensInGroups": 0,
          "skippedCodeTokens": 0,
          "unprocessedOversizedTokens": 0,
          "totalSavings": -30,
          "savingsPercentage": -3.3557046979865772,
          "fileHeaderCount": 1,
          "fileHeaderAvgSize": 30,
          "shellContextCount": 0,
          "shellContextAvgSize": 0,
          "separatorCount": 1,
          "separatorAvgSize": 0
        }
      }
    },
    {
      "filePath": "repo_cache/hedera-smart-contracts/system-contract-dapp-playground/src/api/hedera/hts-interactions/tokenTransfer-interactions/index.ts",
      "totalOriginalTokens": 2519,
      "finalTokenCount": 2661,
      "impactScore": 43,
      "averageComplexity": 6,
      "averageQuality": 7.5,
      "usage": {
        "prompt_tokens": 4362,
        "completion_tokens": 241,
        "total_tokens": 4603
      },
      "retries": 0,
      "hadError": false,
      "scoredChunkGroups": [
        {
          "groupId": 1,
          "score": {
            "complexity_score": 7,
            "code_quality_score": 8,
            "maintainability_score": 7,
            "best_practices_adherence": 8,
            "positive_feedback": "The code effectively leverages gas estimation for transactions, demonstrating a solid understanding of Hedera's operational nuances.",
            "improvement_suggestion": "Parameter sanitization could be refactored into a utility function to simplify the main logic and enhance code reuse.",
            "group_summary": "This code facilitates various types of token transfers on the Hedera network, including fungible and non-fungible tokens."
          },
          "totalTokens": 2512,
          "usage": {
            "prompt_tokens": 3355,
            "completion_tokens": 129,
            "total_tokens": 3484,
            "prompt_tokens_details": {
              "cached_tokens": 0,
              "audio_tokens": 0
            },
            "completion_tokens_details": {
              "reasoning_tokens": 0,
              "audio_tokens": 0,
              "accepted_prediction_tokens": 0,
              "rejected_prediction_tokens": 0
            }
          }
        },
        {
          "groupId": 2,
          "score": {
            "complexity_score": 5,
            "code_quality_score": 7,
            "maintainability_score": 6,
            "best_practices_adherence": 7,
            "positive_feedback": "The use of gas estimation ensures efficient transactions, which is crucial for optimizing costs on the Hedera network.",
            "improvement_suggestion": "Consider implementing retry logic for transaction failures to improve robustness in handling network issues.",
            "group_summary": "Facilitates NFT token transfers on Hedera with gas limit estimation."
          },
          "totalTokens": 149,
          "usage": {
            "prompt_tokens": 1007,
            "completion_tokens": 112,
            "total_tokens": 1119,
            "prompt_tokens_details": {
              "cached_tokens": 0,
              "audio_tokens": 0
            },
            "completion_tokens_details": {
              "reasoning_tokens": 0,
              "audio_tokens": 0,
              "accepted_prediction_tokens": 0,
              "rejected_prediction_tokens": 0
            }
          }
        }
      ],
      "chunkingDetails": {
        "filePath": "repo_cache/hedera-smart-contracts/system-contract-dapp-playground/src/api/hedera/hts-interactions/tokenTransfer-interactions/index.ts",
        "totalFileTokens": 2519,
        "chunks": [
          {
            "originalText": "// SPDX-License-Identifier: Apache-2.0\n\nimport { TNetworkName } from '@/types/common';\nimport { Contract, ethers, isAddress } from 'ethers';\nimport { handleEstimateGas } from '@/utils/common/helpers';\nimport { handleContractResponse } from '@/utils/contract-interactions/HTS/helpers';\nimport { ISmartContractExecutionResult } from '@/types/contract-interactions/shared';\n\n/**\n * @dev transfers Hedera Cryptos\n *\n * @dev integrates TokenTransferContract.cryptoTransferPublic()\n *\n * @param baseContract: ethers.Contract\n *\n * @param signerAddress: ethers.AddressLike\n *\n * @param network: TNetworkName\n *\n * @param transferList: IHederaTokenServiceTransferList\n *\n * @param tokenTransferList: IHederaTokenServiceTokenTransferList[]\n *\n * @param gasLimit: number\n *\n * @return Promise<ISmartContractExecutionResult>\n */\nexport const transferCrypto = async (\n  baseContract: Contract,\n  signerAddress: ethers.AddressLike,\n  network: TNetworkName,\n  transferList: IHederaTokenServiceTransferList,\n  tokenTransferList: IHederaTokenServiceTokenTransferList[],\n  gasLimit: number\n): Promise<ISmartContractExecutionResult> => {\n  // invoking contract methods\n  try {\n    if (gasLimit === 0) {\n      const estimateGasResult = await handleEstimateGas(\n        baseContract,\n        signerAddress,\n        network,\n        'cryptoTransferPublic',\n        [transferList, tokenTransferList]\n      );\n      if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n      gasLimit = estimateGasResult.gasLimit;\n    }\n    const tx = await baseContract.cryptoTransferPublic(transferList, tokenTransferList, {\n      gasLimit,\n    });\n\n    return await handleContractResponse(tx);\n  } catch (err: any) {\n    console.error(err);\n    return { err, transactionHash: err.receipt && err.receipt.hash };\n  }\n};\n\n/**\n * @dev transfers Hedera fungible tokens\n *\n * @dev integrates TokenTransferContract.transferTokensPublic()\n *\n * @param baseContract: ethers.Contract\n *\n * @param signerAddress: ethers.AddressLike\n *\n * @param network: TNetworkName\n *\n * @param hederaTokenAddress: ethers.AddressLike\n *\n * @param accountId: ethers.AddressLike[]\n *\n * @param amount: number[]\n *\n * @param gasLimit: number\n *\n * @return Promise Promise<ISmartContractExecutionResult>\n */\nexport const transferFungibleTokens = async (\n  baseContract: Contract,\n  signerAddress: ethers.AddressLike,\n  network: TNetworkName,\n  hederaTokenAddress: ethers.AddressLike,\n  accountIDs: ethers.AddressLike[],\n  amounts: number[],\n  gasLimit: number\n): Promise<ISmartContractExecutionResult> => {\n  // sanitize params\n  let sanitizeErr;\n  if (!isAddress(hederaTokenAddress)) {\n    sanitizeErr = 'Invalid token address';\n  }\n  if (!sanitizeErr) {\n    accountIDs.some((address) => {\n      if (!isAddress(address)) {\n        sanitizeErr = `${address} is an invalid accountID`;\n        return true;\n      }\n    });\n  }\n  if (!sanitizeErr) {\n    // @notice skipping the first element of the array in the loop as the initial item in the amounts array represents the totalInputAmount multiplied by -1\n    amounts.slice(1).some((amount) => {\n      if (amount < 0) {\n        sanitizeErr = `${amount} is an invalid amount`;\n        return true;\n      }\n    });\n  }\n  if (sanitizeErr) {\n    console.error(sanitizeErr);\n    return { err: sanitizeErr };\n  }\n\n  // invoking contract methods\n  try {\n    if (gasLimit === 0) {",
            "codeOnlyTokens": 803,
            "startLine": 1,
            "endLine": 119,
            "type": ".ts_part_1",
            "isOversized": false
          },
          {
            "originalText": "      const estimateGasResult = await handleEstimateGas(\n        baseContract,\n        signerAddress,\n        network,\n        'transferTokensPublic',\n        [hederaTokenAddress, accountIDs, amounts]\n      );\n      if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n      gasLimit = estimateGasResult.gasLimit;\n    }\n\n    const tx = await baseContract.transferTokensPublic(hederaTokenAddress, accountIDs, amounts, {\n      gasLimit,\n    });\n\n    return await handleContractResponse(tx);\n  } catch (err: any) {\n    console.error(err);\n    return { err, transactionHash: err.receipt && err.receipt.hash };\n  }\n};\n\n/**\n * @dev transfers Hedera non-fungible tokens\n *\n * @dev integrates TokenTransferContract.transferNFTsPublic()\n *\n * @param baseContract: ethers.Contract\n *\n * @param signerAddress: ethers.AddressLike\n *\n * @param network: TNetworkName\n *\n * @param hederaTokenAddress: ethers.AddressLike\n *\n * @param senders: ethers.AddressLike[]\n *\n * @param receivers: ethers.AddressLike[]\n *\n * @param serialNumbers: number[]\n *\n * @param gasLimit: number\n *\n * @return Promise<ISmartContractExecutionResult>\n */\nexport const transferNonFungibleTokens = async (\n  baseContract: Contract,\n  signerAddress: ethers.AddressLike,\n  network: TNetworkName,\n  hederaTokenAddress: ethers.AddressLike,\n  senders: ethers.AddressLike[],\n  receivers: ethers.AddressLike[],\n  serialNumbers: number[],\n  gasLimit: number\n): Promise<ISmartContractExecutionResult> => {\n  // sanitize params\n  let sanitizeErr;\n  if (!isAddress(hederaTokenAddress)) {\n    sanitizeErr = 'Invalid token address';\n  }\n  if (!sanitizeErr) {\n    senders.some((address) => {\n      if (!isAddress(address)) {\n        sanitizeErr = `${address} is an invalid sender accountID`;\n        return true;\n      }\n    });\n  }\n  if (!sanitizeErr) {\n    receivers.some((address) => {\n      if (!isAddress(address)) {\n        sanitizeErr = `${address} is an invalid receiver accountID`;\n        return true;\n      }\n    });\n  }\n  if (!sanitizeErr) {\n    serialNumbers.some((seriNum) => {\n      if (seriNum < 0) {\n        sanitizeErr = `${seriNum} is an invalid serial number`;\n        return true;\n      }\n    });\n  }\n  if (sanitizeErr) {\n    console.error(sanitizeErr);\n    return { err: sanitizeErr };\n  }\n\n  // invoking contract methods\n  try {\n    if (gasLimit === 0) {\n      const estimateGasResult = await handleEstimateGas(\n        baseContract,\n        signerAddress,\n        network,\n        'transferNFTsPublic',\n        [hederaTokenAddress, senders, serialNumbers]\n      );\n      if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n      gasLimit = estimateGasResult.gasLimit;\n    }\n\n    const tx = await baseContract.transferNFTsPublic(hederaTokenAddress, senders, receivers, serialNumbers, {\n      gasLimit,\n    });\n\n    return await handleContractResponse(tx);\n  } catch (err: any) {\n    console.error(err);\n    return { err, transactionHash: err.receipt && err.receipt.hash };\n  }\n};\n\n/**\n * @dev transfers single token (fungible vs non-fungible)\n *\n * @dev integrates TokenTransferContract.transferTokenPublic()\n *\n * @dev integrates TokenTransferContract.transferNFTPublic()\n *\n * @dev integrates TokenTransferContract.transferFromPublic()\n *\n * @dev integrates TokenTransferContract.transferFromNFTPublic()\n *\n * @param baseContract: ethers.Contract",
            "codeOnlyTokens": 800,
            "startLine": 120,
            "endLine": 245,
            "type": ".ts_part_2",
            "isOversized": false
          },
          {
            "originalText": " *\n * @param signerAddress: ethers.AddressLike\n *\n * @param network: TNetworkName\n *\n * @param API: \"FUNGIBLE\" | \"NFT\" | 'FUNGIBLE_FROM' | 'NFT_FROM'\n *\n * @param hederaTokenAddress: ethers.AddressLike\n *\n * @param sender: ethers.AddressLike\n *\n * @param receiver: ethers.AddressLike\n *\n * @param quantity: number (amount/serialNumber)\n *\n * @return Promise<ISmartContractExecutionResult>\n */\nexport const transferSingleToken = async (\n  baseContract: Contract,\n  signerAddress: ethers.AddressLike,\n  network: TNetworkName,\n  API: 'FUNGIBLE' | 'NFT' | 'FUNGIBLE_FROM' | 'NFT_FROM',\n  hederaTokenAddress: ethers.AddressLike,\n  sender: ethers.AddressLike,\n  receiver: ethers.AddressLike,\n  quantity: number,\n  gasLimit: number\n): Promise<ISmartContractExecutionResult> => {\n  // sanitize params\n  let sanitizeErr;\n  if (!isAddress(hederaTokenAddress)) {\n    sanitizeErr = 'Invalid token address';\n  } else if (!isAddress(sender)) {\n    sanitizeErr = 'Invalid sender address';\n  } else if (!isAddress(receiver)) {\n    sanitizeErr = 'Invalid receiver address';\n  } else if (quantity < 0) {\n    sanitizeErr = 'Invalid quantity';\n  }\n  if (sanitizeErr) {\n    console.error(sanitizeErr);\n    return { err: sanitizeErr };\n  }\n\n  // invoking contract methods\n  try {\n    let transactionResult;\n\n    switch (API) {\n      case 'FUNGIBLE':\n        if (gasLimit === 0) {\n          const estimateGasResult = await handleEstimateGas(\n            baseContract,\n            signerAddress,\n            network,\n            'transferTokenPublic',\n            [hederaTokenAddress, sender, receiver, quantity]\n          );\n          if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n          gasLimit = estimateGasResult.gasLimit;\n        }\n\n        transactionResult = await baseContract.transferTokenPublic(\n          hederaTokenAddress,\n          sender,\n          receiver,\n          quantity,\n          { gasLimit }\n        );\n        break;\n\n      case 'NFT':\n        if (gasLimit === 0) {\n          const estimateGasResult = await handleEstimateGas(\n            baseContract,\n            signerAddress,\n            network,\n            'transferNFTPublic',\n            [hederaTokenAddress, sender, receiver, quantity]\n          );\n          if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n          gasLimit = estimateGasResult.gasLimit;\n        }\n\n        transactionResult = await baseContract.transferNFTPublic(\n          hederaTokenAddress,\n          sender,\n          receiver,\n          quantity,\n          { gasLimit }\n        );\n        break;\n\n      case 'FUNGIBLE_FROM':\n        if (gasLimit === 0) {\n          const estimateGasResult = await handleEstimateGas(\n            baseContract,\n            signerAddress,\n            network,\n            'transferFromPublic',\n            [hederaTokenAddress, sender, receiver, quantity]\n          );\n          if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n          gasLimit = estimateGasResult.gasLimit;\n        }\n\n        transactionResult = await baseContract.transferFromPublic(\n          hederaTokenAddress,\n          sender,\n          receiver,\n          quantity,\n          { gasLimit }\n        );\n        break;\n\n      case 'NFT_FROM':\n        if (gasLimit === 0) {\n          const estimateGasResult = await handleEstimateGas(\n            baseContract,\n            signerAddress,\n            network,\n            'transferFromNFTPublic',\n            [hederaTokenAddress, sender, receiver, quantity]\n          );\n          if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };",
            "codeOnlyTokens": 820,
            "startLine": 246,
            "endLine": 370,
            "type": ".ts_part_3",
            "isOversized": false
          },
          {
            "originalText": "          gasLimit = estimateGasResult.gasLimit;\n        }\n\n        transactionResult = await baseContract.transferFromNFTPublic(\n          hederaTokenAddress,\n          sender,\n          receiver,\n          quantity,\n          { gasLimit }\n        );\n        break;\n    }\n\n    return await handleContractResponse(transactionResult);\n  } catch (err: any) {\n    console.error(err);\n    return { err, transactionHash: err.receipt && err.receipt.hash };\n  }\n};\n",
            "codeOnlyTokens": 95,
            "startLine": 371,
            "endLine": 390,
            "type": ".ts_part_4",
            "isOversized": false
          }
        ],
        "groupedChunks": [
          {
            "combinedText": "// File: system-contract-dapp-playground/src/api/hedera/hts-interactions/tokenTransfer-interactions/index.ts\n// Relevant file context:\n// Type: .ts\n\n\n// --- Next chunk ---\n\n// Lines 1-119 (.ts_part_1)\n// SPDX-License-Identifier: Apache-2.0\n\nimport { TNetworkName } from '@/types/common';\nimport { Contract, ethers, isAddress } from 'ethers';\nimport { handleEstimateGas } from '@/utils/common/helpers';\nimport { handleContractResponse } from '@/utils/contract-interactions/HTS/helpers';\nimport { ISmartContractExecutionResult } from '@/types/contract-interactions/shared';\n\n/**\n * @dev transfers Hedera Cryptos\n *\n * @dev integrates TokenTransferContract.cryptoTransferPublic()\n *\n * @param baseContract: ethers.Contract\n *\n * @param signerAddress: ethers.AddressLike\n *\n * @param network: TNetworkName\n *\n * @param transferList: IHederaTokenServiceTransferList\n *\n * @param tokenTransferList: IHederaTokenServiceTokenTransferList[]\n *\n * @param gasLimit: number\n *\n * @return Promise<ISmartContractExecutionResult>\n */\nexport const transferCrypto = async (\n  baseContract: Contract,\n  signerAddress: ethers.AddressLike,\n  network: TNetworkName,\n  transferList: IHederaTokenServiceTransferList,\n  tokenTransferList: IHederaTokenServiceTokenTransferList[],\n  gasLimit: number\n): Promise<ISmartContractExecutionResult> => {\n  // invoking contract methods\n  try {\n    if (gasLimit === 0) {\n      const estimateGasResult = await handleEstimateGas(\n        baseContract,\n        signerAddress,\n        network,\n        'cryptoTransferPublic',\n        [transferList, tokenTransferList]\n      );\n      if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n      gasLimit = estimateGasResult.gasLimit;\n    }\n    const tx = await baseContract.cryptoTransferPublic(transferList, tokenTransferList, {\n      gasLimit,\n    });\n\n    return await handleContractResponse(tx);\n  } catch (err: any) {\n    console.error(err);\n    return { err, transactionHash: err.receipt && err.receipt.hash };\n  }\n};\n\n/**\n * @dev transfers Hedera fungible tokens\n *\n * @dev integrates TokenTransferContract.transferTokensPublic()\n *\n * @param baseContract: ethers.Contract\n *\n * @param signerAddress: ethers.AddressLike\n *\n * @param network: TNetworkName\n *\n * @param hederaTokenAddress: ethers.AddressLike\n *\n * @param accountId: ethers.AddressLike[]\n *\n * @param amount: number[]\n *\n * @param gasLimit: number\n *\n * @return Promise Promise<ISmartContractExecutionResult>\n */\nexport const transferFungibleTokens = async (\n  baseContract: Contract,\n  signerAddress: ethers.AddressLike,\n  network: TNetworkName,\n  hederaTokenAddress: ethers.AddressLike,\n  accountIDs: ethers.AddressLike[],\n  amounts: number[],\n  gasLimit: number\n): Promise<ISmartContractExecutionResult> => {\n  // sanitize params\n  let sanitizeErr;\n  if (!isAddress(hederaTokenAddress)) {\n    sanitizeErr = 'Invalid token address';\n  }\n  if (!sanitizeErr) {\n    accountIDs.some((address) => {\n      if (!isAddress(address)) {\n        sanitizeErr = `${address} is an invalid accountID`;\n        return true;\n      }\n    });\n  }\n  if (!sanitizeErr) {\n    // @notice skipping the first element of the array in the loop as the initial item in the amounts array represents the totalInputAmount multiplied by -1\n    amounts.slice(1).some((amount) => {\n      if (amount < 0) {\n        sanitizeErr = `${amount} is an invalid amount`;\n        return true;\n      }\n    });\n  }\n  if (sanitizeErr) {\n    console.error(sanitizeErr);\n    return { err: sanitizeErr };\n  }\n\n  // invoking contract methods\n  try {\n    if (gasLimit === 0) {\n\n// --- Next chunk ---\n\n// Lines 120-245 (.ts_part_2)\n      const estimateGasResult = await handleEstimateGas(\n        baseContract,\n        signerAddress,\n        network,\n        'transferTokensPublic',\n        [hederaTokenAddress, accountIDs, amounts]\n      );\n      if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n      gasLimit = estimateGasResult.gasLimit;\n    }\n\n    const tx = await baseContract.transferTokensPublic(hederaTokenAddress, accountIDs, amounts, {\n      gasLimit,\n    });\n\n    return await handleContractResponse(tx);\n  } catch (err: any) {\n    console.error(err);\n    return { err, transactionHash: err.receipt && err.receipt.hash };\n  }\n};\n\n/**\n * @dev transfers Hedera non-fungible tokens\n *\n * @dev integrates TokenTransferContract.transferNFTsPublic()\n *\n * @param baseContract: ethers.Contract\n *\n * @param signerAddress: ethers.AddressLike\n *\n * @param network: TNetworkName\n *\n * @param hederaTokenAddress: ethers.AddressLike\n *\n * @param senders: ethers.AddressLike[]\n *\n * @param receivers: ethers.AddressLike[]\n *\n * @param serialNumbers: number[]\n *\n * @param gasLimit: number\n *\n * @return Promise<ISmartContractExecutionResult>\n */\nexport const transferNonFungibleTokens = async (\n  baseContract: Contract,\n  signerAddress: ethers.AddressLike,\n  network: TNetworkName,\n  hederaTokenAddress: ethers.AddressLike,\n  senders: ethers.AddressLike[],\n  receivers: ethers.AddressLike[],\n  serialNumbers: number[],\n  gasLimit: number\n): Promise<ISmartContractExecutionResult> => {\n  // sanitize params\n  let sanitizeErr;\n  if (!isAddress(hederaTokenAddress)) {\n    sanitizeErr = 'Invalid token address';\n  }\n  if (!sanitizeErr) {\n    senders.some((address) => {\n      if (!isAddress(address)) {\n        sanitizeErr = `${address} is an invalid sender accountID`;\n        return true;\n      }\n    });\n  }\n  if (!sanitizeErr) {\n    receivers.some((address) => {\n      if (!isAddress(address)) {\n        sanitizeErr = `${address} is an invalid receiver accountID`;\n        return true;\n      }\n    });\n  }\n  if (!sanitizeErr) {\n    serialNumbers.some((seriNum) => {\n      if (seriNum < 0) {\n        sanitizeErr = `${seriNum} is an invalid serial number`;\n        return true;\n      }\n    });\n  }\n  if (sanitizeErr) {\n    console.error(sanitizeErr);\n    return { err: sanitizeErr };\n  }\n\n  // invoking contract methods\n  try {\n    if (gasLimit === 0) {\n      const estimateGasResult = await handleEstimateGas(\n        baseContract,\n        signerAddress,\n        network,\n        'transferNFTsPublic',\n        [hederaTokenAddress, senders, serialNumbers]\n      );\n      if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n      gasLimit = estimateGasResult.gasLimit;\n    }\n\n    const tx = await baseContract.transferNFTsPublic(hederaTokenAddress, senders, receivers, serialNumbers, {\n      gasLimit,\n    });\n\n    return await handleContractResponse(tx);\n  } catch (err: any) {\n    console.error(err);\n    return { err, transactionHash: err.receipt && err.receipt.hash };\n  }\n};\n\n/**\n * @dev transfers single token (fungible vs non-fungible)\n *\n * @dev integrates TokenTransferContract.transferTokenPublic()\n *\n * @dev integrates TokenTransferContract.transferNFTPublic()\n *\n * @dev integrates TokenTransferContract.transferFromPublic()\n *\n * @dev integrates TokenTransferContract.transferFromNFTPublic()\n *\n * @param baseContract: ethers.Contract\n\n// --- Next chunk ---\n\n// Lines 246-370 (.ts_part_3)\n *\n * @param signerAddress: ethers.AddressLike\n *\n * @param network: TNetworkName\n *\n * @param API: \"FUNGIBLE\" | \"NFT\" | 'FUNGIBLE_FROM' | 'NFT_FROM'\n *\n * @param hederaTokenAddress: ethers.AddressLike\n *\n * @param sender: ethers.AddressLike\n *\n * @param receiver: ethers.AddressLike\n *\n * @param quantity: number (amount/serialNumber)\n *\n * @return Promise<ISmartContractExecutionResult>\n */\nexport const transferSingleToken = async (\n  baseContract: Contract,\n  signerAddress: ethers.AddressLike,\n  network: TNetworkName,\n  API: 'FUNGIBLE' | 'NFT' | 'FUNGIBLE_FROM' | 'NFT_FROM',\n  hederaTokenAddress: ethers.AddressLike,\n  sender: ethers.AddressLike,\n  receiver: ethers.AddressLike,\n  quantity: number,\n  gasLimit: number\n): Promise<ISmartContractExecutionResult> => {\n  // sanitize params\n  let sanitizeErr;\n  if (!isAddress(hederaTokenAddress)) {\n    sanitizeErr = 'Invalid token address';\n  } else if (!isAddress(sender)) {\n    sanitizeErr = 'Invalid sender address';\n  } else if (!isAddress(receiver)) {\n    sanitizeErr = 'Invalid receiver address';\n  } else if (quantity < 0) {\n    sanitizeErr = 'Invalid quantity';\n  }\n  if (sanitizeErr) {\n    console.error(sanitizeErr);\n    return { err: sanitizeErr };\n  }\n\n  // invoking contract methods\n  try {\n    let transactionResult;\n\n    switch (API) {\n      case 'FUNGIBLE':\n        if (gasLimit === 0) {\n          const estimateGasResult = await handleEstimateGas(\n            baseContract,\n            signerAddress,\n            network,\n            'transferTokenPublic',\n            [hederaTokenAddress, sender, receiver, quantity]\n          );\n          if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n          gasLimit = estimateGasResult.gasLimit;\n        }\n\n        transactionResult = await baseContract.transferTokenPublic(\n          hederaTokenAddress,\n          sender,\n          receiver,\n          quantity,\n          { gasLimit }\n        );\n        break;\n\n      case 'NFT':\n        if (gasLimit === 0) {\n          const estimateGasResult = await handleEstimateGas(\n            baseContract,\n            signerAddress,\n            network,\n            'transferNFTPublic',\n            [hederaTokenAddress, sender, receiver, quantity]\n          );\n          if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n          gasLimit = estimateGasResult.gasLimit;\n        }\n\n        transactionResult = await baseContract.transferNFTPublic(\n          hederaTokenAddress,\n          sender,\n          receiver,\n          quantity,\n          { gasLimit }\n        );\n        break;\n\n      case 'FUNGIBLE_FROM':\n        if (gasLimit === 0) {\n          const estimateGasResult = await handleEstimateGas(\n            baseContract,\n            signerAddress,\n            network,\n            'transferFromPublic',\n            [hederaTokenAddress, sender, receiver, quantity]\n          );\n          if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n          gasLimit = estimateGasResult.gasLimit;\n        }\n\n        transactionResult = await baseContract.transferFromPublic(\n          hederaTokenAddress,\n          sender,\n          receiver,\n          quantity,\n          { gasLimit }\n        );\n        break;\n\n      case 'NFT_FROM':\n        if (gasLimit === 0) {\n          const estimateGasResult = await handleEstimateGas(\n            baseContract,\n            signerAddress,\n            network,\n            'transferFromNFTPublic',\n            [hederaTokenAddress, sender, receiver, quantity]\n          );\n          if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };",
            "totalTokens": 2512,
            "chunks": [
              {
                "originalText": "// SPDX-License-Identifier: Apache-2.0\n\nimport { TNetworkName } from '@/types/common';\nimport { Contract, ethers, isAddress } from 'ethers';\nimport { handleEstimateGas } from '@/utils/common/helpers';\nimport { handleContractResponse } from '@/utils/contract-interactions/HTS/helpers';\nimport { ISmartContractExecutionResult } from '@/types/contract-interactions/shared';\n\n/**\n * @dev transfers Hedera Cryptos\n *\n * @dev integrates TokenTransferContract.cryptoTransferPublic()\n *\n * @param baseContract: ethers.Contract\n *\n * @param signerAddress: ethers.AddressLike\n *\n * @param network: TNetworkName\n *\n * @param transferList: IHederaTokenServiceTransferList\n *\n * @param tokenTransferList: IHederaTokenServiceTokenTransferList[]\n *\n * @param gasLimit: number\n *\n * @return Promise<ISmartContractExecutionResult>\n */\nexport const transferCrypto = async (\n  baseContract: Contract,\n  signerAddress: ethers.AddressLike,\n  network: TNetworkName,\n  transferList: IHederaTokenServiceTransferList,\n  tokenTransferList: IHederaTokenServiceTokenTransferList[],\n  gasLimit: number\n): Promise<ISmartContractExecutionResult> => {\n  // invoking contract methods\n  try {\n    if (gasLimit === 0) {\n      const estimateGasResult = await handleEstimateGas(\n        baseContract,\n        signerAddress,\n        network,\n        'cryptoTransferPublic',\n        [transferList, tokenTransferList]\n      );\n      if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n      gasLimit = estimateGasResult.gasLimit;\n    }\n    const tx = await baseContract.cryptoTransferPublic(transferList, tokenTransferList, {\n      gasLimit,\n    });\n\n    return await handleContractResponse(tx);\n  } catch (err: any) {\n    console.error(err);\n    return { err, transactionHash: err.receipt && err.receipt.hash };\n  }\n};\n\n/**\n * @dev transfers Hedera fungible tokens\n *\n * @dev integrates TokenTransferContract.transferTokensPublic()\n *\n * @param baseContract: ethers.Contract\n *\n * @param signerAddress: ethers.AddressLike\n *\n * @param network: TNetworkName\n *\n * @param hederaTokenAddress: ethers.AddressLike\n *\n * @param accountId: ethers.AddressLike[]\n *\n * @param amount: number[]\n *\n * @param gasLimit: number\n *\n * @return Promise Promise<ISmartContractExecutionResult>\n */\nexport const transferFungibleTokens = async (\n  baseContract: Contract,\n  signerAddress: ethers.AddressLike,\n  network: TNetworkName,\n  hederaTokenAddress: ethers.AddressLike,\n  accountIDs: ethers.AddressLike[],\n  amounts: number[],\n  gasLimit: number\n): Promise<ISmartContractExecutionResult> => {\n  // sanitize params\n  let sanitizeErr;\n  if (!isAddress(hederaTokenAddress)) {\n    sanitizeErr = 'Invalid token address';\n  }\n  if (!sanitizeErr) {\n    accountIDs.some((address) => {\n      if (!isAddress(address)) {\n        sanitizeErr = `${address} is an invalid accountID`;\n        return true;\n      }\n    });\n  }\n  if (!sanitizeErr) {\n    // @notice skipping the first element of the array in the loop as the initial item in the amounts array represents the totalInputAmount multiplied by -1\n    amounts.slice(1).some((amount) => {\n      if (amount < 0) {\n        sanitizeErr = `${amount} is an invalid amount`;\n        return true;\n      }\n    });\n  }\n  if (sanitizeErr) {\n    console.error(sanitizeErr);\n    return { err: sanitizeErr };\n  }\n\n  // invoking contract methods\n  try {\n    if (gasLimit === 0) {",
                "codeOnlyTokens": 803,
                "startLine": 1,
                "endLine": 119,
                "type": ".ts_part_1",
                "isOversized": false
              },
              {
                "originalText": "      const estimateGasResult = await handleEstimateGas(\n        baseContract,\n        signerAddress,\n        network,\n        'transferTokensPublic',\n        [hederaTokenAddress, accountIDs, amounts]\n      );\n      if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n      gasLimit = estimateGasResult.gasLimit;\n    }\n\n    const tx = await baseContract.transferTokensPublic(hederaTokenAddress, accountIDs, amounts, {\n      gasLimit,\n    });\n\n    return await handleContractResponse(tx);\n  } catch (err: any) {\n    console.error(err);\n    return { err, transactionHash: err.receipt && err.receipt.hash };\n  }\n};\n\n/**\n * @dev transfers Hedera non-fungible tokens\n *\n * @dev integrates TokenTransferContract.transferNFTsPublic()\n *\n * @param baseContract: ethers.Contract\n *\n * @param signerAddress: ethers.AddressLike\n *\n * @param network: TNetworkName\n *\n * @param hederaTokenAddress: ethers.AddressLike\n *\n * @param senders: ethers.AddressLike[]\n *\n * @param receivers: ethers.AddressLike[]\n *\n * @param serialNumbers: number[]\n *\n * @param gasLimit: number\n *\n * @return Promise<ISmartContractExecutionResult>\n */\nexport const transferNonFungibleTokens = async (\n  baseContract: Contract,\n  signerAddress: ethers.AddressLike,\n  network: TNetworkName,\n  hederaTokenAddress: ethers.AddressLike,\n  senders: ethers.AddressLike[],\n  receivers: ethers.AddressLike[],\n  serialNumbers: number[],\n  gasLimit: number\n): Promise<ISmartContractExecutionResult> => {\n  // sanitize params\n  let sanitizeErr;\n  if (!isAddress(hederaTokenAddress)) {\n    sanitizeErr = 'Invalid token address';\n  }\n  if (!sanitizeErr) {\n    senders.some((address) => {\n      if (!isAddress(address)) {\n        sanitizeErr = `${address} is an invalid sender accountID`;\n        return true;\n      }\n    });\n  }\n  if (!sanitizeErr) {\n    receivers.some((address) => {\n      if (!isAddress(address)) {\n        sanitizeErr = `${address} is an invalid receiver accountID`;\n        return true;\n      }\n    });\n  }\n  if (!sanitizeErr) {\n    serialNumbers.some((seriNum) => {\n      if (seriNum < 0) {\n        sanitizeErr = `${seriNum} is an invalid serial number`;\n        return true;\n      }\n    });\n  }\n  if (sanitizeErr) {\n    console.error(sanitizeErr);\n    return { err: sanitizeErr };\n  }\n\n  // invoking contract methods\n  try {\n    if (gasLimit === 0) {\n      const estimateGasResult = await handleEstimateGas(\n        baseContract,\n        signerAddress,\n        network,\n        'transferNFTsPublic',\n        [hederaTokenAddress, senders, serialNumbers]\n      );\n      if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n      gasLimit = estimateGasResult.gasLimit;\n    }\n\n    const tx = await baseContract.transferNFTsPublic(hederaTokenAddress, senders, receivers, serialNumbers, {\n      gasLimit,\n    });\n\n    return await handleContractResponse(tx);\n  } catch (err: any) {\n    console.error(err);\n    return { err, transactionHash: err.receipt && err.receipt.hash };\n  }\n};\n\n/**\n * @dev transfers single token (fungible vs non-fungible)\n *\n * @dev integrates TokenTransferContract.transferTokenPublic()\n *\n * @dev integrates TokenTransferContract.transferNFTPublic()\n *\n * @dev integrates TokenTransferContract.transferFromPublic()\n *\n * @dev integrates TokenTransferContract.transferFromNFTPublic()\n *\n * @param baseContract: ethers.Contract",
                "codeOnlyTokens": 800,
                "startLine": 120,
                "endLine": 245,
                "type": ".ts_part_2",
                "isOversized": false
              },
              {
                "originalText": " *\n * @param signerAddress: ethers.AddressLike\n *\n * @param network: TNetworkName\n *\n * @param API: \"FUNGIBLE\" | \"NFT\" | 'FUNGIBLE_FROM' | 'NFT_FROM'\n *\n * @param hederaTokenAddress: ethers.AddressLike\n *\n * @param sender: ethers.AddressLike\n *\n * @param receiver: ethers.AddressLike\n *\n * @param quantity: number (amount/serialNumber)\n *\n * @return Promise<ISmartContractExecutionResult>\n */\nexport const transferSingleToken = async (\n  baseContract: Contract,\n  signerAddress: ethers.AddressLike,\n  network: TNetworkName,\n  API: 'FUNGIBLE' | 'NFT' | 'FUNGIBLE_FROM' | 'NFT_FROM',\n  hederaTokenAddress: ethers.AddressLike,\n  sender: ethers.AddressLike,\n  receiver: ethers.AddressLike,\n  quantity: number,\n  gasLimit: number\n): Promise<ISmartContractExecutionResult> => {\n  // sanitize params\n  let sanitizeErr;\n  if (!isAddress(hederaTokenAddress)) {\n    sanitizeErr = 'Invalid token address';\n  } else if (!isAddress(sender)) {\n    sanitizeErr = 'Invalid sender address';\n  } else if (!isAddress(receiver)) {\n    sanitizeErr = 'Invalid receiver address';\n  } else if (quantity < 0) {\n    sanitizeErr = 'Invalid quantity';\n  }\n  if (sanitizeErr) {\n    console.error(sanitizeErr);\n    return { err: sanitizeErr };\n  }\n\n  // invoking contract methods\n  try {\n    let transactionResult;\n\n    switch (API) {\n      case 'FUNGIBLE':\n        if (gasLimit === 0) {\n          const estimateGasResult = await handleEstimateGas(\n            baseContract,\n            signerAddress,\n            network,\n            'transferTokenPublic',\n            [hederaTokenAddress, sender, receiver, quantity]\n          );\n          if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n          gasLimit = estimateGasResult.gasLimit;\n        }\n\n        transactionResult = await baseContract.transferTokenPublic(\n          hederaTokenAddress,\n          sender,\n          receiver,\n          quantity,\n          { gasLimit }\n        );\n        break;\n\n      case 'NFT':\n        if (gasLimit === 0) {\n          const estimateGasResult = await handleEstimateGas(\n            baseContract,\n            signerAddress,\n            network,\n            'transferNFTPublic',\n            [hederaTokenAddress, sender, receiver, quantity]\n          );\n          if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n          gasLimit = estimateGasResult.gasLimit;\n        }\n\n        transactionResult = await baseContract.transferNFTPublic(\n          hederaTokenAddress,\n          sender,\n          receiver,\n          quantity,\n          { gasLimit }\n        );\n        break;\n\n      case 'FUNGIBLE_FROM':\n        if (gasLimit === 0) {\n          const estimateGasResult = await handleEstimateGas(\n            baseContract,\n            signerAddress,\n            network,\n            'transferFromPublic',\n            [hederaTokenAddress, sender, receiver, quantity]\n          );\n          if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n          gasLimit = estimateGasResult.gasLimit;\n        }\n\n        transactionResult = await baseContract.transferFromPublic(\n          hederaTokenAddress,\n          sender,\n          receiver,\n          quantity,\n          { gasLimit }\n        );\n        break;\n\n      case 'NFT_FROM':\n        if (gasLimit === 0) {\n          const estimateGasResult = await handleEstimateGas(\n            baseContract,\n            signerAddress,\n            network,\n            'transferFromNFTPublic',\n            [hederaTokenAddress, sender, receiver, quantity]\n          );\n          if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };",
                "codeOnlyTokens": 820,
                "startLine": 246,
                "endLine": 370,
                "type": ".ts_part_3",
                "isOversized": false
              }
            ],
            "startLine": 1,
            "endLine": 370,
            "groupId": 1
          },
          {
            "combinedText": "// File: system-contract-dapp-playground/src/api/hedera/hts-interactions/tokenTransfer-interactions/index.ts\n// Relevant file context:\n// Type: .ts\n\n\n// --- Next chunk ---\n\n// Lines 371-390 (.ts_part_4)\n          gasLimit = estimateGasResult.gasLimit;\n        }\n\n        transactionResult = await baseContract.transferFromNFTPublic(\n          hederaTokenAddress,\n          sender,\n          receiver,\n          quantity,\n          { gasLimit }\n        );\n        break;\n    }\n\n    return await handleContractResponse(transactionResult);\n  } catch (err: any) {\n    console.error(err);\n    return { err, transactionHash: err.receipt && err.receipt.hash };\n  }\n};\n",
            "totalTokens": 149,
            "chunks": [
              {
                "originalText": "          gasLimit = estimateGasResult.gasLimit;\n        }\n\n        transactionResult = await baseContract.transferFromNFTPublic(\n          hederaTokenAddress,\n          sender,\n          receiver,\n          quantity,\n          { gasLimit }\n        );\n        break;\n    }\n\n    return await handleContractResponse(transactionResult);\n  } catch (err: any) {\n    console.error(err);\n    return { err, transactionHash: err.receipt && err.receipt.hash };\n  }\n};\n",
                "codeOnlyTokens": 95,
                "startLine": 371,
                "endLine": 390,
                "type": ".ts_part_4",
                "isOversized": false
              }
            ],
            "startLine": 371,
            "endLine": 390,
            "groupId": 2
          }
        ],
        "oversizedChunks": [],
        "sendStrategy": "multiple_groups",
        "finalTokenCount": 2661,
        "skippedContent": [],
        "contextHeader": "// File: system-contract-dapp-playground/src/api/hedera/hts-interactions/tokenTransfer-interactions/index.ts\n// Relevant file context:\n// Type: .ts\n",
        "tokenBreakdown": {
          "originalFile": 2519,
          "finalSent": 2661,
          "codeTokensInGroups": 2518,
          "fileHeaderTokensInGroups": 72,
          "shellContextTokensInGroups": 0,
          "separatorTokensInGroups": 71,
          "skippedCodeTokens": 0,
          "unprocessedOversizedTokens": 0,
          "totalSavings": -142,
          "savingsPercentage": -5.6371576022231045,
          "fileHeaderCount": 2,
          "fileHeaderAvgSize": 36,
          "shellContextCount": 0,
          "shellContextAvgSize": 0,
          "separatorCount": 4,
          "separatorAvgSize": 18
        }
      }
    },
    {
      "filePath": "repo_cache/hedera-smart-contracts/contracts/system-contracts/hedera-account-service/HederaAccountService.sol",
      "totalOriginalTokens": 1632,
      "finalTokenCount": 1661,
      "impactScore": 40,
      "averageComplexity": 6,
      "averageQuality": 6.666666666666667,
      "usage": {
        "prompt_tokens": 1962,
        "completion_tokens": 134,
        "total_tokens": 2096
      },
      "retries": 0,
      "hadError": false,
      "scoredChunkGroups": [
        {
          "groupId": 1,
          "score": {
            "file_path": "contracts/system-contracts/hedera-account-service/HederaAccountService.sol",
            "complexity_score": 6,
            "code_quality_score": 7,
            "maintainability_score": 6,
            "best_practices_adherence": 7,
            "positive_feedback": "Clever handling of precompile interactions demonstrates an understanding of Hedera-specific functionality.",
            "improvement_suggestion": "Consider adding events for state changes to enhance transparency and facilitate off-chain tracking.",
            "group_summary": "Defines account service functions using Hedera precompile interactions for efficient account management."
          },
          "totalTokens": 1661,
          "usage": {
            "prompt_tokens": 1962,
            "completion_tokens": 134,
            "total_tokens": 2096
          }
        }
      ],
      "chunkingDetails": {
        "filePath": "repo_cache/hedera-smart-contracts/contracts/system-contracts/hedera-account-service/HederaAccountService.sol",
        "totalFileTokens": 1632,
        "chunks": [
          {
            "originalText": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.5.0 <0.9.0;\npragma experimental ABIEncoderV2;\n\nimport \"../HederaResponseCodes.sol\";\nimport \"./IHederaAccountService.sol\";\n\nabstract contract HederaAccountService {\n    address constant HASPrecompileAddress = address(0x16a);\n\n    /// Returns the amount of hbars that the spender has been authorized to spend on behalf of the owner.\n    /// @param owner The account that has authorized the spender\n    /// @param spender The account that has been authorized by the owner\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return amount The amount of hbar that the spender has been authorized to spend on behalf of the owner.\n    function hbarAllowance(address owner, address spender) internal returns (int64 responseCode, int256 amount)\n    {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.hbarAllowance.selector,\n                owner, spender));\n        (responseCode, amount) = success ? abi.decode(result, (int32, int256)) : (HederaResponseCodes.UNKNOWN, (int256)(0));\n    }\n\n\n    /// Allows spender to withdraw hbars from the owner account multiple times, up to the value amount. If this function is called\n    /// again it overwrites the current allowance with the new amount.\n    /// @param owner The owner of the hbars\n    /// @param spender the account address authorized to spend\n    /// @param amount the amount of hbars authorized to spend.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function hbarApprove(address owner, address spender, int256 amount) internal returns (int64 responseCode)\n    {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.hbarApprove.selector,\n                owner, spender, amount));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Returns the EVM address alias for a given Hedera account.\n    /// @param accountNumAlias The Hedera account number alias to lookup. Must satisfy all of the following:\n    ///                         - Must be in long-zero format (0x000...0<account_num>)\n    ///                         - Must reference an existing Hedera account\n    ///                         - Referenced account must have an associated EVM address alias\n    /// @return responseCode The response code indicating the status of the request:\n    ///                         - SUCCESS (22) if successful\n    ///                         - INVALID_ACCOUNT_ID (15) if any validation of the accountNumAlias fails\n    ///                         - UNKNOWN (21) if the precompile call fails\n    /// @return evmAddressAlias The EVM address alias associated with the Hedera account, or address(0) if the request fails\n    function getEvmAddressAlias(address accountNumAlias) internal returns (int64 responseCode, address evmAddressAlias) \n    {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.getEvmAddressAlias.selector, accountNumAlias));\n        (responseCode, evmAddressAlias) = success ? abi.decode(result, (int32, address)) : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Returns the Hedera Account ID (as account num alias) for the given EVM address alias\n    /// @param evmAddressAlias The EVM address alias to get the Hedera account for. Must satisfy all of the following:\n    ///                         - Must be in EVM format (not a long-zero address)",
            "codeOnlyTokens": 805,
            "startLine": 1,
            "endLine": 58,
            "type": ".sol_part_1",
            "isOversized": false
          },
          {
            "originalText": "    ///                         - Must reference an existing Hedera account\n    ///                         - Referenced account must have an associated account num alias (long-zero format)\n    /// @return responseCode The response code indicating the status of the request:\n    ///                         - SUCCESS (22) if successful\n    ///                         - INVALID_SOLIDITY_ADDRESS (29) if any validation of the evmAddressAlias fails\n    ///                         - UNKNOWN (21) if the precompile call fails\n    /// @return accountNumAlias The Hedera account's num alias in long-zero format, or address(0) if the request fails\n    function getHederaAccountNumAlias(address evmAddressAlias) internal returns (int64 responseCode, address accountNumAlias) {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.getHederaAccountNumAlias.selector, evmAddressAlias));\n        (responseCode, accountNumAlias) = success ? abi.decode(result, (int32, address)) : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Returns true iff a Hedera account num alias or EVM address alias.\n    /// @param addr Some 20-byte address.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return response true iff addr is a Hedera account num alias or an EVM address alias (and false otherwise).\n    function isValidAlias(address addr) internal returns (int64 responseCode, bool response) {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.isValidAlias.selector, addr));\n        (responseCode, response) = success ? (HederaResponseCodes.SUCCESS, abi.decode(result, (bool))) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Determines if the signature is valid for the given message hash and account.\n    /// It is assumed that the signature is composed of a single EDCSA or ED25519 key.\n    /// @param account The account to check the signature against\n    /// @param messageHash The hash of the message to check the signature against\n    /// @param signature The signature to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return authorized True if the signature is valid, false otherwise\n    function isAuthorizedRaw(address account, bytes memory messageHash, bytes memory signature) internal returns (int64 responseCode, bool authorized) {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.isAuthorizedRaw.selector,\n                account, messageHash, signature));\n        (responseCode, authorized) = success ? (HederaResponseCodes.SUCCESS, abi.decode(result, (bool))) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Determines if the signature is valid for the given message and account.\n    /// It is assumed that the signature is composed of a possibly complex cryptographic key.\n    /// @param account The account to check the signature against.\n    /// @param message The message to check the signature against.\n    /// @param signature The signature to check encoded as bytes.\n    /// @return responseCode The response code for the status of the request.  SUCCESS is 22.\n    /// @return authorized True if the signature is valid, false otherwise.\n    function isAuthorized(address account, bytes memory message, bytes memory signature) internal returns (int64 responseCode, bool authorized) {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.isAuthorized.selector,\n                account, message, signature));\n        (responseCode, authorized) = success ? abi.decode(result, (int32, bool)) : (HederaResponseCodes.UNKNOWN, false);",
            "codeOnlyTokens": 824,
            "startLine": 59,
            "endLine": 107,
            "type": ".sol_part_2",
            "isOversized": false
          },
          {
            "originalText": "    }\n}\n",
            "codeOnlyTokens": 3,
            "startLine": 108,
            "endLine": 110,
            "type": ".sol_part_3",
            "isOversized": false
          }
        ],
        "groupedChunks": [
          {
            "combinedText": "// File: contracts/system-contracts/hedera-account-service/HederaAccountService.sol\n// Relevant file context:\n// Type: .sol\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.5.0 <0.9.0;\npragma experimental ABIEncoderV2;\n\nimport \"../HederaResponseCodes.sol\";\nimport \"./IHederaAccountService.sol\";\n\nabstract contract HederaAccountService {\n    address constant HASPrecompileAddress = address(0x16a);\n\n    /// Returns the amount of hbars that the spender has been authorized to spend on behalf of the owner.\n    /// @param owner The account that has authorized the spender\n    /// @param spender The account that has been authorized by the owner\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return amount The amount of hbar that the spender has been authorized to spend on behalf of the owner.\n    function hbarAllowance(address owner, address spender) internal returns (int64 responseCode, int256 amount)\n    {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.hbarAllowance.selector,\n                owner, spender));\n        (responseCode, amount) = success ? abi.decode(result, (int32, int256)) : (HederaResponseCodes.UNKNOWN, (int256)(0));\n    }\n\n\n    /// Allows spender to withdraw hbars from the owner account multiple times, up to the value amount. If this function is called\n    /// again it overwrites the current allowance with the new amount.\n    /// @param owner The owner of the hbars\n    /// @param spender the account address authorized to spend\n    /// @param amount the amount of hbars authorized to spend.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function hbarApprove(address owner, address spender, int256 amount) internal returns (int64 responseCode)\n    {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.hbarApprove.selector,\n                owner, spender, amount));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Returns the EVM address alias for a given Hedera account.\n    /// @param accountNumAlias The Hedera account number alias to lookup. Must satisfy all of the following:\n    ///                         - Must be in long-zero format (0x000...0<account_num>)\n    ///                         - Must reference an existing Hedera account\n    ///                         - Referenced account must have an associated EVM address alias\n    /// @return responseCode The response code indicating the status of the request:\n    ///                         - SUCCESS (22) if successful\n    ///                         - INVALID_ACCOUNT_ID (15) if any validation of the accountNumAlias fails\n    ///                         - UNKNOWN (21) if the precompile call fails\n    /// @return evmAddressAlias The EVM address alias associated with the Hedera account, or address(0) if the request fails\n    function getEvmAddressAlias(address accountNumAlias) internal returns (int64 responseCode, address evmAddressAlias) \n    {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.getEvmAddressAlias.selector, accountNumAlias));\n        (responseCode, evmAddressAlias) = success ? abi.decode(result, (int32, address)) : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Returns the Hedera Account ID (as account num alias) for the given EVM address alias\n    /// @param evmAddressAlias The EVM address alias to get the Hedera account for. Must satisfy all of the following:\n    ///                         - Must be in EVM format (not a long-zero address)\n    ///                         - Must reference an existing Hedera account\n    ///                         - Referenced account must have an associated account num alias (long-zero format)\n    /// @return responseCode The response code indicating the status of the request:\n    ///                         - SUCCESS (22) if successful\n    ///                         - INVALID_SOLIDITY_ADDRESS (29) if any validation of the evmAddressAlias fails\n    ///                         - UNKNOWN (21) if the precompile call fails\n    /// @return accountNumAlias The Hedera account's num alias in long-zero format, or address(0) if the request fails\n    function getHederaAccountNumAlias(address evmAddressAlias) internal returns (int64 responseCode, address accountNumAlias) {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.getHederaAccountNumAlias.selector, evmAddressAlias));\n        (responseCode, accountNumAlias) = success ? abi.decode(result, (int32, address)) : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Returns true iff a Hedera account num alias or EVM address alias.\n    /// @param addr Some 20-byte address.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return response true iff addr is a Hedera account num alias or an EVM address alias (and false otherwise).\n    function isValidAlias(address addr) internal returns (int64 responseCode, bool response) {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.isValidAlias.selector, addr));\n        (responseCode, response) = success ? (HederaResponseCodes.SUCCESS, abi.decode(result, (bool))) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Determines if the signature is valid for the given message hash and account.\n    /// It is assumed that the signature is composed of a single EDCSA or ED25519 key.\n    /// @param account The account to check the signature against\n    /// @param messageHash The hash of the message to check the signature against\n    /// @param signature The signature to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return authorized True if the signature is valid, false otherwise\n    function isAuthorizedRaw(address account, bytes memory messageHash, bytes memory signature) internal returns (int64 responseCode, bool authorized) {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.isAuthorizedRaw.selector,\n                account, messageHash, signature));\n        (responseCode, authorized) = success ? (HederaResponseCodes.SUCCESS, abi.decode(result, (bool))) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Determines if the signature is valid for the given message and account.\n    /// It is assumed that the signature is composed of a possibly complex cryptographic key.\n    /// @param account The account to check the signature against.\n    /// @param message The message to check the signature against.\n    /// @param signature The signature to check encoded as bytes.\n    /// @return responseCode The response code for the status of the request.  SUCCESS is 22.\n    /// @return authorized True if the signature is valid, false otherwise.\n    function isAuthorized(address account, bytes memory message, bytes memory signature) internal returns (int64 responseCode, bool authorized) {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.isAuthorized.selector,\n                account, message, signature));\n        (responseCode, authorized) = success ? abi.decode(result, (int32, bool)) : (HederaResponseCodes.UNKNOWN, false);\n    }\n}\n",
            "totalTokens": 1661,
            "chunks": [
              {
                "originalText": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.5.0 <0.9.0;\npragma experimental ABIEncoderV2;\n\nimport \"../HederaResponseCodes.sol\";\nimport \"./IHederaAccountService.sol\";\n\nabstract contract HederaAccountService {\n    address constant HASPrecompileAddress = address(0x16a);\n\n    /// Returns the amount of hbars that the spender has been authorized to spend on behalf of the owner.\n    /// @param owner The account that has authorized the spender\n    /// @param spender The account that has been authorized by the owner\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return amount The amount of hbar that the spender has been authorized to spend on behalf of the owner.\n    function hbarAllowance(address owner, address spender) internal returns (int64 responseCode, int256 amount)\n    {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.hbarAllowance.selector,\n                owner, spender));\n        (responseCode, amount) = success ? abi.decode(result, (int32, int256)) : (HederaResponseCodes.UNKNOWN, (int256)(0));\n    }\n\n\n    /// Allows spender to withdraw hbars from the owner account multiple times, up to the value amount. If this function is called\n    /// again it overwrites the current allowance with the new amount.\n    /// @param owner The owner of the hbars\n    /// @param spender the account address authorized to spend\n    /// @param amount the amount of hbars authorized to spend.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function hbarApprove(address owner, address spender, int256 amount) internal returns (int64 responseCode)\n    {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.hbarApprove.selector,\n                owner, spender, amount));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Returns the EVM address alias for a given Hedera account.\n    /// @param accountNumAlias The Hedera account number alias to lookup. Must satisfy all of the following:\n    ///                         - Must be in long-zero format (0x000...0<account_num>)\n    ///                         - Must reference an existing Hedera account\n    ///                         - Referenced account must have an associated EVM address alias\n    /// @return responseCode The response code indicating the status of the request:\n    ///                         - SUCCESS (22) if successful\n    ///                         - INVALID_ACCOUNT_ID (15) if any validation of the accountNumAlias fails\n    ///                         - UNKNOWN (21) if the precompile call fails\n    /// @return evmAddressAlias The EVM address alias associated with the Hedera account, or address(0) if the request fails\n    function getEvmAddressAlias(address accountNumAlias) internal returns (int64 responseCode, address evmAddressAlias) \n    {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.getEvmAddressAlias.selector, accountNumAlias));\n        (responseCode, evmAddressAlias) = success ? abi.decode(result, (int32, address)) : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Returns the Hedera Account ID (as account num alias) for the given EVM address alias\n    /// @param evmAddressAlias The EVM address alias to get the Hedera account for. Must satisfy all of the following:\n    ///                         - Must be in EVM format (not a long-zero address)\n    ///                         - Must reference an existing Hedera account\n    ///                         - Referenced account must have an associated account num alias (long-zero format)\n    /// @return responseCode The response code indicating the status of the request:\n    ///                         - SUCCESS (22) if successful\n    ///                         - INVALID_SOLIDITY_ADDRESS (29) if any validation of the evmAddressAlias fails\n    ///                         - UNKNOWN (21) if the precompile call fails\n    /// @return accountNumAlias The Hedera account's num alias in long-zero format, or address(0) if the request fails\n    function getHederaAccountNumAlias(address evmAddressAlias) internal returns (int64 responseCode, address accountNumAlias) {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.getHederaAccountNumAlias.selector, evmAddressAlias));\n        (responseCode, accountNumAlias) = success ? abi.decode(result, (int32, address)) : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Returns true iff a Hedera account num alias or EVM address alias.\n    /// @param addr Some 20-byte address.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return response true iff addr is a Hedera account num alias or an EVM address alias (and false otherwise).\n    function isValidAlias(address addr) internal returns (int64 responseCode, bool response) {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.isValidAlias.selector, addr));\n        (responseCode, response) = success ? (HederaResponseCodes.SUCCESS, abi.decode(result, (bool))) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Determines if the signature is valid for the given message hash and account.\n    /// It is assumed that the signature is composed of a single EDCSA or ED25519 key.\n    /// @param account The account to check the signature against\n    /// @param messageHash The hash of the message to check the signature against\n    /// @param signature The signature to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return authorized True if the signature is valid, false otherwise\n    function isAuthorizedRaw(address account, bytes memory messageHash, bytes memory signature) internal returns (int64 responseCode, bool authorized) {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.isAuthorizedRaw.selector,\n                account, messageHash, signature));\n        (responseCode, authorized) = success ? (HederaResponseCodes.SUCCESS, abi.decode(result, (bool))) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Determines if the signature is valid for the given message and account.\n    /// It is assumed that the signature is composed of a possibly complex cryptographic key.\n    /// @param account The account to check the signature against.\n    /// @param message The message to check the signature against.\n    /// @param signature The signature to check encoded as bytes.\n    /// @return responseCode The response code for the status of the request.  SUCCESS is 22.\n    /// @return authorized True if the signature is valid, false otherwise.\n    function isAuthorized(address account, bytes memory message, bytes memory signature) internal returns (int64 responseCode, bool authorized) {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.isAuthorized.selector,\n                account, message, signature));\n        (responseCode, authorized) = success ? abi.decode(result, (int32, bool)) : (HederaResponseCodes.UNKNOWN, false);\n    }\n}\n",
                "codeOnlyTokens": 1632,
                "startLine": 1,
                "endLine": 110,
                "type": "full_file",
                "isOversized": false
              }
            ],
            "startLine": 1,
            "endLine": 110,
            "groupId": 1
          }
        ],
        "oversizedChunks": [],
        "sendStrategy": "full_file",
        "finalTokenCount": 1661,
        "skippedContent": [],
        "contextHeader": "// File: contracts/system-contracts/hedera-account-service/HederaAccountService.sol\n// Relevant file context:\n// Type: .sol\n",
        "tokenBreakdown": {
          "originalFile": 1632,
          "finalSent": 1661,
          "codeTokensInGroups": 1632,
          "fileHeaderTokensInGroups": 29,
          "shellContextTokensInGroups": 0,
          "separatorTokensInGroups": 0,
          "skippedCodeTokens": 0,
          "unprocessedOversizedTokens": 0,
          "totalSavings": -29,
          "savingsPercentage": -1.7769607843137254,
          "fileHeaderCount": 1,
          "fileHeaderAvgSize": 29,
          "shellContextCount": 0,
          "shellContextAvgSize": 0,
          "separatorCount": 1,
          "separatorAvgSize": 0
        }
      }
    },
    {
      "filePath": "repo_cache/hedera-smart-contracts/system-contract-dapp-playground/src/components/activity/ActivityTransactionTable/index.tsx",
      "totalOriginalTokens": 1582,
      "finalTokenCount": 1612,
      "impactScore": 38.333333333333336,
      "averageComplexity": 5,
      "averageQuality": 7.666666666666667,
      "usage": {
        "prompt_tokens": 1904,
        "completion_tokens": 134,
        "total_tokens": 2038
      },
      "retries": 0,
      "hadError": false,
      "scoredChunkGroups": [
        {
          "groupId": 1,
          "score": {
            "file_path": "system-contract-dapp-playground/src/components/activity/ActivityTransactionTable/index.tsx",
            "complexity_score": 5,
            "code_quality_score": 8,
            "maintainability_score": 7,
            "best_practices_adherence": 8,
            "positive_feedback": "The component effectively utilizes React hooks and state management for dynamic transaction display.",
            "improvement_suggestion": "Consider memoizing complex calculations or rendering to improve performance with large transaction lists.",
            "group_summary": "Displays a paginated table of Hedera transactions with interactive selection and detailed visual feedback."
          },
          "totalTokens": 1612,
          "usage": {
            "prompt_tokens": 1904,
            "completion_tokens": 134,
            "total_tokens": 2038
          }
        }
      ],
      "chunkingDetails": {
        "filePath": "repo_cache/hedera-smart-contracts/system-contract-dapp-playground/src/components/activity/ActivityTransactionTable/index.tsx",
        "totalFileTokens": 1582,
        "chunks": [
          {
            "originalText": "// SPDX-License-Identifier: Apache-2.0\n\nimport Link from 'next/link';\nimport { FiExternalLink } from 'react-icons/fi';\nimport { Dispatch, SetStateAction } from 'react';\nimport { copyContentToClipboard } from '../../common/methods/common';\nimport { ITransactionResult } from '@/types/contract-interactions/shared';\nimport PageinationButtons from '@/components/common/components/PageinationButtons';\nimport {\n  HEDERA_BRANDING_COLORS,\n  HEDERA_CHAKRA_TABLE_VARIANTS,\n  HEDERA_CHAKRA_INPUT_BOX_SIZES,\n} from '@/utils/common/constants';\nimport {\n  Tr,\n  Th,\n  Td,\n  Tbody,\n  Thead,\n  Table,\n  Popover,\n  Checkbox,\n  Tooltip,\n  PopoverContent,\n  PopoverTrigger,\n  TableContainer,\n} from '@chakra-ui/react';\n\ninterface PageProps {\n  onOpen: () => void;\n  allChecked: boolean;\n  isIndeterminate: boolean;\n  parsedHederaNetwork: any;\n  TRANSACTION_PAGE_SIZE: number;\n  currentTransactionPage: number;\n  transactionList: ITransactionResult[];\n  paginatedTransactionResults: ITransactionResult[];\n  setCurrentTransactionPage: Dispatch<SetStateAction<number>>;\n  setTransactionList: Dispatch<SetStateAction<ITransactionResult[]>>;\n  setSelectedTransactionList: Dispatch<SetStateAction<ITransactionResult[]>>;\n  setQueryReponseObj: Dispatch<\n    SetStateAction<{\n      isOpen: boolean;\n      selectedTransaction: ITransactionResult;\n    }>\n  >;\n}\n\nconst ActivityTransactionTable = ({\n  onOpen,\n  allChecked,\n  transactionList,\n  isIndeterminate,\n  setTransactionList,\n  setQueryReponseObj,\n  parsedHederaNetwork,\n  TRANSACTION_PAGE_SIZE,\n  currentTransactionPage,\n  setCurrentTransactionPage,\n  setSelectedTransactionList,\n  paginatedTransactionResults,\n}: PageProps) => {\n  return (\n    <>\n      <TableContainer className=\"flex flex-col gap-3 overflow-x-hidden\">\n        <Table variant={HEDERA_CHAKRA_TABLE_VARIANTS.unstyled} size={HEDERA_CHAKRA_INPUT_BOX_SIZES.small}>\n          <Thead>\n            <Tr className=\"border-b\">\n              <Th color={HEDERA_BRANDING_COLORS.violet} isNumeric className=\"flex justify-start\">\n                Index\n              </Th>\n              <Th color={HEDERA_BRANDING_COLORS.violet}>Request Type</Th>\n              <Th color={HEDERA_BRANDING_COLORS.violet}>Transaction Type</Th>\n              <Th color={HEDERA_BRANDING_COLORS.violet}>Status</Th>\n              <Th color={HEDERA_BRANDING_COLORS.violet}>Transaction hash</Th>\n              <Th>\n                <Checkbox\n                  size={HEDERA_CHAKRA_INPUT_BOX_SIZES.medium}\n                  colorScheme=\"teal\"\n                  isChecked={allChecked}\n                  isIndeterminate={isIndeterminate}\n                  onChange={(e) => {\n                    setTransactionList((prev) =>\n                      prev.map((record) => ({ ...record, selected: e.target.checked }))\n                    );\n                    if (e.target.checked) {\n                      setSelectedTransactionList(\n                        transactionList.map((record) => ({ ...record, selected: e.target.checked }))\n                      );\n                    } else {\n                      setSelectedTransactionList([]);\n                    }\n                  }}\n                />\n              </Th>\n            </Tr>\n          </Thead>\n\n          <Tbody className=\"font-light\">\n            {paginatedTransactionResults.map((transaction) => {\n              return (\n                <Tr\n                  key={transaction.txHash}\n                  onClick={() => {\n                    if (transaction.readonly) {\n                      onOpen();\n                      setQueryReponseObj((prev) => ({\n                        ...prev,\n                        isOpen: true,",
            "codeOnlyTokens": 804,
            "startLine": 1,
            "endLine": 109,
            "type": ".tsx_part_1",
            "isOversized": false
          },
          {
            "originalText": "                        selectedTransaction: transaction,\n                      }));\n                    }\n                  }}\n                  title={transaction.readonly ? 'Click to show query response' : ''}\n                  className={` border-b border-white/30 ${\n                    transaction.status === 'success' ? 'hover:bg-hedera-green/10' : 'hover:bg-red-400/10'\n                  } ${transaction.readonly && 'cursor-pointer'}`}\n                >\n                  {/* index */}\n                  <Td>\n                    <p>{transaction.recordIndex}</p>\n                  </Td>\n\n                  {/* request type */}\n                  <Td>{transaction.readonly ? `QUERY` : `TRANSACTION`}</Td>\n\n                  {/* Transaction type */}\n                  <Td>{transaction.transactionType}</Td>\n\n                  {/* status */}\n                  <Td>\n                    <p className={transaction.status === 'success' ? `text-hedera-green` : `text-red-400`}>\n                      {transaction.status.toUpperCase()}\n                    </p>\n                  </Td>\n\n                  {/* txHash */}\n                  <Td className=\"cursor-pointer\">\n                    <div className=\"flex gap-1 items-center justify-between\">\n                      {transaction.readonly ? (\n                        <>N/A</>\n                      ) : (\n                        <>\n                          <div onClick={() => copyContentToClipboard(transaction.txHash)}>\n                            <Popover>\n                              <PopoverTrigger>\n                                <div className=\"flex gap-1 items-center\">\n                                  <Tooltip label=\"click to copy transaction hash\">\n                                    <p>{`${transaction.txHash.slice(0, 15)}...${transaction.txHash.slice(\n                                      -15\n                                    )}`}</p>\n                                  </Tooltip>\n                                </div>\n                              </PopoverTrigger>\n                              <PopoverContent width={'fit-content'} border={'none'}>\n                                <div className=\"bg-secondary px-3 py-2 border-none font-medium\">Copied</div>\n                              </PopoverContent>\n                            </Popover>\n                          </div>\n                          <Tooltip\n                            label={'Explore this transaction on HashScan'}\n                            placement=\"top\"\n                            fontWeight={'medium'}\n                          >\n                            <Link\n                              href={`https://hashscan.io/${parsedHederaNetwork}/transaction/${transaction.txHash}`}\n                              target=\"_blank\"\n                            >\n                              <FiExternalLink />\n                            </Link>\n                          </Tooltip>\n                        </>\n                      )}\n                    </div>\n                  </Td>\n\n                  <Td onClick={(e) => e.stopPropagation()}>\n                    <Checkbox\n                      size={HEDERA_CHAKRA_INPUT_BOX_SIZES.medium}\n                      colorScheme=\"teal\"\n                      isChecked={transaction.selected}\n                      onChange={(e) => {\n                        // include this record to the global selectedTransactionList state\n                        const checkedValue = e.target.checked;\n                        if (checkedValue) {\n                          setSelectedTransactionList((prev) => [...prev, transaction]);\n                          setTransactionList((prev) =>\n                            prev.map((record) => {\n                              if (record.txHash === transaction.txHash) {\n                                record.selected = checkedValue;\n                              }\n                              return record;\n                            })\n                          );\n                        } else {\n                          setSelectedTransactionList((prev) =>\n                            prev.filter((prev) => prev.txHash !== transaction.txHash)\n                          );\n                          setTransactionList((prev) =>\n                            prev.map((record) => {\n                              if (record.txHash === transaction.txHash) {\n                                record.selected = checkedValue;\n                              }\n                              return record;\n                            })\n                          );\n                        }\n                      }}\n                    />\n                  </Td>\n                </Tr>\n              );\n            })}\n          </Tbody>\n        </Table>\n      </TableContainer>\n\n      {/* pagination buttons */}\n      <PageinationButtons\n        transactionList={transactionList}\n        TRANSACTION_PAGE_SIZE={TRANSACTION_PAGE_SIZE}\n        currentTransactionPage={currentTransactionPage}\n        setCurrentTransactionPage={setCurrentTransactionPage}\n      />\n    </>\n  );\n};\n\nexport default ActivityTransactionTable;\n",
            "codeOnlyTokens": 778,
            "startLine": 110,
            "endLine": 230,
            "type": ".tsx_part_2",
            "isOversized": false
          }
        ],
        "groupedChunks": [
          {
            "combinedText": "// File: system-contract-dapp-playground/src/components/activity/ActivityTransactionTable/index.tsx\n// Relevant file context:\n// Type: .tsx\n// SPDX-License-Identifier: Apache-2.0\n\nimport Link from 'next/link';\nimport { FiExternalLink } from 'react-icons/fi';\nimport { Dispatch, SetStateAction } from 'react';\nimport { copyContentToClipboard } from '../../common/methods/common';\nimport { ITransactionResult } from '@/types/contract-interactions/shared';\nimport PageinationButtons from '@/components/common/components/PageinationButtons';\nimport {\n  HEDERA_BRANDING_COLORS,\n  HEDERA_CHAKRA_TABLE_VARIANTS,\n  HEDERA_CHAKRA_INPUT_BOX_SIZES,\n} from '@/utils/common/constants';\nimport {\n  Tr,\n  Th,\n  Td,\n  Tbody,\n  Thead,\n  Table,\n  Popover,\n  Checkbox,\n  Tooltip,\n  PopoverContent,\n  PopoverTrigger,\n  TableContainer,\n} from '@chakra-ui/react';\n\ninterface PageProps {\n  onOpen: () => void;\n  allChecked: boolean;\n  isIndeterminate: boolean;\n  parsedHederaNetwork: any;\n  TRANSACTION_PAGE_SIZE: number;\n  currentTransactionPage: number;\n  transactionList: ITransactionResult[];\n  paginatedTransactionResults: ITransactionResult[];\n  setCurrentTransactionPage: Dispatch<SetStateAction<number>>;\n  setTransactionList: Dispatch<SetStateAction<ITransactionResult[]>>;\n  setSelectedTransactionList: Dispatch<SetStateAction<ITransactionResult[]>>;\n  setQueryReponseObj: Dispatch<\n    SetStateAction<{\n      isOpen: boolean;\n      selectedTransaction: ITransactionResult;\n    }>\n  >;\n}\n\nconst ActivityTransactionTable = ({\n  onOpen,\n  allChecked,\n  transactionList,\n  isIndeterminate,\n  setTransactionList,\n  setQueryReponseObj,\n  parsedHederaNetwork,\n  TRANSACTION_PAGE_SIZE,\n  currentTransactionPage,\n  setCurrentTransactionPage,\n  setSelectedTransactionList,\n  paginatedTransactionResults,\n}: PageProps) => {\n  return (\n    <>\n      <TableContainer className=\"flex flex-col gap-3 overflow-x-hidden\">\n        <Table variant={HEDERA_CHAKRA_TABLE_VARIANTS.unstyled} size={HEDERA_CHAKRA_INPUT_BOX_SIZES.small}>\n          <Thead>\n            <Tr className=\"border-b\">\n              <Th color={HEDERA_BRANDING_COLORS.violet} isNumeric className=\"flex justify-start\">\n                Index\n              </Th>\n              <Th color={HEDERA_BRANDING_COLORS.violet}>Request Type</Th>\n              <Th color={HEDERA_BRANDING_COLORS.violet}>Transaction Type</Th>\n              <Th color={HEDERA_BRANDING_COLORS.violet}>Status</Th>\n              <Th color={HEDERA_BRANDING_COLORS.violet}>Transaction hash</Th>\n              <Th>\n                <Checkbox\n                  size={HEDERA_CHAKRA_INPUT_BOX_SIZES.medium}\n                  colorScheme=\"teal\"\n                  isChecked={allChecked}\n                  isIndeterminate={isIndeterminate}\n                  onChange={(e) => {\n                    setTransactionList((prev) =>\n                      prev.map((record) => ({ ...record, selected: e.target.checked }))\n                    );\n                    if (e.target.checked) {\n                      setSelectedTransactionList(\n                        transactionList.map((record) => ({ ...record, selected: e.target.checked }))\n                      );\n                    } else {\n                      setSelectedTransactionList([]);\n                    }\n                  }}\n                />\n              </Th>\n            </Tr>\n          </Thead>\n\n          <Tbody className=\"font-light\">\n            {paginatedTransactionResults.map((transaction) => {\n              return (\n                <Tr\n                  key={transaction.txHash}\n                  onClick={() => {\n                    if (transaction.readonly) {\n                      onOpen();\n                      setQueryReponseObj((prev) => ({\n                        ...prev,\n                        isOpen: true,\n                        selectedTransaction: transaction,\n                      }));\n                    }\n                  }}\n                  title={transaction.readonly ? 'Click to show query response' : ''}\n                  className={` border-b border-white/30 ${\n                    transaction.status === 'success' ? 'hover:bg-hedera-green/10' : 'hover:bg-red-400/10'\n                  } ${transaction.readonly && 'cursor-pointer'}`}\n                >\n                  {/* index */}\n                  <Td>\n                    <p>{transaction.recordIndex}</p>\n                  </Td>\n\n                  {/* request type */}\n                  <Td>{transaction.readonly ? `QUERY` : `TRANSACTION`}</Td>\n\n                  {/* Transaction type */}\n                  <Td>{transaction.transactionType}</Td>\n\n                  {/* status */}\n                  <Td>\n                    <p className={transaction.status === 'success' ? `text-hedera-green` : `text-red-400`}>\n                      {transaction.status.toUpperCase()}\n                    </p>\n                  </Td>\n\n                  {/* txHash */}\n                  <Td className=\"cursor-pointer\">\n                    <div className=\"flex gap-1 items-center justify-between\">\n                      {transaction.readonly ? (\n                        <>N/A</>\n                      ) : (\n                        <>\n                          <div onClick={() => copyContentToClipboard(transaction.txHash)}>\n                            <Popover>\n                              <PopoverTrigger>\n                                <div className=\"flex gap-1 items-center\">\n                                  <Tooltip label=\"click to copy transaction hash\">\n                                    <p>{`${transaction.txHash.slice(0, 15)}...${transaction.txHash.slice(\n                                      -15\n                                    )}`}</p>\n                                  </Tooltip>\n                                </div>\n                              </PopoverTrigger>\n                              <PopoverContent width={'fit-content'} border={'none'}>\n                                <div className=\"bg-secondary px-3 py-2 border-none font-medium\">Copied</div>\n                              </PopoverContent>\n                            </Popover>\n                          </div>\n                          <Tooltip\n                            label={'Explore this transaction on HashScan'}\n                            placement=\"top\"\n                            fontWeight={'medium'}\n                          >\n                            <Link\n                              href={`https://hashscan.io/${parsedHederaNetwork}/transaction/${transaction.txHash}`}\n                              target=\"_blank\"\n                            >\n                              <FiExternalLink />\n                            </Link>\n                          </Tooltip>\n                        </>\n                      )}\n                    </div>\n                  </Td>\n\n                  <Td onClick={(e) => e.stopPropagation()}>\n                    <Checkbox\n                      size={HEDERA_CHAKRA_INPUT_BOX_SIZES.medium}\n                      colorScheme=\"teal\"\n                      isChecked={transaction.selected}\n                      onChange={(e) => {\n                        // include this record to the global selectedTransactionList state\n                        const checkedValue = e.target.checked;\n                        if (checkedValue) {\n                          setSelectedTransactionList((prev) => [...prev, transaction]);\n                          setTransactionList((prev) =>\n                            prev.map((record) => {\n                              if (record.txHash === transaction.txHash) {\n                                record.selected = checkedValue;\n                              }\n                              return record;\n                            })\n                          );\n                        } else {\n                          setSelectedTransactionList((prev) =>\n                            prev.filter((prev) => prev.txHash !== transaction.txHash)\n                          );\n                          setTransactionList((prev) =>\n                            prev.map((record) => {\n                              if (record.txHash === transaction.txHash) {\n                                record.selected = checkedValue;\n                              }\n                              return record;\n                            })\n                          );\n                        }\n                      }}\n                    />\n                  </Td>\n                </Tr>\n              );\n            })}\n          </Tbody>\n        </Table>\n      </TableContainer>\n\n      {/* pagination buttons */}\n      <PageinationButtons\n        transactionList={transactionList}\n        TRANSACTION_PAGE_SIZE={TRANSACTION_PAGE_SIZE}\n        currentTransactionPage={currentTransactionPage}\n        setCurrentTransactionPage={setCurrentTransactionPage}\n      />\n    </>\n  );\n};\n\nexport default ActivityTransactionTable;\n",
            "totalTokens": 1612,
            "chunks": [
              {
                "originalText": "// SPDX-License-Identifier: Apache-2.0\n\nimport Link from 'next/link';\nimport { FiExternalLink } from 'react-icons/fi';\nimport { Dispatch, SetStateAction } from 'react';\nimport { copyContentToClipboard } from '../../common/methods/common';\nimport { ITransactionResult } from '@/types/contract-interactions/shared';\nimport PageinationButtons from '@/components/common/components/PageinationButtons';\nimport {\n  HEDERA_BRANDING_COLORS,\n  HEDERA_CHAKRA_TABLE_VARIANTS,\n  HEDERA_CHAKRA_INPUT_BOX_SIZES,\n} from '@/utils/common/constants';\nimport {\n  Tr,\n  Th,\n  Td,\n  Tbody,\n  Thead,\n  Table,\n  Popover,\n  Checkbox,\n  Tooltip,\n  PopoverContent,\n  PopoverTrigger,\n  TableContainer,\n} from '@chakra-ui/react';\n\ninterface PageProps {\n  onOpen: () => void;\n  allChecked: boolean;\n  isIndeterminate: boolean;\n  parsedHederaNetwork: any;\n  TRANSACTION_PAGE_SIZE: number;\n  currentTransactionPage: number;\n  transactionList: ITransactionResult[];\n  paginatedTransactionResults: ITransactionResult[];\n  setCurrentTransactionPage: Dispatch<SetStateAction<number>>;\n  setTransactionList: Dispatch<SetStateAction<ITransactionResult[]>>;\n  setSelectedTransactionList: Dispatch<SetStateAction<ITransactionResult[]>>;\n  setQueryReponseObj: Dispatch<\n    SetStateAction<{\n      isOpen: boolean;\n      selectedTransaction: ITransactionResult;\n    }>\n  >;\n}\n\nconst ActivityTransactionTable = ({\n  onOpen,\n  allChecked,\n  transactionList,\n  isIndeterminate,\n  setTransactionList,\n  setQueryReponseObj,\n  parsedHederaNetwork,\n  TRANSACTION_PAGE_SIZE,\n  currentTransactionPage,\n  setCurrentTransactionPage,\n  setSelectedTransactionList,\n  paginatedTransactionResults,\n}: PageProps) => {\n  return (\n    <>\n      <TableContainer className=\"flex flex-col gap-3 overflow-x-hidden\">\n        <Table variant={HEDERA_CHAKRA_TABLE_VARIANTS.unstyled} size={HEDERA_CHAKRA_INPUT_BOX_SIZES.small}>\n          <Thead>\n            <Tr className=\"border-b\">\n              <Th color={HEDERA_BRANDING_COLORS.violet} isNumeric className=\"flex justify-start\">\n                Index\n              </Th>\n              <Th color={HEDERA_BRANDING_COLORS.violet}>Request Type</Th>\n              <Th color={HEDERA_BRANDING_COLORS.violet}>Transaction Type</Th>\n              <Th color={HEDERA_BRANDING_COLORS.violet}>Status</Th>\n              <Th color={HEDERA_BRANDING_COLORS.violet}>Transaction hash</Th>\n              <Th>\n                <Checkbox\n                  size={HEDERA_CHAKRA_INPUT_BOX_SIZES.medium}\n                  colorScheme=\"teal\"\n                  isChecked={allChecked}\n                  isIndeterminate={isIndeterminate}\n                  onChange={(e) => {\n                    setTransactionList((prev) =>\n                      prev.map((record) => ({ ...record, selected: e.target.checked }))\n                    );\n                    if (e.target.checked) {\n                      setSelectedTransactionList(\n                        transactionList.map((record) => ({ ...record, selected: e.target.checked }))\n                      );\n                    } else {\n                      setSelectedTransactionList([]);\n                    }\n                  }}\n                />\n              </Th>\n            </Tr>\n          </Thead>\n\n          <Tbody className=\"font-light\">\n            {paginatedTransactionResults.map((transaction) => {\n              return (\n                <Tr\n                  key={transaction.txHash}\n                  onClick={() => {\n                    if (transaction.readonly) {\n                      onOpen();\n                      setQueryReponseObj((prev) => ({\n                        ...prev,\n                        isOpen: true,\n                        selectedTransaction: transaction,\n                      }));\n                    }\n                  }}\n                  title={transaction.readonly ? 'Click to show query response' : ''}\n                  className={` border-b border-white/30 ${\n                    transaction.status === 'success' ? 'hover:bg-hedera-green/10' : 'hover:bg-red-400/10'\n                  } ${transaction.readonly && 'cursor-pointer'}`}\n                >\n                  {/* index */}\n                  <Td>\n                    <p>{transaction.recordIndex}</p>\n                  </Td>\n\n                  {/* request type */}\n                  <Td>{transaction.readonly ? `QUERY` : `TRANSACTION`}</Td>\n\n                  {/* Transaction type */}\n                  <Td>{transaction.transactionType}</Td>\n\n                  {/* status */}\n                  <Td>\n                    <p className={transaction.status === 'success' ? `text-hedera-green` : `text-red-400`}>\n                      {transaction.status.toUpperCase()}\n                    </p>\n                  </Td>\n\n                  {/* txHash */}\n                  <Td className=\"cursor-pointer\">\n                    <div className=\"flex gap-1 items-center justify-between\">\n                      {transaction.readonly ? (\n                        <>N/A</>\n                      ) : (\n                        <>\n                          <div onClick={() => copyContentToClipboard(transaction.txHash)}>\n                            <Popover>\n                              <PopoverTrigger>\n                                <div className=\"flex gap-1 items-center\">\n                                  <Tooltip label=\"click to copy transaction hash\">\n                                    <p>{`${transaction.txHash.slice(0, 15)}...${transaction.txHash.slice(\n                                      -15\n                                    )}`}</p>\n                                  </Tooltip>\n                                </div>\n                              </PopoverTrigger>\n                              <PopoverContent width={'fit-content'} border={'none'}>\n                                <div className=\"bg-secondary px-3 py-2 border-none font-medium\">Copied</div>\n                              </PopoverContent>\n                            </Popover>\n                          </div>\n                          <Tooltip\n                            label={'Explore this transaction on HashScan'}\n                            placement=\"top\"\n                            fontWeight={'medium'}\n                          >\n                            <Link\n                              href={`https://hashscan.io/${parsedHederaNetwork}/transaction/${transaction.txHash}`}\n                              target=\"_blank\"\n                            >\n                              <FiExternalLink />\n                            </Link>\n                          </Tooltip>\n                        </>\n                      )}\n                    </div>\n                  </Td>\n\n                  <Td onClick={(e) => e.stopPropagation()}>\n                    <Checkbox\n                      size={HEDERA_CHAKRA_INPUT_BOX_SIZES.medium}\n                      colorScheme=\"teal\"\n                      isChecked={transaction.selected}\n                      onChange={(e) => {\n                        // include this record to the global selectedTransactionList state\n                        const checkedValue = e.target.checked;\n                        if (checkedValue) {\n                          setSelectedTransactionList((prev) => [...prev, transaction]);\n                          setTransactionList((prev) =>\n                            prev.map((record) => {\n                              if (record.txHash === transaction.txHash) {\n                                record.selected = checkedValue;\n                              }\n                              return record;\n                            })\n                          );\n                        } else {\n                          setSelectedTransactionList((prev) =>\n                            prev.filter((prev) => prev.txHash !== transaction.txHash)\n                          );\n                          setTransactionList((prev) =>\n                            prev.map((record) => {\n                              if (record.txHash === transaction.txHash) {\n                                record.selected = checkedValue;\n                              }\n                              return record;\n                            })\n                          );\n                        }\n                      }}\n                    />\n                  </Td>\n                </Tr>\n              );\n            })}\n          </Tbody>\n        </Table>\n      </TableContainer>\n\n      {/* pagination buttons */}\n      <PageinationButtons\n        transactionList={transactionList}\n        TRANSACTION_PAGE_SIZE={TRANSACTION_PAGE_SIZE}\n        currentTransactionPage={currentTransactionPage}\n        setCurrentTransactionPage={setCurrentTransactionPage}\n      />\n    </>\n  );\n};\n\nexport default ActivityTransactionTable;\n",
                "codeOnlyTokens": 1582,
                "startLine": 1,
                "endLine": 230,
                "type": "full_file",
                "isOversized": false
              }
            ],
            "startLine": 1,
            "endLine": 230,
            "groupId": 1
          }
        ],
        "oversizedChunks": [],
        "sendStrategy": "full_file",
        "finalTokenCount": 1612,
        "skippedContent": [],
        "contextHeader": "// File: system-contract-dapp-playground/src/components/activity/ActivityTransactionTable/index.tsx\n// Relevant file context:\n// Type: .tsx\n",
        "tokenBreakdown": {
          "originalFile": 1582,
          "finalSent": 1612,
          "codeTokensInGroups": 1582,
          "fileHeaderTokensInGroups": 30,
          "shellContextTokensInGroups": 0,
          "separatorTokensInGroups": 0,
          "skippedCodeTokens": 0,
          "unprocessedOversizedTokens": 0,
          "totalSavings": -30,
          "savingsPercentage": -1.8963337547408345,
          "fileHeaderCount": 1,
          "fileHeaderAvgSize": 30,
          "shellContextCount": 0,
          "shellContextAvgSize": 0,
          "separatorCount": 1,
          "separatorAvgSize": 0
        }
      }
    },
    {
      "filePath": "repo_cache/hedera-smart-contracts/system-contract-dapp-playground/src/components/navbar/index.tsx",
      "totalOriginalTokens": 1263,
      "finalTokenCount": 1289,
      "impactScore": 33.333333333333336,
      "averageComplexity": 5,
      "averageQuality": 6.666666666666667,
      "usage": {
        "prompt_tokens": 1571,
        "completion_tokens": 128,
        "total_tokens": 1699
      },
      "retries": 0,
      "hadError": false,
      "scoredChunkGroups": [
        {
          "groupId": 1,
          "score": {
            "file_path": "system-contract-dapp-playground/src/components/navbar/index.tsx",
            "complexity_score": 5,
            "code_quality_score": 7,
            "maintainability_score": 6,
            "best_practices_adherence": 7,
            "positive_feedback": "The responsive design and pertinent handling of user accounts improve the user experience on Hedera-related DApps.",
            "improvement_suggestion": "Consider optimizing state management to minimize unnecessary re-renders when account information changes.",
            "group_summary": "A responsive navigation bar that manages user account information and network state."
          },
          "totalTokens": 1289,
          "usage": {
            "prompt_tokens": 1571,
            "completion_tokens": 128,
            "total_tokens": 1699
          }
        }
      ],
      "chunkingDetails": {
        "filePath": "repo_cache/hedera-smart-contracts/system-contract-dapp-playground/src/components/navbar/index.tsx",
        "totalFileTokens": 1263,
        "chunks": [
          {
            "originalText": "// SPDX-License-Identifier: Apache-2.0\n\n'use client';\n\nimport Link from 'next/link';\nimport Image from 'next/image';\nimport { motion } from 'framer-motion';\nimport WalletPopup from '../wallet-popup';\nimport { useToast } from '@chakra-ui/react';\nimport { useEffect, useState } from 'react';\nimport { TNetworkName } from '@/types/common';\nimport { usePathname } from 'next/navigation';\nimport { BsChevronDown } from 'react-icons/bs';\nimport { CommonErrorToast } from '../toast/CommonToast';\nimport { isProtectedRoute } from '@/utils/common/helpers';\nimport { loadAccountInfoFromCookies } from '@/api/cookies';\nimport { navVariants } from '@/libs/framer-motion/variants';\nimport { HEDERA_COMMON_WALLET_REVERT_REASONS } from '@/utils/common/constants';\n\nconst Navbar = () => {\n  // local states\n  const toaster = useToast();\n  const pathname = usePathname();\n  const [accounts, setAccounts] = useState<string[]>([]);\n  const [isConnected, setIsConnected] = useState(false);\n  const [didWalletPop, setDidWalletPop] = useState(false);\n  const [network, setNetwork] = useState<TNetworkName>('testnet');\n\n  // listen to pathname change event to retrieve account information cookies\n  useEffect(() => {\n    if (isProtectedRoute(pathname)) {\n      // retrieve account info from cookies\n      const accountsInfo = loadAccountInfoFromCookies();\n\n      // just best pratice to handle error as this would rarely happen as we have already gated all the checks in middleware.js\n      if (\n        !accountsInfo.isConnected ||\n        !accountsInfo.accounts ||\n        !accountsInfo.network ||\n        accountsInfo.error\n      ) {\n        CommonErrorToast({\n          toaster,\n          title: 'Error retrieving account information',\n          description: HEDERA_COMMON_WALLET_REVERT_REASONS.DEFAULT.description,\n        });\n        return;\n      }\n\n      // update states\n      setAccounts(JSON.parse(accountsInfo.accounts));\n      setIsConnected(JSON.parse(accountsInfo.isConnected));\n      setNetwork(JSON.parse(accountsInfo.network) as TNetworkName);\n    }\n  }, [pathname, toaster]);\n\n  return (\n    <motion.nav\n      initial={{ opacity: 0 }}\n      whileInView={{ opacity: 1 }}\n      transition={{\n        delay: 0.3,\n        duration: 0.3,\n      }}\n      viewport={{ once: true }}\n      className=\"px-6 pt-6 flex flex-col justify-between items-center z-50\"\n    >\n      {/* Protected Navbar */}\n      {isConnected ? (\n        <div className=\"grid grid-rows-2 sm:grid-rows-1 sm:grid-cols-2 lg:grid-cols-3 w-full justify-center gap-3 pb-6\">\n          {/* Logo */}\n          <Link href={'/'} className=\"flex gap-3 items-center justify-center sm:justify-start\">\n            <Image\n              src={'/brandings/hedera-logomark.svg'}\n              alt={'hedera-logomark'}\n              width={50}\n              height={50}\n              className=\"z-50\"\n            />\n            <p className=\"text-white text-[2rem]\">Hedera</p>\n          </Link>\n\n          {/* DApp playground */}\n          <div className=\"hidden lg:flex lg:gap-1 lg:items-center lg:justify-center\">\n            <div className=\"flex justify-center items-center text-hedera-green\">\n              <div className=\"rounded-r-[9px] border-hedera-green w-[52px] h-[27px] border-[5px] mt-1\" />\n              <div className=\"font-medium text-[2rem] uppercase\">App</div>\n            </div>\n\n            {/* Playground */}\n            <div className=\"uppercase text-[2rem] bg-clip-text text-white\">Playground</div>",
            "codeOnlyTokens": 818,
            "startLine": 1,
            "endLine": 91,
            "type": ".tsx_part_1",
            "isOversized": false
          },
          {
            "originalText": "          </div>\n\n          {/* wallet info */}\n          <div className=\"text-white flex justify-end\">\n            {/* wallet wrapper */}\n            <div\n              className=\"bg-gradient-to-r from-hedera-gradient-2-lime/60 to-hedera-gradient-2-teal rounded-lg flex items-center px-3 cursor-pointer\"\n              onClick={() => {\n                setDidWalletPop(true);\n              }}\n            >\n              {/* logo */}\n              <Image src={'/brandings/hedera-logomark.svg'} alt={'hedera-logomark'} width={30} height={30} />\n\n              {/* vertical bar */}\n              <div className=\"bg-white/30 w-[1px] h-full mx-3\" />\n\n              {/* address */}\n              <p className=\"text-lg font-medium\">\n                {accounts[0].slice(0, 7)}...{accounts[0].slice(-5)}\n              </p>\n\n              {/* downward arrow */}\n              <div className=\"text-xl ml-1\">\n                <BsChevronDown />\n              </div>\n            </div>\n          </div>\n        </div>\n      ) : (\n        <motion.div\n          variants={navVariants}\n          initial=\"hidden\"\n          whileInView=\"show\"\n          viewport={{ once: true }}\n          className=\"flex justify-between w-full\"\n        >\n          {/* Unprotected Navbar */}\n          <Link href={'/'}>\n            {/* Logo */}\n            <Image\n              src={'/brandings/hedera-logomark.svg'}\n              alt={'hedera-logomark'}\n              width={50}\n              height={50}\n              className=\"z-50\"\n            />\n          </Link>\n\n          {/* Text logo */}\n          <p className=\"text-white text-[2rem]\">Hedera</p>\n        </motion.div>\n      )}\n\n      {isConnected && <hr className=\"w-[99vw] border-t border-white/40\" />}\n\n      {didWalletPop && (\n        <WalletPopup network={network} userAddress={accounts[0]} setIsOpen={setDidWalletPop} />\n      )}\n    </motion.nav>\n  );\n};\n\nexport default Navbar;\n",
            "codeOnlyTokens": 445,
            "startLine": 92,
            "endLine": 156,
            "type": ".tsx_part_2",
            "isOversized": false
          }
        ],
        "groupedChunks": [
          {
            "combinedText": "// File: system-contract-dapp-playground/src/components/navbar/index.tsx\n// Relevant file context:\n// Type: .tsx\n// SPDX-License-Identifier: Apache-2.0\n\n'use client';\n\nimport Link from 'next/link';\nimport Image from 'next/image';\nimport { motion } from 'framer-motion';\nimport WalletPopup from '../wallet-popup';\nimport { useToast } from '@chakra-ui/react';\nimport { useEffect, useState } from 'react';\nimport { TNetworkName } from '@/types/common';\nimport { usePathname } from 'next/navigation';\nimport { BsChevronDown } from 'react-icons/bs';\nimport { CommonErrorToast } from '../toast/CommonToast';\nimport { isProtectedRoute } from '@/utils/common/helpers';\nimport { loadAccountInfoFromCookies } from '@/api/cookies';\nimport { navVariants } from '@/libs/framer-motion/variants';\nimport { HEDERA_COMMON_WALLET_REVERT_REASONS } from '@/utils/common/constants';\n\nconst Navbar = () => {\n  // local states\n  const toaster = useToast();\n  const pathname = usePathname();\n  const [accounts, setAccounts] = useState<string[]>([]);\n  const [isConnected, setIsConnected] = useState(false);\n  const [didWalletPop, setDidWalletPop] = useState(false);\n  const [network, setNetwork] = useState<TNetworkName>('testnet');\n\n  // listen to pathname change event to retrieve account information cookies\n  useEffect(() => {\n    if (isProtectedRoute(pathname)) {\n      // retrieve account info from cookies\n      const accountsInfo = loadAccountInfoFromCookies();\n\n      // just best pratice to handle error as this would rarely happen as we have already gated all the checks in middleware.js\n      if (\n        !accountsInfo.isConnected ||\n        !accountsInfo.accounts ||\n        !accountsInfo.network ||\n        accountsInfo.error\n      ) {\n        CommonErrorToast({\n          toaster,\n          title: 'Error retrieving account information',\n          description: HEDERA_COMMON_WALLET_REVERT_REASONS.DEFAULT.description,\n        });\n        return;\n      }\n\n      // update states\n      setAccounts(JSON.parse(accountsInfo.accounts));\n      setIsConnected(JSON.parse(accountsInfo.isConnected));\n      setNetwork(JSON.parse(accountsInfo.network) as TNetworkName);\n    }\n  }, [pathname, toaster]);\n\n  return (\n    <motion.nav\n      initial={{ opacity: 0 }}\n      whileInView={{ opacity: 1 }}\n      transition={{\n        delay: 0.3,\n        duration: 0.3,\n      }}\n      viewport={{ once: true }}\n      className=\"px-6 pt-6 flex flex-col justify-between items-center z-50\"\n    >\n      {/* Protected Navbar */}\n      {isConnected ? (\n        <div className=\"grid grid-rows-2 sm:grid-rows-1 sm:grid-cols-2 lg:grid-cols-3 w-full justify-center gap-3 pb-6\">\n          {/* Logo */}\n          <Link href={'/'} className=\"flex gap-3 items-center justify-center sm:justify-start\">\n            <Image\n              src={'/brandings/hedera-logomark.svg'}\n              alt={'hedera-logomark'}\n              width={50}\n              height={50}\n              className=\"z-50\"\n            />\n            <p className=\"text-white text-[2rem]\">Hedera</p>\n          </Link>\n\n          {/* DApp playground */}\n          <div className=\"hidden lg:flex lg:gap-1 lg:items-center lg:justify-center\">\n            <div className=\"flex justify-center items-center text-hedera-green\">\n              <div className=\"rounded-r-[9px] border-hedera-green w-[52px] h-[27px] border-[5px] mt-1\" />\n              <div className=\"font-medium text-[2rem] uppercase\">App</div>\n            </div>\n\n            {/* Playground */}\n            <div className=\"uppercase text-[2rem] bg-clip-text text-white\">Playground</div>\n          </div>\n\n          {/* wallet info */}\n          <div className=\"text-white flex justify-end\">\n            {/* wallet wrapper */}\n            <div\n              className=\"bg-gradient-to-r from-hedera-gradient-2-lime/60 to-hedera-gradient-2-teal rounded-lg flex items-center px-3 cursor-pointer\"\n              onClick={() => {\n                setDidWalletPop(true);\n              }}\n            >\n              {/* logo */}\n              <Image src={'/brandings/hedera-logomark.svg'} alt={'hedera-logomark'} width={30} height={30} />\n\n              {/* vertical bar */}\n              <div className=\"bg-white/30 w-[1px] h-full mx-3\" />\n\n              {/* address */}\n              <p className=\"text-lg font-medium\">\n                {accounts[0].slice(0, 7)}...{accounts[0].slice(-5)}\n              </p>\n\n              {/* downward arrow */}\n              <div className=\"text-xl ml-1\">\n                <BsChevronDown />\n              </div>\n            </div>\n          </div>\n        </div>\n      ) : (\n        <motion.div\n          variants={navVariants}\n          initial=\"hidden\"\n          whileInView=\"show\"\n          viewport={{ once: true }}\n          className=\"flex justify-between w-full\"\n        >\n          {/* Unprotected Navbar */}\n          <Link href={'/'}>\n            {/* Logo */}\n            <Image\n              src={'/brandings/hedera-logomark.svg'}\n              alt={'hedera-logomark'}\n              width={50}\n              height={50}\n              className=\"z-50\"\n            />\n          </Link>\n\n          {/* Text logo */}\n          <p className=\"text-white text-[2rem]\">Hedera</p>\n        </motion.div>\n      )}\n\n      {isConnected && <hr className=\"w-[99vw] border-t border-white/40\" />}\n\n      {didWalletPop && (\n        <WalletPopup network={network} userAddress={accounts[0]} setIsOpen={setDidWalletPop} />\n      )}\n    </motion.nav>\n  );\n};\n\nexport default Navbar;\n",
            "totalTokens": 1289,
            "chunks": [
              {
                "originalText": "// SPDX-License-Identifier: Apache-2.0\n\n'use client';\n\nimport Link from 'next/link';\nimport Image from 'next/image';\nimport { motion } from 'framer-motion';\nimport WalletPopup from '../wallet-popup';\nimport { useToast } from '@chakra-ui/react';\nimport { useEffect, useState } from 'react';\nimport { TNetworkName } from '@/types/common';\nimport { usePathname } from 'next/navigation';\nimport { BsChevronDown } from 'react-icons/bs';\nimport { CommonErrorToast } from '../toast/CommonToast';\nimport { isProtectedRoute } from '@/utils/common/helpers';\nimport { loadAccountInfoFromCookies } from '@/api/cookies';\nimport { navVariants } from '@/libs/framer-motion/variants';\nimport { HEDERA_COMMON_WALLET_REVERT_REASONS } from '@/utils/common/constants';\n\nconst Navbar = () => {\n  // local states\n  const toaster = useToast();\n  const pathname = usePathname();\n  const [accounts, setAccounts] = useState<string[]>([]);\n  const [isConnected, setIsConnected] = useState(false);\n  const [didWalletPop, setDidWalletPop] = useState(false);\n  const [network, setNetwork] = useState<TNetworkName>('testnet');\n\n  // listen to pathname change event to retrieve account information cookies\n  useEffect(() => {\n    if (isProtectedRoute(pathname)) {\n      // retrieve account info from cookies\n      const accountsInfo = loadAccountInfoFromCookies();\n\n      // just best pratice to handle error as this would rarely happen as we have already gated all the checks in middleware.js\n      if (\n        !accountsInfo.isConnected ||\n        !accountsInfo.accounts ||\n        !accountsInfo.network ||\n        accountsInfo.error\n      ) {\n        CommonErrorToast({\n          toaster,\n          title: 'Error retrieving account information',\n          description: HEDERA_COMMON_WALLET_REVERT_REASONS.DEFAULT.description,\n        });\n        return;\n      }\n\n      // update states\n      setAccounts(JSON.parse(accountsInfo.accounts));\n      setIsConnected(JSON.parse(accountsInfo.isConnected));\n      setNetwork(JSON.parse(accountsInfo.network) as TNetworkName);\n    }\n  }, [pathname, toaster]);\n\n  return (\n    <motion.nav\n      initial={{ opacity: 0 }}\n      whileInView={{ opacity: 1 }}\n      transition={{\n        delay: 0.3,\n        duration: 0.3,\n      }}\n      viewport={{ once: true }}\n      className=\"px-6 pt-6 flex flex-col justify-between items-center z-50\"\n    >\n      {/* Protected Navbar */}\n      {isConnected ? (\n        <div className=\"grid grid-rows-2 sm:grid-rows-1 sm:grid-cols-2 lg:grid-cols-3 w-full justify-center gap-3 pb-6\">\n          {/* Logo */}\n          <Link href={'/'} className=\"flex gap-3 items-center justify-center sm:justify-start\">\n            <Image\n              src={'/brandings/hedera-logomark.svg'}\n              alt={'hedera-logomark'}\n              width={50}\n              height={50}\n              className=\"z-50\"\n            />\n            <p className=\"text-white text-[2rem]\">Hedera</p>\n          </Link>\n\n          {/* DApp playground */}\n          <div className=\"hidden lg:flex lg:gap-1 lg:items-center lg:justify-center\">\n            <div className=\"flex justify-center items-center text-hedera-green\">\n              <div className=\"rounded-r-[9px] border-hedera-green w-[52px] h-[27px] border-[5px] mt-1\" />\n              <div className=\"font-medium text-[2rem] uppercase\">App</div>\n            </div>\n\n            {/* Playground */}\n            <div className=\"uppercase text-[2rem] bg-clip-text text-white\">Playground</div>\n          </div>\n\n          {/* wallet info */}\n          <div className=\"text-white flex justify-end\">\n            {/* wallet wrapper */}\n            <div\n              className=\"bg-gradient-to-r from-hedera-gradient-2-lime/60 to-hedera-gradient-2-teal rounded-lg flex items-center px-3 cursor-pointer\"\n              onClick={() => {\n                setDidWalletPop(true);\n              }}\n            >\n              {/* logo */}\n              <Image src={'/brandings/hedera-logomark.svg'} alt={'hedera-logomark'} width={30} height={30} />\n\n              {/* vertical bar */}\n              <div className=\"bg-white/30 w-[1px] h-full mx-3\" />\n\n              {/* address */}\n              <p className=\"text-lg font-medium\">\n                {accounts[0].slice(0, 7)}...{accounts[0].slice(-5)}\n              </p>\n\n              {/* downward arrow */}\n              <div className=\"text-xl ml-1\">\n                <BsChevronDown />\n              </div>\n            </div>\n          </div>\n        </div>\n      ) : (\n        <motion.div\n          variants={navVariants}\n          initial=\"hidden\"\n          whileInView=\"show\"\n          viewport={{ once: true }}\n          className=\"flex justify-between w-full\"\n        >\n          {/* Unprotected Navbar */}\n          <Link href={'/'}>\n            {/* Logo */}\n            <Image\n              src={'/brandings/hedera-logomark.svg'}\n              alt={'hedera-logomark'}\n              width={50}\n              height={50}\n              className=\"z-50\"\n            />\n          </Link>\n\n          {/* Text logo */}\n          <p className=\"text-white text-[2rem]\">Hedera</p>\n        </motion.div>\n      )}\n\n      {isConnected && <hr className=\"w-[99vw] border-t border-white/40\" />}\n\n      {didWalletPop && (\n        <WalletPopup network={network} userAddress={accounts[0]} setIsOpen={setDidWalletPop} />\n      )}\n    </motion.nav>\n  );\n};\n\nexport default Navbar;\n",
                "codeOnlyTokens": 1263,
                "startLine": 1,
                "endLine": 156,
                "type": "full_file",
                "isOversized": false
              }
            ],
            "startLine": 1,
            "endLine": 156,
            "groupId": 1
          }
        ],
        "oversizedChunks": [],
        "sendStrategy": "full_file",
        "finalTokenCount": 1289,
        "skippedContent": [],
        "contextHeader": "// File: system-contract-dapp-playground/src/components/navbar/index.tsx\n// Relevant file context:\n// Type: .tsx\n",
        "tokenBreakdown": {
          "originalFile": 1263,
          "finalSent": 1289,
          "codeTokensInGroups": 1263,
          "fileHeaderTokensInGroups": 26,
          "shellContextTokensInGroups": 0,
          "separatorTokensInGroups": 0,
          "skippedCodeTokens": 0,
          "unprocessedOversizedTokens": 0,
          "totalSavings": -26,
          "savingsPercentage": -2.058590657165479,
          "fileHeaderCount": 1,
          "fileHeaderAvgSize": 26,
          "shellContextCount": 0,
          "shellContextAvgSize": 0,
          "separatorCount": 1,
          "separatorAvgSize": 0
        }
      }
    },
    {
      "filePath": "repo_cache/hedera-smart-contracts/system-contract-dapp-playground/src/utils/common/helpers.ts",
      "totalOriginalTokens": 1549,
      "finalTokenCount": 1574,
      "impactScore": 32,
      "averageComplexity": 4,
      "averageQuality": 8,
      "usage": {
        "prompt_tokens": 1859,
        "completion_tokens": 134,
        "total_tokens": 1993
      },
      "retries": 0,
      "hadError": false,
      "scoredChunkGroups": [
        {
          "groupId": 1,
          "score": {
            "file_path": "system-contract-dapp-playground/src/utils/common/helpers.ts",
            "complexity_score": 4,
            "code_quality_score": 8,
            "maintainability_score": 8,
            "best_practices_adherence": 8,
            "positive_feedback": "Provides well-structured utility functions for transaction handling in Hedera applications.",
            "improvement_suggestion": "Integrate TypeScript types more extensively to enhance type safety throughout utility functions.",
            "group_summary": "Contains utility functions for validating and processing Hedera-related information and transactions."
          },
          "totalTokens": 1574,
          "usage": {
            "prompt_tokens": 1859,
            "completion_tokens": 134,
            "total_tokens": 1993
          }
        }
      ],
      "chunkingDetails": {
        "filePath": "repo_cache/hedera-smart-contracts/system-contract-dapp-playground/src/utils/common/helpers.ts",
        "totalFileTokens": 1549,
        "chunks": [
          {
            "originalText": "// SPDX-License-Identifier: Apache-2.0\n\nimport { Contract, ethers } from 'ethers';\nimport { TNetworkName } from '@/types/common';\nimport { getCurrentChainId } from '@/api/wallet';\nimport { HEDERA_NETWORKS, PROTECTED_ROUTES } from './constants';\nimport { ITransactionResult } from '@/types/contract-interactions/shared';\nimport { estimateGasViaMirrorNode } from '@/api/mirror-node';\n\n/**\n * @dev validating if a route is protected\n * @param pathname string\n * @returns boolean\n */\nexport const isProtectedRoute = (pathname: string) => {\n  return PROTECTED_ROUTES.includes(pathname);\n};\n\n/**\n * @dev Handles checking if the connected network is the expected network (i.e. HEDERA_TESTNET, HEDERA_PREVIEWNET, HEDERA_LOCALNET, HEDERA_MAINNET)\n *\n * @params walletProvider: ethers.BrowserProvider\n *\n * @returns bool\n */\nexport const isCorrectHederaNetwork = async (walletProvider: ethers.BrowserProvider) => {\n  // get current chainId\n  const currentChainId = (await getCurrentChainId(walletProvider)).currentChainId as string;\n\n  return (\n    currentChainId === HEDERA_NETWORKS.mainnet.chainIdHex ||\n    currentChainId === HEDERA_NETWORKS.testnet.chainIdHex ||\n    currentChainId === HEDERA_NETWORKS.previewnet.chainIdHex ||\n    currentChainId === HEDERA_NETWORKS.localnet.chainIdHex\n  );\n};\n\n/**\n * @dev convert chainId to network name\n *\n * @params chainId string\n *\n * @returns string\n */\nexport const chainIdToNetwork = (chainId: string): TNetworkName => {\n  switch (chainId) {\n    case '0x127':\n      return 'mainnet';\n    case '0x128':\n      return 'testnet';\n    case '0x129':\n      return 'previewnet';\n    case '0x12a':\n    default:\n      return 'localnet';\n  }\n};\n\n/**\n * @dev convert ABI function name from camelCase to normal\n *\n * @params functionName: string\n *\n * @returns string\n */\nexport const convertCalmelCaseFunctionName = (functionName: string) => {\n  // Split the string into words based on camel case\n  const fnNames = functionName.replace(/([a-z])([A-Z])/g, '$1 $2').split(' ');\n\n  // Capitalize the first letter of each function name\n  const titleCaseNames = fnNames.map((fnName) => fnName.charAt(0).toUpperCase() + fnName.slice(1));\n\n  // Join the names back together with a space\n  const titleCaseFunctionName = titleCaseNames.join(' ');\n\n  return titleCaseFunctionName;\n};\n\n/**\n * @dev create a random unique key string\n *\n * @param byteLength: number\n *\n * @return string\n */\nexport const generatedRandomUniqueKey = (byteLength: number) => {\n  const randomBytes = ethers.randomBytes(9);\n  const randomKey = ethers.hexlify(randomBytes);\n  return randomKey;\n};\n\n/**\n * @dev prepare a list of transaction in order from newest to oldest based on the timestamp when each transaction occurs\n *\n * @returns allTransactions: ITransactionResult[]\n */\nexport const prepareTransactionList = () => {\n  // prepare\n  const transactions: ITransactionResult[] = [];\n\n  // loop through localStorage items\n  if (typeof localStorage !== 'undefined') {\n    for (let i = 0; i < localStorage.length; i++) {\n      // get key\n      const key = localStorage.key(i);\n\n      // only include item with KEY includes 'HEDERA' and NOT include 'READONLY'\n      if (key?.includes('HEDERA')) {",
            "codeOnlyTokens": 806,
            "startLine": 1,
            "endLine": 108,
            "type": ".ts_part_1",
            "isOversized": false
          },
          {
            "originalText": "        const records = JSON.parse(localStorage.getItem(key) || '');\n        records.forEach((record: any) => {\n          transactions.push({ ...record });\n        });\n      }\n    }\n  }\n\n  // sort transactions from oldest to newest to assign recordIndex\n  const sortedTransactions = transactions\n    .sort((txA, txB) => txA.transactionTimeStamp - txB.transactionTimeStamp)\n    .map((record, index) => ({ ...record, recordIndex: index + 1 }));\n\n  return sortedTransactions;\n};\n\n/**\n * @dev prepare headers object for CSV exporting feature\n */\nexport const prepareCSVHeaders = () => {\n  return [\n    {\n      label: 'Request Type',\n      key: 'reques_type',\n    },\n    {\n      label: 'Transaction Type',\n      key: 'transaction_type',\n    },\n    {\n      label: 'Status',\n      key: 'status',\n    },\n    {\n      label: 'Transaction Hash',\n      key: 'transaction_hash',\n    },\n    {\n      label: 'Contract Address',\n      key: 'contract_address',\n    },\n    {\n      label: 'Timestamp',\n      key: 'transaction_time_stamp',\n    },\n    {\n      label: 'Query Reponse',\n      key: 'query_response',\n    },\n    {\n      label: 'HashScan Explorer',\n      key: 'hashscan_explorer',\n    },\n  ];\n};\n\n/**\n * @dev prepare data object for CSV exporting feature\n */\nexport const prepareCSVData = (transactionList: ITransactionResult[], network: string) => {\n  const queryResponseKeys = [\n    'ownerOf',\n    'tokenURI',\n    'approves',\n    'approves',\n    'balanceOf',\n    'allowances',\n    'ercTokenInfo',\n  ];\n\n  // sort transactionList based on order\n  const sortedTransactionList = transactionList.sort((txA, txB) => {\n    return txA.transactionTimeStamp - txB.transactionTimeStamp;\n  });\n\n  return sortedTransactionList.map((transaction) => {\n    // prepare query responses\n    let queryResponse;\n    queryResponseKeys.forEach((key) => {\n      if ((transaction as any)[key] && transaction.readonly) {\n        queryResponse = JSON.stringify((transaction as any)[key]).replaceAll(',', ';');\n      }\n    });\n\n    return {\n      status: transaction.status,\n      query_response: queryResponse || 'N/A',\n      transaction_type: transaction.transactionType,\n      contract_address: transaction.sessionedContractAddress,\n      reques_type: transaction.readonly ? 'QUERY' : 'TRANSACTION',\n      transaction_hash: transaction.readonly ? 'N/A' : transaction.txHash,\n      transaction_time_stamp: new Date(transaction.transactionTimeStamp).toLocaleString(),\n      hashscan_explorer: transaction.readonly\n        ? 'N/A'\n        : `https://hashscan.io/${network}/transaction/${transaction.txHash}`,\n    };\n  });\n};\n\n/**\n * @dev handles estimating gas\n */\nexport const handleEstimateGas = async (\n  baseContract: Contract,\n  signerAddress: ethers.AddressLike,\n  network: TNetworkName,\n  functionSignature: string,\n  args: any[]\n) => {\n  // prepare arguments for estimateGas()\n  const contractAddress = await baseContract.getAddress();\n\n  const calldata = baseContract.interface.encodeFunctionData(functionSignature, args);\n  const estimateGas = await estimateGasViaMirrorNode(contractAddress, signerAddress, calldata, network);\n  if (!estimateGas.gasLimit || estimateGas.err) return { err: estimateGas.err };\n\n  return { gasLimit: estimateGas.gasLimit };\n};\n",
            "codeOnlyTokens": 743,
            "startLine": 109,
            "endLine": 227,
            "type": ".ts_part_2",
            "isOversized": false
          }
        ],
        "groupedChunks": [
          {
            "combinedText": "// File: system-contract-dapp-playground/src/utils/common/helpers.ts\n// Relevant file context:\n// Type: .ts\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Contract, ethers } from 'ethers';\nimport { TNetworkName } from '@/types/common';\nimport { getCurrentChainId } from '@/api/wallet';\nimport { HEDERA_NETWORKS, PROTECTED_ROUTES } from './constants';\nimport { ITransactionResult } from '@/types/contract-interactions/shared';\nimport { estimateGasViaMirrorNode } from '@/api/mirror-node';\n\n/**\n * @dev validating if a route is protected\n * @param pathname string\n * @returns boolean\n */\nexport const isProtectedRoute = (pathname: string) => {\n  return PROTECTED_ROUTES.includes(pathname);\n};\n\n/**\n * @dev Handles checking if the connected network is the expected network (i.e. HEDERA_TESTNET, HEDERA_PREVIEWNET, HEDERA_LOCALNET, HEDERA_MAINNET)\n *\n * @params walletProvider: ethers.BrowserProvider\n *\n * @returns bool\n */\nexport const isCorrectHederaNetwork = async (walletProvider: ethers.BrowserProvider) => {\n  // get current chainId\n  const currentChainId = (await getCurrentChainId(walletProvider)).currentChainId as string;\n\n  return (\n    currentChainId === HEDERA_NETWORKS.mainnet.chainIdHex ||\n    currentChainId === HEDERA_NETWORKS.testnet.chainIdHex ||\n    currentChainId === HEDERA_NETWORKS.previewnet.chainIdHex ||\n    currentChainId === HEDERA_NETWORKS.localnet.chainIdHex\n  );\n};\n\n/**\n * @dev convert chainId to network name\n *\n * @params chainId string\n *\n * @returns string\n */\nexport const chainIdToNetwork = (chainId: string): TNetworkName => {\n  switch (chainId) {\n    case '0x127':\n      return 'mainnet';\n    case '0x128':\n      return 'testnet';\n    case '0x129':\n      return 'previewnet';\n    case '0x12a':\n    default:\n      return 'localnet';\n  }\n};\n\n/**\n * @dev convert ABI function name from camelCase to normal\n *\n * @params functionName: string\n *\n * @returns string\n */\nexport const convertCalmelCaseFunctionName = (functionName: string) => {\n  // Split the string into words based on camel case\n  const fnNames = functionName.replace(/([a-z])([A-Z])/g, '$1 $2').split(' ');\n\n  // Capitalize the first letter of each function name\n  const titleCaseNames = fnNames.map((fnName) => fnName.charAt(0).toUpperCase() + fnName.slice(1));\n\n  // Join the names back together with a space\n  const titleCaseFunctionName = titleCaseNames.join(' ');\n\n  return titleCaseFunctionName;\n};\n\n/**\n * @dev create a random unique key string\n *\n * @param byteLength: number\n *\n * @return string\n */\nexport const generatedRandomUniqueKey = (byteLength: number) => {\n  const randomBytes = ethers.randomBytes(9);\n  const randomKey = ethers.hexlify(randomBytes);\n  return randomKey;\n};\n\n/**\n * @dev prepare a list of transaction in order from newest to oldest based on the timestamp when each transaction occurs\n *\n * @returns allTransactions: ITransactionResult[]\n */\nexport const prepareTransactionList = () => {\n  // prepare\n  const transactions: ITransactionResult[] = [];\n\n  // loop through localStorage items\n  if (typeof localStorage !== 'undefined') {\n    for (let i = 0; i < localStorage.length; i++) {\n      // get key\n      const key = localStorage.key(i);\n\n      // only include item with KEY includes 'HEDERA' and NOT include 'READONLY'\n      if (key?.includes('HEDERA')) {\n        const records = JSON.parse(localStorage.getItem(key) || '');\n        records.forEach((record: any) => {\n          transactions.push({ ...record });\n        });\n      }\n    }\n  }\n\n  // sort transactions from oldest to newest to assign recordIndex\n  const sortedTransactions = transactions\n    .sort((txA, txB) => txA.transactionTimeStamp - txB.transactionTimeStamp)\n    .map((record, index) => ({ ...record, recordIndex: index + 1 }));\n\n  return sortedTransactions;\n};\n\n/**\n * @dev prepare headers object for CSV exporting feature\n */\nexport const prepareCSVHeaders = () => {\n  return [\n    {\n      label: 'Request Type',\n      key: 'reques_type',\n    },\n    {\n      label: 'Transaction Type',\n      key: 'transaction_type',\n    },\n    {\n      label: 'Status',\n      key: 'status',\n    },\n    {\n      label: 'Transaction Hash',\n      key: 'transaction_hash',\n    },\n    {\n      label: 'Contract Address',\n      key: 'contract_address',\n    },\n    {\n      label: 'Timestamp',\n      key: 'transaction_time_stamp',\n    },\n    {\n      label: 'Query Reponse',\n      key: 'query_response',\n    },\n    {\n      label: 'HashScan Explorer',\n      key: 'hashscan_explorer',\n    },\n  ];\n};\n\n/**\n * @dev prepare data object for CSV exporting feature\n */\nexport const prepareCSVData = (transactionList: ITransactionResult[], network: string) => {\n  const queryResponseKeys = [\n    'ownerOf',\n    'tokenURI',\n    'approves',\n    'approves',\n    'balanceOf',\n    'allowances',\n    'ercTokenInfo',\n  ];\n\n  // sort transactionList based on order\n  const sortedTransactionList = transactionList.sort((txA, txB) => {\n    return txA.transactionTimeStamp - txB.transactionTimeStamp;\n  });\n\n  return sortedTransactionList.map((transaction) => {\n    // prepare query responses\n    let queryResponse;\n    queryResponseKeys.forEach((key) => {\n      if ((transaction as any)[key] && transaction.readonly) {\n        queryResponse = JSON.stringify((transaction as any)[key]).replaceAll(',', ';');\n      }\n    });\n\n    return {\n      status: transaction.status,\n      query_response: queryResponse || 'N/A',\n      transaction_type: transaction.transactionType,\n      contract_address: transaction.sessionedContractAddress,\n      reques_type: transaction.readonly ? 'QUERY' : 'TRANSACTION',\n      transaction_hash: transaction.readonly ? 'N/A' : transaction.txHash,\n      transaction_time_stamp: new Date(transaction.transactionTimeStamp).toLocaleString(),\n      hashscan_explorer: transaction.readonly\n        ? 'N/A'\n        : `https://hashscan.io/${network}/transaction/${transaction.txHash}`,\n    };\n  });\n};\n\n/**\n * @dev handles estimating gas\n */\nexport const handleEstimateGas = async (\n  baseContract: Contract,\n  signerAddress: ethers.AddressLike,\n  network: TNetworkName,\n  functionSignature: string,\n  args: any[]\n) => {\n  // prepare arguments for estimateGas()\n  const contractAddress = await baseContract.getAddress();\n\n  const calldata = baseContract.interface.encodeFunctionData(functionSignature, args);\n  const estimateGas = await estimateGasViaMirrorNode(contractAddress, signerAddress, calldata, network);\n  if (!estimateGas.gasLimit || estimateGas.err) return { err: estimateGas.err };\n\n  return { gasLimit: estimateGas.gasLimit };\n};\n",
            "totalTokens": 1574,
            "chunks": [
              {
                "originalText": "// SPDX-License-Identifier: Apache-2.0\n\nimport { Contract, ethers } from 'ethers';\nimport { TNetworkName } from '@/types/common';\nimport { getCurrentChainId } from '@/api/wallet';\nimport { HEDERA_NETWORKS, PROTECTED_ROUTES } from './constants';\nimport { ITransactionResult } from '@/types/contract-interactions/shared';\nimport { estimateGasViaMirrorNode } from '@/api/mirror-node';\n\n/**\n * @dev validating if a route is protected\n * @param pathname string\n * @returns boolean\n */\nexport const isProtectedRoute = (pathname: string) => {\n  return PROTECTED_ROUTES.includes(pathname);\n};\n\n/**\n * @dev Handles checking if the connected network is the expected network (i.e. HEDERA_TESTNET, HEDERA_PREVIEWNET, HEDERA_LOCALNET, HEDERA_MAINNET)\n *\n * @params walletProvider: ethers.BrowserProvider\n *\n * @returns bool\n */\nexport const isCorrectHederaNetwork = async (walletProvider: ethers.BrowserProvider) => {\n  // get current chainId\n  const currentChainId = (await getCurrentChainId(walletProvider)).currentChainId as string;\n\n  return (\n    currentChainId === HEDERA_NETWORKS.mainnet.chainIdHex ||\n    currentChainId === HEDERA_NETWORKS.testnet.chainIdHex ||\n    currentChainId === HEDERA_NETWORKS.previewnet.chainIdHex ||\n    currentChainId === HEDERA_NETWORKS.localnet.chainIdHex\n  );\n};\n\n/**\n * @dev convert chainId to network name\n *\n * @params chainId string\n *\n * @returns string\n */\nexport const chainIdToNetwork = (chainId: string): TNetworkName => {\n  switch (chainId) {\n    case '0x127':\n      return 'mainnet';\n    case '0x128':\n      return 'testnet';\n    case '0x129':\n      return 'previewnet';\n    case '0x12a':\n    default:\n      return 'localnet';\n  }\n};\n\n/**\n * @dev convert ABI function name from camelCase to normal\n *\n * @params functionName: string\n *\n * @returns string\n */\nexport const convertCalmelCaseFunctionName = (functionName: string) => {\n  // Split the string into words based on camel case\n  const fnNames = functionName.replace(/([a-z])([A-Z])/g, '$1 $2').split(' ');\n\n  // Capitalize the first letter of each function name\n  const titleCaseNames = fnNames.map((fnName) => fnName.charAt(0).toUpperCase() + fnName.slice(1));\n\n  // Join the names back together with a space\n  const titleCaseFunctionName = titleCaseNames.join(' ');\n\n  return titleCaseFunctionName;\n};\n\n/**\n * @dev create a random unique key string\n *\n * @param byteLength: number\n *\n * @return string\n */\nexport const generatedRandomUniqueKey = (byteLength: number) => {\n  const randomBytes = ethers.randomBytes(9);\n  const randomKey = ethers.hexlify(randomBytes);\n  return randomKey;\n};\n\n/**\n * @dev prepare a list of transaction in order from newest to oldest based on the timestamp when each transaction occurs\n *\n * @returns allTransactions: ITransactionResult[]\n */\nexport const prepareTransactionList = () => {\n  // prepare\n  const transactions: ITransactionResult[] = [];\n\n  // loop through localStorage items\n  if (typeof localStorage !== 'undefined') {\n    for (let i = 0; i < localStorage.length; i++) {\n      // get key\n      const key = localStorage.key(i);\n\n      // only include item with KEY includes 'HEDERA' and NOT include 'READONLY'\n      if (key?.includes('HEDERA')) {\n        const records = JSON.parse(localStorage.getItem(key) || '');\n        records.forEach((record: any) => {\n          transactions.push({ ...record });\n        });\n      }\n    }\n  }\n\n  // sort transactions from oldest to newest to assign recordIndex\n  const sortedTransactions = transactions\n    .sort((txA, txB) => txA.transactionTimeStamp - txB.transactionTimeStamp)\n    .map((record, index) => ({ ...record, recordIndex: index + 1 }));\n\n  return sortedTransactions;\n};\n\n/**\n * @dev prepare headers object for CSV exporting feature\n */\nexport const prepareCSVHeaders = () => {\n  return [\n    {\n      label: 'Request Type',\n      key: 'reques_type',\n    },\n    {\n      label: 'Transaction Type',\n      key: 'transaction_type',\n    },\n    {\n      label: 'Status',\n      key: 'status',\n    },\n    {\n      label: 'Transaction Hash',\n      key: 'transaction_hash',\n    },\n    {\n      label: 'Contract Address',\n      key: 'contract_address',\n    },\n    {\n      label: 'Timestamp',\n      key: 'transaction_time_stamp',\n    },\n    {\n      label: 'Query Reponse',\n      key: 'query_response',\n    },\n    {\n      label: 'HashScan Explorer',\n      key: 'hashscan_explorer',\n    },\n  ];\n};\n\n/**\n * @dev prepare data object for CSV exporting feature\n */\nexport const prepareCSVData = (transactionList: ITransactionResult[], network: string) => {\n  const queryResponseKeys = [\n    'ownerOf',\n    'tokenURI',\n    'approves',\n    'approves',\n    'balanceOf',\n    'allowances',\n    'ercTokenInfo',\n  ];\n\n  // sort transactionList based on order\n  const sortedTransactionList = transactionList.sort((txA, txB) => {\n    return txA.transactionTimeStamp - txB.transactionTimeStamp;\n  });\n\n  return sortedTransactionList.map((transaction) => {\n    // prepare query responses\n    let queryResponse;\n    queryResponseKeys.forEach((key) => {\n      if ((transaction as any)[key] && transaction.readonly) {\n        queryResponse = JSON.stringify((transaction as any)[key]).replaceAll(',', ';');\n      }\n    });\n\n    return {\n      status: transaction.status,\n      query_response: queryResponse || 'N/A',\n      transaction_type: transaction.transactionType,\n      contract_address: transaction.sessionedContractAddress,\n      reques_type: transaction.readonly ? 'QUERY' : 'TRANSACTION',\n      transaction_hash: transaction.readonly ? 'N/A' : transaction.txHash,\n      transaction_time_stamp: new Date(transaction.transactionTimeStamp).toLocaleString(),\n      hashscan_explorer: transaction.readonly\n        ? 'N/A'\n        : `https://hashscan.io/${network}/transaction/${transaction.txHash}`,\n    };\n  });\n};\n\n/**\n * @dev handles estimating gas\n */\nexport const handleEstimateGas = async (\n  baseContract: Contract,\n  signerAddress: ethers.AddressLike,\n  network: TNetworkName,\n  functionSignature: string,\n  args: any[]\n) => {\n  // prepare arguments for estimateGas()\n  const contractAddress = await baseContract.getAddress();\n\n  const calldata = baseContract.interface.encodeFunctionData(functionSignature, args);\n  const estimateGas = await estimateGasViaMirrorNode(contractAddress, signerAddress, calldata, network);\n  if (!estimateGas.gasLimit || estimateGas.err) return { err: estimateGas.err };\n\n  return { gasLimit: estimateGas.gasLimit };\n};\n",
                "codeOnlyTokens": 1549,
                "startLine": 1,
                "endLine": 227,
                "type": "full_file",
                "isOversized": false
              }
            ],
            "startLine": 1,
            "endLine": 227,
            "groupId": 1
          }
        ],
        "oversizedChunks": [],
        "sendStrategy": "full_file",
        "finalTokenCount": 1574,
        "skippedContent": [],
        "contextHeader": "// File: system-contract-dapp-playground/src/utils/common/helpers.ts\n// Relevant file context:\n// Type: .ts\n",
        "tokenBreakdown": {
          "originalFile": 1549,
          "finalSent": 1574,
          "codeTokensInGroups": 1549,
          "fileHeaderTokensInGroups": 25,
          "shellContextTokensInGroups": 0,
          "separatorTokensInGroups": 0,
          "skippedCodeTokens": 0,
          "unprocessedOversizedTokens": 0,
          "totalSavings": -25,
          "savingsPercentage": -1.6139444803098775,
          "fileHeaderCount": 1,
          "fileHeaderAvgSize": 25,
          "shellContextCount": 0,
          "shellContextAvgSize": 0,
          "separatorCount": 1,
          "separatorAvgSize": 0
        }
      }
    },
    {
      "filePath": "repo_cache/hedera-smart-contracts/system-contract-dapp-playground/src/sections/overview/index.tsx",
      "totalOriginalTokens": 867,
      "finalTokenCount": 895,
      "impactScore": 30.666666666666668,
      "averageComplexity": 4,
      "averageQuality": 7.666666666666667,
      "usage": {
        "prompt_tokens": 1091,
        "completion_tokens": 128,
        "total_tokens": 1219
      },
      "retries": 0,
      "hadError": false,
      "scoredChunkGroups": [
        {
          "groupId": 1,
          "score": {
            "file_path": "system-contract-dapp-playground/src/sections/overview/index.tsx",
            "complexity_score": 4,
            "code_quality_score": 8,
            "maintainability_score": 8,
            "best_practices_adherence": 7,
            "positive_feedback": "Well-structured presentation of Hedera information aids new users in understanding the ecosystem.",
            "improvement_suggestion": "Consider segmenting sections further to enhance usability for new users navigating through details.",
            "group_summary": "An overview section providing information about Hedera and its smart contracts."
          },
          "totalTokens": 895,
          "usage": {
            "prompt_tokens": 1091,
            "completion_tokens": 128,
            "total_tokens": 1219
          }
        }
      ],
      "chunkingDetails": {
        "filePath": "repo_cache/hedera-smart-contracts/system-contract-dapp-playground/src/sections/overview/index.tsx",
        "totalFileTokens": 867,
        "chunks": [
          {
            "originalText": "// SPDX-License-Identifier: Apache-2.0\n\n'use client';\n\nimport Link from 'next/link';\nimport { motion } from 'framer-motion';\nimport { NAV_SIDE_BAR_ITEMS } from '@/utils/common/constants';\n\nconst OverviewSection = () => {\n  return (\n    <motion.section\n      initial={{ opacity: 0 }}\n      whileInView={{ opacity: 1 }}\n      transition={{\n        delay: 0.3,\n        duration: 0.6,\n      }}\n      viewport={{ once: true }}\n      className=\"text-white w-full flex pt-7 pl-7 flex-col gap-9 min-w-[70rem]\"\n    >\n      {/* top part */}\n      <div className=\"flex flex-col gap-6\">\n        {/* Overview */}\n        <h2 className=\"text-[1.88rem] font-medium leading-10\">Overview</h2>\n\n        {/* Hedera Network */}\n        <div>\n          {/* Title */}\n          <div className=\"text-[1.65rem] font-medium\">Hedera Network</div>\n\n          {/* content */}\n          <div className=\"tracking-tight text-white/70\">\n            Hedera is a fully open source public distributed ledger that utilizes the fast, fair, and secure\n            hashgraph consensus. Its network services include Solidity-based smart contracts, as well as\n            native tokenization and consensus services used to build decentralized applications. Learn more\n            about{' '}\n            <Link\n              href={'https://hedera.com/'}\n              target=\"_blank\"\n              className=\"underline text-hedera-purple font-normal\"\n            >\n              Hedera network\n            </Link>\n            !\n          </div>\n        </div>\n\n        {/* Hedera Smart Contract Library */}\n        <div>\n          {/* title */}\n          <div className=\"text-[1.65rem] font-medium\">Hedera Smart Contract Library</div>\n          {/* content */}\n          <div className=\"tracking-tight text-white/70\">\n            Seamlessly scale your projects using Solidity smart contracts on Hedera, taking advantage of its\n            unparalleled efficiency. Curious to explore the inner workings of smart contracts hosted on Dapp\n            Playground? The source code for{' '}\n            <Link\n              href={'https://github.com/hashgraph/hedera-smart-contracts'}\n              target=\"_blank\"\n              className=\"underline text-hedera-purple font-normal\"\n            >\n              Hedera smart contract library\n            </Link>{' '}\n            is readily available on Github, awaiting your delve into its intricacies.\n          </div>\n        </div>\n      </div>\n\n      {/* break line */}\n      <hr className=\"border-t border-white/40\" />\n\n      {/* bottom part */}\n      <div className=\"flex flex-col gap-12 pb-9\">\n        {/* DApp Playground */}\n        <div>\n          {/* title */}\n          <h1 className=\"text-[1.88rem] font-medium leading-10\">DApp Playground</h1>\n          {/* content */}\n          <div className=\"tracking-tight text-white/70\">\n            An intuitively designed interface aimed at highlighting the capabilities of Hedera Network&apos;s\n            system contracts. This revolutionary platform empowers developers to effortlessly deploy and\n            engage with illustrative system contracts, simplifying the task of constructing and resolving\n            issues within decentralized applications.\n          </div>\n        </div>\n\n        {/* buttons */}\n        <div className=\"flex flex-col gap-3\">\n          <div className=\"tracking-tight text-white/70\">Here are the contracts exposed on this platform:</div>\n\n          <div className=\"grid grid-rows-2 grid-cols-3 gap-x-6 gap-y-3\">\n            {NAV_SIDE_BAR_ITEMS.slice(1).map((item) => (\n              <Link\n                key={item.name}\n                href={item.path}\n                className=\"tracking-tighter text-white/70 border border-white/30 text-center py-1 px-6 rounded-xl flex items-center justify-center hover:bg-black/30 transition duration-300\"",
            "codeOnlyTokens": 826,
            "startLine": 1,
            "endLine": 96,
            "type": ".tsx_part_1",
            "isOversized": false
          },
          {
            "originalText": "              >\n                {' '}\n                {item.name}\n              </Link>\n            ))}\n          </div>\n        </div>\n      </div>\n    </motion.section>\n  );\n};\n\nexport default OverviewSection;\n",
            "codeOnlyTokens": 41,
            "startLine": 97,
            "endLine": 110,
            "type": ".tsx_part_2",
            "isOversized": false
          }
        ],
        "groupedChunks": [
          {
            "combinedText": "// File: system-contract-dapp-playground/src/sections/overview/index.tsx\n// Relevant file context:\n// Type: .tsx\n// SPDX-License-Identifier: Apache-2.0\n\n'use client';\n\nimport Link from 'next/link';\nimport { motion } from 'framer-motion';\nimport { NAV_SIDE_BAR_ITEMS } from '@/utils/common/constants';\n\nconst OverviewSection = () => {\n  return (\n    <motion.section\n      initial={{ opacity: 0 }}\n      whileInView={{ opacity: 1 }}\n      transition={{\n        delay: 0.3,\n        duration: 0.6,\n      }}\n      viewport={{ once: true }}\n      className=\"text-white w-full flex pt-7 pl-7 flex-col gap-9 min-w-[70rem]\"\n    >\n      {/* top part */}\n      <div className=\"flex flex-col gap-6\">\n        {/* Overview */}\n        <h2 className=\"text-[1.88rem] font-medium leading-10\">Overview</h2>\n\n        {/* Hedera Network */}\n        <div>\n          {/* Title */}\n          <div className=\"text-[1.65rem] font-medium\">Hedera Network</div>\n\n          {/* content */}\n          <div className=\"tracking-tight text-white/70\">\n            Hedera is a fully open source public distributed ledger that utilizes the fast, fair, and secure\n            hashgraph consensus. Its network services include Solidity-based smart contracts, as well as\n            native tokenization and consensus services used to build decentralized applications. Learn more\n            about{' '}\n            <Link\n              href={'https://hedera.com/'}\n              target=\"_blank\"\n              className=\"underline text-hedera-purple font-normal\"\n            >\n              Hedera network\n            </Link>\n            !\n          </div>\n        </div>\n\n        {/* Hedera Smart Contract Library */}\n        <div>\n          {/* title */}\n          <div className=\"text-[1.65rem] font-medium\">Hedera Smart Contract Library</div>\n          {/* content */}\n          <div className=\"tracking-tight text-white/70\">\n            Seamlessly scale your projects using Solidity smart contracts on Hedera, taking advantage of its\n            unparalleled efficiency. Curious to explore the inner workings of smart contracts hosted on Dapp\n            Playground? The source code for{' '}\n            <Link\n              href={'https://github.com/hashgraph/hedera-smart-contracts'}\n              target=\"_blank\"\n              className=\"underline text-hedera-purple font-normal\"\n            >\n              Hedera smart contract library\n            </Link>{' '}\n            is readily available on Github, awaiting your delve into its intricacies.\n          </div>\n        </div>\n      </div>\n\n      {/* break line */}\n      <hr className=\"border-t border-white/40\" />\n\n      {/* bottom part */}\n      <div className=\"flex flex-col gap-12 pb-9\">\n        {/* DApp Playground */}\n        <div>\n          {/* title */}\n          <h1 className=\"text-[1.88rem] font-medium leading-10\">DApp Playground</h1>\n          {/* content */}\n          <div className=\"tracking-tight text-white/70\">\n            An intuitively designed interface aimed at highlighting the capabilities of Hedera Network&apos;s\n            system contracts. This revolutionary platform empowers developers to effortlessly deploy and\n            engage with illustrative system contracts, simplifying the task of constructing and resolving\n            issues within decentralized applications.\n          </div>\n        </div>\n\n        {/* buttons */}\n        <div className=\"flex flex-col gap-3\">\n          <div className=\"tracking-tight text-white/70\">Here are the contracts exposed on this platform:</div>\n\n          <div className=\"grid grid-rows-2 grid-cols-3 gap-x-6 gap-y-3\">\n            {NAV_SIDE_BAR_ITEMS.slice(1).map((item) => (\n              <Link\n                key={item.name}\n                href={item.path}\n                className=\"tracking-tighter text-white/70 border border-white/30 text-center py-1 px-6 rounded-xl flex items-center justify-center hover:bg-black/30 transition duration-300\"\n              >\n                {' '}\n                {item.name}\n              </Link>\n            ))}\n          </div>\n        </div>\n      </div>\n    </motion.section>\n  );\n};\n\nexport default OverviewSection;\n",
            "totalTokens": 895,
            "chunks": [
              {
                "originalText": "// SPDX-License-Identifier: Apache-2.0\n\n'use client';\n\nimport Link from 'next/link';\nimport { motion } from 'framer-motion';\nimport { NAV_SIDE_BAR_ITEMS } from '@/utils/common/constants';\n\nconst OverviewSection = () => {\n  return (\n    <motion.section\n      initial={{ opacity: 0 }}\n      whileInView={{ opacity: 1 }}\n      transition={{\n        delay: 0.3,\n        duration: 0.6,\n      }}\n      viewport={{ once: true }}\n      className=\"text-white w-full flex pt-7 pl-7 flex-col gap-9 min-w-[70rem]\"\n    >\n      {/* top part */}\n      <div className=\"flex flex-col gap-6\">\n        {/* Overview */}\n        <h2 className=\"text-[1.88rem] font-medium leading-10\">Overview</h2>\n\n        {/* Hedera Network */}\n        <div>\n          {/* Title */}\n          <div className=\"text-[1.65rem] font-medium\">Hedera Network</div>\n\n          {/* content */}\n          <div className=\"tracking-tight text-white/70\">\n            Hedera is a fully open source public distributed ledger that utilizes the fast, fair, and secure\n            hashgraph consensus. Its network services include Solidity-based smart contracts, as well as\n            native tokenization and consensus services used to build decentralized applications. Learn more\n            about{' '}\n            <Link\n              href={'https://hedera.com/'}\n              target=\"_blank\"\n              className=\"underline text-hedera-purple font-normal\"\n            >\n              Hedera network\n            </Link>\n            !\n          </div>\n        </div>\n\n        {/* Hedera Smart Contract Library */}\n        <div>\n          {/* title */}\n          <div className=\"text-[1.65rem] font-medium\">Hedera Smart Contract Library</div>\n          {/* content */}\n          <div className=\"tracking-tight text-white/70\">\n            Seamlessly scale your projects using Solidity smart contracts on Hedera, taking advantage of its\n            unparalleled efficiency. Curious to explore the inner workings of smart contracts hosted on Dapp\n            Playground? The source code for{' '}\n            <Link\n              href={'https://github.com/hashgraph/hedera-smart-contracts'}\n              target=\"_blank\"\n              className=\"underline text-hedera-purple font-normal\"\n            >\n              Hedera smart contract library\n            </Link>{' '}\n            is readily available on Github, awaiting your delve into its intricacies.\n          </div>\n        </div>\n      </div>\n\n      {/* break line */}\n      <hr className=\"border-t border-white/40\" />\n\n      {/* bottom part */}\n      <div className=\"flex flex-col gap-12 pb-9\">\n        {/* DApp Playground */}\n        <div>\n          {/* title */}\n          <h1 className=\"text-[1.88rem] font-medium leading-10\">DApp Playground</h1>\n          {/* content */}\n          <div className=\"tracking-tight text-white/70\">\n            An intuitively designed interface aimed at highlighting the capabilities of Hedera Network&apos;s\n            system contracts. This revolutionary platform empowers developers to effortlessly deploy and\n            engage with illustrative system contracts, simplifying the task of constructing and resolving\n            issues within decentralized applications.\n          </div>\n        </div>\n\n        {/* buttons */}\n        <div className=\"flex flex-col gap-3\">\n          <div className=\"tracking-tight text-white/70\">Here are the contracts exposed on this platform:</div>\n\n          <div className=\"grid grid-rows-2 grid-cols-3 gap-x-6 gap-y-3\">\n            {NAV_SIDE_BAR_ITEMS.slice(1).map((item) => (\n              <Link\n                key={item.name}\n                href={item.path}\n                className=\"tracking-tighter text-white/70 border border-white/30 text-center py-1 px-6 rounded-xl flex items-center justify-center hover:bg-black/30 transition duration-300\"\n              >\n                {' '}\n                {item.name}\n              </Link>\n            ))}\n          </div>\n        </div>\n      </div>\n    </motion.section>\n  );\n};\n\nexport default OverviewSection;\n",
                "codeOnlyTokens": 867,
                "startLine": 1,
                "endLine": 110,
                "type": "full_file",
                "isOversized": false
              }
            ],
            "startLine": 1,
            "endLine": 110,
            "groupId": 1
          }
        ],
        "oversizedChunks": [],
        "sendStrategy": "full_file",
        "finalTokenCount": 895,
        "skippedContent": [],
        "contextHeader": "// File: system-contract-dapp-playground/src/sections/overview/index.tsx\n// Relevant file context:\n// Type: .tsx\n",
        "tokenBreakdown": {
          "originalFile": 867,
          "finalSent": 895,
          "codeTokensInGroups": 867,
          "fileHeaderTokensInGroups": 28,
          "shellContextTokensInGroups": 0,
          "separatorTokensInGroups": 0,
          "skippedCodeTokens": 0,
          "unprocessedOversizedTokens": 0,
          "totalSavings": -28,
          "savingsPercentage": -3.229527104959631,
          "fileHeaderCount": 1,
          "fileHeaderAvgSize": 28,
          "shellContextCount": 0,
          "shellContextAvgSize": 0,
          "separatorCount": 1,
          "separatorAvgSize": 0
        }
      }
    },
    {
      "filePath": "repo_cache/hedera-smart-contracts/contracts/system-contracts/exchange-rate/ExchangeRateSystemContract.sol",
      "totalOriginalTokens": 191,
      "finalTokenCount": 218,
      "impactScore": 28.333333333333336,
      "averageComplexity": 5,
      "averageQuality": 5.666666666666667,
      "usage": {
        "prompt_tokens": 258,
        "completion_tokens": 134,
        "total_tokens": 392
      },
      "retries": 0,
      "hadError": false,
      "scoredChunkGroups": [
        {
          "groupId": 1,
          "score": {
            "file_path": "contracts/system-contracts/exchange-rate/ExchangeRateSystemContract.sol",
            "complexity_score": 5,
            "code_quality_score": 6,
            "maintainability_score": 5,
            "best_practices_adherence": 6,
            "positive_feedback": "Incorporates a cost model for function access, which is a practical approach for managing contract interactions.",
            "improvement_suggestion": "Introduce additional validation checks and fallback mechanisms to improve robustness against invalid calls.",
            "group_summary": "A system contract that manages toll-based access and approximates USD value in Hedera's context."
          },
          "totalTokens": 218,
          "usage": {
            "prompt_tokens": 258,
            "completion_tokens": 134,
            "total_tokens": 392
          }
        }
      ],
      "chunkingDetails": {
        "filePath": "repo_cache/hedera-smart-contracts/contracts/system-contracts/exchange-rate/ExchangeRateSystemContract.sol",
        "totalFileTokens": 191,
        "chunks": [
          {
            "originalText": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.5.0 <0.9.0;\n\nimport \"./SelfFunding.sol\";\n\n\ncontract ExchangeRateSystemContract is SelfFunding {\n    // The USD in cents that must be sent as msg.value\n    uint256 toll;\n\n    constructor(uint256 _toll) {\n        toll = _toll;\n    }\n\n    function gatedAccess() external payable costsCents(toll) {\n        // Hope it was worth it!\n    }\n\n    function approxUsdValue() external payable returns (uint256 tinycents) {\n        tinycents = tinybarsToTinycents(msg.value);\n    }\n\n    function invalidCall() external payable {\n        // Should fail, this is not a valid selector \n        (bool success, ) = PRECOMPILE_ADDRESS.call(\n            abi.encodeWithSelector(ExchangeRateSystemContract.approxUsdValue.selector));\n        require(success);\n    }\n}\n",
            "codeOnlyTokens": 191,
            "startLine": 1,
            "endLine": 30,
            "type": ".sol",
            "isOversized": false
          }
        ],
        "groupedChunks": [
          {
            "combinedText": "// File: contracts/system-contracts/exchange-rate/ExchangeRateSystemContract.sol\n// Relevant file context:\n// Type: .sol\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.5.0 <0.9.0;\n\nimport \"./SelfFunding.sol\";\n\n\ncontract ExchangeRateSystemContract is SelfFunding {\n    // The USD in cents that must be sent as msg.value\n    uint256 toll;\n\n    constructor(uint256 _toll) {\n        toll = _toll;\n    }\n\n    function gatedAccess() external payable costsCents(toll) {\n        // Hope it was worth it!\n    }\n\n    function approxUsdValue() external payable returns (uint256 tinycents) {\n        tinycents = tinybarsToTinycents(msg.value);\n    }\n\n    function invalidCall() external payable {\n        // Should fail, this is not a valid selector \n        (bool success, ) = PRECOMPILE_ADDRESS.call(\n            abi.encodeWithSelector(ExchangeRateSystemContract.approxUsdValue.selector));\n        require(success);\n    }\n}\n",
            "totalTokens": 218,
            "chunks": [
              {
                "originalText": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.5.0 <0.9.0;\n\nimport \"./SelfFunding.sol\";\n\n\ncontract ExchangeRateSystemContract is SelfFunding {\n    // The USD in cents that must be sent as msg.value\n    uint256 toll;\n\n    constructor(uint256 _toll) {\n        toll = _toll;\n    }\n\n    function gatedAccess() external payable costsCents(toll) {\n        // Hope it was worth it!\n    }\n\n    function approxUsdValue() external payable returns (uint256 tinycents) {\n        tinycents = tinybarsToTinycents(msg.value);\n    }\n\n    function invalidCall() external payable {\n        // Should fail, this is not a valid selector \n        (bool success, ) = PRECOMPILE_ADDRESS.call(\n            abi.encodeWithSelector(ExchangeRateSystemContract.approxUsdValue.selector));\n        require(success);\n    }\n}\n",
                "codeOnlyTokens": 191,
                "startLine": 1,
                "endLine": 30,
                "type": "full_file",
                "isOversized": false
              }
            ],
            "startLine": 1,
            "endLine": 30,
            "groupId": 1
          }
        ],
        "oversizedChunks": [],
        "sendStrategy": "full_file",
        "finalTokenCount": 218,
        "skippedContent": [],
        "contextHeader": "// File: contracts/system-contracts/exchange-rate/ExchangeRateSystemContract.sol\n// Relevant file context:\n// Type: .sol\n",
        "tokenBreakdown": {
          "originalFile": 191,
          "finalSent": 218,
          "codeTokensInGroups": 191,
          "fileHeaderTokensInGroups": 27,
          "shellContextTokensInGroups": 0,
          "separatorTokensInGroups": 0,
          "skippedCodeTokens": 0,
          "unprocessedOversizedTokens": 0,
          "totalSavings": -27,
          "savingsPercentage": -14.136125654450263,
          "fileHeaderCount": 1,
          "fileHeaderAvgSize": 27,
          "shellContextCount": 0,
          "shellContextAvgSize": 0,
          "separatorCount": 1,
          "separatorAvgSize": 0
        }
      }
    },
    {
      "filePath": "repo_cache/hedera-smart-contracts/system-contract-dapp-playground/src/app/page.tsx",
      "totalOriginalTokens": 75,
      "finalTokenCount": 100,
      "impactScore": 17.333333333333332,
      "averageComplexity": 2,
      "averageQuality": 8.666666666666666,
      "usage": {
        "prompt_tokens": 122,
        "completion_tokens": 128,
        "total_tokens": 250
      },
      "retries": 0,
      "hadError": false,
      "scoredChunkGroups": [
        {
          "groupId": 1,
          "score": {
            "file_path": "system-contract-dapp-playground/src/app/page.tsx",
            "complexity_score": 2,
            "code_quality_score": 9,
            "maintainability_score": 9,
            "best_practices_adherence": 8,
            "positive_feedback": "Clean organization of components allows for straightforward layout management.",
            "improvement_suggestion": "Consider abstracting layout components to enable better reuse across different pages.",
            "group_summary": "The main application page orchestrating navigation and content layout for the dApp."
          },
          "totalTokens": 100,
          "usage": {
            "prompt_tokens": 122,
            "completion_tokens": 128,
            "total_tokens": 250
          }
        }
      ],
      "chunkingDetails": {
        "filePath": "repo_cache/hedera-smart-contracts/system-contract-dapp-playground/src/app/page.tsx",
        "totalFileTokens": 75,
        "chunks": [
          {
            "originalText": "// SPDX-License-Identifier: Apache-2.0\n\nimport Footer from '@/components/footer';\nimport Navbar from '@/components/navbar';\nimport LandingPage from '@/sections/landing';\n\nexport default function Home() {\n  return (\n    <main className=\"h-screen flex flex-col\">\n      <Navbar />\n      <LandingPage />;\n      <Footer />\n    </main>\n  );\n}\n",
            "codeOnlyTokens": 75,
            "startLine": 1,
            "endLine": 16,
            "type": ".tsx",
            "isOversized": false
          }
        ],
        "groupedChunks": [
          {
            "combinedText": "// File: system-contract-dapp-playground/src/app/page.tsx\n// Relevant file context:\n// Type: .tsx\n// SPDX-License-Identifier: Apache-2.0\n\nimport Footer from '@/components/footer';\nimport Navbar from '@/components/navbar';\nimport LandingPage from '@/sections/landing';\n\nexport default function Home() {\n  return (\n    <main className=\"h-screen flex flex-col\">\n      <Navbar />\n      <LandingPage />;\n      <Footer />\n    </main>\n  );\n}\n",
            "totalTokens": 100,
            "chunks": [
              {
                "originalText": "// SPDX-License-Identifier: Apache-2.0\n\nimport Footer from '@/components/footer';\nimport Navbar from '@/components/navbar';\nimport LandingPage from '@/sections/landing';\n\nexport default function Home() {\n  return (\n    <main className=\"h-screen flex flex-col\">\n      <Navbar />\n      <LandingPage />;\n      <Footer />\n    </main>\n  );\n}\n",
                "codeOnlyTokens": 75,
                "startLine": 1,
                "endLine": 16,
                "type": "full_file",
                "isOversized": false
              }
            ],
            "startLine": 1,
            "endLine": 16,
            "groupId": 1
          }
        ],
        "oversizedChunks": [],
        "sendStrategy": "full_file",
        "finalTokenCount": 100,
        "skippedContent": [],
        "contextHeader": "// File: system-contract-dapp-playground/src/app/page.tsx\n// Relevant file context:\n// Type: .tsx\n",
        "tokenBreakdown": {
          "originalFile": 75,
          "finalSent": 100,
          "codeTokensInGroups": 75,
          "fileHeaderTokensInGroups": 25,
          "shellContextTokensInGroups": 0,
          "separatorTokensInGroups": 0,
          "skippedCodeTokens": 0,
          "unprocessedOversizedTokens": 0,
          "totalSavings": -25,
          "savingsPercentage": -33.33333333333333,
          "fileHeaderCount": 1,
          "fileHeaderAvgSize": 25,
          "shellContextCount": 0,
          "shellContextAvgSize": 0,
          "separatorCount": 1,
          "separatorAvgSize": 0
        }
      }
    }
  ],
  "finalProjectScore": 8.531582146063732,
  "finalReview": {
    "model": "gemini-2.5-pro",
    "dossierBudget": 16000,
    "strategy": "top_impact_per_file",
    "filesSentForFinalEval": [
      "repo_cache/hedera-smart-contracts/scripts/hedera-response-codes-protobuf-parser.js",
      "repo_cache/hedera-smart-contracts/contracts/system-contracts/hedera-token-service/IHederaTokenService.sol",
      "repo_cache/hedera-smart-contracts/contracts/system-contracts/hedera-token-service/HederaTokenService.sol",
      "repo_cache/hedera-smart-contracts/system-contract-dapp-playground/src/api/hedera/hts-interactions/tokenQuery-interactions/index.ts",
      "repo_cache/hedera-smart-contracts/system-contract-dapp-playground/src/api/hedera/hts-interactions/tokenCreateCustom-interactions/index.ts",
      "repo_cache/hedera-smart-contracts/system-contract-dapp-playground/src/api/hedera/hts-interactions/tokenTransfer-interactions/index.ts",
      "repo_cache/hedera-smart-contracts/system-contract-dapp-playground/src/api/hedera/index.ts",
      "repo_cache/hedera-smart-contracts/contracts/system-contracts/hedera-account-service/IHederaAccountService.sol",
      "repo_cache/hedera-smart-contracts/system-contract-dapp-playground/src/components/navbar/index.tsx",
      "repo_cache/hedera-smart-contracts/system-contract-dapp-playground/src/app/page.tsx"
    ],
    "usage": {
      "prompt_tokens": 19694,
      "completion_tokens": 3930,
      "total_tokens": 23624
    },
    "multiplier": 1.18,
    "final_score_multiplier": 1.18,
    "reasoning": {
      "multiplier_justification": "The initial automated score significantly undervalued the project's deep adherence to Hedera-specific development patterns. The candidate demonstrates mastery of critical, non-obvious concepts such as parsing emitted events for return data from precompile calls, correctly handling Hedera's 32-byte address format in a 20-byte EVM context, and implementing dynamic client-side gas estimation. The utility script for auto-generating Solidity constants from the official protobuf definitions is a mark of a principal architect focused on maintainability and accuracy, justifying a substantial score increase.",
      "security_assessment": "The on-chain security posture is excellent. The smart contracts are stateless wrappers around Hedera's native precompiles, which effectively outsources the core security model to the Hedera platform itself. This design minimizes the attack surface, leaving no room for common vulnerabilities like re-entrancy, access control flaws, or state manipulation bugs within the contract code. The use of `internal` visibility for precompile-calling functions is a correct and secure pattern, ensuring that inheriting contracts have full control over exposure and access. The off-chain code includes robust input validation, preventing malformed data from being sent in transactions.",
      "gas_efficiency_assessment": "The project demonstrates optimal gas efficiency. On-chain, the use of direct low-level `call`s to precompile addresses is the most efficient method possible for invoking HTS and HAS functions from a smart contract. The abstract contract pattern allows for direct integration into other contracts, avoiding the overhead of external calls. Off-chain, the implementation of a dynamic `handleEstimateGas` utility function is a standout feature, ensuring transactions are submitted with an appropriate gas limit, which reduces costs for users and minimizes transaction failures.",
      "sdk_and_hts_usage_assessment": "The candidate's use of the SDK (ethers.js in this context) and interaction with HTS is exemplary and demonstrates true Hedera expertise. The client-side TypeScript code correctly constructs complex structs required by the HTS precompiles, manages transaction lifecycle, and properly interprets results. Crucially, the code correctly retrieves transaction outputs by parsing event logs rather than looking for direct return values—a fundamental concept in Hedera precompile interaction that many developers miss. This, combined with meticulous error handling and parameter sanitization, shows a production-ready approach to dApp development on Hedera.",
      "context_sufficiency_assessment": "The provided dossier was highly sufficient, offering a clear view into the smart contracts, client-side interaction logic, and utility scripts. However, the single most helpful additional file would have been the `hardhat.config.js` (or `.ts`). This configuration file would have provided definitive insight into the project's build, test, and deployment pipeline, including compiler versions, network endpoints, and any custom scripts, completing the architectural overview."
    },
    "refined_tech_stack": [
      "Hedera Token Service (HTS)",
      "Hedera Account Service (HAS)",
      "Hedera Precompiled Contracts",
      "Solidity",
      "Hardhat",
      "Ethers.js",
      "TypeScript",
      "Next.js",
      "React",
      "Node.js",
      "Protobuf.js",
      "Chakra UI"
    ],
    "holistic_project_summary": "This is a polished and architecturally sound project that serves as both a high-quality reference library and a functional dApp playground for the Hedera network. The candidate exhibits a deep, practical understanding of Hedera-specific smart contract development, producing code that is secure, efficient, and exceptionally well-documented. The project is a valuable asset that expertly bridges the gap between traditional EVM development and the unique features of Hedera.",
    "groupsInDossier": 10,
    "dossierCode": "\n\n// --- From File: repo_cache/hedera-smart-contracts/scripts/hedera-response-codes-protobuf-parser.js (Top Group #1) ---\n// Initial Score: { Complexity: 8, Quality: 8.3 }\n// File: scripts/hedera-response-codes-protobuf-parser.js\n// Relevant file context:\n// Type: .js\n// SPDX-License-Identifier: Apache-2.0\n\nconst fs = require('fs');\nconst axios = require('axios');\nconst protobufjs = require('protobufjs');\n\nasync function main() {\n  const version = (await axios.get('https://raw.githubusercontent.com/hashgraph/hedera-services/refs/heads/main/version.txt')).data.replace('\\n', '');\n  const res = (await axios.get('https://raw.githubusercontent.com/hashgraph/hedera-services/refs/heads/main/hapi/hedera-protobufs/services/response_code.proto')).data;\n  const parsedProto = protobufjs.parse(res, {\n    keepCase: true,\n    alternateCommentMode: true,\n    preferTrailingComment: true\n  });\n  const responseCodes = parsedProto.root.nested.proto.nested.ResponseCodeEnum;\n\n  let contract =\n      `// SPDX-License-Identifier: Apache-2.0\\n` +\n      `pragma solidity >=0.4.9 <0.9.0;\\n` +\n      `\\n// this contract is auto-generated by a manual triggered script in utils/hedera-response-codes-protobuf-parser.js` +\n      `\\n// the generated contract is using hedera response codes from services version ${version}` +\n      `\\n// https://github.com/hashgraph/hedera-services/blob/main/hapi/hedera-protobufs/services/response_code.proto\\n\\n` +\n      `library HederaResponseCodes {\\n`;\n  for (const [name, code] of Object.entries(responseCodes.values)) {\n    const comment = responseCodes?.comments[name];\n    if (comment) {\n      contract += `    /// ${comment.replaceAll('\\n', ' ') ?? ''}\\n`;\n    }\n    contract += `    int32 internal constant ${name} = ${code};\\n\\n`;\n  }\n  contract += '}\\n';\n\n  console.log(`The generated contract is using hedera response codes from services version ${version}`);\n\n  fs.writeFileSync('./contracts/system-contracts/HederaResponseCodes.sol', contract);\n}\n\nmain();\n\n\n// --- From File: repo_cache/hedera-smart-contracts/contracts/system-contracts/hedera-token-service/IHederaTokenService.sol (Top Group #1) ---\n// Initial Score: { Complexity: 8, Quality: 7.7 }\n// File: contracts/system-contracts/hedera-token-service/IHederaTokenService.sol\n// Relevant file context:\n// Type: .sol\n\n\n// --- Next chunk ---\n\n// Lines 1-74 (.sol_part_1)\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.9 <0.9.0;\npragma experimental ABIEncoderV2;\n\ninterface IHederaTokenService {\n    /// Transfers cryptocurrency among two or more accounts by making the desired adjustments to their\n    /// balances. Each transfer list can specify up to 10 adjustments. Each negative amount is withdrawn\n    /// from the corresponding account (a sender), and each positive one is added to the corresponding\n    /// account (a receiver). The amounts list must sum to zero. Each amount is a number of tinybars\n    /// (there are 100,000,000 tinybars in one hbar).  If any sender account fails to have sufficient\n    /// hbars, then the entire transaction fails, and none of those transfers occur, though the\n    /// transaction fee is still charged. This transaction must be signed by the keys for all the sending\n    /// accounts, and for any receiving accounts that have receiverSigRequired == true. The signatures\n    /// are in the same order as the accounts, skipping those accounts that don't need a signature.\n    /// @custom:version 0.3.0 previous version did not include isApproval\n    struct AccountAmount {\n        // The Account ID, as a solidity address, that sends/receives cryptocurrency or tokens\n        address accountID;\n\n        // The amount of  the lowest denomination of the given token that\n        // the account sends(negative) or receives(positive)\n        int64 amount;\n\n        // If true then the transfer is expected to be an approved allowance and the\n        // accountID is expected to be the owner. The default is false (omitted).\n        bool isApproval;\n    }\n\n    /// A sender account, a receiver account, and the serial number of an NFT of a Token with\n    /// NON_FUNGIBLE_UNIQUE type. When minting NFTs the sender will be the default AccountID instance\n    /// (0.0.0 aka 0x0) and when burning NFTs, the receiver will be the default AccountID instance.\n    /// @custom:version 0.3.0 previous version did not include isApproval\n    struct NftTransfer {\n        // The solidity address of the sender\n        address senderAccountID;\n\n        // The solidity address of the receiver\n        address receiverAccountID;\n\n        // The serial number of the NFT\n        int64 serialNumber;\n\n        // If true then the transfer is expected to be an approved allowance and the\n        // accountID is expected to be the owner. The default is false (omitted).\n        bool isApproval;\n    }\n\n    struct TokenTransferList {\n        // The ID of the token as a solidity address\n        address token;\n\n        // Applicable to tokens of type FUNGIBLE_COMMON. Multiple list of AccountAmounts, each of which\n        // has an account and amount.\n        AccountAmount[] transfers;\n\n        // Applicable to tokens of type NON_FUNGIBLE_UNIQUE. Multiple list of NftTransfers, each of\n        // which has a sender and receiver account, including the serial number of the NFT\n        NftTransfer[] nftTransfers;\n    }\n\n    struct TransferList {\n        // Multiple list of AccountAmounts, each of which has an account and amount.\n        // Used to transfer hbars between the accounts in the list.\n        AccountAmount[] transfers;\n    }\n\n    /// Expiry properties of a Hedera token - second, autoRenewAccount, autoRenewPeriod\n    struct Expiry {\n        // The epoch second at which the token should expire; if an auto-renew account and period are\n        // specified, this is coerced to the current epoch second plus the autoRenewPeriod\n        int64 second;\n\n        // ID of an account which will be automatically charged to renew the token's expiration, at\n        // autoRenewPeriod interval, expressed as a solidity address\n\n// --- Next chunk ---\n\n// Lines 75-145 (.sol_part_2)\n        address autoRenewAccount;\n\n        // The interval at which the auto-renew account will be charged to extend the token's expiry\n        int64 autoRenewPeriod;\n    }\n\n    /// A Key can be a public key from either the Ed25519 or ECDSA(secp256k1) signature schemes, where\n    /// in the ECDSA(secp256k1) case we require the 33-byte compressed form of the public key. We call\n    /// these public keys <b>primitive keys</b>.\n    /// A Key can also be the ID of a smart contract instance, which is then authorized to perform any\n    /// precompiled contract action that requires this key to sign.\n    /// Note that when a Key is a smart contract ID, it <i>doesn't</i> mean the contract with that ID\n    /// will actually create a cryptographic signature. It only means that when the contract calls a\n    /// precompiled contract, the resulting \"child transaction\" will be authorized to perform any action\n    /// controlled by the Key.\n    /// Exactly one of the possible values should be populated in order for the Key to be valid.\n    struct KeyValue {\n\n        // if set to true, the key of the calling Hedera account will be inherited as the token key\n        bool inheritAccountKey;\n\n        // smart contract instance that is authorized as if it had signed with a key\n        address contractId;\n\n        // Ed25519 public key bytes\n        bytes ed25519;\n\n        // Compressed ECDSA(secp256k1) public key bytes\n        bytes ECDSA_secp256k1;\n\n        // A smart contract that, if the recipient of the active message frame, should be treated\n        // as having signed. (Note this does not mean the <i>code being executed in the frame</i>\n        // will belong to the given contract, since it could be running another contract's code via\n        // <tt>delegatecall</tt>. So setting this key is a more permissive version of setting the\n        // contractID key, which also requires the code in the active message frame belong to the\n        // the contract with the given id.)\n        address delegatableContractId;\n    }\n\n    /// A list of token key types the key should be applied to and the value of the key\n    struct TokenKey {\n\n        // bit field representing the key type. Keys of all types that have corresponding bits set to 1\n        // will be created for the token.\n        // 0th bit: adminKey\n        // 1st bit: kycKey\n        // 2nd bit: freezeKey\n        // 3rd bit: wipeKey\n        // 4th bit: supplyKey\n        // 5th bit: feeScheduleKey\n        // 6th bit: pauseKey\n        // 7th bit: ignored\n        uint keyType;\n\n        // the value that will be set to the key type\n        KeyValue key;\n    }\n\n    /// Basic properties of a Hedera Token - name, symbol, memo, tokenSupplyType, maxSupply,\n    /// treasury, freezeDefault. These properties are related both to Fungible and NFT token types.\n    struct HederaToken {\n        // The publicly visible name of the token. The token name is specified as a Unicode string.\n        // Its UTF-8 encoding cannot exceed 100 bytes, and cannot contain the 0 byte (NUL).\n        string name;\n\n        // The publicly visible token symbol. The token symbol is specified as a Unicode string.\n        // Its UTF-8 encoding cannot exceed 100 bytes, and cannot contain the 0 byte (NUL).\n        string symbol;\n\n        // The ID of the account which will act as a treasury for the token as a solidity address.\n        // This account will receive the specified initial supply or the newly minted NFTs in\n\n// --- Next chunk ---\n\n// Lines 146-252 (.sol_part_3)\n        // the case for NON_FUNGIBLE_UNIQUE Type\n        address treasury;\n\n        // The memo associated with the token (UTF-8 encoding max 100 bytes)\n        string memo;\n\n        // IWA compatibility. Specified the token supply type. Defaults to INFINITE\n        bool tokenSupplyType;\n\n        // IWA Compatibility. Depends on TokenSupplyType. For tokens of type FUNGIBLE_COMMON - the\n        // maximum number of tokens that can be in circulation. For tokens of type NON_FUNGIBLE_UNIQUE -\n        // the maximum number of NFTs (serial numbers) that can be minted. This field can never be changed!\n        int64 maxSupply;\n\n        // The default Freeze status (frozen or unfrozen) of Hedera accounts relative to this token. If\n        // true, an account must be unfrozen before it can receive the token\n        bool freezeDefault;\n\n        // list of keys to set to the token\n        TokenKey[] tokenKeys;\n\n        // expiry properties of a Hedera token - second, autoRenewAccount, autoRenewPeriod\n        Expiry expiry;\n    }\n\n    /// Additional post creation fungible and non fungible properties of a Hedera Token.\n    struct TokenInfo {\n        /// Basic properties of a Hedera Token\n        HederaToken token;\n\n        /// The number of tokens (fungible) or serials (non-fungible) of the token\n        int64 totalSupply;\n\n        /// Specifies whether the token is deleted or not\n        bool deleted;\n\n        /// Specifies whether the token kyc was defaulted with KycNotApplicable (true) or Revoked (false)\n        bool defaultKycStatus;\n\n        /// Specifies whether the token is currently paused or not\n        bool pauseStatus;\n\n        /// The fixed fees collected when transferring the token\n        FixedFee[] fixedFees;\n\n        /// The fractional fees collected when transferring the token\n        FractionalFee[] fractionalFees;\n\n        /// The royalty fees collected when transferring the token\n        RoyaltyFee[] royaltyFees;\n\n        /// The ID of the network ledger\n        string ledgerId;\n    }\n\n    /// Additional fungible properties of a Hedera Token.\n    struct FungibleTokenInfo {\n        /// The shared hedera token info\n        TokenInfo tokenInfo;\n\n        /// The number of decimal places a token is divisible by\n        int32 decimals;\n    }\n\n    /// Additional non fungible properties of a Hedera Token.\n    struct NonFungibleTokenInfo {\n        /// The shared hedera token info\n        TokenInfo tokenInfo;\n\n        /// The serial number of the nft\n        int64 serialNumber;\n\n        /// The account id specifying the owner of the non fungible token\n        address ownerId;\n\n        /// The epoch second at which the token was created.\n        int64 creationTime;\n\n        /// The unique metadata of the NFT\n        bytes metadata;\n\n        /// The account id specifying an account that has been granted spending permissions on this nft\n        address spenderId;\n    }\n\n    /// A fixed number of units (hbar or token) to assess as a fee during a transfer of\n    /// units of the token to which this fixed fee is attached. The denomination of\n    /// the fee depends on the values of tokenId, useHbarsForPayment and\n    /// useCurrentTokenForPayment. Exactly one of the values should be set.\n    struct FixedFee {\n\n        int64 amount;\n\n        // Specifies ID of token that should be used for fixed fee denomination\n        address tokenId;\n\n        // Specifies this fixed fee should be denominated in Hbar\n        bool useHbarsForPayment;\n\n        // Specifies this fixed fee should be denominated in the Token currently being created\n        bool useCurrentTokenForPayment;\n\n        // The ID of the account to receive the custom fee, expressed as a solidity address\n        address feeCollector;\n    }\n\n    /// A fraction of the transferred units of a token to assess as a fee. The amount assessed will never\n\n// --- From File: repo_cache/hedera-smart-contracts/contracts/system-contracts/hedera-token-service/HederaTokenService.sol (Top Group #1) ---\n// Initial Score: { Complexity: 8, Quality: 7.0 }\n// File: contracts/system-contracts/hedera-token-service/HederaTokenService.sol\n// Relevant file context:\n// Type: .sol\n\n\n// --- Next chunk ---\n\n// Lines 1-65 (.sol_part_1)\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.5.0 <0.9.0;\npragma experimental ABIEncoderV2;\n\nimport \"../HederaResponseCodes.sol\";\nimport \"./IHederaTokenService.sol\";\n\nabstract contract HederaTokenService {\n    address constant precompileAddress = address(0x167);\n    // 90 days in seconds\n    int32 constant defaultAutoRenewPeriod = 7776000;\n\n    modifier nonEmptyExpiry(IHederaTokenService.HederaToken memory token)\n    {\n        if (token.expiry.second == 0 && token.expiry.autoRenewPeriod == 0) {\n            token.expiry.autoRenewPeriod = defaultAutoRenewPeriod;\n        }\n        _;\n    }\n\n    /// Generic event\n    event CallResponseEvent(bool, bytes);\n\n    /// Performs transfers among combinations of tokens and hbars\n    /// @param transferList the list of hbar transfers to do\n    /// @param tokenTransfers the list of transfers to do\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @custom:version 0.3.0 the signature of the previous version was cryptoTransfer(TokenTransferList[] memory tokenTransfers)\n    function cryptoTransfer(IHederaTokenService.TransferList memory transferList, IHederaTokenService.TokenTransferList[] memory tokenTransfers) internal\n    returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.cryptoTransfer.selector, transferList, tokenTransfers));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Mints an amount of the token to the defined treasury account\n    /// @param token The token for which to mint tokens. If token does not exist, transaction results in\n    ///              INVALID_TOKEN_ID\n    /// @param amount Applicable to tokens of type FUNGIBLE_COMMON. The amount to mint to the Treasury Account.\n    ///               Amount must be a positive non-zero number represented in the lowest denomination of the\n    ///               token. The new supply must be lower than 2^63.\n    /// @param metadata Applicable to tokens of type NON_FUNGIBLE_UNIQUE. A list of metadata that are being created.\n    ///                 Maximum allowed size of each metadata is 100 bytes\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return newTotalSupply The new supply of tokens. For NFTs it is the total count of NFTs\n    /// @return serialNumbers If the token is an NFT the newly generate serial numbers, otherwise empty.\n    function mintToken(address token, int64 amount, bytes[] memory metadata) internal\n    returns (int responseCode, int64 newTotalSupply, int64[] memory serialNumbers)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.mintToken.selector,\n            token, amount, metadata));\n        (responseCode, newTotalSupply, serialNumbers) =\n        success\n        ? abi.decode(result, (int32, int64, int64[]))\n        : (HederaResponseCodes.UNKNOWN, int64(0), new int64[](0));\n    }\n\n    /// Burns an amount of the token from the defined treasury account\n    /// @param token The token for which to burn tokens. If token does not exist, transaction results in\n    ///              INVALID_TOKEN_ID\n    /// @param amount  Applicable to tokens of type FUNGIBLE_COMMON. The amount to burn from the Treasury Account.\n    ///                Amount must be a positive non-zero number, not bigger than the token balance of the treasury\n    ///                account (0; balance], represented in the lowest denomination.\n\n// --- Next chunk ---\n\n// Lines 66-119 (.sol_part_2)\n    /// @param serialNumbers Applicable to tokens of type NON_FUNGIBLE_UNIQUE. The list of serial numbers to be burned.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return newTotalSupply The new supply of tokens. For NFTs it is the total count of NFTs\n    function burnToken(address token, int64 amount, int64[] memory serialNumbers) internal\n    returns (int responseCode, int64 newTotalSupply)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.burnToken.selector,\n            token, amount, serialNumbers));\n        (responseCode, newTotalSupply) =\n        success\n        ? abi.decode(result, (int32, int64))\n        : (HederaResponseCodes.UNKNOWN, int64(0));\n    }\n\n    ///  Associates the provided account with the provided tokens. Must be signed by the provided\n    ///  Account's key or called from the accounts contract key\n    ///  If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.\n    ///  If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.\n    ///  If any of the provided tokens is not found, the transaction will resolve to INVALID_TOKEN_REF.\n    ///  If any of the provided tokens has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.\n    ///  If an association between the provided account and any of the tokens already exists, the\n    ///  transaction will resolve to TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT.\n    ///  If the provided account's associations count exceed the constraint of maximum token associations\n    ///    per account, the transaction will resolve to TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED.\n    ///  On success, associations between the provided account and tokens are made and the account is\n    ///    ready to interact with the tokens.\n    /// @param account The account to be associated with the provided tokens\n    /// @param tokens The tokens to be associated with the provided account. In the case of NON_FUNGIBLE_UNIQUE\n    ///               Type, once an account is associated, it can hold any number of NFTs (serial numbers) of that\n    ///               token type\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function associateTokens(address account, address[] memory tokens) internal returns (int responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.associateTokens.selector,\n            account, tokens));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    function associateToken(address account, address token) internal returns (int responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.associateToken.selector,\n            account, token));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Dissociates the provided account with the provided tokens. Must be signed by the provided\n    /// Account's key.\n    /// If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.\n    /// If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.\n    /// If any of the provided tokens is not found, the transaction will resolve to INVALID_TOKEN_REF.\n    /// If any of the provided tokens has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.\n    /// If an association between the provided account and any of the tokens does not exist, the\n    /// transaction will resolve to TOKEN_NOT_ASSOCIATED_TO_ACCOUNT.\n\n// --- Next chunk ---\n\n// Lines 120-177 (.sol_part_3)\n    /// If a token has not been deleted and has not expired, and the user has a nonzero balance, the\n    /// transaction will resolve to TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES.\n    /// If a <b>fungible token</b> has expired, the user can disassociate even if their token balance is\n    /// not zero.\n    /// If a <b>non fungible token</b> has expired, the user can <b>not</b> disassociate if their token\n    /// balance is not zero. The transaction will resolve to TRANSACTION_REQUIRED_ZERO_TOKEN_BALANCES.\n    /// On success, associations between the provided account and tokens are removed.\n    /// @param account The account to be dissociated from the provided tokens\n    /// @param tokens The tokens to be dissociated from the provided account.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function dissociateTokens(address account, address[] memory tokens) internal returns (int responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.dissociateTokens.selector,\n            account, tokens));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    function dissociateToken(address account, address token) internal returns (int responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.dissociateToken.selector,\n            account, token));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Creates a Fungible Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @param initialTotalSupply Specifies the initial supply of tokens to be put in circulation. The\n    /// initial supply is sent to the Treasury Account. The supply is in the lowest denomination possible.\n    /// @param decimals the number of decimal places a token is divisible by\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createFungibleToken(\n        IHederaTokenService.HederaToken memory token,\n        int64 initialTotalSupply,\n        int32 decimals) nonEmptyExpiry(token)\n    internal returns (int responseCode, address tokenAddress) {\n        (bool success, bytes memory result) = precompileAddress.call{value : msg.value}(\n            abi.encodeWithSelector(IHederaTokenService.createFungibleToken.selector,\n            token, initialTotalSupply, decimals));\n\n\n        (responseCode, tokenAddress) = success ? abi.decode(result, (int32, address)) : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Creates a Fungible Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @param initialTotalSupply Specifies the initial supply of tokens to be put in circulation. The\n    /// initial supply is sent to the Treasury Account. The supply is in the lowest denomination possible.\n    /// @param decimals the number of decimal places a token is divisible by\n    /// @param fixedFees list of fixed fees to apply to the token\n    /// @param fractionalFees list of fractional fees to apply to the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createFungibleTokenWithCustomFees(\n        IHederaTokenService.HederaToken memory token,\n        int64 initialTotalSupply,\n        int32 decimals,\n        IHederaTokenService.FixedFee[] memory fixedFees,\n\n// --- From File: repo_cache/hedera-smart-contracts/system-contract-dapp-playground/src/api/hedera/hts-interactions/tokenQuery-interactions/index.ts (Top Group #1) ---\n// Initial Score: { Complexity: 7, Quality: 7.7 }\n// File: system-contract-dapp-playground/src/api/hedera/hts-interactions/tokenQuery-interactions/index.ts\n// Relevant file context:\n// Type: .ts\n\n\n// --- Next chunk ---\n\n// Lines 1-108 (.ts_part_1)\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Contract, ethers, isAddress } from 'ethers';\nimport { ISmartContractExecutionResult } from '@/types/contract-interactions/shared';\nimport { KEY_TYPE_MAP } from '@/utils/contract-interactions/HTS/token-create-custom/constant';\nimport {\n  convertsArgsProxyToHTSSpecificInfo,\n  convertsArgsProxyToHTSTokenInfo,\n  handleContractResponseWithDynamicEventNames,\n} from '@/utils/contract-interactions/HTS/helpers';\nimport { TNetworkName } from '@/types/common';\nimport { handleEstimateGas } from '@/utils/common/helpers';\n\n/**\n * @dev queries token validity\n *\n * @dev integrates TokenQueryContract.isTokenPublic()\n *\n * @param baseContract: ethers.Contract\n *\n * @param signerAddress: ethers.AddressLike\n *\n * @param network: TNetworkName\n *\n * @param hederaTokenAddress: ethers.AddressLike\n *\n * @param gasLimit: number\n *\n * @return Promise<ISmartContractExecutionResult>\n */\nexport const queryTokenValidity = async (\n  baseContract: Contract,\n  signerAddress: ethers.AddressLike,\n  network: TNetworkName,\n  hederaTokenAddress: ethers.AddressLike,\n  gasLimit: number\n): Promise<ISmartContractExecutionResult> => {\n  // sanitize param\n  if (!isAddress(hederaTokenAddress)) {\n    console.error('Invalid token address');\n    return { err: 'Invalid token address' };\n  }\n\n  try {\n    if (gasLimit === 0) {\n      const estimateGasResult = await handleEstimateGas(\n        baseContract,\n        signerAddress,\n        network,\n        'isTokenPublic',\n        [hederaTokenAddress]\n      );\n      if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n      gasLimit = estimateGasResult.gasLimit;\n    }\n\n    const transactionResult = await baseContract.isTokenPublic(hederaTokenAddress, { gasLimit });\n    // get transaction receipt\n    const txReceipt = await transactionResult.wait();\n\n    // retrieve information from event\n    const { data } = txReceipt.logs.filter((event: any) => event.fragment.name === 'IsToken')[0];\n    return { IsToken: data, transactionHash: txReceipt.hash };\n  } catch (err: any) {\n    console.error(err);\n    return { err, transactionHash: err.receipt && err.receipt.hash };\n  }\n};\n\n/**\n * @dev queries token general information\n *\n * @dev integrates TokenQueryContract.getTokenInfoPublic()\n *\n * @dev integrates TokenQueryContract.getFungibleTokenInfoPublic()\n *\n * @dev integrates TokenQueryContract.getNonFungibleTokenInfoPublic()\n *\n * @param baseContract: ethers.Contract\n *\n * @param signerAddress: ethers.AddressLike\n *\n * @param network: TNetworkName\n *\n * @param API: \"TOKEN_INFO\" | \"FUNGIBLE_INFO\" | \"NON_FUNFIBLE_INFO\"\n *\n * @param hederaTokenAddress: ethers.AddressLike\n *\n * @param gasLimit: number\n *\n * @param serialNumber?: number\n *\n * @return Promise<ISmartContractExecutionResult>\n */\nexport const queryTokenGeneralInfomation = async (\n  baseContract: Contract,\n  signerAddress: ethers.AddressLike,\n  network: TNetworkName,\n  API: 'TOKEN' | 'FUNGIBLE' | 'NON_FUNFIBLE',\n  hederaTokenAddress: ethers.AddressLike,\n  gasLimit: number,\n  serialNumber?: number\n): Promise<ISmartContractExecutionResult> => {\n  // sanitize param\n  if (!isAddress(hederaTokenAddress)) {\n    console.error('Invalid token address');\n    return { err: 'Invalid token address' };\n  } else if (serialNumber && serialNumber < 0) {\n\n// --- Next chunk ---\n\n// Lines 109-223 (.ts_part_2)\n    console.error('Invalid serial number');\n    return { err: 'Invalid serial number' };\n  }\n\n  // prepare events map\n  const eventMaps = {\n    TOKEN: 'TokenInfo',\n    FUNGIBLE: 'FungibleTokenInfo',\n    NON_FUNFIBLE: 'NonFungibleTokenInfo',\n  };\n\n  // prepare function signagure and arguments\n  const selector = {\n    funcSig: '',\n    args: [] as any,\n  };\n  switch (API) {\n    case 'TOKEN':\n      selector.funcSig = 'getTokenInfoPublic';\n      selector.args = [hederaTokenAddress];\n      break;\n    case 'FUNGIBLE':\n      selector.funcSig = 'getFungibleTokenInfoPublic';\n      selector.args = [hederaTokenAddress];\n      break;\n    case 'NON_FUNFIBLE':\n      if (!serialNumber) {\n        console.error('Serial number is needed for querying NON_FUNGIBLE');\n        return { err: 'Serial number is needed for querying NON_FUNGIBLE' };\n      }\n      selector.funcSig = 'getNonFungibleTokenInfoPublic';\n      selector.args = [hederaTokenAddress, serialNumber];\n      break;\n  }\n\n  // prepare gasLimit\n  if (gasLimit === 0) {\n    const estimateGasResult = await handleEstimateGas(\n      baseContract,\n      signerAddress,\n      network,\n      selector.funcSig,\n      selector.args\n    );\n    if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n    gasLimit = estimateGasResult.gasLimit;\n  }\n\n  // invoking contract methods\n  try {\n    let transactionResult;\n    switch (API) {\n      case 'TOKEN':\n        // prepare transaction\n        transactionResult = await baseContract.getTokenInfoPublic(hederaTokenAddress, { gasLimit });\n        break;\n      case 'FUNGIBLE':\n        // prepare transaction\n        transactionResult = await baseContract.getFungibleTokenInfoPublic(hederaTokenAddress, { gasLimit });\n        break;\n      case 'NON_FUNFIBLE':\n        if (!serialNumber) {\n          console.error('Serial number is needed for querying NON_FUNGIBLE');\n          return { err: 'Serial number is needed for querying NON_FUNGIBLE' };\n        } else {\n          // prepare transaction\n          transactionResult = await baseContract.getNonFungibleTokenInfoPublic(\n            hederaTokenAddress,\n            serialNumber,\n            { gasLimit }\n          );\n        }\n        break;\n    }\n\n    // get transaction receipt\n    const txReceipt = await transactionResult.wait();\n\n    // retrieve information from event\n    const { args } = txReceipt.logs.filter((event: any) => event.fragment.name === eventMaps[API])[0];\n\n    return {\n      [eventMaps[API]]: convertsArgsProxyToHTSTokenInfo(args.tokenInfo, API),\n      transactionHash: txReceipt.hash,\n    };\n  } catch (err: any) {\n    console.error(err);\n    return { err, transactionHash: err.receipt && err.receipt.hash };\n  }\n};\n\n/**\n * @dev queries token's certain information fields\n *\n * @dev integrates TokenQueryContract.getTokenDefaultFreezeStatusPublic()\n *\n * @dev integrates TokenQueryContract.getTokenDefaultKycStatusPublic()\n *\n * @dev integrates TokenQueryContract.getTokenCustomFeesPublic()\n *\n * @dev integrates TokenQueryContract.getTokenExpiryInfoPublic()\n *\n * @dev integrates TokenQueryContract.getTokenTypePublic()\n *\n * @dev integrates TokenQueryContract.getTokenKeyPublic()\n *\n * @param baseContract: ethers.Contract\n *\n * @param signerAddress: ethers.AddressLike\n *\n * @param network: TNetworkName\n *\n * @param network: TNetworkName\n *\n * @param API: \"DEFAULT_FREEZE_STATUS\" | \"DEFAULT_KYC_STATUS\" | \"CUSTOM_FEES\" | \"TOKEN_EXPIRY\" | \"TOKEN_TYPE\" | \"TOKEN_KEYS\"\n\n// --- Next chunk ---\n\n// Lines 224-335 (.ts_part_3)\n *\n * @param hederaTokenAddress: ethers.AddressLike,\n *\n * @param gasLimit: number\n *\n * @param keyType?: IHederaTokenServiceKeyType\n *\n * @return Promise<ISmartContractExecutionResult>\n */\nexport const queryTokenSpecificInfomation = async (\n  baseContract: Contract,\n  signerAddress: ethers.AddressLike,\n  network: TNetworkName,\n  API:\n    | 'TOKEN_TYPE'\n    | 'TOKEN_KEYS'\n    | 'CUSTOM_FEES'\n    | 'TOKEN_EXPIRY'\n    | 'DEFAULT_KYC_STATUS'\n    | 'DEFAULT_FREEZE_STATUS',\n  hederaTokenAddress: ethers.AddressLike,\n  gasLimit: number,\n  keyType?: IHederaTokenServiceKeyType\n): Promise<ISmartContractExecutionResult> => {\n  // sanitize param\n  if (!isAddress(hederaTokenAddress)) {\n    console.error('Invalid token address');\n    return { err: 'Invalid token address' };\n  }\n\n  // prepare events map\n  const eventMaps = {\n    TOKEN_TYPE: 'TokenType',\n    TOKEN_KEYS: 'TokenKey',\n    CUSTOM_FEES: 'TokenCustomFees',\n    TOKEN_EXPIRY: 'TokenExpiryInfo',\n    DEFAULT_KYC_STATUS: 'TokenDefaultKycStatus',\n    DEFAULT_FREEZE_STATUS: 'TokenDefaultFreezeStatus',\n  };\n\n  // prepare function signagure and arguments\n  const selector = {\n    funcSig: '',\n    args: [hederaTokenAddress] as any,\n  };\n  switch (API) {\n    case 'DEFAULT_FREEZE_STATUS':\n      selector.funcSig = 'getTokenDefaultFreezeStatusPublic';\n      break;\n    case 'DEFAULT_KYC_STATUS':\n      selector.funcSig = 'getTokenDefaultKycStatusPublic';\n      break;\n    case 'CUSTOM_FEES':\n      selector.funcSig = 'getTokenCustomFeesPublic';\n      break;\n    case 'TOKEN_EXPIRY':\n      selector.funcSig = 'getTokenExpiryInfoPublic';\n      break;\n    case 'TOKEN_TYPE':\n      selector.funcSig = 'getTokenTypePublic';\n      break;\n    case 'TOKEN_KEYS':\n      if (!keyType) {\n        console.error('Key Type is needed for querying NON_FUNGIBLE');\n        return { err: 'Key Type is needed for querying NON_FUNGIBLE' };\n      }\n      selector.funcSig = 'getTokenKeyPublic';\n      selector.args = [hederaTokenAddress, KEY_TYPE_MAP[keyType]];\n      break;\n  }\n\n  // prepare gasLimit\n  if (gasLimit === 0) {\n    const estimateGasResult = await handleEstimateGas(\n      baseContract,\n      signerAddress,\n      network,\n      selector.funcSig,\n      selector.args\n    );\n    if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n    gasLimit = estimateGasResult.gasLimit;\n  }\n\n  // invoking contract methods\n  try {\n    let transactionResult;\n    switch (API) {\n      case 'DEFAULT_FREEZE_STATUS':\n        transactionResult = await baseContract.getTokenDefaultFreezeStatusPublic(hederaTokenAddress, {\n          gasLimit,\n        });\n        break;\n\n      case 'DEFAULT_KYC_STATUS':\n        transactionResult = await baseContract.getTokenDefaultKycStatusPublic(hederaTokenAddress, {\n          gasLimit,\n        });\n        break;\n\n      case 'CUSTOM_FEES':\n        transactionResult = await baseContract.getTokenCustomFeesPublic(hederaTokenAddress, { gasLimit });\n        break;\n\n      case 'TOKEN_EXPIRY':\n        transactionResult = await baseContract.getTokenExpiryInfoPublic(hederaTokenAddress, { gasLimit });\n        break;\n      case 'TOKEN_TYPE':\n        transactionResult = await baseContract.getTokenTypePublic(hederaTokenAddress, { gasLimit });\n        break;\n      case 'TOKEN_KEYS':\n        if (!keyType) {\n\n// --- From File: repo_cache/hedera-smart-contracts/system-contract-dapp-playground/src/api/hedera/hts-interactions/tokenCreateCustom-interactions/index.ts (Top Group #1) ---\n// Initial Score: { Complexity: 7, Quality: 7.7 }\n// File: system-contract-dapp-playground/src/api/hedera/hts-interactions/tokenCreateCustom-interactions/index.ts\n// Relevant file context:\n// Type: .ts\n\n\n// --- Next chunk ---\n\n// Lines 1-122 (.ts_part_1)\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  handleContractResponse,\n  prepareHederaTokenKeyArray,\n} from '@/utils/contract-interactions/HTS/helpers';\nimport { Contract, ethers, isAddress } from 'ethers';\nimport { ISmartContractExecutionResult } from '@/types/contract-interactions/shared';\nimport { handleEstimateGas } from '@/utils/common/helpers';\nimport { TNetworkName } from '@/types/common';\n\n/**\n * @dev creates a Hedera fungible token\n *\n * @dev integrates tokenCreateCustomContract.createFungibleTokenPublic() and tokenCreateCustomContract.createFungibleTokenWithCustomFeesPublic()\n *\n * @param baseContract: ethers.Contract\n *\n * @param name: string\n *\n * @param symbol: string\n *\n * @param memo: string\n *\n * @param initialTotalSupply: number\n *\n * @param maxSupply: number\n *\n * @param decimals: number\n *\n * @param freezeDefaultStatus: boolean\n *\n * @param treasury: string\n *\n * @param inputKeys: ICommonKeyObject[],\n *\n * @param msgValue: string\n *\n * @param feeTokenAddress?: string\n *\n * @param feeAmount?: number\n *\n * @return Promise<ISmartContractExecutionResult>\n *\n * @see https://github.com/hashgraph/hedera-smart-contracts/blob/main/contracts/system-contracts/hedera-token-service/IHederaTokenService.sol#L136\n *      for more information on the purposes of the params\n */\nexport const createHederaFungibleToken = async (\n  baseContract: Contract,\n  name: string,\n  symbol: string,\n  memo: string,\n  initialTotalSupply: number,\n  maxSupply: number,\n  decimals: number,\n  freezeDefaultStatus: boolean,\n  treasury: string,\n  inputKeys: ICommonKeyObject[],\n  msgValue: string,\n  feeTokenAddress?: string,\n  feeAmount?: number\n): Promise<ISmartContractExecutionResult> => {\n  // sanitize params\n  let sanitizeErr;\n  if (initialTotalSupply < 0) {\n    sanitizeErr = 'initial total supply cannot be negative';\n  } else if (maxSupply < 0) {\n    sanitizeErr = 'max supply cannot be negative';\n  } else if (decimals < 0) {\n    sanitizeErr = 'decimals cannot be negative';\n  } else if (!isAddress(treasury)) {\n    sanitizeErr = 'invalid treasury address';\n  } else if (feeTokenAddress && !isAddress(feeTokenAddress)) {\n    sanitizeErr = 'invalid fee token address';\n  }\n  if (sanitizeErr) {\n    console.error(sanitizeErr);\n    return { err: sanitizeErr };\n  }\n\n  // prepare keys array\n  const keyRes = prepareHederaTokenKeyArray(inputKeys);\n\n  // handle error\n  if (keyRes.err) {\n    console.error(keyRes.err);\n    return { err: keyRes.err };\n  }\n\n  try {\n    let tokenCreateTx;\n    if (feeTokenAddress) {\n      tokenCreateTx = await baseContract.createFungibleTokenWithCustomFeesPublic(\n        treasury,\n        feeTokenAddress,\n        name,\n        symbol,\n        memo,\n        initialTotalSupply,\n        maxSupply,\n        decimals,\n        feeAmount,\n        keyRes.hederaTokenKeys,\n        {\n          value: ethers.parseEther(msgValue),\n          gasLimit: 1_000_000,\n        }\n      );\n    } else {\n      tokenCreateTx = await baseContract.createFungibleTokenPublic(\n        name,\n        symbol,\n        memo,\n        initialTotalSupply,\n        maxSupply,\n        decimals,\n        freezeDefaultStatus,\n        treasury,\n        keyRes.hederaTokenKeys,\n        {\n          value: ethers.parseEther(msgValue),\n          gasLimit: 1_000_000,\n\n// --- Next chunk ---\n\n// Lines 123-242 (.ts_part_2)\n        }\n      );\n    }\n\n    const txReceipt = await tokenCreateTx.wait();\n\n    const { data } = txReceipt.logs.filter((event: any) => event.fragment.name === 'CreatedToken')[0];\n\n    // @notice since the returned `data` is 32 byte, convert it to the public 20-byte address standard\n    const tokenAddress = `0x${data.slice(-40)}`;\n\n    return { tokenAddress, transactionHash: txReceipt.hash };\n  } catch (err: any) {\n    console.error(err);\n    return { err, transactionHash: err.receipt && err.receipt.hash };\n  }\n};\n\n/**\n * @dev creates a Hedera non fungible token\n *\n * @dev integrates tokenCreateCustomContract.createNonFungibleTokenPublic() and tokenCreateCustomContract.createNonFungibleTokenWithCustomFeesPublic()\n *\n * @param baseContract: ethers.Contract\n *\n * @param name: string\n *\n * @param symbol: string\n *\n * @param memo: string\n *\n * @param maxSupply: number\n *\n * @param treasury: ethers.AddressLike\n *\n * @param inputKeys: ICommonKeyObject[],\n *\n * @param msgValue: string\n *\n * @param feeTokenAddress?: ethers.AddressLike\n *\n * @param feeAmount?: number\n *\n * @return Promise<ISmartContractExecutionResult>\n *\n * @see https://github.com/hashgraph/hedera-smart-contracts/blob/main/contracts/system-contracts/hedera-token-service/IHederaTokenService.sol#L136\n *      for more information on the purposes of the params\n */\nexport const createHederaNonFungibleToken = async (\n  baseContract: Contract,\n  name: string,\n  symbol: string,\n  memo: string,\n  maxSupply: number,\n  treasury: ethers.AddressLike,\n  inputKeys: ICommonKeyObject[],\n  msgValue: string,\n  feeTokenAddress?: ethers.AddressLike,\n  feeAmount?: number\n): Promise<ISmartContractExecutionResult> => {\n  // sanitize params\n  let sanitizeErr;\n  if (maxSupply < 0) {\n    sanitizeErr = 'max supply cannot be negative';\n  } else if (!isAddress(treasury)) {\n    sanitizeErr = 'invalid treasury address';\n  } else if (feeTokenAddress && !isAddress(feeTokenAddress)) {\n    sanitizeErr = 'invalid fee token address';\n  }\n\n  if (sanitizeErr) {\n    console.error(sanitizeErr);\n    return { err: sanitizeErr };\n  }\n\n  // prepare keys array\n  const keyRes = prepareHederaTokenKeyArray(inputKeys);\n\n  // handle error\n  if (keyRes.err) {\n    return { err: keyRes.err };\n  }\n\n  try {\n    let tokenCreateTx;\n    if (feeTokenAddress) {\n      tokenCreateTx = await baseContract.createNonFungibleTokenWithCustomFeesPublic(\n        treasury,\n        feeTokenAddress,\n        name,\n        symbol,\n        memo,\n        maxSupply,\n        feeAmount,\n        keyRes.hederaTokenKeys,\n        {\n          value: ethers.parseEther(msgValue),\n          gasLimit: 1_000_000,\n        }\n      );\n    } else {\n      tokenCreateTx = await baseContract.createNonFungibleTokenPublic(\n        name,\n        symbol,\n        memo,\n        maxSupply,\n        treasury,\n        keyRes.hederaTokenKeys,\n        {\n          value: ethers.parseEther(msgValue),\n          gasLimit: 1_000_000,\n        }\n      );\n    }\n\n    const txReceipt = await tokenCreateTx.wait();\n\n    const { data } = txReceipt.logs.filter((event: any) => event.fragment.name === 'CreatedToken')[0];\n\n    // @notice since the returned `data` is 32 byte, convert it to the public 20-byte address standard\n\n// --- Next chunk ---\n\n// Lines 243-354 (.ts_part_3)\n    const tokenAddress = `0x${data.slice(-40)}`;\n\n    return { tokenAddress, transactionHash: txReceipt.hash };\n  } catch (err: any) {\n    console.error(err);\n    return { err, transactionHash: err.receipt && err.receipt.hash };\n  }\n};\n\n/**\n * @dev mints Hedera tokens\n *\n * @dev integrates tokenCreateCustomContract.mintTokenPublic()\n *\n * @param baseContract: ethers.Contract\n *\n * @param signerAddress: ethers.AddressLike\n *\n * @param network: TNetworkName\n *\n * @param tokenType: 'FUNGIBLE' | 'NON_FUNGIBLE'\n *\n * @param hederaTokenAddress: ethers.AddressLike\n *\n * @param amountToMint: number\n *\n * @param metadata: string[]\n *\n * @param gasLimit: number\n *\n * @return Promise<ISmartContractExecutionResult>\n */\nexport const mintHederaToken = async (\n  baseContract: Contract,\n  signerAddress: ethers.AddressLike,\n  network: TNetworkName,\n  tokenType: 'FUNGIBLE' | 'NON_FUNGIBLE',\n  hederaTokenAddress: ethers.AddressLike,\n  amountToMint: number,\n  metadata: string[],\n  gasLimit: number\n): Promise<ISmartContractExecutionResult> => {\n  // sanitize params\n  let sanitizeErr;\n  if (!isAddress(hederaTokenAddress)) {\n    sanitizeErr = 'invalid Hedera token address';\n  } else if (tokenType === 'FUNGIBLE' && amountToMint < 0) {\n    sanitizeErr = 'amount to mint cannot be negative when minting a fungible token';\n  } else if (tokenType === 'NON_FUNGIBLE' && amountToMint !== 0) {\n    sanitizeErr = 'amount to mint must be 0 when minting a non-fungible token';\n  }\n\n  if (sanitizeErr) {\n    console.error(sanitizeErr);\n    return { err: sanitizeErr };\n  }\n\n  // convert metadata to Buffer[]\n  const bufferedMetadata = metadata.map((meta) => Buffer.from(meta));\n\n  // execute .mintTokenPublic() method\n  try {\n    if (gasLimit === 0) {\n      const estimateGasResult = await handleEstimateGas(\n        baseContract,\n        signerAddress,\n        network,\n        'mintTokenPublic',\n        [hederaTokenAddress, amountToMint, bufferedMetadata]\n      );\n      if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n      gasLimit = estimateGasResult.gasLimit;\n    }\n    const tx = await baseContract.mintTokenPublic(hederaTokenAddress, amountToMint, bufferedMetadata, {\n      gasLimit,\n    });\n\n    // handle contract responses\n    return await handleContractResponse(tx);\n  } catch (err: any) {\n    console.error(err);\n    return { err, transactionHash: err.receipt && err.receipt.hash };\n  }\n};\n\n/**\n * @dev mints Hedera tokens and transfer it to another address\n *\n * @dev integrates tokenCreateCustomContract.mintTokenToAddressPublic() & tokenCreateCustomContract.mintNonFungibleTokenToAddressPublic()\n *\n * @param baseContract: ethers.Contract\n *\n * @param signerAddress: ethers.AddressLike\n *\n * @param network: TNetworkName\n *\n * @param tokenType: 'FUNGIBLE' | 'NON_FUNGIBLE'\n *\n * @param hederaTokenAddress: ethers.AddressLike\n *\n * @param recipientAddress: ethers.AddressLike\n *\n * @param amountToMint: number\n *\n * @param metadata: string[]\n *\n * @param gasLimit: number\n *\n * @return Promise<ISmartContractExecutionResult>\n */\nexport const mintHederaTokenToAddress = async (\n  baseContract: Contract,\n\n// --- From File: repo_cache/hedera-smart-contracts/system-contract-dapp-playground/src/api/hedera/hts-interactions/tokenTransfer-interactions/index.ts (Top Group #1) ---\n// Initial Score: { Complexity: 7, Quality: 7.7 }\n// File: system-contract-dapp-playground/src/api/hedera/hts-interactions/tokenTransfer-interactions/index.ts\n// Relevant file context:\n// Type: .ts\n\n\n// --- Next chunk ---\n\n// Lines 1-119 (.ts_part_1)\n// SPDX-License-Identifier: Apache-2.0\n\nimport { TNetworkName } from '@/types/common';\nimport { Contract, ethers, isAddress } from 'ethers';\nimport { handleEstimateGas } from '@/utils/common/helpers';\nimport { handleContractResponse } from '@/utils/contract-interactions/HTS/helpers';\nimport { ISmartContractExecutionResult } from '@/types/contract-interactions/shared';\n\n/**\n * @dev transfers Hedera Cryptos\n *\n * @dev integrates TokenTransferContract.cryptoTransferPublic()\n *\n * @param baseContract: ethers.Contract\n *\n * @param signerAddress: ethers.AddressLike\n *\n * @param network: TNetworkName\n *\n * @param transferList: IHederaTokenServiceTransferList\n *\n * @param tokenTransferList: IHederaTokenServiceTokenTransferList[]\n *\n * @param gasLimit: number\n *\n * @return Promise<ISmartContractExecutionResult>\n */\nexport const transferCrypto = async (\n  baseContract: Contract,\n  signerAddress: ethers.AddressLike,\n  network: TNetworkName,\n  transferList: IHederaTokenServiceTransferList,\n  tokenTransferList: IHederaTokenServiceTokenTransferList[],\n  gasLimit: number\n): Promise<ISmartContractExecutionResult> => {\n  // invoking contract methods\n  try {\n    if (gasLimit === 0) {\n      const estimateGasResult = await handleEstimateGas(\n        baseContract,\n        signerAddress,\n        network,\n        'cryptoTransferPublic',\n        [transferList, tokenTransferList]\n      );\n      if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n      gasLimit = estimateGasResult.gasLimit;\n    }\n    const tx = await baseContract.cryptoTransferPublic(transferList, tokenTransferList, {\n      gasLimit,\n    });\n\n    return await handleContractResponse(tx);\n  } catch (err: any) {\n    console.error(err);\n    return { err, transactionHash: err.receipt && err.receipt.hash };\n  }\n};\n\n/**\n * @dev transfers Hedera fungible tokens\n *\n * @dev integrates TokenTransferContract.transferTokensPublic()\n *\n * @param baseContract: ethers.Contract\n *\n * @param signerAddress: ethers.AddressLike\n *\n * @param network: TNetworkName\n *\n * @param hederaTokenAddress: ethers.AddressLike\n *\n * @param accountId: ethers.AddressLike[]\n *\n * @param amount: number[]\n *\n * @param gasLimit: number\n *\n * @return Promise Promise<ISmartContractExecutionResult>\n */\nexport const transferFungibleTokens = async (\n  baseContract: Contract,\n  signerAddress: ethers.AddressLike,\n  network: TNetworkName,\n  hederaTokenAddress: ethers.AddressLike,\n  accountIDs: ethers.AddressLike[],\n  amounts: number[],\n  gasLimit: number\n): Promise<ISmartContractExecutionResult> => {\n  // sanitize params\n  let sanitizeErr;\n  if (!isAddress(hederaTokenAddress)) {\n    sanitizeErr = 'Invalid token address';\n  }\n  if (!sanitizeErr) {\n    accountIDs.some((address) => {\n      if (!isAddress(address)) {\n        sanitizeErr = `${address} is an invalid accountID`;\n        return true;\n      }\n    });\n  }\n  if (!sanitizeErr) {\n    // @notice skipping the first element of the array in the loop as the initial item in the amounts array represents the totalInputAmount multiplied by -1\n    amounts.slice(1).some((amount) => {\n      if (amount < 0) {\n        sanitizeErr = `${amount} is an invalid amount`;\n        return true;\n      }\n    });\n  }\n  if (sanitizeErr) {\n    console.error(sanitizeErr);\n    return { err: sanitizeErr };\n  }\n\n  // invoking contract methods\n  try {\n    if (gasLimit === 0) {\n\n// --- Next chunk ---\n\n// Lines 120-245 (.ts_part_2)\n      const estimateGasResult = await handleEstimateGas(\n        baseContract,\n        signerAddress,\n        network,\n        'transferTokensPublic',\n        [hederaTokenAddress, accountIDs, amounts]\n      );\n      if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n      gasLimit = estimateGasResult.gasLimit;\n    }\n\n    const tx = await baseContract.transferTokensPublic(hederaTokenAddress, accountIDs, amounts, {\n      gasLimit,\n    });\n\n    return await handleContractResponse(tx);\n  } catch (err: any) {\n    console.error(err);\n    return { err, transactionHash: err.receipt && err.receipt.hash };\n  }\n};\n\n/**\n * @dev transfers Hedera non-fungible tokens\n *\n * @dev integrates TokenTransferContract.transferNFTsPublic()\n *\n * @param baseContract: ethers.Contract\n *\n * @param signerAddress: ethers.AddressLike\n *\n * @param network: TNetworkName\n *\n * @param hederaTokenAddress: ethers.AddressLike\n *\n * @param senders: ethers.AddressLike[]\n *\n * @param receivers: ethers.AddressLike[]\n *\n * @param serialNumbers: number[]\n *\n * @param gasLimit: number\n *\n * @return Promise<ISmartContractExecutionResult>\n */\nexport const transferNonFungibleTokens = async (\n  baseContract: Contract,\n  signerAddress: ethers.AddressLike,\n  network: TNetworkName,\n  hederaTokenAddress: ethers.AddressLike,\n  senders: ethers.AddressLike[],\n  receivers: ethers.AddressLike[],\n  serialNumbers: number[],\n  gasLimit: number\n): Promise<ISmartContractExecutionResult> => {\n  // sanitize params\n  let sanitizeErr;\n  if (!isAddress(hederaTokenAddress)) {\n    sanitizeErr = 'Invalid token address';\n  }\n  if (!sanitizeErr) {\n    senders.some((address) => {\n      if (!isAddress(address)) {\n        sanitizeErr = `${address} is an invalid sender accountID`;\n        return true;\n      }\n    });\n  }\n  if (!sanitizeErr) {\n    receivers.some((address) => {\n      if (!isAddress(address)) {\n        sanitizeErr = `${address} is an invalid receiver accountID`;\n        return true;\n      }\n    });\n  }\n  if (!sanitizeErr) {\n    serialNumbers.some((seriNum) => {\n      if (seriNum < 0) {\n        sanitizeErr = `${seriNum} is an invalid serial number`;\n        return true;\n      }\n    });\n  }\n  if (sanitizeErr) {\n    console.error(sanitizeErr);\n    return { err: sanitizeErr };\n  }\n\n  // invoking contract methods\n  try {\n    if (gasLimit === 0) {\n      const estimateGasResult = await handleEstimateGas(\n        baseContract,\n        signerAddress,\n        network,\n        'transferNFTsPublic',\n        [hederaTokenAddress, senders, serialNumbers]\n      );\n      if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n      gasLimit = estimateGasResult.gasLimit;\n    }\n\n    const tx = await baseContract.transferNFTsPublic(hederaTokenAddress, senders, receivers, serialNumbers, {\n      gasLimit,\n    });\n\n    return await handleContractResponse(tx);\n  } catch (err: any) {\n    console.error(err);\n    return { err, transactionHash: err.receipt && err.receipt.hash };\n  }\n};\n\n/**\n * @dev transfers single token (fungible vs non-fungible)\n *\n * @dev integrates TokenTransferContract.transferTokenPublic()\n *\n * @dev integrates TokenTransferContract.transferNFTPublic()\n *\n * @dev integrates TokenTransferContract.transferFromPublic()\n *\n * @dev integrates TokenTransferContract.transferFromNFTPublic()\n *\n * @param baseContract: ethers.Contract\n\n// --- Next chunk ---\n\n// Lines 246-370 (.ts_part_3)\n *\n * @param signerAddress: ethers.AddressLike\n *\n * @param network: TNetworkName\n *\n * @param API: \"FUNGIBLE\" | \"NFT\" | 'FUNGIBLE_FROM' | 'NFT_FROM'\n *\n * @param hederaTokenAddress: ethers.AddressLike\n *\n * @param sender: ethers.AddressLike\n *\n * @param receiver: ethers.AddressLike\n *\n * @param quantity: number (amount/serialNumber)\n *\n * @return Promise<ISmartContractExecutionResult>\n */\nexport const transferSingleToken = async (\n  baseContract: Contract,\n  signerAddress: ethers.AddressLike,\n  network: TNetworkName,\n  API: 'FUNGIBLE' | 'NFT' | 'FUNGIBLE_FROM' | 'NFT_FROM',\n  hederaTokenAddress: ethers.AddressLike,\n  sender: ethers.AddressLike,\n  receiver: ethers.AddressLike,\n  quantity: number,\n  gasLimit: number\n): Promise<ISmartContractExecutionResult> => {\n  // sanitize params\n  let sanitizeErr;\n  if (!isAddress(hederaTokenAddress)) {\n    sanitizeErr = 'Invalid token address';\n  } else if (!isAddress(sender)) {\n    sanitizeErr = 'Invalid sender address';\n  } else if (!isAddress(receiver)) {\n    sanitizeErr = 'Invalid receiver address';\n  } else if (quantity < 0) {\n    sanitizeErr = 'Invalid quantity';\n  }\n  if (sanitizeErr) {\n    console.error(sanitizeErr);\n    return { err: sanitizeErr };\n  }\n\n  // invoking contract methods\n  try {\n    let transactionResult;\n\n    switch (API) {\n      case 'FUNGIBLE':\n        if (gasLimit === 0) {\n          const estimateGasResult = await handleEstimateGas(\n            baseContract,\n            signerAddress,\n            network,\n            'transferTokenPublic',\n            [hederaTokenAddress, sender, receiver, quantity]\n          );\n          if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n          gasLimit = estimateGasResult.gasLimit;\n        }\n\n        transactionResult = await baseContract.transferTokenPublic(\n          hederaTokenAddress,\n          sender,\n          receiver,\n          quantity,\n          { gasLimit }\n        );\n        break;\n\n      case 'NFT':\n        if (gasLimit === 0) {\n          const estimateGasResult = await handleEstimateGas(\n            baseContract,\n            signerAddress,\n            network,\n            'transferNFTPublic',\n            [hederaTokenAddress, sender, receiver, quantity]\n          );\n          if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n          gasLimit = estimateGasResult.gasLimit;\n        }\n\n        transactionResult = await baseContract.transferNFTPublic(\n          hederaTokenAddress,\n          sender,\n          receiver,\n          quantity,\n          { gasLimit }\n        );\n        break;\n\n      case 'FUNGIBLE_FROM':\n        if (gasLimit === 0) {\n          const estimateGasResult = await handleEstimateGas(\n            baseContract,\n            signerAddress,\n            network,\n            'transferFromPublic',\n            [hederaTokenAddress, sender, receiver, quantity]\n          );\n          if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n          gasLimit = estimateGasResult.gasLimit;\n        }\n\n        transactionResult = await baseContract.transferFromPublic(\n          hederaTokenAddress,\n          sender,\n          receiver,\n          quantity,\n          { gasLimit }\n        );\n        break;\n\n      case 'NFT_FROM':\n        if (gasLimit === 0) {\n          const estimateGasResult = await handleEstimateGas(\n            baseContract,\n            signerAddress,\n            network,\n            'transferFromNFTPublic',\n            [hederaTokenAddress, sender, receiver, quantity]\n          );\n          if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n\n// --- From File: repo_cache/hedera-smart-contracts/system-contract-dapp-playground/src/api/hedera/index.ts (Top Group #1) ---\n// Initial Score: { Complexity: 7, Quality: 7.0 }\n// File: system-contract-dapp-playground/src/api/hedera/index.ts\n// Relevant file context:\n// Type: .ts\n// SPDX-License-Identifier: Apache-2.0\n\nimport { ContractFactory } from 'ethers';\nimport { getWalletProvider } from '../wallet';\nimport { ITransactionResult } from '@/types/contract-interactions/shared';\nimport { IContractABI, IHederaSmartContractResult } from '@/types/common';\nimport { HEDERA_TRANSACTION_RESULT_STORAGE_KEYS } from '@/utils/common/constants';\n\n/**\n * @dev deploys smart contract to Hedera network\n *\n * @params contractABI: IContractABI\n *\n * @params contractBytecode: string\n *\n * @return Promise<IHederaSmartContractResult>\n *\n * @resource https://github.com/ed-marquez/hedera-example-metamask-counter-dapp/blob/master/src/components/hedera/contractDeploy.js\n */\nexport const deploySmartContract = async (\n  contractABI: IContractABI[],\n  contractBytecode: string,\n  params: any[]\n): Promise<IHederaSmartContractResult> => {\n  // states\n  const transactionResultStorageKey = HEDERA_TRANSACTION_RESULT_STORAGE_KEYS['CONTRACT-CREATE'];\n\n  // get contract create transactions from localStorage\n  const cachedCreateTransactions = localStorage.getItem(transactionResultStorageKey);\n  const contractCreateTransactions = cachedCreateTransactions ? JSON.parse(cachedCreateTransactions) : [];\n\n  // get signer\n  const walletProvider = getWalletProvider();\n  if (walletProvider.err || !walletProvider.walletProvider) {\n    return { err: walletProvider.err };\n  }\n  const walletSigner = await walletProvider.walletProvider.getSigner();\n\n  // Deploy smart contract\n  try {\n    // prepare gaslimit\n    const gasLimit = 4_000_000;\n\n    // get contract from contract factory\n    const contract = new ContractFactory(JSON.stringify(contractABI), contractBytecode, walletSigner);\n\n    // execute deploy transaction\n    const contractDeployTx = await contract.deploy(...params, {\n      gasLimit,\n    });\n\n    // get contractAddress\n    const contractAddress = await contractDeployTx.getAddress();\n\n    // retrieve transaction receipt\n    const txReceipt = contractDeployTx.deploymentTransaction();\n\n    // prepare create transaction result\n    if (txReceipt) {\n      const createTransactionResult: ITransactionResult = {\n        status: 'success',\n        transactionResultStorageKey,\n        transactionTimeStamp: Date.now(),\n        txHash: txReceipt.hash as string,\n        transactionType: 'CONTRACT-CREATE',\n        sessionedContractAddress: contractAddress,\n      };\n      contractCreateTransactions.push(createTransactionResult);\n      localStorage.setItem(transactionResultStorageKey, JSON.stringify(contractCreateTransactions));\n    }\n\n    return { contractAddress };\n  } catch (err) {\n    console.error(err);\n    return { err };\n  }\n};\n\n\n// --- From File: repo_cache/hedera-smart-contracts/contracts/system-contracts/hedera-account-service/IHederaAccountService.sol (Top Group #1) ---\n// Initial Score: { Complexity: 6, Quality: 7.7 }\n// File: contracts/system-contracts/hedera-account-service/IHederaAccountService.sol\n// Relevant file context:\n// Type: .sol\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.9 <0.9.0;\npragma experimental ABIEncoderV2;\n\ninterface IHederaAccountService {\n\n    /// Returns the amount of hbars that the spender has been authorized to spend on behalf of the owner.\n    /// @param owner The account that has authorized the spender\n    /// @param spender The account that has been authorized by the owner\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return amount The amount of hbar that the spender has been authorized to spend on behalf of the owner.\n    function hbarAllowance(address owner, address spender)\n    external\n    returns (int64 responseCode, int256 amount);\n\n    /// Allows spender to withdraw hbars from the owner account multiple times, up to the value amount. If this function is called\n    /// again it overwrites the current allowance with the new amount.\n    /// @param owner The owner of the hbars\n    /// @param spender the account address authorized to spend\n    /// @param amount the amount of hbars authorized to spend.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function hbarApprove(\n        address owner,\n        address spender,\n        int256 amount\n    ) external returns (int64 responseCode);\n\n    // Returns the EVM address alias for the given Hedera account.\n    /// @param accountNumAlias The Hedera account to get the EVM address alias for.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return evmAddressAlias The EVM address alias for the given Hedera account.\n    function getEvmAddressAlias(address accountNumAlias) external\n        returns (int64 responseCode, address evmAddressAlias);\n\n    /// Returns the Hedera Account ID (as account num alias) for the given EVM address alias\n    /// @param evmAddressAlias The EVM address alias to get the Hedera account for.\n    /// @return responseCode The response code for the status of the request.  SUCCESS is 22.\n    /// @return accountNumAlias The Hedera account's num for the given EVM address alias.\n    function getHederaAccountNumAlias(address evmAddressAlias) external\n        returns (int64 responseCode, address accountNumAlias);\n\n    /// Returns true iff a Hedera account num alias or EVM address alias.\n    /// @param addr Some 20-byte address.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return response true iff addr is a Hedera account num alias or an EVM address alias (and false otherwise).\n    function isValidAlias(address addr) external returns (int64 responseCode, bool response);\n\n    /// Determines if the signature is valid for the given message hash and account.\n    /// It is assumed that the signature is composed of a single EDCSA or ED25519 key.\n    /// @param account The account to check the signature against.\n    /// @param messageHash The hash of the message to check the signature against.\n    /// @param signature The signature to check.\n    /// @return responseCode The response code for the status of the request.  SUCCESS is 22.\n    /// @return authorized True if the signature is valid, false otherwise.\n    function isAuthorizedRaw(\n        address account,\n        bytes memory messageHash,\n        bytes memory signature\n    ) external returns (int64 responseCode, bool authorized);\n\n    /// Determines if the signature is valid for the given message and account.\n    /// It is assumed that the signature is composed of a possibly complex cryptographic key.\n    /// @param account The account to check the signature against.\n    /// @param message The message to check the signature against.\n    /// @param signature The signature to check encoded as bytes.\n    /// @return responseCode The response code for the status of the request.  SUCCESS is 22.\n    /// @return authorized True if the signature is valid, false otherwise.\n    function isAuthorized(\n        address account,\n        bytes memory message,\n        bytes memory signature\n    ) external returns (int64 responseCode, bool authorized);\n}\n\n\n// --- From File: repo_cache/hedera-smart-contracts/system-contract-dapp-playground/src/components/navbar/index.tsx (Top Group #1) ---\n// Initial Score: { Complexity: 5, Quality: 6.7 }\n// File: system-contract-dapp-playground/src/components/navbar/index.tsx\n// Relevant file context:\n// Type: .tsx\n// SPDX-License-Identifier: Apache-2.0\n\n'use client';\n\nimport Link from 'next/link';\nimport Image from 'next/image';\nimport { motion } from 'framer-motion';\nimport WalletPopup from '../wallet-popup';\nimport { useToast } from '@chakra-ui/react';\nimport { useEffect, useState } from 'react';\nimport { TNetworkName } from '@/types/common';\nimport { usePathname } from 'next/navigation';\nimport { BsChevronDown } from 'react-icons/bs';\nimport { CommonErrorToast } from '../toast/CommonToast';\nimport { isProtectedRoute } from '@/utils/common/helpers';\nimport { loadAccountInfoFromCookies } from '@/api/cookies';\nimport { navVariants } from '@/libs/framer-motion/variants';\nimport { HEDERA_COMMON_WALLET_REVERT_REASONS } from '@/utils/common/constants';\n\nconst Navbar = () => {\n  // local states\n  const toaster = useToast();\n  const pathname = usePathname();\n  const [accounts, setAccounts] = useState<string[]>([]);\n  const [isConnected, setIsConnected] = useState(false);\n  const [didWalletPop, setDidWalletPop] = useState(false);\n  const [network, setNetwork] = useState<TNetworkName>('testnet');\n\n  // listen to pathname change event to retrieve account information cookies\n  useEffect(() => {\n    if (isProtectedRoute(pathname)) {\n      // retrieve account info from cookies\n      const accountsInfo = loadAccountInfoFromCookies();\n\n      // just best pratice to handle error as this would rarely happen as we have already gated all the checks in middleware.js\n      if (\n        !accountsInfo.isConnected ||\n        !accountsInfo.accounts ||\n        !accountsInfo.network ||\n        accountsInfo.error\n      ) {\n        CommonErrorToast({\n          toaster,\n          title: 'Error retrieving account information',\n          description: HEDERA_COMMON_WALLET_REVERT_REASONS.DEFAULT.description,\n        });\n        return;\n      }\n\n      // update states\n      setAccounts(JSON.parse(accountsInfo.accounts));\n      setIsConnected(JSON.parse(accountsInfo.isConnected));\n      setNetwork(JSON.parse(accountsInfo.network) as TNetworkName);\n    }\n  }, [pathname, toaster]);\n\n  return (\n    <motion.nav\n      initial={{ opacity: 0 }}\n      whileInView={{ opacity: 1 }}\n      transition={{\n        delay: 0.3,\n        duration: 0.3,\n      }}\n      viewport={{ once: true }}\n      className=\"px-6 pt-6 flex flex-col justify-between items-center z-50\"\n    >\n      {/* Protected Navbar */}\n      {isConnected ? (\n        <div className=\"grid grid-rows-2 sm:grid-rows-1 sm:grid-cols-2 lg:grid-cols-3 w-full justify-center gap-3 pb-6\">\n          {/* Logo */}\n          <Link href={'/'} className=\"flex gap-3 items-center justify-center sm:justify-start\">\n            <Image\n              src={'/brandings/hedera-logomark.svg'}\n              alt={'hedera-logomark'}\n              width={50}\n              height={50}\n              className=\"z-50\"\n            />\n            <p className=\"text-white text-[2rem]\">Hedera</p>\n          </Link>\n\n          {/* DApp playground */}\n          <div className=\"hidden lg:flex lg:gap-1 lg:items-center lg:justify-center\">\n            <div className=\"flex justify-center items-center text-hedera-green\">\n              <div className=\"rounded-r-[9px] border-hedera-green w-[52px] h-[27px] border-[5px] mt-1\" />\n              <div className=\"font-medium text-[2rem] uppercase\">App</div>\n            </div>\n\n            {/* Playground */}\n            <div className=\"uppercase text-[2rem] bg-clip-text text-white\">Playground</div>\n          </div>\n\n          {/* wallet info */}\n          <div className=\"text-white flex justify-end\">\n            {/* wallet wrapper */}\n            <div\n              className=\"bg-gradient-to-r from-hedera-gradient-2-lime/60 to-hedera-gradient-2-teal rounded-lg flex items-center px-3 cursor-pointer\"\n              onClick={() => {\n                setDidWalletPop(true);\n              }}\n            >\n              {/* logo */}\n              <Image src={'/brandings/hedera-logomark.svg'} alt={'hedera-logomark'} width={30} height={30} />\n\n              {/* vertical bar */}\n              <div className=\"bg-white/30 w-[1px] h-full mx-3\" />\n\n              {/* address */}\n              <p className=\"text-lg font-medium\">\n                {accounts[0].slice(0, 7)}...{accounts[0].slice(-5)}\n              </p>\n\n              {/* downward arrow */}\n              <div className=\"text-xl ml-1\">\n                <BsChevronDown />\n              </div>\n            </div>\n          </div>\n        </div>\n      ) : (\n        <motion.div\n          variants={navVariants}\n          initial=\"hidden\"\n          whileInView=\"show\"\n          viewport={{ once: true }}\n          className=\"flex justify-between w-full\"\n        >\n          {/* Unprotected Navbar */}\n          <Link href={'/'}>\n            {/* Logo */}\n            <Image\n              src={'/brandings/hedera-logomark.svg'}\n              alt={'hedera-logomark'}\n              width={50}\n              height={50}\n              className=\"z-50\"\n            />\n          </Link>\n\n          {/* Text logo */}\n          <p className=\"text-white text-[2rem]\">Hedera</p>\n        </motion.div>\n      )}\n\n      {isConnected && <hr className=\"w-[99vw] border-t border-white/40\" />}\n\n      {didWalletPop && (\n        <WalletPopup network={network} userAddress={accounts[0]} setIsOpen={setDidWalletPop} />\n      )}\n    </motion.nav>\n  );\n};\n\nexport default Navbar;\n\n\n// --- From File: repo_cache/hedera-smart-contracts/system-contract-dapp-playground/src/app/page.tsx (Top Group #1) ---\n// Initial Score: { Complexity: 2, Quality: 8.7 }\n// File: system-contract-dapp-playground/src/app/page.tsx\n// Relevant file context:\n// Type: .tsx\n// SPDX-License-Identifier: Apache-2.0\n\nimport Footer from '@/components/footer';\nimport Navbar from '@/components/navbar';\nimport LandingPage from '@/sections/landing';\n\nexport default function Home() {\n  return (\n    <main className=\"h-screen flex flex-col\">\n      <Navbar />\n      <LandingPage />;\n      <Footer />\n    </main>\n  );\n}\n"
  }
}