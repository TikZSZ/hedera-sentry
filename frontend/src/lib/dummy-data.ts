// src/lib/dummy-data.ts

import type { ProjectScorecard } from '@/types'; // Assuming you create a types.ts for your interfaces

export const DUMMY_PROJECT_SCORECARD: ProjectScorecard = {
  "runId": "2025-08-08T05:04:17.329Z",
  "repoName": "hedera-smart-contracts",
  "model": "gpt-4o-mini",
  "preliminaryProjectScore": 7.08897093660907,
  "mainDomain": "Hedera dApp",
  "techStack": [
    "Solidity",
    "Hardhat"
  ],
  "projectEssence": "The Hedera Smart Contracts project is a reference library for utilizing Hedera's system contracts, focusing on the Hedera Token Service (HTS), Hedera Account Service (HAS), and other smart contract functionalities through the Ethereum Virtual Machine (EVM). It aims to provide developers with precompiled smart contracts and examples to help integrate Hedera services into their applications, including native EVM transactions and enhanced features for token management and scheduling.",
  "profile": {
    "complexity": 6.720050224336645,
    "quality": 7.465573602786666,
    "maintainability": 6.82786329675108,
    "best_practices": 7.551889758325417
  },
  "usage": {
    "prompt_tokens": 53399,
    "completion_tokens": 6104,
    "total_tokens": 59503
  },
  "totalRetries": 1,
  "totalFailedFiles": 0,
  "warnings": {
    "vendedCodeFlagged": []
  },
  "scoredFiles": [
    {
      "filePath": "contracts/system-contracts/hedera-token-service/IHederaTokenService.sol",
      "totalOriginalTokens": 9663,
      "finalTokenCount": 9995,
      "impactScore": 60.666666666666664,
      "averageComplexity": 8,
      "averageQuality": 7.5,
      "usage": {
        "prompt_tokens": 14007,
        "completion_tokens": 1009,
        "total_tokens": 15016
      },
      "retries": 0,
      "hadError": false,
      "scoredChunkGroups": [
        {
          "groupId": 1,
          "score": {
            "complexity_score": 8,
            "code_quality_score": 9,
            "maintainability_score": 8,
            "best_practices_adherence": 8,
            "web3_pattern_identification": "Structured Data Types",
            "hedera_red_flag": {
              "description": "Potential for misuse of the accounts and addresses without validation, leading to errors in transactions.",
              "exact_code_snippet": "address accountID;"
            },
            "hedera_optimization_suggestion": {
              "description": "Using fixed sizes for arrays instead of dynamic arrays where possible can lead to gas savings.",
              "exact_code_snippet": "AccountAmount[] transfers;"
            },
            "positive_feedback": "The use of structured data types to handle complex transfer logic in a clear manner is commendable, as it significantly improves readability and organization.",
            "group_summary": "This code defines the interface for the Hedera Token Service, which handles cryptocurrency transfers, token management, and the relationships between various token properties and accounts in a structured manner."
          },
          "totalTokens": 2517,
          "usage": {
            "prompt_tokens": 3499,
            "completion_tokens": 219,
            "total_tokens": 3718,
            "prompt_tokens_details": {
              "cached_tokens": 0,
              "audio_tokens": 0
            },
            "completion_tokens_details": {
              "reasoning_tokens": 0,
              "audio_tokens": 0,
              "accepted_prediction_tokens": 0,
              "rejected_prediction_tokens": 0
            }
          }
        },
        {
          "groupId": 2,
          "score": {
            "complexity_score": 8,
            "code_quality_score": 7,
            "maintainability_score": 7,
            "best_practices_adherence": 8,
            "web3_pattern_identification": "Token Management Pattern",
            "hedera_red_flag": {
              "description": "",
              "exact_code_snippet": ""
            },
            "hedera_optimization_suggestion": {
              "description": "Consider replacing int64 types with uint64 for amounts to improve clarity, as negative values shouldn't be logically applicable for token amounts.",
              "exact_code_snippet": "int64 amount; // appears in various function definitions."
            },
            "positive_feedback": "The structure of the different fee types (FractionalFee, RoyaltyFee) elegantly allows for flexible fee mechanisms that enhance transaction versatility on Hedera.",
            "group_summary": "This code defines complex structures and functions related to the Hedera Token Service, enabling advanced token management, including fee structures and operational methods essential for the proper handling of fungible and non-fungible tokens."
          },
          "totalTokens": 2497,
          "usage": {
            "prompt_tokens": 3503,
            "completion_tokens": 222,
            "total_tokens": 3725,
            "prompt_tokens_details": {
              "cached_tokens": 0,
              "audio_tokens": 0
            },
            "completion_tokens_details": {
              "reasoning_tokens": 0,
              "audio_tokens": 0,
              "accepted_prediction_tokens": 0,
              "rejected_prediction_tokens": 0
            }
          }
        },
        {
          "groupId": 3,
          "score": {
            "complexity_score": 8,
            "code_quality_score": 7,
            "maintainability_score": 7,
            "best_practices_adherence": 8,
            "web3_pattern_identification": "Checks-Effects-Interactions",
            "hedera_red_flag": {
              "description": "The `approve` function does not implement any checks for the token contract's address or the spender, which could lead to misuse.",
              "exact_code_snippet": "function approve(address token, address spender, uint256 amount) external returns (int64 responseCode);"
            },
            "hedera_optimization_suggestion": {
              "description": "Consider using `int32` instead of `int64` for token amounts, where applicable, to reduce gas consumption, as the maximum value required is much less than what `int64` provides.",
              "exact_code_snippet": "function transferTokens(address token, address[] memory accountId, int64[] memory amount) external returns (int64 responseCode);"
            },
            "positive_feedback": "The use of memory arrays for fees and amounts demonstrates a commendable approach to handling dynamic data structures efficiently within smart contracts.",
            "group_summary": "This code defines the interface for the Hedera Token Service, allowing for the creation, transfer, and management of fungible and non-fungible tokens, while enabling custom fees and permission management."
          },
          "totalTokens": 2502,
          "usage": {
            "prompt_tokens": 3515,
            "completion_tokens": 294,
            "total_tokens": 3809,
            "prompt_tokens_details": {
              "cached_tokens": 0,
              "audio_tokens": 0
            },
            "completion_tokens_details": {
              "reasoning_tokens": 0,
              "audio_tokens": 0,
              "accepted_prediction_tokens": 0,
              "rejected_prediction_tokens": 0
            }
          }
        },
        {
          "groupId": 4,
          "score": {
            "complexity_score": 8,
            "code_quality_score": 7,
            "maintainability_score": 7,
            "best_practices_adherence": 8,
            "web3_pattern_identification": "Contract Interaction Pattern",
            "hedera_red_flag": {
              "description": "The use of public function visibility in certain critical operations may expose vulnerabilities if not properly managed with access control.",
              "exact_code_snippet": "function freezeToken(address token, address account)"
            },
            "hedera_optimization_suggestion": {
              "description": "Consider using structs to group frequently used parameters for functions, to reduce gas costs and improve readability.",
              "exact_code_snippet": "function updateFungibleTokenCustomFees(address token,  IHederaTokenService.FixedFee[] memory fixedFees, IHederaTokenService.FractionalFee[] memory fractionalFees)"
            },
            "positive_feedback": "The handling of pending airdrops showcases a sophisticated use of Hedera's features, making it a valuable operation in token distribution.",
            "group_summary": "This Solidity contract interface outlines several operations for managing fungible and non-fungible tokens within the Hedera Token Service, including querying token information, freezing and unfreezing accounts, updating token fees, and processing airdrops."
          },
          "totalTokens": 2479,
          "usage": {
            "prompt_tokens": 3490,
            "completion_tokens": 274,
            "total_tokens": 3764,
            "prompt_tokens_details": {
              "cached_tokens": 0,
              "audio_tokens": 0
            },
            "completion_tokens_details": {
              "reasoning_tokens": 0,
              "audio_tokens": 0,
              "accepted_prediction_tokens": 0,
              "rejected_prediction_tokens": 0
            }
          }
        }
      ],
      "chunkingDetails": {
        "filePath": "contracts/system-contracts/hedera-token-service/IHederaTokenService.sol",
        "totalFileTokens": 9663,
        "chunks": [
          {
            "originalText": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.9 <0.9.0;\npragma experimental ABIEncoderV2;\n\ninterface IHederaTokenService {\n    /// Transfers cryptocurrency among two or more accounts by making the desired adjustments to their\n    /// balances. Each transfer list can specify up to 10 adjustments. Each negative amount is withdrawn\n    /// from the corresponding account (a sender), and each positive one is added to the corresponding\n    /// account (a receiver). The amounts list must sum to zero. Each amount is a number of tinybars\n    /// (there are 100,000,000 tinybars in one hbar).  If any sender account fails to have sufficient\n    /// hbars, then the entire transaction fails, and none of those transfers occur, though the\n    /// transaction fee is still charged. This transaction must be signed by the keys for all the sending\n    /// accounts, and for any receiving accounts that have receiverSigRequired == true. The signatures\n    /// are in the same order as the accounts, skipping those accounts that don't need a signature.\n    /// @custom:version 0.3.0 previous version did not include isApproval\n    struct AccountAmount {\n        // The Account ID, as a solidity address, that sends/receives cryptocurrency or tokens\n        address accountID;\n\n        // The amount of  the lowest denomination of the given token that\n        // the account sends(negative) or receives(positive)\n        int64 amount;\n\n        // If true then the transfer is expected to be an approved allowance and the\n        // accountID is expected to be the owner. The default is false (omitted).\n        bool isApproval;\n    }\n\n    /// A sender account, a receiver account, and the serial number of an NFT of a Token with\n    /// NON_FUNGIBLE_UNIQUE type. When minting NFTs the sender will be the default AccountID instance\n    /// (0.0.0 aka 0x0) and when burning NFTs, the receiver will be the default AccountID instance.\n    /// @custom:version 0.3.0 previous version did not include isApproval\n    struct NftTransfer {\n        // The solidity address of the sender\n        address senderAccountID;\n\n        // The solidity address of the receiver\n        address receiverAccountID;\n\n        // The serial number of the NFT\n        int64 serialNumber;\n\n        // If true then the transfer is expected to be an approved allowance and the\n        // accountID is expected to be the owner. The default is false (omitted).\n        bool isApproval;\n    }\n\n    struct TokenTransferList {\n        // The ID of the token as a solidity address\n        address token;\n\n        // Applicable to tokens of type FUNGIBLE_COMMON. Multiple list of AccountAmounts, each of which\n        // has an account and amount.\n        AccountAmount[] transfers;\n\n        // Applicable to tokens of type NON_FUNGIBLE_UNIQUE. Multiple list of NftTransfers, each of\n        // which has a sender and receiver account, including the serial number of the NFT\n        NftTransfer[] nftTransfers;\n    }\n\n    struct TransferList {\n        // Multiple list of AccountAmounts, each of which has an account and amount.\n        // Used to transfer hbars between the accounts in the list.\n        AccountAmount[] transfers;\n    }\n\n    /// Expiry properties of a Hedera token - second, autoRenewAccount, autoRenewPeriod\n    struct Expiry {\n        // The epoch second at which the token should expire; if an auto-renew account and period are\n        // specified, this is coerced to the current epoch second plus the autoRenewPeriod\n        int64 second;\n\n        // ID of an account which will be automatically charged to renew the token's expiration, at\n        // autoRenewPeriod interval, expressed as a solidity address",
            "codeOnlyTokens": 805,
            "startLine": 1,
            "endLine": 74,
            "type": ".sol_part_1",
            "isOversized": false
          },
          {
            "originalText": "        address autoRenewAccount;\n\n        // The interval at which the auto-renew account will be charged to extend the token's expiry\n        int64 autoRenewPeriod;\n    }\n\n    /// A Key can be a public key from either the Ed25519 or ECDSA(secp256k1) signature schemes, where\n    /// in the ECDSA(secp256k1) case we require the 33-byte compressed form of the public key. We call\n    /// these public keys <b>primitive keys</b>.\n    /// A Key can also be the ID of a smart contract instance, which is then authorized to perform any\n    /// precompiled contract action that requires this key to sign.\n    /// Note that when a Key is a smart contract ID, it <i>doesn't</i> mean the contract with that ID\n    /// will actually create a cryptographic signature. It only means that when the contract calls a\n    /// precompiled contract, the resulting \"child transaction\" will be authorized to perform any action\n    /// controlled by the Key.\n    /// Exactly one of the possible values should be populated in order for the Key to be valid.\n    struct KeyValue {\n\n        // if set to true, the key of the calling Hedera account will be inherited as the token key\n        bool inheritAccountKey;\n\n        // smart contract instance that is authorized as if it had signed with a key\n        address contractId;\n\n        // Ed25519 public key bytes\n        bytes ed25519;\n\n        // Compressed ECDSA(secp256k1) public key bytes\n        bytes ECDSA_secp256k1;\n\n        // A smart contract that, if the recipient of the active message frame, should be treated\n        // as having signed. (Note this does not mean the <i>code being executed in the frame</i>\n        // will belong to the given contract, since it could be running another contract's code via\n        // <tt>delegatecall</tt>. So setting this key is a more permissive version of setting the\n        // contractID key, which also requires the code in the active message frame belong to the\n        // the contract with the given id.)\n        address delegatableContractId;\n    }\n\n    /// A list of token key types the key should be applied to and the value of the key\n    struct TokenKey {\n\n        // bit field representing the key type. Keys of all types that have corresponding bits set to 1\n        // will be created for the token.\n        // 0th bit: adminKey\n        // 1st bit: kycKey\n        // 2nd bit: freezeKey\n        // 3rd bit: wipeKey\n        // 4th bit: supplyKey\n        // 5th bit: feeScheduleKey\n        // 6th bit: pauseKey\n        // 7th bit: ignored\n        uint keyType;\n\n        // the value that will be set to the key type\n        KeyValue key;\n    }\n\n    /// Basic properties of a Hedera Token - name, symbol, memo, tokenSupplyType, maxSupply,\n    /// treasury, freezeDefault. These properties are related both to Fungible and NFT token types.\n    struct HederaToken {\n        // The publicly visible name of the token. The token name is specified as a Unicode string.\n        // Its UTF-8 encoding cannot exceed 100 bytes, and cannot contain the 0 byte (NUL).\n        string name;\n\n        // The publicly visible token symbol. The token symbol is specified as a Unicode string.\n        // Its UTF-8 encoding cannot exceed 100 bytes, and cannot contain the 0 byte (NUL).\n        string symbol;\n\n        // The ID of the account which will act as a treasury for the token as a solidity address.\n        // This account will receive the specified initial supply or the newly minted NFTs in",
            "codeOnlyTokens": 810,
            "startLine": 75,
            "endLine": 145,
            "type": ".sol_part_2",
            "isOversized": false
          },
          {
            "originalText": "        // the case for NON_FUNGIBLE_UNIQUE Type\n        address treasury;\n\n        // The memo associated with the token (UTF-8 encoding max 100 bytes)\n        string memo;\n\n        // IWA compatibility. Specified the token supply type. Defaults to INFINITE\n        bool tokenSupplyType;\n\n        // IWA Compatibility. Depends on TokenSupplyType. For tokens of type FUNGIBLE_COMMON - the\n        // maximum number of tokens that can be in circulation. For tokens of type NON_FUNGIBLE_UNIQUE -\n        // the maximum number of NFTs (serial numbers) that can be minted. This field can never be changed!\n        int64 maxSupply;\n\n        // The default Freeze status (frozen or unfrozen) of Hedera accounts relative to this token. If\n        // true, an account must be unfrozen before it can receive the token\n        bool freezeDefault;\n\n        // list of keys to set to the token\n        TokenKey[] tokenKeys;\n\n        // expiry properties of a Hedera token - second, autoRenewAccount, autoRenewPeriod\n        Expiry expiry;\n    }\n\n    /// Additional post creation fungible and non fungible properties of a Hedera Token.\n    struct TokenInfo {\n        /// Basic properties of a Hedera Token\n        HederaToken token;\n\n        /// The number of tokens (fungible) or serials (non-fungible) of the token\n        int64 totalSupply;\n\n        /// Specifies whether the token is deleted or not\n        bool deleted;\n\n        /// Specifies whether the token kyc was defaulted with KycNotApplicable (true) or Revoked (false)\n        bool defaultKycStatus;\n\n        /// Specifies whether the token is currently paused or not\n        bool pauseStatus;\n\n        /// The fixed fees collected when transferring the token\n        FixedFee[] fixedFees;\n\n        /// The fractional fees collected when transferring the token\n        FractionalFee[] fractionalFees;\n\n        /// The royalty fees collected when transferring the token\n        RoyaltyFee[] royaltyFees;\n\n        /// The ID of the network ledger\n        string ledgerId;\n    }\n\n    /// Additional fungible properties of a Hedera Token.\n    struct FungibleTokenInfo {\n        /// The shared hedera token info\n        TokenInfo tokenInfo;\n\n        /// The number of decimal places a token is divisible by\n        int32 decimals;\n    }\n\n    /// Additional non fungible properties of a Hedera Token.\n    struct NonFungibleTokenInfo {\n        /// The shared hedera token info\n        TokenInfo tokenInfo;\n\n        /// The serial number of the nft\n        int64 serialNumber;\n\n        /// The account id specifying the owner of the non fungible token\n        address ownerId;\n\n        /// The epoch second at which the token was created.\n        int64 creationTime;\n\n        /// The unique metadata of the NFT\n        bytes metadata;\n\n        /// The account id specifying an account that has been granted spending permissions on this nft\n        address spenderId;\n    }\n\n    /// A fixed number of units (hbar or token) to assess as a fee during a transfer of\n    /// units of the token to which this fixed fee is attached. The denomination of\n    /// the fee depends on the values of tokenId, useHbarsForPayment and\n    /// useCurrentTokenForPayment. Exactly one of the values should be set.\n    struct FixedFee {\n\n        int64 amount;\n\n        // Specifies ID of token that should be used for fixed fee denomination\n        address tokenId;\n\n        // Specifies this fixed fee should be denominated in Hbar\n        bool useHbarsForPayment;\n\n        // Specifies this fixed fee should be denominated in the Token currently being created\n        bool useCurrentTokenForPayment;\n\n        // The ID of the account to receive the custom fee, expressed as a solidity address\n        address feeCollector;\n    }\n\n    /// A fraction of the transferred units of a token to assess as a fee. The amount assessed will never",
            "codeOnlyTokens": 817,
            "startLine": 146,
            "endLine": 252,
            "type": ".sol_part_3",
            "isOversized": false
          },
          {
            "originalText": "    /// be less than the given minimumAmount, and never greater than the given maximumAmount.  The\n    /// denomination is always units of the token to which this fractional fee is attached.\n    struct FractionalFee {\n        // A rational number's numerator, used to set the amount of a value transfer to collect as a custom fee\n        int64 numerator;\n\n        // A rational number's denominator, used to set the amount of a value transfer to collect as a custom fee\n        int64 denominator;\n\n        // The minimum amount to assess\n        int64 minimumAmount;\n\n        // The maximum amount to assess (zero implies no maximum)\n        int64 maximumAmount;\n        bool netOfTransfers;\n\n        // The ID of the account to receive the custom fee, expressed as a solidity address\n        address feeCollector;\n    }\n\n    /// A fee to assess during a transfer that changes ownership of an NFT. Defines the fraction of\n    /// the fungible value exchanged for an NFT that the ledger should collect as a royalty. (\"Fungible\n    /// value\" includes both ℏ and units of fungible HTS tokens.) When the NFT sender does not receive\n    /// any fungible value, the ledger will assess the fallback fee, if present, to the new NFT owner.\n    /// Royalty fees can only be added to tokens of type type NON_FUNGIBLE_UNIQUE.\n    struct RoyaltyFee {\n        // A fraction's numerator of fungible value exchanged for an NFT to collect as royalty\n        int64 numerator;\n\n        // A fraction's denominator of fungible value exchanged for an NFT to collect as royalty\n        int64 denominator;\n\n        // If present, the fee to assess to the NFT receiver when no fungible value\n        // is exchanged with the sender. Consists of:\n        // amount: the amount to charge for the fee\n        // tokenId: Specifies ID of token that should be used for fixed fee denomination\n        // useHbarsForPayment: Specifies this fee should be denominated in Hbar\n        int64 amount;\n        address tokenId;\n        bool useHbarsForPayment;\n\n        // The ID of the account to receive the custom fee, expressed as a solidity address\n        address feeCollector;\n    }\n\n    /// Represents a pending airdrop of a token or NFT to a receiver\n    /// @param sender The address of the account sending the airdrop\n    /// @param receiver The address of the account receiving the airdrop\n    /// @param token The address of the token being airdropped\n    /// @param serial For NFT airdrops, the serial number of the NFT. For fungible tokens, this should be 0\n    struct PendingAirdrop {\n        address sender;\n        address receiver;\n        address token;\n        int64 serial;\n    }\n\n    /// Represents a unique NFT by its token address and serial number\n    /// @param nft The address of the NFT token\n    /// @param serial The serial number that uniquely identifies this NFT within its token type\n    struct NftID {\n        address nft;\n        int64 serial;\n    }\n\n    /**********************\n     * Direct HTS Calls   *\n     **********************/\n\n    /// Performs transfers among combinations of tokens and hbars\n    /// @param transferList the list of hbar transfers to do\n    /// @param tokenTransfers the list of token transfers to do\n    /// @custom:version 0.3.0 the signature of the previous version was cryptoTransfer(TokenTransferList[] memory tokenTransfers)\n    function cryptoTransfer(TransferList memory transferList, TokenTransferList[] memory tokenTransfers)\n        external\n        returns (int64 responseCode);\n\n    /// Mints an amount of the token to the defined treasury account\n    /// @param token The token for which to mint tokens. If token does not exist, transaction results in\n    ///              INVALID_TOKEN_ID",
            "codeOnlyTokens": 801,
            "startLine": 253,
            "endLine": 332,
            "type": ".sol_part_4",
            "isOversized": false
          },
          {
            "originalText": "    /// @param amount Applicable to tokens of type FUNGIBLE_COMMON. The amount to mint to the Treasury Account.\n    ///               Amount must be a positive non-zero number represented in the lowest denomination of the\n    ///               token. The new supply must be lower than 2^63.\n    /// @param metadata Applicable to tokens of type NON_FUNGIBLE_UNIQUE. A list of metadata that are being created.\n    ///                 Maximum allowed size of each metadata is 100 bytes\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return newTotalSupply The new supply of tokens. For NFTs it is the total count of NFTs\n    /// @return serialNumbers If the token is an NFT the newly generate serial numbers, othersise empty.\n    function mintToken(\n        address token,\n        int64 amount,\n        bytes[] memory metadata\n    )\n        external\n        returns (\n            int64 responseCode,\n            int64 newTotalSupply,\n            int64[] memory serialNumbers\n        );\n\n    /// Burns an amount of the token from the defined treasury account\n    /// @param token The token for which to burn tokens. If token does not exist, transaction results in\n    ///              INVALID_TOKEN_ID\n    /// @param amount  Applicable to tokens of type FUNGIBLE_COMMON. The amount to burn from the Treasury Account.\n    ///                Amount must be a positive non-zero number, not bigger than the token balance of the treasury\n    ///                account (0; balance], represented in the lowest denomination.\n    /// @param serialNumbers Applicable to tokens of type NON_FUNGIBLE_UNIQUE. The list of serial numbers to be burned.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return newTotalSupply The new supply of tokens. For NFTs it is the total count of NFTs\n    function burnToken(\n        address token,\n        int64 amount,\n        int64[] memory serialNumbers\n    ) external returns (int64 responseCode, int64 newTotalSupply);\n\n    ///  Associates the provided account with the provided tokens. Must be signed by the provided\n    ///  Account's key or called from the accounts contract key\n    ///  If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.\n    ///  If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.\n    ///  If any of the provided tokens is not found, the transaction will resolve to INVALID_TOKEN_REF.\n    ///  If any of the provided tokens has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.\n    ///  If an association between the provided account and any of the tokens already exists, the\n    ///  transaction will resolve to TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT.\n    ///  If the provided account's associations count exceed the constraint of maximum token associations\n    ///    per account, the transaction will resolve to TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED.\n    ///  On success, associations between the provided account and tokens are made and the account is\n    ///    ready to interact with the tokens.\n    /// @param account The account to be associated with the provided tokens\n    /// @param tokens The tokens to be associated with the provided account. In the case of NON_FUNGIBLE_UNIQUE\n    ///               Type, once an account is associated, it can hold any number of NFTs (serial numbers) of that\n    ///               token type\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function associateTokens(address account, address[] memory tokens)\n        external\n        returns (int64 responseCode);\n\n    /// Single-token variant of associateTokens. Will be mapped to a single entry array call of associateTokens\n    /// @param account The account to be associated with the provided token",
            "codeOnlyTokens": 806,
            "startLine": 333,
            "endLine": 390,
            "type": ".sol_part_5",
            "isOversized": false
          },
          {
            "originalText": "    /// @param token The token to be associated with the provided account\n    function associateToken(address account, address token)\n        external\n        returns (int64 responseCode);\n\n    /// Dissociates the provided account with the provided tokens. Must be signed by the provided\n    /// Account's key.\n    /// If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.\n    /// If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.\n    /// If any of the provided tokens is not found, the transaction will resolve to INVALID_TOKEN_REF.\n    /// If any of the provided tokens has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.\n    /// If an association between the provided account and any of the tokens does not exist, the\n    /// transaction will resolve to TOKEN_NOT_ASSOCIATED_TO_ACCOUNT.\n    /// If a token has not been deleted and has not expired, and the user has a nonzero balance, the\n    /// transaction will resolve to TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES.\n    /// If a <b>fungible token</b> has expired, the user can disassociate even if their token balance is\n    /// not zero.\n    /// If a <b>non fungible token</b> has expired, the user can <b>not</b> disassociate if their token\n    /// balance is not zero. The transaction will resolve to TRANSACTION_REQUIRED_ZERO_TOKEN_BALANCES.\n    /// On success, associations between the provided account and tokens are removed.\n    /// @param account The account to be dissociated from the provided tokens\n    /// @param tokens The tokens to be dissociated from the provided account.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function dissociateTokens(address account, address[] memory tokens)\n        external\n        returns (int64 responseCode);\n\n    /// Single-token variant of dissociateTokens. Will be mapped to a single entry array call of dissociateTokens\n    /// @param account The account to be associated with the provided token\n    /// @param token The token to be associated with the provided account\n    function dissociateToken(address account, address token)\n        external\n        returns (int64 responseCode);\n\n    /// Creates a Fungible Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @param initialTotalSupply Specifies the initial supply of tokens to be put in circulation. The\n    /// initial supply is sent to the Treasury Account. The supply is in the lowest denomination possible.\n    /// @param decimals the number of decimal places a token is divisible by\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createFungibleToken(\n        HederaToken memory token,\n        int64 initialTotalSupply,\n        int32 decimals\n    ) external payable returns (int64 responseCode, address tokenAddress);\n\n    /// Creates a Fungible Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @param initialTotalSupply Specifies the initial supply of tokens to be put in circulation. The\n    /// initial supply is sent to the Treasury Account. The supply is in the lowest denomination possible.\n    /// @param decimals the number of decimal places a token is divisible by.\n    /// @param fixedFees list of fixed fees to apply to the token\n    /// @param fractionalFees list of fractional fees to apply to the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createFungibleTokenWithCustomFees(\n        HederaToken memory token,\n        int64 initialTotalSupply,",
            "codeOnlyTokens": 804,
            "startLine": 391,
            "endLine": 449,
            "type": ".sol_part_6",
            "isOversized": false
          },
          {
            "originalText": "        int32 decimals,\n        FixedFee[] memory fixedFees,\n        FractionalFee[] memory fractionalFees\n    ) external payable returns (int64 responseCode, address tokenAddress);\n\n    /// Creates an Non Fungible Unique Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createNonFungibleToken(HederaToken memory token)\n        external\n        payable\n        returns (int64 responseCode, address tokenAddress);\n\n    /// Creates an Non Fungible Unique Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @param fixedFees list of fixed fees to apply to the token\n    /// @param royaltyFees list of royalty fees to apply to the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createNonFungibleTokenWithCustomFees(\n        HederaToken memory token,\n        FixedFee[] memory fixedFees,\n        RoyaltyFee[] memory royaltyFees\n    ) external payable returns (int64 responseCode, address tokenAddress);\n\n    /**********************\n     * ABIV1 calls        *\n     **********************/\n\n    /// Initiates a Fungible Token Transfer\n    /// @param token The ID of the token as a solidity address\n    /// @param accountId account to do a transfer to/from\n    /// @param amount The amount from the accountId at the same index\n    function transferTokens(\n        address token,\n        address[] memory accountId,\n        int64[] memory amount\n    ) external returns (int64 responseCode);\n\n    /// Initiates a Non-Fungable Token Transfer\n    /// @param token The ID of the token as a solidity address\n    /// @param sender the sender of an nft\n    /// @param receiver the receiver of the nft sent by the same index at sender\n    /// @param serialNumber the serial number of the nft sent by the same index at sender\n    function transferNFTs(\n        address token,\n        address[] memory sender,\n        address[] memory receiver,\n        int64[] memory serialNumber\n    ) external returns (int64 responseCode);\n\n    /// Transfers tokens where the calling account/contract is implicitly the first entry in the token transfer list,\n    /// where the amount is the value needed to zero balance the transfers. Regular signing rules apply for sending\n    /// (positive amount) or receiving (negative amount)\n    /// @param token The token to transfer to/from\n    /// @param sender The sender for the transaction\n    /// @param recipient The receiver of the transaction\n    /// @param amount Non-negative value to send. a negative value will result in a failure.\n    function transferToken(\n        address token,\n        address sender,\n        address recipient,\n        int64 amount\n    ) external returns (int64 responseCode);\n\n    /// Transfers tokens where the calling account/contract is implicitly the first entry in the token transfer list,\n    /// where the amount is the value needed to zero balance the transfers. Regular signing rules apply for sending\n    /// (positive amount) or receiving (negative amount)\n    /// @param token The token to transfer to/from\n    /// @param sender The sender for the transaction\n    /// @param recipient The receiver of the transaction\n    /// @param serialNumber The serial number of the NFT to transfer.\n    function transferNFT(\n        address token,\n        address sender,\n        address recipient,\n        int64 serialNumber\n    ) external returns (int64 responseCode);\n\n    /// Allows spender to withdraw from your account multiple times, up to the value amount. If this function is called\n    /// again it overwrites the current allowance with value.",
            "codeOnlyTokens": 809,
            "startLine": 450,
            "endLine": 531,
            "type": ".sol_part_7",
            "isOversized": false
          },
          {
            "originalText": "    /// Only Applicable to Fungible Tokens\n    /// @param token The hedera token address to approve\n    /// @param spender the account address authorized to spend\n    /// @param amount the amount of tokens authorized to spend.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function approve(\n        address token,\n        address spender,\n        uint256 amount\n    ) external returns (int64 responseCode);\n\n    /// Transfers `amount` tokens from `from` to `to` using the\n    //  allowance mechanism. `amount` is then deducted from the caller's allowance.\n    /// Only applicable to fungible tokens\n    /// @param token The address of the fungible Hedera token to transfer\n    /// @param from The account address of the owner of the token, on the behalf of which to transfer `amount` tokens\n    /// @param to The account address of the receiver of the `amount` tokens\n    /// @param amount The amount of tokens to transfer from `from` to `to`\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function transferFrom(address token, address from, address to, uint256 amount) external returns (int64 responseCode);\n\n    /// Returns the amount which spender is still allowed to withdraw from owner.\n    /// Only Applicable to Fungible Tokens\n    /// @param token The Hedera token address to check the allowance of\n    /// @param owner the owner of the tokens to be spent\n    /// @param spender the spender of the tokens\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return allowance The amount which spender is still allowed to withdraw from owner.\n    function allowance(\n        address token,\n        address owner,\n        address spender\n    ) external returns (int64 responseCode, uint256 allowance);\n\n    /// Allow or reaffirm the approved address to transfer an NFT the approved address does not own.\n    /// Only Applicable to NFT Tokens\n    /// @param token The Hedera NFT token address to approve\n    /// @param approved The new approved NFT controller.  To revoke approvals pass in the zero address.\n    /// @param serialNumber The NFT serial number  to approve\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function approveNFT(\n        address token,\n        address approved,\n        uint256 serialNumber\n    ) external returns (int64 responseCode);\n\n    /// Transfers `serialNumber` of `token` from `from` to `to` using the allowance mechanism.\n    /// Only applicable to NFT tokens\n    /// @param token The address of the non-fungible Hedera token to transfer\n    /// @param from The account address of the owner of `serialNumber` of `token`\n    /// @param to The account address of the receiver of `serialNumber`\n    /// @param serialNumber The NFT serial number to transfer\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function transferFromNFT(address token, address from, address to, uint256 serialNumber) external returns (int64 responseCode);\n\n    /// Get the approved address for a single NFT\n    /// Only Applicable to NFT Tokens\n    /// @param token The Hedera NFT token address to check approval\n    /// @param serialNumber The NFT to find the approved address for\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return approved The approved address for this NFT, or the zero address if there is none\n    function getApproved(address token, uint256 serialNumber)\n        external\n        returns (int64 responseCode, address approved);\n\n    /// Enable or disable approval for a third party (\"operator\") to manage",
            "codeOnlyTokens": 806,
            "startLine": 532,
            "endLine": 597,
            "type": ".sol_part_8",
            "isOversized": false
          },
          {
            "originalText": "    ///  all of `msg.sender`'s assets\n    /// @param token The Hedera NFT token address to approve\n    /// @param operator Address to add to the set of authorized operators\n    /// @param approved True if the operator is approved, false to revoke approval\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function setApprovalForAll(\n        address token,\n        address operator,\n        bool approved\n    ) external returns (int64 responseCode);\n\n    /// Query if an address is an authorized operator for another address\n    /// Only Applicable to NFT Tokens\n    /// @param token The Hedera NFT token address to approve\n    /// @param owner The address that owns the NFTs\n    /// @param operator The address that acts on behalf of the owner\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return approved True if `operator` is an approved operator for `owner`, false otherwise\n    function isApprovedForAll(\n        address token,\n        address owner,\n        address operator\n    ) external returns (int64 responseCode, bool approved);\n\n    /// Query if token account is frozen\n    /// @param token The token address to check\n    /// @param account The account address associated with the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return frozen True if `account` is frozen for `token`\n    function isFrozen(address token, address account)\n        external\n        returns (int64 responseCode, bool frozen);\n\n    /// Query if token account has kyc granted\n    /// @param token The token address to check\n    /// @param account The account address associated with the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return kycGranted True if `account` has kyc granted for `token`\n    function isKyc(address token, address account)\n        external\n        returns (int64 responseCode, bool kycGranted);\n\n    /// Operation to delete token\n    /// @param token The token address to be deleted\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function deleteToken(address token) external returns (int64 responseCode);\n\n    /// Query token custom fees\n    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return fixedFees Set of fixed fees for `token`\n    /// @return fractionalFees Set of fractional fees for `token`\n    /// @return royaltyFees Set of royalty fees for `token`\n    function getTokenCustomFees(address token)\n        external\n        returns (int64 responseCode, FixedFee[] memory fixedFees, FractionalFee[] memory fractionalFees, RoyaltyFee[] memory royaltyFees);\n\n    /// Query token default freeze status\n    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return defaultFreezeStatus True if `token` default freeze status is frozen.\n    function getTokenDefaultFreezeStatus(address token)\n        external\n        returns (int64 responseCode, bool defaultFreezeStatus);\n\n    /// Query token default kyc status\n    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return defaultKycStatus True if `token` default kyc status is KycNotApplicable and false if Revoked.\n    function getTokenDefaultKycStatus(address token)\n        external\n        returns (int64 responseCode, bool defaultKycStatus);",
            "codeOnlyTokens": 803,
            "startLine": 598,
            "endLine": 669,
            "type": ".sol_part_9",
            "isOversized": false
          },
          {
            "originalText": "\n    /// Query token expiry info\n    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return expiry Expiry info for `token`\n    function getTokenExpiryInfo(address token)\n        external\n        returns (int64 responseCode, Expiry memory expiry);\n\n    /// Query fungible token info\n    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return fungibleTokenInfo FungibleTokenInfo info for `token`\n    function getFungibleTokenInfo(address token)\n        external\n        returns (int64 responseCode, FungibleTokenInfo memory fungibleTokenInfo);\n\n    /// Query token info\n    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenInfo TokenInfo info for `token`\n    function getTokenInfo(address token)\n        external\n        returns (int64 responseCode, TokenInfo memory tokenInfo);\n\n    /// Query token KeyValue\n    /// @param token The token address to check\n    /// @param keyType The keyType of the desired KeyValue\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return key KeyValue info for key of type `keyType`\n    function getTokenKey(address token, uint keyType)\n        external\n        returns (int64 responseCode, KeyValue memory key);\n\n    /// Query non fungible token info\n    /// @param token The token address to check\n    /// @param serialNumber The NFT serialNumber to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return nonFungibleTokenInfo NonFungibleTokenInfo info for `token` `serialNumber`\n    function getNonFungibleTokenInfo(address token, int64 serialNumber)\n        external\n        returns (int64 responseCode, NonFungibleTokenInfo memory nonFungibleTokenInfo);\n\n    /// Operation to freeze token account\n    /// @param token The token address\n    /// @param account The account address to be frozen\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function freezeToken(address token, address account)\n        external\n        returns (int64 responseCode);\n\n    /// Operation to unfreeze token account\n    /// @param token The token address\n    /// @param account The account address to be unfrozen\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function unfreezeToken(address token, address account)\n        external\n        returns (int64 responseCode);\n\n    /// Operation to grant kyc to token account\n    /// @param token The token address\n    /// @param account The account address to grant kyc\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function grantTokenKyc(address token, address account)\n        external\n        returns (int64 responseCode);\n\n    /// Operation to revoke kyc to token account\n    /// @param token The token address\n    /// @param account The account address to revoke kyc\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function revokeTokenKyc(address token, address account)\n        external\n        returns (int64 responseCode);\n\n    /// Operation to pause token\n    /// @param token The token address to be paused\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.",
            "codeOnlyTokens": 800,
            "startLine": 670,
            "endLine": 747,
            "type": ".sol_part_10",
            "isOversized": false
          },
          {
            "originalText": "    function pauseToken(address token) external returns (int64 responseCode);\n\n    /// Operation to unpause token\n    /// @param token The token address to be unpaused\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function unpauseToken(address token) external returns (int64 responseCode);\n\n    /// Operation to wipe fungible tokens from account\n    /// @param token The token address\n    /// @param account The account address to revoke kyc\n    /// @param amount The number of tokens to wipe\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function wipeTokenAccount(\n        address token,\n        address account,\n        int64 amount\n    ) external returns (int64 responseCode);\n\n    /// Operation to wipe non fungible tokens from account\n    /// @param token The token address\n    /// @param account The account address to revoke kyc\n    /// @param  serialNumbers The serial numbers of token to wipe\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function wipeTokenAccountNFT(\n        address token,\n        address account,\n        int64[] memory serialNumbers\n    ) external returns (int64 responseCode);\n\n    /// Operation to update token info\n    /// @param token The token address\n    /// @param tokenInfo The hedera token info to update token with\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateTokenInfo(address token, HederaToken memory tokenInfo)\n        external\n        returns (int64 responseCode);\n\n    /// Operation to update token expiry info\n    /// @param token The token address\n    /// @param expiryInfo The hedera token expiry info\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateTokenExpiryInfo(address token, Expiry memory expiryInfo)\n        external\n        returns (int64 responseCode);\n\n    /// Operation to update token expiry info\n    /// @param token The token address\n    /// @param keys The token keys\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateTokenKeys(address token, TokenKey[] memory keys)\n        external\n        returns (int64 responseCode);\n\n    /// Query if valid token found for the given address\n    /// @param token The token address\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return isToken True if valid token found for the given address\n    function isToken(address token)\n        external returns\n        (int64 responseCode, bool isToken);\n\n    /// Query to return the token type for a given address\n    /// @param token The token address\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenType the token type. 0 is FUNGIBLE_COMMON, 1 is NON_FUNGIBLE_UNIQUE, -1 is UNRECOGNIZED\n    function getTokenType(address token)\n        external returns\n        (int64 responseCode, int32 tokenType);\n\n    /// Initiates a Redirect For Token\n    /// @param token The token address\n    /// @param encodedFunctionSelector The function selector from the ERC20 interface + the bytes input for the function called\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return response The result of the call that had been encoded and sent for execution.\n    function redirectForToken(address token, bytes memory encodedFunctionSelector) external returns (int64 responseCode, bytes memory response);\n\n    /// Update the custom fees for a fungible token",
            "codeOnlyTokens": 805,
            "startLine": 748,
            "endLine": 824,
            "type": ".sol_part_11",
            "isOversized": false
          },
          {
            "originalText": "    /// @param token The token address\n    /// @param fixedFees Set of fixed fees for `token`\n    /// @param fractionalFees Set of fractional fees for `token`\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateFungibleTokenCustomFees(address token,  IHederaTokenService.FixedFee[] memory fixedFees, IHederaTokenService.FractionalFee[] memory fractionalFees) external returns (int64 responseCode);\n\n    /// Update the custom fees for a non-fungible token\n    /// @param token The token address\n    /// @param fixedFees Set of fixed fees for `token`\n    /// @param royaltyFees Set of royalty fees for `token`\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateNonFungibleTokenCustomFees(address token, IHederaTokenService.FixedFee[] memory fixedFees, IHederaTokenService.RoyaltyFee[] memory royaltyFees) external returns (int64 responseCode);\n\n    /// @notice Airdrop one or more tokens to one or more accounts\n    /// @notice Recipients will receive tokens in one of these ways:\n    /// @notice     - Immediately if already associated with the token\n    /// @notice     - Immediately with auto-association if they have available slots\n    /// @notice     - As a pending airdrop requiring claim if they have \"receiver signature required\" \n    /// @notice     - As a pending airdrop requiring claim if they have no available auto-association slots\n    /// @notice Immediate airdrops are irreversible, pending airdrops can be canceled\n    /// @notice All transfer fees and auto-renewal rent costs are charged to the transaction submitter\n    /// @param tokenTransfers Array of token transfer lists containing token addresses and recipient details\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function airdropTokens(TokenTransferList[] memory tokenTransfers) external returns (int64 responseCode);\n\n    /// @notice Cancels pending airdrops that have not yet been claimed\n    /// @param pendingAirdrops Array of pending airdrops to cancel\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function cancelAirdrops(PendingAirdrop[] memory pendingAirdrops) external returns (int64 responseCode);\n\n    /// @notice Claims pending airdrops that were sent to the calling account\n    /// @param pendingAirdrops Array of pending airdrops to claim\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function claimAirdrops(PendingAirdrop[] memory pendingAirdrops) external returns (int64 responseCode);\n\n    /// @notice Rejects one or more tokens by transferring their full balance from the requesting account to the treasury\n    /// @notice This transfer does not charge any custom fees or royalties defined for the tokens\n    /// @notice For fungible tokens, the requesting account's balance will become 0 and the treasury balance will increase by that amount\n    /// @notice For non-fungible tokens, the requesting account will no longer hold the rejected serial numbers and they will be transferred to the treasury\n    /// @param rejectingAddress The address rejecting the tokens\n    /// @param ftAddresses Array of fungible token addresses to reject\n    /// @param nftIDs Array of NFT IDs to reject\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function rejectTokens(address rejectingAddress, address[] memory ftAddresses, NftID[] memory nftIDs) external returns (int64 responseCode);\n}\n",
            "codeOnlyTokens": 791,
            "startLine": 825,
            "endLine": 870,
            "type": ".sol_part_12",
            "isOversized": false
          }
        ],
        "groupedChunks": [
          {
            "combinedText": "// File: contracts/system-contracts/hedera-token-service/IHederaTokenService.sol\n// Relevant file context:\n// Type: .sol\n\n\n// --- Next chunk ---\n\n// Lines 1-74 (.sol_part_1)\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.9 <0.9.0;\npragma experimental ABIEncoderV2;\n\ninterface IHederaTokenService {\n    /// Transfers cryptocurrency among two or more accounts by making the desired adjustments to their\n    /// balances. Each transfer list can specify up to 10 adjustments. Each negative amount is withdrawn\n    /// from the corresponding account (a sender), and each positive one is added to the corresponding\n    /// account (a receiver). The amounts list must sum to zero. Each amount is a number of tinybars\n    /// (there are 100,000,000 tinybars in one hbar).  If any sender account fails to have sufficient\n    /// hbars, then the entire transaction fails, and none of those transfers occur, though the\n    /// transaction fee is still charged. This transaction must be signed by the keys for all the sending\n    /// accounts, and for any receiving accounts that have receiverSigRequired == true. The signatures\n    /// are in the same order as the accounts, skipping those accounts that don't need a signature.\n    /// @custom:version 0.3.0 previous version did not include isApproval\n    struct AccountAmount {\n        // The Account ID, as a solidity address, that sends/receives cryptocurrency or tokens\n        address accountID;\n\n        // The amount of  the lowest denomination of the given token that\n        // the account sends(negative) or receives(positive)\n        int64 amount;\n\n        // If true then the transfer is expected to be an approved allowance and the\n        // accountID is expected to be the owner. The default is false (omitted).\n        bool isApproval;\n    }\n\n    /// A sender account, a receiver account, and the serial number of an NFT of a Token with\n    /// NON_FUNGIBLE_UNIQUE type. When minting NFTs the sender will be the default AccountID instance\n    /// (0.0.0 aka 0x0) and when burning NFTs, the receiver will be the default AccountID instance.\n    /// @custom:version 0.3.0 previous version did not include isApproval\n    struct NftTransfer {\n        // The solidity address of the sender\n        address senderAccountID;\n\n        // The solidity address of the receiver\n        address receiverAccountID;\n\n        // The serial number of the NFT\n        int64 serialNumber;\n\n        // If true then the transfer is expected to be an approved allowance and the\n        // accountID is expected to be the owner. The default is false (omitted).\n        bool isApproval;\n    }\n\n    struct TokenTransferList {\n        // The ID of the token as a solidity address\n        address token;\n\n        // Applicable to tokens of type FUNGIBLE_COMMON. Multiple list of AccountAmounts, each of which\n        // has an account and amount.\n        AccountAmount[] transfers;\n\n        // Applicable to tokens of type NON_FUNGIBLE_UNIQUE. Multiple list of NftTransfers, each of\n        // which has a sender and receiver account, including the serial number of the NFT\n        NftTransfer[] nftTransfers;\n    }\n\n    struct TransferList {\n        // Multiple list of AccountAmounts, each of which has an account and amount.\n        // Used to transfer hbars between the accounts in the list.\n        AccountAmount[] transfers;\n    }\n\n    /// Expiry properties of a Hedera token - second, autoRenewAccount, autoRenewPeriod\n    struct Expiry {\n        // The epoch second at which the token should expire; if an auto-renew account and period are\n        // specified, this is coerced to the current epoch second plus the autoRenewPeriod\n        int64 second;\n\n        // ID of an account which will be automatically charged to renew the token's expiration, at\n        // autoRenewPeriod interval, expressed as a solidity address\n\n// --- Next chunk ---\n\n// Lines 75-145 (.sol_part_2)\n        address autoRenewAccount;\n\n        // The interval at which the auto-renew account will be charged to extend the token's expiry\n        int64 autoRenewPeriod;\n    }\n\n    /// A Key can be a public key from either the Ed25519 or ECDSA(secp256k1) signature schemes, where\n    /// in the ECDSA(secp256k1) case we require the 33-byte compressed form of the public key. We call\n    /// these public keys <b>primitive keys</b>.\n    /// A Key can also be the ID of a smart contract instance, which is then authorized to perform any\n    /// precompiled contract action that requires this key to sign.\n    /// Note that when a Key is a smart contract ID, it <i>doesn't</i> mean the contract with that ID\n    /// will actually create a cryptographic signature. It only means that when the contract calls a\n    /// precompiled contract, the resulting \"child transaction\" will be authorized to perform any action\n    /// controlled by the Key.\n    /// Exactly one of the possible values should be populated in order for the Key to be valid.\n    struct KeyValue {\n\n        // if set to true, the key of the calling Hedera account will be inherited as the token key\n        bool inheritAccountKey;\n\n        // smart contract instance that is authorized as if it had signed with a key\n        address contractId;\n\n        // Ed25519 public key bytes\n        bytes ed25519;\n\n        // Compressed ECDSA(secp256k1) public key bytes\n        bytes ECDSA_secp256k1;\n\n        // A smart contract that, if the recipient of the active message frame, should be treated\n        // as having signed. (Note this does not mean the <i>code being executed in the frame</i>\n        // will belong to the given contract, since it could be running another contract's code via\n        // <tt>delegatecall</tt>. So setting this key is a more permissive version of setting the\n        // contractID key, which also requires the code in the active message frame belong to the\n        // the contract with the given id.)\n        address delegatableContractId;\n    }\n\n    /// A list of token key types the key should be applied to and the value of the key\n    struct TokenKey {\n\n        // bit field representing the key type. Keys of all types that have corresponding bits set to 1\n        // will be created for the token.\n        // 0th bit: adminKey\n        // 1st bit: kycKey\n        // 2nd bit: freezeKey\n        // 3rd bit: wipeKey\n        // 4th bit: supplyKey\n        // 5th bit: feeScheduleKey\n        // 6th bit: pauseKey\n        // 7th bit: ignored\n        uint keyType;\n\n        // the value that will be set to the key type\n        KeyValue key;\n    }\n\n    /// Basic properties of a Hedera Token - name, symbol, memo, tokenSupplyType, maxSupply,\n    /// treasury, freezeDefault. These properties are related both to Fungible and NFT token types.\n    struct HederaToken {\n        // The publicly visible name of the token. The token name is specified as a Unicode string.\n        // Its UTF-8 encoding cannot exceed 100 bytes, and cannot contain the 0 byte (NUL).\n        string name;\n\n        // The publicly visible token symbol. The token symbol is specified as a Unicode string.\n        // Its UTF-8 encoding cannot exceed 100 bytes, and cannot contain the 0 byte (NUL).\n        string symbol;\n\n        // The ID of the account which will act as a treasury for the token as a solidity address.\n        // This account will receive the specified initial supply or the newly minted NFTs in\n\n// --- Next chunk ---\n\n// Lines 146-252 (.sol_part_3)\n        // the case for NON_FUNGIBLE_UNIQUE Type\n        address treasury;\n\n        // The memo associated with the token (UTF-8 encoding max 100 bytes)\n        string memo;\n\n        // IWA compatibility. Specified the token supply type. Defaults to INFINITE\n        bool tokenSupplyType;\n\n        // IWA Compatibility. Depends on TokenSupplyType. For tokens of type FUNGIBLE_COMMON - the\n        // maximum number of tokens that can be in circulation. For tokens of type NON_FUNGIBLE_UNIQUE -\n        // the maximum number of NFTs (serial numbers) that can be minted. This field can never be changed!\n        int64 maxSupply;\n\n        // The default Freeze status (frozen or unfrozen) of Hedera accounts relative to this token. If\n        // true, an account must be unfrozen before it can receive the token\n        bool freezeDefault;\n\n        // list of keys to set to the token\n        TokenKey[] tokenKeys;\n\n        // expiry properties of a Hedera token - second, autoRenewAccount, autoRenewPeriod\n        Expiry expiry;\n    }\n\n    /// Additional post creation fungible and non fungible properties of a Hedera Token.\n    struct TokenInfo {\n        /// Basic properties of a Hedera Token\n        HederaToken token;\n\n        /// The number of tokens (fungible) or serials (non-fungible) of the token\n        int64 totalSupply;\n\n        /// Specifies whether the token is deleted or not\n        bool deleted;\n\n        /// Specifies whether the token kyc was defaulted with KycNotApplicable (true) or Revoked (false)\n        bool defaultKycStatus;\n\n        /// Specifies whether the token is currently paused or not\n        bool pauseStatus;\n\n        /// The fixed fees collected when transferring the token\n        FixedFee[] fixedFees;\n\n        /// The fractional fees collected when transferring the token\n        FractionalFee[] fractionalFees;\n\n        /// The royalty fees collected when transferring the token\n        RoyaltyFee[] royaltyFees;\n\n        /// The ID of the network ledger\n        string ledgerId;\n    }\n\n    /// Additional fungible properties of a Hedera Token.\n    struct FungibleTokenInfo {\n        /// The shared hedera token info\n        TokenInfo tokenInfo;\n\n        /// The number of decimal places a token is divisible by\n        int32 decimals;\n    }\n\n    /// Additional non fungible properties of a Hedera Token.\n    struct NonFungibleTokenInfo {\n        /// The shared hedera token info\n        TokenInfo tokenInfo;\n\n        /// The serial number of the nft\n        int64 serialNumber;\n\n        /// The account id specifying the owner of the non fungible token\n        address ownerId;\n\n        /// The epoch second at which the token was created.\n        int64 creationTime;\n\n        /// The unique metadata of the NFT\n        bytes metadata;\n\n        /// The account id specifying an account that has been granted spending permissions on this nft\n        address spenderId;\n    }\n\n    /// A fixed number of units (hbar or token) to assess as a fee during a transfer of\n    /// units of the token to which this fixed fee is attached. The denomination of\n    /// the fee depends on the values of tokenId, useHbarsForPayment and\n    /// useCurrentTokenForPayment. Exactly one of the values should be set.\n    struct FixedFee {\n\n        int64 amount;\n\n        // Specifies ID of token that should be used for fixed fee denomination\n        address tokenId;\n\n        // Specifies this fixed fee should be denominated in Hbar\n        bool useHbarsForPayment;\n\n        // Specifies this fixed fee should be denominated in the Token currently being created\n        bool useCurrentTokenForPayment;\n\n        // The ID of the account to receive the custom fee, expressed as a solidity address\n        address feeCollector;\n    }\n\n    /// A fraction of the transferred units of a token to assess as a fee. The amount assessed will never",
            "totalTokens": 2517,
            "chunks": [
              {
                "originalText": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.9 <0.9.0;\npragma experimental ABIEncoderV2;\n\ninterface IHederaTokenService {\n    /// Transfers cryptocurrency among two or more accounts by making the desired adjustments to their\n    /// balances. Each transfer list can specify up to 10 adjustments. Each negative amount is withdrawn\n    /// from the corresponding account (a sender), and each positive one is added to the corresponding\n    /// account (a receiver). The amounts list must sum to zero. Each amount is a number of tinybars\n    /// (there are 100,000,000 tinybars in one hbar).  If any sender account fails to have sufficient\n    /// hbars, then the entire transaction fails, and none of those transfers occur, though the\n    /// transaction fee is still charged. This transaction must be signed by the keys for all the sending\n    /// accounts, and for any receiving accounts that have receiverSigRequired == true. The signatures\n    /// are in the same order as the accounts, skipping those accounts that don't need a signature.\n    /// @custom:version 0.3.0 previous version did not include isApproval\n    struct AccountAmount {\n        // The Account ID, as a solidity address, that sends/receives cryptocurrency or tokens\n        address accountID;\n\n        // The amount of  the lowest denomination of the given token that\n        // the account sends(negative) or receives(positive)\n        int64 amount;\n\n        // If true then the transfer is expected to be an approved allowance and the\n        // accountID is expected to be the owner. The default is false (omitted).\n        bool isApproval;\n    }\n\n    /// A sender account, a receiver account, and the serial number of an NFT of a Token with\n    /// NON_FUNGIBLE_UNIQUE type. When minting NFTs the sender will be the default AccountID instance\n    /// (0.0.0 aka 0x0) and when burning NFTs, the receiver will be the default AccountID instance.\n    /// @custom:version 0.3.0 previous version did not include isApproval\n    struct NftTransfer {\n        // The solidity address of the sender\n        address senderAccountID;\n\n        // The solidity address of the receiver\n        address receiverAccountID;\n\n        // The serial number of the NFT\n        int64 serialNumber;\n\n        // If true then the transfer is expected to be an approved allowance and the\n        // accountID is expected to be the owner. The default is false (omitted).\n        bool isApproval;\n    }\n\n    struct TokenTransferList {\n        // The ID of the token as a solidity address\n        address token;\n\n        // Applicable to tokens of type FUNGIBLE_COMMON. Multiple list of AccountAmounts, each of which\n        // has an account and amount.\n        AccountAmount[] transfers;\n\n        // Applicable to tokens of type NON_FUNGIBLE_UNIQUE. Multiple list of NftTransfers, each of\n        // which has a sender and receiver account, including the serial number of the NFT\n        NftTransfer[] nftTransfers;\n    }\n\n    struct TransferList {\n        // Multiple list of AccountAmounts, each of which has an account and amount.\n        // Used to transfer hbars between the accounts in the list.\n        AccountAmount[] transfers;\n    }\n\n    /// Expiry properties of a Hedera token - second, autoRenewAccount, autoRenewPeriod\n    struct Expiry {\n        // The epoch second at which the token should expire; if an auto-renew account and period are\n        // specified, this is coerced to the current epoch second plus the autoRenewPeriod\n        int64 second;\n\n        // ID of an account which will be automatically charged to renew the token's expiration, at\n        // autoRenewPeriod interval, expressed as a solidity address",
                "codeOnlyTokens": 805,
                "startLine": 1,
                "endLine": 74,
                "type": ".sol_part_1",
                "isOversized": false
              },
              {
                "originalText": "        address autoRenewAccount;\n\n        // The interval at which the auto-renew account will be charged to extend the token's expiry\n        int64 autoRenewPeriod;\n    }\n\n    /// A Key can be a public key from either the Ed25519 or ECDSA(secp256k1) signature schemes, where\n    /// in the ECDSA(secp256k1) case we require the 33-byte compressed form of the public key. We call\n    /// these public keys <b>primitive keys</b>.\n    /// A Key can also be the ID of a smart contract instance, which is then authorized to perform any\n    /// precompiled contract action that requires this key to sign.\n    /// Note that when a Key is a smart contract ID, it <i>doesn't</i> mean the contract with that ID\n    /// will actually create a cryptographic signature. It only means that when the contract calls a\n    /// precompiled contract, the resulting \"child transaction\" will be authorized to perform any action\n    /// controlled by the Key.\n    /// Exactly one of the possible values should be populated in order for the Key to be valid.\n    struct KeyValue {\n\n        // if set to true, the key of the calling Hedera account will be inherited as the token key\n        bool inheritAccountKey;\n\n        // smart contract instance that is authorized as if it had signed with a key\n        address contractId;\n\n        // Ed25519 public key bytes\n        bytes ed25519;\n\n        // Compressed ECDSA(secp256k1) public key bytes\n        bytes ECDSA_secp256k1;\n\n        // A smart contract that, if the recipient of the active message frame, should be treated\n        // as having signed. (Note this does not mean the <i>code being executed in the frame</i>\n        // will belong to the given contract, since it could be running another contract's code via\n        // <tt>delegatecall</tt>. So setting this key is a more permissive version of setting the\n        // contractID key, which also requires the code in the active message frame belong to the\n        // the contract with the given id.)\n        address delegatableContractId;\n    }\n\n    /// A list of token key types the key should be applied to and the value of the key\n    struct TokenKey {\n\n        // bit field representing the key type. Keys of all types that have corresponding bits set to 1\n        // will be created for the token.\n        // 0th bit: adminKey\n        // 1st bit: kycKey\n        // 2nd bit: freezeKey\n        // 3rd bit: wipeKey\n        // 4th bit: supplyKey\n        // 5th bit: feeScheduleKey\n        // 6th bit: pauseKey\n        // 7th bit: ignored\n        uint keyType;\n\n        // the value that will be set to the key type\n        KeyValue key;\n    }\n\n    /// Basic properties of a Hedera Token - name, symbol, memo, tokenSupplyType, maxSupply,\n    /// treasury, freezeDefault. These properties are related both to Fungible and NFT token types.\n    struct HederaToken {\n        // The publicly visible name of the token. The token name is specified as a Unicode string.\n        // Its UTF-8 encoding cannot exceed 100 bytes, and cannot contain the 0 byte (NUL).\n        string name;\n\n        // The publicly visible token symbol. The token symbol is specified as a Unicode string.\n        // Its UTF-8 encoding cannot exceed 100 bytes, and cannot contain the 0 byte (NUL).\n        string symbol;\n\n        // The ID of the account which will act as a treasury for the token as a solidity address.\n        // This account will receive the specified initial supply or the newly minted NFTs in",
                "codeOnlyTokens": 810,
                "startLine": 75,
                "endLine": 145,
                "type": ".sol_part_2",
                "isOversized": false
              },
              {
                "originalText": "        // the case for NON_FUNGIBLE_UNIQUE Type\n        address treasury;\n\n        // The memo associated with the token (UTF-8 encoding max 100 bytes)\n        string memo;\n\n        // IWA compatibility. Specified the token supply type. Defaults to INFINITE\n        bool tokenSupplyType;\n\n        // IWA Compatibility. Depends on TokenSupplyType. For tokens of type FUNGIBLE_COMMON - the\n        // maximum number of tokens that can be in circulation. For tokens of type NON_FUNGIBLE_UNIQUE -\n        // the maximum number of NFTs (serial numbers) that can be minted. This field can never be changed!\n        int64 maxSupply;\n\n        // The default Freeze status (frozen or unfrozen) of Hedera accounts relative to this token. If\n        // true, an account must be unfrozen before it can receive the token\n        bool freezeDefault;\n\n        // list of keys to set to the token\n        TokenKey[] tokenKeys;\n\n        // expiry properties of a Hedera token - second, autoRenewAccount, autoRenewPeriod\n        Expiry expiry;\n    }\n\n    /// Additional post creation fungible and non fungible properties of a Hedera Token.\n    struct TokenInfo {\n        /// Basic properties of a Hedera Token\n        HederaToken token;\n\n        /// The number of tokens (fungible) or serials (non-fungible) of the token\n        int64 totalSupply;\n\n        /// Specifies whether the token is deleted or not\n        bool deleted;\n\n        /// Specifies whether the token kyc was defaulted with KycNotApplicable (true) or Revoked (false)\n        bool defaultKycStatus;\n\n        /// Specifies whether the token is currently paused or not\n        bool pauseStatus;\n\n        /// The fixed fees collected when transferring the token\n        FixedFee[] fixedFees;\n\n        /// The fractional fees collected when transferring the token\n        FractionalFee[] fractionalFees;\n\n        /// The royalty fees collected when transferring the token\n        RoyaltyFee[] royaltyFees;\n\n        /// The ID of the network ledger\n        string ledgerId;\n    }\n\n    /// Additional fungible properties of a Hedera Token.\n    struct FungibleTokenInfo {\n        /// The shared hedera token info\n        TokenInfo tokenInfo;\n\n        /// The number of decimal places a token is divisible by\n        int32 decimals;\n    }\n\n    /// Additional non fungible properties of a Hedera Token.\n    struct NonFungibleTokenInfo {\n        /// The shared hedera token info\n        TokenInfo tokenInfo;\n\n        /// The serial number of the nft\n        int64 serialNumber;\n\n        /// The account id specifying the owner of the non fungible token\n        address ownerId;\n\n        /// The epoch second at which the token was created.\n        int64 creationTime;\n\n        /// The unique metadata of the NFT\n        bytes metadata;\n\n        /// The account id specifying an account that has been granted spending permissions on this nft\n        address spenderId;\n    }\n\n    /// A fixed number of units (hbar or token) to assess as a fee during a transfer of\n    /// units of the token to which this fixed fee is attached. The denomination of\n    /// the fee depends on the values of tokenId, useHbarsForPayment and\n    /// useCurrentTokenForPayment. Exactly one of the values should be set.\n    struct FixedFee {\n\n        int64 amount;\n\n        // Specifies ID of token that should be used for fixed fee denomination\n        address tokenId;\n\n        // Specifies this fixed fee should be denominated in Hbar\n        bool useHbarsForPayment;\n\n        // Specifies this fixed fee should be denominated in the Token currently being created\n        bool useCurrentTokenForPayment;\n\n        // The ID of the account to receive the custom fee, expressed as a solidity address\n        address feeCollector;\n    }\n\n    /// A fraction of the transferred units of a token to assess as a fee. The amount assessed will never",
                "codeOnlyTokens": 817,
                "startLine": 146,
                "endLine": 252,
                "type": ".sol_part_3",
                "isOversized": false
              }
            ],
            "startLine": 1,
            "endLine": 252,
            "groupId": 1
          },
          {
            "combinedText": "// File: contracts/system-contracts/hedera-token-service/IHederaTokenService.sol\n// Relevant file context:\n// Type: .sol\n\n\n// --- Next chunk ---\n\n// Lines 253-332 (.sol_part_4)\n    /// be less than the given minimumAmount, and never greater than the given maximumAmount.  The\n    /// denomination is always units of the token to which this fractional fee is attached.\n    struct FractionalFee {\n        // A rational number's numerator, used to set the amount of a value transfer to collect as a custom fee\n        int64 numerator;\n\n        // A rational number's denominator, used to set the amount of a value transfer to collect as a custom fee\n        int64 denominator;\n\n        // The minimum amount to assess\n        int64 minimumAmount;\n\n        // The maximum amount to assess (zero implies no maximum)\n        int64 maximumAmount;\n        bool netOfTransfers;\n\n        // The ID of the account to receive the custom fee, expressed as a solidity address\n        address feeCollector;\n    }\n\n    /// A fee to assess during a transfer that changes ownership of an NFT. Defines the fraction of\n    /// the fungible value exchanged for an NFT that the ledger should collect as a royalty. (\"Fungible\n    /// value\" includes both ℏ and units of fungible HTS tokens.) When the NFT sender does not receive\n    /// any fungible value, the ledger will assess the fallback fee, if present, to the new NFT owner.\n    /// Royalty fees can only be added to tokens of type type NON_FUNGIBLE_UNIQUE.\n    struct RoyaltyFee {\n        // A fraction's numerator of fungible value exchanged for an NFT to collect as royalty\n        int64 numerator;\n\n        // A fraction's denominator of fungible value exchanged for an NFT to collect as royalty\n        int64 denominator;\n\n        // If present, the fee to assess to the NFT receiver when no fungible value\n        // is exchanged with the sender. Consists of:\n        // amount: the amount to charge for the fee\n        // tokenId: Specifies ID of token that should be used for fixed fee denomination\n        // useHbarsForPayment: Specifies this fee should be denominated in Hbar\n        int64 amount;\n        address tokenId;\n        bool useHbarsForPayment;\n\n        // The ID of the account to receive the custom fee, expressed as a solidity address\n        address feeCollector;\n    }\n\n    /// Represents a pending airdrop of a token or NFT to a receiver\n    /// @param sender The address of the account sending the airdrop\n    /// @param receiver The address of the account receiving the airdrop\n    /// @param token The address of the token being airdropped\n    /// @param serial For NFT airdrops, the serial number of the NFT. For fungible tokens, this should be 0\n    struct PendingAirdrop {\n        address sender;\n        address receiver;\n        address token;\n        int64 serial;\n    }\n\n    /// Represents a unique NFT by its token address and serial number\n    /// @param nft The address of the NFT token\n    /// @param serial The serial number that uniquely identifies this NFT within its token type\n    struct NftID {\n        address nft;\n        int64 serial;\n    }\n\n    /**********************\n     * Direct HTS Calls   *\n     **********************/\n\n    /// Performs transfers among combinations of tokens and hbars\n    /// @param transferList the list of hbar transfers to do\n    /// @param tokenTransfers the list of token transfers to do\n    /// @custom:version 0.3.0 the signature of the previous version was cryptoTransfer(TokenTransferList[] memory tokenTransfers)\n    function cryptoTransfer(TransferList memory transferList, TokenTransferList[] memory tokenTransfers)\n        external\n        returns (int64 responseCode);\n\n    /// Mints an amount of the token to the defined treasury account\n    /// @param token The token for which to mint tokens. If token does not exist, transaction results in\n    ///              INVALID_TOKEN_ID\n\n// --- Next chunk ---\n\n// Lines 333-390 (.sol_part_5)\n    /// @param amount Applicable to tokens of type FUNGIBLE_COMMON. The amount to mint to the Treasury Account.\n    ///               Amount must be a positive non-zero number represented in the lowest denomination of the\n    ///               token. The new supply must be lower than 2^63.\n    /// @param metadata Applicable to tokens of type NON_FUNGIBLE_UNIQUE. A list of metadata that are being created.\n    ///                 Maximum allowed size of each metadata is 100 bytes\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return newTotalSupply The new supply of tokens. For NFTs it is the total count of NFTs\n    /// @return serialNumbers If the token is an NFT the newly generate serial numbers, othersise empty.\n    function mintToken(\n        address token,\n        int64 amount,\n        bytes[] memory metadata\n    )\n        external\n        returns (\n            int64 responseCode,\n            int64 newTotalSupply,\n            int64[] memory serialNumbers\n        );\n\n    /// Burns an amount of the token from the defined treasury account\n    /// @param token The token for which to burn tokens. If token does not exist, transaction results in\n    ///              INVALID_TOKEN_ID\n    /// @param amount  Applicable to tokens of type FUNGIBLE_COMMON. The amount to burn from the Treasury Account.\n    ///                Amount must be a positive non-zero number, not bigger than the token balance of the treasury\n    ///                account (0; balance], represented in the lowest denomination.\n    /// @param serialNumbers Applicable to tokens of type NON_FUNGIBLE_UNIQUE. The list of serial numbers to be burned.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return newTotalSupply The new supply of tokens. For NFTs it is the total count of NFTs\n    function burnToken(\n        address token,\n        int64 amount,\n        int64[] memory serialNumbers\n    ) external returns (int64 responseCode, int64 newTotalSupply);\n\n    ///  Associates the provided account with the provided tokens. Must be signed by the provided\n    ///  Account's key or called from the accounts contract key\n    ///  If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.\n    ///  If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.\n    ///  If any of the provided tokens is not found, the transaction will resolve to INVALID_TOKEN_REF.\n    ///  If any of the provided tokens has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.\n    ///  If an association between the provided account and any of the tokens already exists, the\n    ///  transaction will resolve to TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT.\n    ///  If the provided account's associations count exceed the constraint of maximum token associations\n    ///    per account, the transaction will resolve to TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED.\n    ///  On success, associations between the provided account and tokens are made and the account is\n    ///    ready to interact with the tokens.\n    /// @param account The account to be associated with the provided tokens\n    /// @param tokens The tokens to be associated with the provided account. In the case of NON_FUNGIBLE_UNIQUE\n    ///               Type, once an account is associated, it can hold any number of NFTs (serial numbers) of that\n    ///               token type\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function associateTokens(address account, address[] memory tokens)\n        external\n        returns (int64 responseCode);\n\n    /// Single-token variant of associateTokens. Will be mapped to a single entry array call of associateTokens\n    /// @param account The account to be associated with the provided token\n\n// --- Next chunk ---\n\n// Lines 391-449 (.sol_part_6)\n    /// @param token The token to be associated with the provided account\n    function associateToken(address account, address token)\n        external\n        returns (int64 responseCode);\n\n    /// Dissociates the provided account with the provided tokens. Must be signed by the provided\n    /// Account's key.\n    /// If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.\n    /// If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.\n    /// If any of the provided tokens is not found, the transaction will resolve to INVALID_TOKEN_REF.\n    /// If any of the provided tokens has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.\n    /// If an association between the provided account and any of the tokens does not exist, the\n    /// transaction will resolve to TOKEN_NOT_ASSOCIATED_TO_ACCOUNT.\n    /// If a token has not been deleted and has not expired, and the user has a nonzero balance, the\n    /// transaction will resolve to TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES.\n    /// If a <b>fungible token</b> has expired, the user can disassociate even if their token balance is\n    /// not zero.\n    /// If a <b>non fungible token</b> has expired, the user can <b>not</b> disassociate if their token\n    /// balance is not zero. The transaction will resolve to TRANSACTION_REQUIRED_ZERO_TOKEN_BALANCES.\n    /// On success, associations between the provided account and tokens are removed.\n    /// @param account The account to be dissociated from the provided tokens\n    /// @param tokens The tokens to be dissociated from the provided account.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function dissociateTokens(address account, address[] memory tokens)\n        external\n        returns (int64 responseCode);\n\n    /// Single-token variant of dissociateTokens. Will be mapped to a single entry array call of dissociateTokens\n    /// @param account The account to be associated with the provided token\n    /// @param token The token to be associated with the provided account\n    function dissociateToken(address account, address token)\n        external\n        returns (int64 responseCode);\n\n    /// Creates a Fungible Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @param initialTotalSupply Specifies the initial supply of tokens to be put in circulation. The\n    /// initial supply is sent to the Treasury Account. The supply is in the lowest denomination possible.\n    /// @param decimals the number of decimal places a token is divisible by\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createFungibleToken(\n        HederaToken memory token,\n        int64 initialTotalSupply,\n        int32 decimals\n    ) external payable returns (int64 responseCode, address tokenAddress);\n\n    /// Creates a Fungible Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @param initialTotalSupply Specifies the initial supply of tokens to be put in circulation. The\n    /// initial supply is sent to the Treasury Account. The supply is in the lowest denomination possible.\n    /// @param decimals the number of decimal places a token is divisible by.\n    /// @param fixedFees list of fixed fees to apply to the token\n    /// @param fractionalFees list of fractional fees to apply to the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createFungibleTokenWithCustomFees(\n        HederaToken memory token,\n        int64 initialTotalSupply,",
            "totalTokens": 2497,
            "chunks": [
              {
                "originalText": "    /// be less than the given minimumAmount, and never greater than the given maximumAmount.  The\n    /// denomination is always units of the token to which this fractional fee is attached.\n    struct FractionalFee {\n        // A rational number's numerator, used to set the amount of a value transfer to collect as a custom fee\n        int64 numerator;\n\n        // A rational number's denominator, used to set the amount of a value transfer to collect as a custom fee\n        int64 denominator;\n\n        // The minimum amount to assess\n        int64 minimumAmount;\n\n        // The maximum amount to assess (zero implies no maximum)\n        int64 maximumAmount;\n        bool netOfTransfers;\n\n        // The ID of the account to receive the custom fee, expressed as a solidity address\n        address feeCollector;\n    }\n\n    /// A fee to assess during a transfer that changes ownership of an NFT. Defines the fraction of\n    /// the fungible value exchanged for an NFT that the ledger should collect as a royalty. (\"Fungible\n    /// value\" includes both ℏ and units of fungible HTS tokens.) When the NFT sender does not receive\n    /// any fungible value, the ledger will assess the fallback fee, if present, to the new NFT owner.\n    /// Royalty fees can only be added to tokens of type type NON_FUNGIBLE_UNIQUE.\n    struct RoyaltyFee {\n        // A fraction's numerator of fungible value exchanged for an NFT to collect as royalty\n        int64 numerator;\n\n        // A fraction's denominator of fungible value exchanged for an NFT to collect as royalty\n        int64 denominator;\n\n        // If present, the fee to assess to the NFT receiver when no fungible value\n        // is exchanged with the sender. Consists of:\n        // amount: the amount to charge for the fee\n        // tokenId: Specifies ID of token that should be used for fixed fee denomination\n        // useHbarsForPayment: Specifies this fee should be denominated in Hbar\n        int64 amount;\n        address tokenId;\n        bool useHbarsForPayment;\n\n        // The ID of the account to receive the custom fee, expressed as a solidity address\n        address feeCollector;\n    }\n\n    /// Represents a pending airdrop of a token or NFT to a receiver\n    /// @param sender The address of the account sending the airdrop\n    /// @param receiver The address of the account receiving the airdrop\n    /// @param token The address of the token being airdropped\n    /// @param serial For NFT airdrops, the serial number of the NFT. For fungible tokens, this should be 0\n    struct PendingAirdrop {\n        address sender;\n        address receiver;\n        address token;\n        int64 serial;\n    }\n\n    /// Represents a unique NFT by its token address and serial number\n    /// @param nft The address of the NFT token\n    /// @param serial The serial number that uniquely identifies this NFT within its token type\n    struct NftID {\n        address nft;\n        int64 serial;\n    }\n\n    /**********************\n     * Direct HTS Calls   *\n     **********************/\n\n    /// Performs transfers among combinations of tokens and hbars\n    /// @param transferList the list of hbar transfers to do\n    /// @param tokenTransfers the list of token transfers to do\n    /// @custom:version 0.3.0 the signature of the previous version was cryptoTransfer(TokenTransferList[] memory tokenTransfers)\n    function cryptoTransfer(TransferList memory transferList, TokenTransferList[] memory tokenTransfers)\n        external\n        returns (int64 responseCode);\n\n    /// Mints an amount of the token to the defined treasury account\n    /// @param token The token for which to mint tokens. If token does not exist, transaction results in\n    ///              INVALID_TOKEN_ID",
                "codeOnlyTokens": 801,
                "startLine": 253,
                "endLine": 332,
                "type": ".sol_part_4",
                "isOversized": false
              },
              {
                "originalText": "    /// @param amount Applicable to tokens of type FUNGIBLE_COMMON. The amount to mint to the Treasury Account.\n    ///               Amount must be a positive non-zero number represented in the lowest denomination of the\n    ///               token. The new supply must be lower than 2^63.\n    /// @param metadata Applicable to tokens of type NON_FUNGIBLE_UNIQUE. A list of metadata that are being created.\n    ///                 Maximum allowed size of each metadata is 100 bytes\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return newTotalSupply The new supply of tokens. For NFTs it is the total count of NFTs\n    /// @return serialNumbers If the token is an NFT the newly generate serial numbers, othersise empty.\n    function mintToken(\n        address token,\n        int64 amount,\n        bytes[] memory metadata\n    )\n        external\n        returns (\n            int64 responseCode,\n            int64 newTotalSupply,\n            int64[] memory serialNumbers\n        );\n\n    /// Burns an amount of the token from the defined treasury account\n    /// @param token The token for which to burn tokens. If token does not exist, transaction results in\n    ///              INVALID_TOKEN_ID\n    /// @param amount  Applicable to tokens of type FUNGIBLE_COMMON. The amount to burn from the Treasury Account.\n    ///                Amount must be a positive non-zero number, not bigger than the token balance of the treasury\n    ///                account (0; balance], represented in the lowest denomination.\n    /// @param serialNumbers Applicable to tokens of type NON_FUNGIBLE_UNIQUE. The list of serial numbers to be burned.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return newTotalSupply The new supply of tokens. For NFTs it is the total count of NFTs\n    function burnToken(\n        address token,\n        int64 amount,\n        int64[] memory serialNumbers\n    ) external returns (int64 responseCode, int64 newTotalSupply);\n\n    ///  Associates the provided account with the provided tokens. Must be signed by the provided\n    ///  Account's key or called from the accounts contract key\n    ///  If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.\n    ///  If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.\n    ///  If any of the provided tokens is not found, the transaction will resolve to INVALID_TOKEN_REF.\n    ///  If any of the provided tokens has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.\n    ///  If an association between the provided account and any of the tokens already exists, the\n    ///  transaction will resolve to TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT.\n    ///  If the provided account's associations count exceed the constraint of maximum token associations\n    ///    per account, the transaction will resolve to TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED.\n    ///  On success, associations between the provided account and tokens are made and the account is\n    ///    ready to interact with the tokens.\n    /// @param account The account to be associated with the provided tokens\n    /// @param tokens The tokens to be associated with the provided account. In the case of NON_FUNGIBLE_UNIQUE\n    ///               Type, once an account is associated, it can hold any number of NFTs (serial numbers) of that\n    ///               token type\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function associateTokens(address account, address[] memory tokens)\n        external\n        returns (int64 responseCode);\n\n    /// Single-token variant of associateTokens. Will be mapped to a single entry array call of associateTokens\n    /// @param account The account to be associated with the provided token",
                "codeOnlyTokens": 806,
                "startLine": 333,
                "endLine": 390,
                "type": ".sol_part_5",
                "isOversized": false
              },
              {
                "originalText": "    /// @param token The token to be associated with the provided account\n    function associateToken(address account, address token)\n        external\n        returns (int64 responseCode);\n\n    /// Dissociates the provided account with the provided tokens. Must be signed by the provided\n    /// Account's key.\n    /// If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.\n    /// If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.\n    /// If any of the provided tokens is not found, the transaction will resolve to INVALID_TOKEN_REF.\n    /// If any of the provided tokens has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.\n    /// If an association between the provided account and any of the tokens does not exist, the\n    /// transaction will resolve to TOKEN_NOT_ASSOCIATED_TO_ACCOUNT.\n    /// If a token has not been deleted and has not expired, and the user has a nonzero balance, the\n    /// transaction will resolve to TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES.\n    /// If a <b>fungible token</b> has expired, the user can disassociate even if their token balance is\n    /// not zero.\n    /// If a <b>non fungible token</b> has expired, the user can <b>not</b> disassociate if their token\n    /// balance is not zero. The transaction will resolve to TRANSACTION_REQUIRED_ZERO_TOKEN_BALANCES.\n    /// On success, associations between the provided account and tokens are removed.\n    /// @param account The account to be dissociated from the provided tokens\n    /// @param tokens The tokens to be dissociated from the provided account.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function dissociateTokens(address account, address[] memory tokens)\n        external\n        returns (int64 responseCode);\n\n    /// Single-token variant of dissociateTokens. Will be mapped to a single entry array call of dissociateTokens\n    /// @param account The account to be associated with the provided token\n    /// @param token The token to be associated with the provided account\n    function dissociateToken(address account, address token)\n        external\n        returns (int64 responseCode);\n\n    /// Creates a Fungible Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @param initialTotalSupply Specifies the initial supply of tokens to be put in circulation. The\n    /// initial supply is sent to the Treasury Account. The supply is in the lowest denomination possible.\n    /// @param decimals the number of decimal places a token is divisible by\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createFungibleToken(\n        HederaToken memory token,\n        int64 initialTotalSupply,\n        int32 decimals\n    ) external payable returns (int64 responseCode, address tokenAddress);\n\n    /// Creates a Fungible Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @param initialTotalSupply Specifies the initial supply of tokens to be put in circulation. The\n    /// initial supply is sent to the Treasury Account. The supply is in the lowest denomination possible.\n    /// @param decimals the number of decimal places a token is divisible by.\n    /// @param fixedFees list of fixed fees to apply to the token\n    /// @param fractionalFees list of fractional fees to apply to the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createFungibleTokenWithCustomFees(\n        HederaToken memory token,\n        int64 initialTotalSupply,",
                "codeOnlyTokens": 804,
                "startLine": 391,
                "endLine": 449,
                "type": ".sol_part_6",
                "isOversized": false
              }
            ],
            "startLine": 253,
            "endLine": 449,
            "groupId": 2
          },
          {
            "combinedText": "// File: contracts/system-contracts/hedera-token-service/IHederaTokenService.sol\n// Relevant file context:\n// Type: .sol\n\n\n// --- Next chunk ---\n\n// Lines 450-531 (.sol_part_7)\n        int32 decimals,\n        FixedFee[] memory fixedFees,\n        FractionalFee[] memory fractionalFees\n    ) external payable returns (int64 responseCode, address tokenAddress);\n\n    /// Creates an Non Fungible Unique Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createNonFungibleToken(HederaToken memory token)\n        external\n        payable\n        returns (int64 responseCode, address tokenAddress);\n\n    /// Creates an Non Fungible Unique Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @param fixedFees list of fixed fees to apply to the token\n    /// @param royaltyFees list of royalty fees to apply to the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createNonFungibleTokenWithCustomFees(\n        HederaToken memory token,\n        FixedFee[] memory fixedFees,\n        RoyaltyFee[] memory royaltyFees\n    ) external payable returns (int64 responseCode, address tokenAddress);\n\n    /**********************\n     * ABIV1 calls        *\n     **********************/\n\n    /// Initiates a Fungible Token Transfer\n    /// @param token The ID of the token as a solidity address\n    /// @param accountId account to do a transfer to/from\n    /// @param amount The amount from the accountId at the same index\n    function transferTokens(\n        address token,\n        address[] memory accountId,\n        int64[] memory amount\n    ) external returns (int64 responseCode);\n\n    /// Initiates a Non-Fungable Token Transfer\n    /// @param token The ID of the token as a solidity address\n    /// @param sender the sender of an nft\n    /// @param receiver the receiver of the nft sent by the same index at sender\n    /// @param serialNumber the serial number of the nft sent by the same index at sender\n    function transferNFTs(\n        address token,\n        address[] memory sender,\n        address[] memory receiver,\n        int64[] memory serialNumber\n    ) external returns (int64 responseCode);\n\n    /// Transfers tokens where the calling account/contract is implicitly the first entry in the token transfer list,\n    /// where the amount is the value needed to zero balance the transfers. Regular signing rules apply for sending\n    /// (positive amount) or receiving (negative amount)\n    /// @param token The token to transfer to/from\n    /// @param sender The sender for the transaction\n    /// @param recipient The receiver of the transaction\n    /// @param amount Non-negative value to send. a negative value will result in a failure.\n    function transferToken(\n        address token,\n        address sender,\n        address recipient,\n        int64 amount\n    ) external returns (int64 responseCode);\n\n    /// Transfers tokens where the calling account/contract is implicitly the first entry in the token transfer list,\n    /// where the amount is the value needed to zero balance the transfers. Regular signing rules apply for sending\n    /// (positive amount) or receiving (negative amount)\n    /// @param token The token to transfer to/from\n    /// @param sender The sender for the transaction\n    /// @param recipient The receiver of the transaction\n    /// @param serialNumber The serial number of the NFT to transfer.\n    function transferNFT(\n        address token,\n        address sender,\n        address recipient,\n        int64 serialNumber\n    ) external returns (int64 responseCode);\n\n    /// Allows spender to withdraw from your account multiple times, up to the value amount. If this function is called\n    /// again it overwrites the current allowance with value.\n\n// --- Next chunk ---\n\n// Lines 532-597 (.sol_part_8)\n    /// Only Applicable to Fungible Tokens\n    /// @param token The hedera token address to approve\n    /// @param spender the account address authorized to spend\n    /// @param amount the amount of tokens authorized to spend.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function approve(\n        address token,\n        address spender,\n        uint256 amount\n    ) external returns (int64 responseCode);\n\n    /// Transfers `amount` tokens from `from` to `to` using the\n    //  allowance mechanism. `amount` is then deducted from the caller's allowance.\n    /// Only applicable to fungible tokens\n    /// @param token The address of the fungible Hedera token to transfer\n    /// @param from The account address of the owner of the token, on the behalf of which to transfer `amount` tokens\n    /// @param to The account address of the receiver of the `amount` tokens\n    /// @param amount The amount of tokens to transfer from `from` to `to`\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function transferFrom(address token, address from, address to, uint256 amount) external returns (int64 responseCode);\n\n    /// Returns the amount which spender is still allowed to withdraw from owner.\n    /// Only Applicable to Fungible Tokens\n    /// @param token The Hedera token address to check the allowance of\n    /// @param owner the owner of the tokens to be spent\n    /// @param spender the spender of the tokens\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return allowance The amount which spender is still allowed to withdraw from owner.\n    function allowance(\n        address token,\n        address owner,\n        address spender\n    ) external returns (int64 responseCode, uint256 allowance);\n\n    /// Allow or reaffirm the approved address to transfer an NFT the approved address does not own.\n    /// Only Applicable to NFT Tokens\n    /// @param token The Hedera NFT token address to approve\n    /// @param approved The new approved NFT controller.  To revoke approvals pass in the zero address.\n    /// @param serialNumber The NFT serial number  to approve\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function approveNFT(\n        address token,\n        address approved,\n        uint256 serialNumber\n    ) external returns (int64 responseCode);\n\n    /// Transfers `serialNumber` of `token` from `from` to `to` using the allowance mechanism.\n    /// Only applicable to NFT tokens\n    /// @param token The address of the non-fungible Hedera token to transfer\n    /// @param from The account address of the owner of `serialNumber` of `token`\n    /// @param to The account address of the receiver of `serialNumber`\n    /// @param serialNumber The NFT serial number to transfer\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function transferFromNFT(address token, address from, address to, uint256 serialNumber) external returns (int64 responseCode);\n\n    /// Get the approved address for a single NFT\n    /// Only Applicable to NFT Tokens\n    /// @param token The Hedera NFT token address to check approval\n    /// @param serialNumber The NFT to find the approved address for\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return approved The approved address for this NFT, or the zero address if there is none\n    function getApproved(address token, uint256 serialNumber)\n        external\n        returns (int64 responseCode, address approved);\n\n    /// Enable or disable approval for a third party (\"operator\") to manage\n\n// --- Next chunk ---\n\n// Lines 598-669 (.sol_part_9)\n    ///  all of `msg.sender`'s assets\n    /// @param token The Hedera NFT token address to approve\n    /// @param operator Address to add to the set of authorized operators\n    /// @param approved True if the operator is approved, false to revoke approval\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function setApprovalForAll(\n        address token,\n        address operator,\n        bool approved\n    ) external returns (int64 responseCode);\n\n    /// Query if an address is an authorized operator for another address\n    /// Only Applicable to NFT Tokens\n    /// @param token The Hedera NFT token address to approve\n    /// @param owner The address that owns the NFTs\n    /// @param operator The address that acts on behalf of the owner\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return approved True if `operator` is an approved operator for `owner`, false otherwise\n    function isApprovedForAll(\n        address token,\n        address owner,\n        address operator\n    ) external returns (int64 responseCode, bool approved);\n\n    /// Query if token account is frozen\n    /// @param token The token address to check\n    /// @param account The account address associated with the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return frozen True if `account` is frozen for `token`\n    function isFrozen(address token, address account)\n        external\n        returns (int64 responseCode, bool frozen);\n\n    /// Query if token account has kyc granted\n    /// @param token The token address to check\n    /// @param account The account address associated with the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return kycGranted True if `account` has kyc granted for `token`\n    function isKyc(address token, address account)\n        external\n        returns (int64 responseCode, bool kycGranted);\n\n    /// Operation to delete token\n    /// @param token The token address to be deleted\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function deleteToken(address token) external returns (int64 responseCode);\n\n    /// Query token custom fees\n    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return fixedFees Set of fixed fees for `token`\n    /// @return fractionalFees Set of fractional fees for `token`\n    /// @return royaltyFees Set of royalty fees for `token`\n    function getTokenCustomFees(address token)\n        external\n        returns (int64 responseCode, FixedFee[] memory fixedFees, FractionalFee[] memory fractionalFees, RoyaltyFee[] memory royaltyFees);\n\n    /// Query token default freeze status\n    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return defaultFreezeStatus True if `token` default freeze status is frozen.\n    function getTokenDefaultFreezeStatus(address token)\n        external\n        returns (int64 responseCode, bool defaultFreezeStatus);\n\n    /// Query token default kyc status\n    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return defaultKycStatus True if `token` default kyc status is KycNotApplicable and false if Revoked.\n    function getTokenDefaultKycStatus(address token)\n        external\n        returns (int64 responseCode, bool defaultKycStatus);",
            "totalTokens": 2502,
            "chunks": [
              {
                "originalText": "        int32 decimals,\n        FixedFee[] memory fixedFees,\n        FractionalFee[] memory fractionalFees\n    ) external payable returns (int64 responseCode, address tokenAddress);\n\n    /// Creates an Non Fungible Unique Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createNonFungibleToken(HederaToken memory token)\n        external\n        payable\n        returns (int64 responseCode, address tokenAddress);\n\n    /// Creates an Non Fungible Unique Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @param fixedFees list of fixed fees to apply to the token\n    /// @param royaltyFees list of royalty fees to apply to the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createNonFungibleTokenWithCustomFees(\n        HederaToken memory token,\n        FixedFee[] memory fixedFees,\n        RoyaltyFee[] memory royaltyFees\n    ) external payable returns (int64 responseCode, address tokenAddress);\n\n    /**********************\n     * ABIV1 calls        *\n     **********************/\n\n    /// Initiates a Fungible Token Transfer\n    /// @param token The ID of the token as a solidity address\n    /// @param accountId account to do a transfer to/from\n    /// @param amount The amount from the accountId at the same index\n    function transferTokens(\n        address token,\n        address[] memory accountId,\n        int64[] memory amount\n    ) external returns (int64 responseCode);\n\n    /// Initiates a Non-Fungable Token Transfer\n    /// @param token The ID of the token as a solidity address\n    /// @param sender the sender of an nft\n    /// @param receiver the receiver of the nft sent by the same index at sender\n    /// @param serialNumber the serial number of the nft sent by the same index at sender\n    function transferNFTs(\n        address token,\n        address[] memory sender,\n        address[] memory receiver,\n        int64[] memory serialNumber\n    ) external returns (int64 responseCode);\n\n    /// Transfers tokens where the calling account/contract is implicitly the first entry in the token transfer list,\n    /// where the amount is the value needed to zero balance the transfers. Regular signing rules apply for sending\n    /// (positive amount) or receiving (negative amount)\n    /// @param token The token to transfer to/from\n    /// @param sender The sender for the transaction\n    /// @param recipient The receiver of the transaction\n    /// @param amount Non-negative value to send. a negative value will result in a failure.\n    function transferToken(\n        address token,\n        address sender,\n        address recipient,\n        int64 amount\n    ) external returns (int64 responseCode);\n\n    /// Transfers tokens where the calling account/contract is implicitly the first entry in the token transfer list,\n    /// where the amount is the value needed to zero balance the transfers. Regular signing rules apply for sending\n    /// (positive amount) or receiving (negative amount)\n    /// @param token The token to transfer to/from\n    /// @param sender The sender for the transaction\n    /// @param recipient The receiver of the transaction\n    /// @param serialNumber The serial number of the NFT to transfer.\n    function transferNFT(\n        address token,\n        address sender,\n        address recipient,\n        int64 serialNumber\n    ) external returns (int64 responseCode);\n\n    /// Allows spender to withdraw from your account multiple times, up to the value amount. If this function is called\n    /// again it overwrites the current allowance with value.",
                "codeOnlyTokens": 809,
                "startLine": 450,
                "endLine": 531,
                "type": ".sol_part_7",
                "isOversized": false
              },
              {
                "originalText": "    /// Only Applicable to Fungible Tokens\n    /// @param token The hedera token address to approve\n    /// @param spender the account address authorized to spend\n    /// @param amount the amount of tokens authorized to spend.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function approve(\n        address token,\n        address spender,\n        uint256 amount\n    ) external returns (int64 responseCode);\n\n    /// Transfers `amount` tokens from `from` to `to` using the\n    //  allowance mechanism. `amount` is then deducted from the caller's allowance.\n    /// Only applicable to fungible tokens\n    /// @param token The address of the fungible Hedera token to transfer\n    /// @param from The account address of the owner of the token, on the behalf of which to transfer `amount` tokens\n    /// @param to The account address of the receiver of the `amount` tokens\n    /// @param amount The amount of tokens to transfer from `from` to `to`\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function transferFrom(address token, address from, address to, uint256 amount) external returns (int64 responseCode);\n\n    /// Returns the amount which spender is still allowed to withdraw from owner.\n    /// Only Applicable to Fungible Tokens\n    /// @param token The Hedera token address to check the allowance of\n    /// @param owner the owner of the tokens to be spent\n    /// @param spender the spender of the tokens\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return allowance The amount which spender is still allowed to withdraw from owner.\n    function allowance(\n        address token,\n        address owner,\n        address spender\n    ) external returns (int64 responseCode, uint256 allowance);\n\n    /// Allow or reaffirm the approved address to transfer an NFT the approved address does not own.\n    /// Only Applicable to NFT Tokens\n    /// @param token The Hedera NFT token address to approve\n    /// @param approved The new approved NFT controller.  To revoke approvals pass in the zero address.\n    /// @param serialNumber The NFT serial number  to approve\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function approveNFT(\n        address token,\n        address approved,\n        uint256 serialNumber\n    ) external returns (int64 responseCode);\n\n    /// Transfers `serialNumber` of `token` from `from` to `to` using the allowance mechanism.\n    /// Only applicable to NFT tokens\n    /// @param token The address of the non-fungible Hedera token to transfer\n    /// @param from The account address of the owner of `serialNumber` of `token`\n    /// @param to The account address of the receiver of `serialNumber`\n    /// @param serialNumber The NFT serial number to transfer\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function transferFromNFT(address token, address from, address to, uint256 serialNumber) external returns (int64 responseCode);\n\n    /// Get the approved address for a single NFT\n    /// Only Applicable to NFT Tokens\n    /// @param token The Hedera NFT token address to check approval\n    /// @param serialNumber The NFT to find the approved address for\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return approved The approved address for this NFT, or the zero address if there is none\n    function getApproved(address token, uint256 serialNumber)\n        external\n        returns (int64 responseCode, address approved);\n\n    /// Enable or disable approval for a third party (\"operator\") to manage",
                "codeOnlyTokens": 806,
                "startLine": 532,
                "endLine": 597,
                "type": ".sol_part_8",
                "isOversized": false
              },
              {
                "originalText": "    ///  all of `msg.sender`'s assets\n    /// @param token The Hedera NFT token address to approve\n    /// @param operator Address to add to the set of authorized operators\n    /// @param approved True if the operator is approved, false to revoke approval\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function setApprovalForAll(\n        address token,\n        address operator,\n        bool approved\n    ) external returns (int64 responseCode);\n\n    /// Query if an address is an authorized operator for another address\n    /// Only Applicable to NFT Tokens\n    /// @param token The Hedera NFT token address to approve\n    /// @param owner The address that owns the NFTs\n    /// @param operator The address that acts on behalf of the owner\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return approved True if `operator` is an approved operator for `owner`, false otherwise\n    function isApprovedForAll(\n        address token,\n        address owner,\n        address operator\n    ) external returns (int64 responseCode, bool approved);\n\n    /// Query if token account is frozen\n    /// @param token The token address to check\n    /// @param account The account address associated with the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return frozen True if `account` is frozen for `token`\n    function isFrozen(address token, address account)\n        external\n        returns (int64 responseCode, bool frozen);\n\n    /// Query if token account has kyc granted\n    /// @param token The token address to check\n    /// @param account The account address associated with the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return kycGranted True if `account` has kyc granted for `token`\n    function isKyc(address token, address account)\n        external\n        returns (int64 responseCode, bool kycGranted);\n\n    /// Operation to delete token\n    /// @param token The token address to be deleted\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function deleteToken(address token) external returns (int64 responseCode);\n\n    /// Query token custom fees\n    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return fixedFees Set of fixed fees for `token`\n    /// @return fractionalFees Set of fractional fees for `token`\n    /// @return royaltyFees Set of royalty fees for `token`\n    function getTokenCustomFees(address token)\n        external\n        returns (int64 responseCode, FixedFee[] memory fixedFees, FractionalFee[] memory fractionalFees, RoyaltyFee[] memory royaltyFees);\n\n    /// Query token default freeze status\n    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return defaultFreezeStatus True if `token` default freeze status is frozen.\n    function getTokenDefaultFreezeStatus(address token)\n        external\n        returns (int64 responseCode, bool defaultFreezeStatus);\n\n    /// Query token default kyc status\n    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return defaultKycStatus True if `token` default kyc status is KycNotApplicable and false if Revoked.\n    function getTokenDefaultKycStatus(address token)\n        external\n        returns (int64 responseCode, bool defaultKycStatus);",
                "codeOnlyTokens": 803,
                "startLine": 598,
                "endLine": 669,
                "type": ".sol_part_9",
                "isOversized": false
              }
            ],
            "startLine": 450,
            "endLine": 669,
            "groupId": 3
          },
          {
            "combinedText": "// File: contracts/system-contracts/hedera-token-service/IHederaTokenService.sol\n// Relevant file context:\n// Type: .sol\n\n\n// --- Next chunk ---\n\n// Lines 670-747 (.sol_part_10)\n\n    /// Query token expiry info\n    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return expiry Expiry info for `token`\n    function getTokenExpiryInfo(address token)\n        external\n        returns (int64 responseCode, Expiry memory expiry);\n\n    /// Query fungible token info\n    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return fungibleTokenInfo FungibleTokenInfo info for `token`\n    function getFungibleTokenInfo(address token)\n        external\n        returns (int64 responseCode, FungibleTokenInfo memory fungibleTokenInfo);\n\n    /// Query token info\n    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenInfo TokenInfo info for `token`\n    function getTokenInfo(address token)\n        external\n        returns (int64 responseCode, TokenInfo memory tokenInfo);\n\n    /// Query token KeyValue\n    /// @param token The token address to check\n    /// @param keyType The keyType of the desired KeyValue\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return key KeyValue info for key of type `keyType`\n    function getTokenKey(address token, uint keyType)\n        external\n        returns (int64 responseCode, KeyValue memory key);\n\n    /// Query non fungible token info\n    /// @param token The token address to check\n    /// @param serialNumber The NFT serialNumber to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return nonFungibleTokenInfo NonFungibleTokenInfo info for `token` `serialNumber`\n    function getNonFungibleTokenInfo(address token, int64 serialNumber)\n        external\n        returns (int64 responseCode, NonFungibleTokenInfo memory nonFungibleTokenInfo);\n\n    /// Operation to freeze token account\n    /// @param token The token address\n    /// @param account The account address to be frozen\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function freezeToken(address token, address account)\n        external\n        returns (int64 responseCode);\n\n    /// Operation to unfreeze token account\n    /// @param token The token address\n    /// @param account The account address to be unfrozen\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function unfreezeToken(address token, address account)\n        external\n        returns (int64 responseCode);\n\n    /// Operation to grant kyc to token account\n    /// @param token The token address\n    /// @param account The account address to grant kyc\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function grantTokenKyc(address token, address account)\n        external\n        returns (int64 responseCode);\n\n    /// Operation to revoke kyc to token account\n    /// @param token The token address\n    /// @param account The account address to revoke kyc\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function revokeTokenKyc(address token, address account)\n        external\n        returns (int64 responseCode);\n\n    /// Operation to pause token\n    /// @param token The token address to be paused\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n\n// --- Next chunk ---\n\n// Lines 748-824 (.sol_part_11)\n    function pauseToken(address token) external returns (int64 responseCode);\n\n    /// Operation to unpause token\n    /// @param token The token address to be unpaused\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function unpauseToken(address token) external returns (int64 responseCode);\n\n    /// Operation to wipe fungible tokens from account\n    /// @param token The token address\n    /// @param account The account address to revoke kyc\n    /// @param amount The number of tokens to wipe\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function wipeTokenAccount(\n        address token,\n        address account,\n        int64 amount\n    ) external returns (int64 responseCode);\n\n    /// Operation to wipe non fungible tokens from account\n    /// @param token The token address\n    /// @param account The account address to revoke kyc\n    /// @param  serialNumbers The serial numbers of token to wipe\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function wipeTokenAccountNFT(\n        address token,\n        address account,\n        int64[] memory serialNumbers\n    ) external returns (int64 responseCode);\n\n    /// Operation to update token info\n    /// @param token The token address\n    /// @param tokenInfo The hedera token info to update token with\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateTokenInfo(address token, HederaToken memory tokenInfo)\n        external\n        returns (int64 responseCode);\n\n    /// Operation to update token expiry info\n    /// @param token The token address\n    /// @param expiryInfo The hedera token expiry info\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateTokenExpiryInfo(address token, Expiry memory expiryInfo)\n        external\n        returns (int64 responseCode);\n\n    /// Operation to update token expiry info\n    /// @param token The token address\n    /// @param keys The token keys\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateTokenKeys(address token, TokenKey[] memory keys)\n        external\n        returns (int64 responseCode);\n\n    /// Query if valid token found for the given address\n    /// @param token The token address\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return isToken True if valid token found for the given address\n    function isToken(address token)\n        external returns\n        (int64 responseCode, bool isToken);\n\n    /// Query to return the token type for a given address\n    /// @param token The token address\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenType the token type. 0 is FUNGIBLE_COMMON, 1 is NON_FUNGIBLE_UNIQUE, -1 is UNRECOGNIZED\n    function getTokenType(address token)\n        external returns\n        (int64 responseCode, int32 tokenType);\n\n    /// Initiates a Redirect For Token\n    /// @param token The token address\n    /// @param encodedFunctionSelector The function selector from the ERC20 interface + the bytes input for the function called\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return response The result of the call that had been encoded and sent for execution.\n    function redirectForToken(address token, bytes memory encodedFunctionSelector) external returns (int64 responseCode, bytes memory response);\n\n    /// Update the custom fees for a fungible token\n\n// --- Next chunk ---\n\n// Lines 825-870 (.sol_part_12)\n    /// @param token The token address\n    /// @param fixedFees Set of fixed fees for `token`\n    /// @param fractionalFees Set of fractional fees for `token`\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateFungibleTokenCustomFees(address token,  IHederaTokenService.FixedFee[] memory fixedFees, IHederaTokenService.FractionalFee[] memory fractionalFees) external returns (int64 responseCode);\n\n    /// Update the custom fees for a non-fungible token\n    /// @param token The token address\n    /// @param fixedFees Set of fixed fees for `token`\n    /// @param royaltyFees Set of royalty fees for `token`\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateNonFungibleTokenCustomFees(address token, IHederaTokenService.FixedFee[] memory fixedFees, IHederaTokenService.RoyaltyFee[] memory royaltyFees) external returns (int64 responseCode);\n\n    /// @notice Airdrop one or more tokens to one or more accounts\n    /// @notice Recipients will receive tokens in one of these ways:\n    /// @notice     - Immediately if already associated with the token\n    /// @notice     - Immediately with auto-association if they have available slots\n    /// @notice     - As a pending airdrop requiring claim if they have \"receiver signature required\" \n    /// @notice     - As a pending airdrop requiring claim if they have no available auto-association slots\n    /// @notice Immediate airdrops are irreversible, pending airdrops can be canceled\n    /// @notice All transfer fees and auto-renewal rent costs are charged to the transaction submitter\n    /// @param tokenTransfers Array of token transfer lists containing token addresses and recipient details\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function airdropTokens(TokenTransferList[] memory tokenTransfers) external returns (int64 responseCode);\n\n    /// @notice Cancels pending airdrops that have not yet been claimed\n    /// @param pendingAirdrops Array of pending airdrops to cancel\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function cancelAirdrops(PendingAirdrop[] memory pendingAirdrops) external returns (int64 responseCode);\n\n    /// @notice Claims pending airdrops that were sent to the calling account\n    /// @param pendingAirdrops Array of pending airdrops to claim\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function claimAirdrops(PendingAirdrop[] memory pendingAirdrops) external returns (int64 responseCode);\n\n    /// @notice Rejects one or more tokens by transferring their full balance from the requesting account to the treasury\n    /// @notice This transfer does not charge any custom fees or royalties defined for the tokens\n    /// @notice For fungible tokens, the requesting account's balance will become 0 and the treasury balance will increase by that amount\n    /// @notice For non-fungible tokens, the requesting account will no longer hold the rejected serial numbers and they will be transferred to the treasury\n    /// @param rejectingAddress The address rejecting the tokens\n    /// @param ftAddresses Array of fungible token addresses to reject\n    /// @param nftIDs Array of NFT IDs to reject\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function rejectTokens(address rejectingAddress, address[] memory ftAddresses, NftID[] memory nftIDs) external returns (int64 responseCode);\n}\n",
            "totalTokens": 2479,
            "chunks": [
              {
                "originalText": "\n    /// Query token expiry info\n    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return expiry Expiry info for `token`\n    function getTokenExpiryInfo(address token)\n        external\n        returns (int64 responseCode, Expiry memory expiry);\n\n    /// Query fungible token info\n    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return fungibleTokenInfo FungibleTokenInfo info for `token`\n    function getFungibleTokenInfo(address token)\n        external\n        returns (int64 responseCode, FungibleTokenInfo memory fungibleTokenInfo);\n\n    /// Query token info\n    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenInfo TokenInfo info for `token`\n    function getTokenInfo(address token)\n        external\n        returns (int64 responseCode, TokenInfo memory tokenInfo);\n\n    /// Query token KeyValue\n    /// @param token The token address to check\n    /// @param keyType The keyType of the desired KeyValue\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return key KeyValue info for key of type `keyType`\n    function getTokenKey(address token, uint keyType)\n        external\n        returns (int64 responseCode, KeyValue memory key);\n\n    /// Query non fungible token info\n    /// @param token The token address to check\n    /// @param serialNumber The NFT serialNumber to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return nonFungibleTokenInfo NonFungibleTokenInfo info for `token` `serialNumber`\n    function getNonFungibleTokenInfo(address token, int64 serialNumber)\n        external\n        returns (int64 responseCode, NonFungibleTokenInfo memory nonFungibleTokenInfo);\n\n    /// Operation to freeze token account\n    /// @param token The token address\n    /// @param account The account address to be frozen\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function freezeToken(address token, address account)\n        external\n        returns (int64 responseCode);\n\n    /// Operation to unfreeze token account\n    /// @param token The token address\n    /// @param account The account address to be unfrozen\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function unfreezeToken(address token, address account)\n        external\n        returns (int64 responseCode);\n\n    /// Operation to grant kyc to token account\n    /// @param token The token address\n    /// @param account The account address to grant kyc\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function grantTokenKyc(address token, address account)\n        external\n        returns (int64 responseCode);\n\n    /// Operation to revoke kyc to token account\n    /// @param token The token address\n    /// @param account The account address to revoke kyc\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function revokeTokenKyc(address token, address account)\n        external\n        returns (int64 responseCode);\n\n    /// Operation to pause token\n    /// @param token The token address to be paused\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.",
                "codeOnlyTokens": 800,
                "startLine": 670,
                "endLine": 747,
                "type": ".sol_part_10",
                "isOversized": false
              },
              {
                "originalText": "    function pauseToken(address token) external returns (int64 responseCode);\n\n    /// Operation to unpause token\n    /// @param token The token address to be unpaused\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function unpauseToken(address token) external returns (int64 responseCode);\n\n    /// Operation to wipe fungible tokens from account\n    /// @param token The token address\n    /// @param account The account address to revoke kyc\n    /// @param amount The number of tokens to wipe\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function wipeTokenAccount(\n        address token,\n        address account,\n        int64 amount\n    ) external returns (int64 responseCode);\n\n    /// Operation to wipe non fungible tokens from account\n    /// @param token The token address\n    /// @param account The account address to revoke kyc\n    /// @param  serialNumbers The serial numbers of token to wipe\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function wipeTokenAccountNFT(\n        address token,\n        address account,\n        int64[] memory serialNumbers\n    ) external returns (int64 responseCode);\n\n    /// Operation to update token info\n    /// @param token The token address\n    /// @param tokenInfo The hedera token info to update token with\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateTokenInfo(address token, HederaToken memory tokenInfo)\n        external\n        returns (int64 responseCode);\n\n    /// Operation to update token expiry info\n    /// @param token The token address\n    /// @param expiryInfo The hedera token expiry info\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateTokenExpiryInfo(address token, Expiry memory expiryInfo)\n        external\n        returns (int64 responseCode);\n\n    /// Operation to update token expiry info\n    /// @param token The token address\n    /// @param keys The token keys\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateTokenKeys(address token, TokenKey[] memory keys)\n        external\n        returns (int64 responseCode);\n\n    /// Query if valid token found for the given address\n    /// @param token The token address\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return isToken True if valid token found for the given address\n    function isToken(address token)\n        external returns\n        (int64 responseCode, bool isToken);\n\n    /// Query to return the token type for a given address\n    /// @param token The token address\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenType the token type. 0 is FUNGIBLE_COMMON, 1 is NON_FUNGIBLE_UNIQUE, -1 is UNRECOGNIZED\n    function getTokenType(address token)\n        external returns\n        (int64 responseCode, int32 tokenType);\n\n    /// Initiates a Redirect For Token\n    /// @param token The token address\n    /// @param encodedFunctionSelector The function selector from the ERC20 interface + the bytes input for the function called\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return response The result of the call that had been encoded and sent for execution.\n    function redirectForToken(address token, bytes memory encodedFunctionSelector) external returns (int64 responseCode, bytes memory response);\n\n    /// Update the custom fees for a fungible token",
                "codeOnlyTokens": 805,
                "startLine": 748,
                "endLine": 824,
                "type": ".sol_part_11",
                "isOversized": false
              },
              {
                "originalText": "    /// @param token The token address\n    /// @param fixedFees Set of fixed fees for `token`\n    /// @param fractionalFees Set of fractional fees for `token`\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateFungibleTokenCustomFees(address token,  IHederaTokenService.FixedFee[] memory fixedFees, IHederaTokenService.FractionalFee[] memory fractionalFees) external returns (int64 responseCode);\n\n    /// Update the custom fees for a non-fungible token\n    /// @param token The token address\n    /// @param fixedFees Set of fixed fees for `token`\n    /// @param royaltyFees Set of royalty fees for `token`\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateNonFungibleTokenCustomFees(address token, IHederaTokenService.FixedFee[] memory fixedFees, IHederaTokenService.RoyaltyFee[] memory royaltyFees) external returns (int64 responseCode);\n\n    /// @notice Airdrop one or more tokens to one or more accounts\n    /// @notice Recipients will receive tokens in one of these ways:\n    /// @notice     - Immediately if already associated with the token\n    /// @notice     - Immediately with auto-association if they have available slots\n    /// @notice     - As a pending airdrop requiring claim if they have \"receiver signature required\" \n    /// @notice     - As a pending airdrop requiring claim if they have no available auto-association slots\n    /// @notice Immediate airdrops are irreversible, pending airdrops can be canceled\n    /// @notice All transfer fees and auto-renewal rent costs are charged to the transaction submitter\n    /// @param tokenTransfers Array of token transfer lists containing token addresses and recipient details\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function airdropTokens(TokenTransferList[] memory tokenTransfers) external returns (int64 responseCode);\n\n    /// @notice Cancels pending airdrops that have not yet been claimed\n    /// @param pendingAirdrops Array of pending airdrops to cancel\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function cancelAirdrops(PendingAirdrop[] memory pendingAirdrops) external returns (int64 responseCode);\n\n    /// @notice Claims pending airdrops that were sent to the calling account\n    /// @param pendingAirdrops Array of pending airdrops to claim\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function claimAirdrops(PendingAirdrop[] memory pendingAirdrops) external returns (int64 responseCode);\n\n    /// @notice Rejects one or more tokens by transferring their full balance from the requesting account to the treasury\n    /// @notice This transfer does not charge any custom fees or royalties defined for the tokens\n    /// @notice For fungible tokens, the requesting account's balance will become 0 and the treasury balance will increase by that amount\n    /// @notice For non-fungible tokens, the requesting account will no longer hold the rejected serial numbers and they will be transferred to the treasury\n    /// @param rejectingAddress The address rejecting the tokens\n    /// @param ftAddresses Array of fungible token addresses to reject\n    /// @param nftIDs Array of NFT IDs to reject\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function rejectTokens(address rejectingAddress, address[] memory ftAddresses, NftID[] memory nftIDs) external returns (int64 responseCode);\n}\n",
                "codeOnlyTokens": 791,
                "startLine": 825,
                "endLine": 870,
                "type": ".sol_part_12",
                "isOversized": false
              }
            ],
            "startLine": 670,
            "endLine": 870,
            "groupId": 4
          }
        ],
        "oversizedChunks": [],
        "sendStrategy": "multiple_groups",
        "finalTokenCount": 9995,
        "skippedContent": [],
        "contextHeader": "// File: contracts/system-contracts/hedera-token-service/IHederaTokenService.sol\n// Relevant file context:\n// Type: .sol\n",
        "tokenBreakdown": {
          "originalFile": 9663,
          "finalSent": 9995,
          "codeTokensInGroups": 9657,
          "fileHeaderTokensInGroups": 120,
          "shellContextTokensInGroups": 0,
          "separatorTokensInGroups": 218,
          "skippedCodeTokens": 0,
          "unprocessedOversizedTokens": 0,
          "totalSavings": -332,
          "savingsPercentage": -3.4357859877884716,
          "fileHeaderCount": 4,
          "fileHeaderAvgSize": 30,
          "shellContextCount": 0,
          "shellContextAvgSize": 0,
          "separatorCount": 12,
          "separatorAvgSize": 18
        }
      }
    },
    {
      "filePath": "lib/layer-zero/hts/HederaTokenService.sol",
      "totalOriginalTokens": 1501,
      "finalTokenCount": 1528,
      "impactScore": 58.666666666666664,
      "averageComplexity": 8,
      "averageQuality": 7.333333333333333,
      "usage": {
        "prompt_tokens": 1849,
        "completion_tokens": 241,
        "total_tokens": 2090
      },
      "retries": 0,
      "hadError": false,
      "scoredChunkGroups": [
        {
          "groupId": 1,
          "score": {
            "file_path": "lib/layer-zero/hts/HederaTokenService.sol",
            "complexity_score": 8,
            "code_quality_score": 8,
            "maintainability_score": 7,
            "best_practices_adherence": 7,
            "web3_pattern_identification": "Transactional Method Encapsulation",
            "hedera_red_flag": {
              "description": "Direct use of addresses without validation can lead to transactions being sent to invalid or malicious contracts.",
              "exact_code_snippet": "address constant precompileAddress = address(0x167);"
            },
            "hedera_optimization_suggestion": {
              "description": "Implement validation checks for addresses before making calls to precompiled contracts to avoid potential issues.",
              "exact_code_snippet": "address constant precompileAddress = address(0x167);"
            },
            "positive_feedback": "The use of modifiers for input validation demonstrates a solid understanding of Solidity's capabilities to ensure contract integrity.",
            "group_summary": "HederaTokenService defines key methods for managing tokens, incorporating best practices through modifiers and response handling patterns."
          },
          "totalTokens": 1528,
          "usage": {
            "prompt_tokens": 1849,
            "completion_tokens": 241,
            "total_tokens": 2090
          }
        }
      ],
      "chunkingDetails": {
        "filePath": "lib/layer-zero/hts/HederaTokenService.sol",
        "totalFileTokens": 1501,
        "chunks": [
          {
            "originalText": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.5.0 <0.9.0;\npragma experimental ABIEncoderV2;\n\nimport \"./IHederaTokenService.sol\";\n\nabstract contract HederaTokenService {\n    // all response codes are defined here https://github.com/hashgraph/hedera-smart-contracts/blob/main/contracts/system-contracts/HederaResponseCodes.sol\n    int32 constant UNKNOWN_CODE = 21;\n    int32 constant SUCCESS_CODE = 22;\n\n    address constant precompileAddress = address(0x167);\n    // 90 days in seconds\n    int32 constant defaultAutoRenewPeriod = 7776000;\n\n    modifier nonEmptyExpiry(IHederaTokenService.HederaToken memory token) {\n        if (token.expiry.second == 0 && token.expiry.autoRenewPeriod == 0) {\n            token.expiry.autoRenewPeriod = defaultAutoRenewPeriod;\n        }\n        _;\n    }\n\n    /// Generic event\n    event CallResponseEvent(bool, bytes);\n\n    /// Mints an amount of the token to the defined treasury account\n    /// @param token The token for which to mint tokens. If token does not exist, transaction results in\n    ///              INVALID_TOKEN_ID\n    /// @param amount Applicable to tokens of type FUNGIBLE_COMMON. The amount to mint to the Treasury Account.\n    ///               Amount must be a positive non-zero number represented in the lowest denomination of the\n    ///               token. The new supply must be lower than 2^63.\n    /// @param metadata Applicable to tokens of type NON_FUNGIBLE_UNIQUE. A list of metadata that are being created.\n    ///                 Maximum allowed size of each metadata is 100 bytes\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return newTotalSupply The new supply of tokens. For NFTs it is the total count of NFTs\n    /// @return serialNumbers If the token is an NFT the newly generate serial numbers, otherwise empty.\n    function mintToken(\n        address token,\n        int64 amount,\n        bytes[] memory metadata\n    )\n        internal\n        returns (\n            int responseCode,\n            int64 newTotalSupply,\n            int64[] memory serialNumbers\n        )\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(\n                IHederaTokenService.mintToken.selector,\n                token,\n                amount,\n                metadata\n            )\n        );\n        (responseCode, newTotalSupply, serialNumbers) = success\n            ? abi.decode(result, (int32, int64, int64[]))\n            : (HederaTokenService.UNKNOWN_CODE, int64(0), new int64[](0));\n    }\n\n    /// Burns an amount of the token from the defined treasury account\n    /// @param token The token for which to burn tokens. If token does not exist, transaction results in\n    ///              INVALID_TOKEN_ID\n    /// @param amount  Applicable to tokens of type FUNGIBLE_COMMON. The amount to burn from the Treasury Account.\n    ///                Amount must be a positive non-zero number, not bigger than the token balance of the treasury\n    ///                account (0; balance], represented in the lowest denomination.\n    /// @param serialNumbers Applicable to tokens of type NON_FUNGIBLE_UNIQUE. The list of serial numbers to be burned.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return newTotalSupply The new supply of tokens. For NFTs it is the total count of NFTs\n    function burnToken(\n        address token,\n        int64 amount,\n        int64[] memory serialNumbers\n    ) internal returns (int responseCode, int64 newTotalSupply) {\n        (bool success, bytes memory result) = precompileAddress.call(",
            "codeOnlyTokens": 804,
            "startLine": 1,
            "endLine": 76,
            "type": ".sol_part_1",
            "isOversized": false
          },
          {
            "originalText": "            abi.encodeWithSelector(\n                IHederaTokenService.burnToken.selector,\n                token,\n                amount,\n                serialNumbers\n            )\n        );\n        (responseCode, newTotalSupply) = success\n            ? abi.decode(result, (int32, int64))\n            : (HederaTokenService.UNKNOWN_CODE, int64(0));\n    }\n\n    /// Creates a Fungible Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @param initialTotalSupply Specifies the initial supply of tokens to be put in circulation. The\n    /// initial supply is sent to the Treasury Account. The supply is in the lowest denomination possible.\n    /// @param decimals the number of decimal places a token is divisible by\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createFungibleToken(\n        IHederaTokenService.HederaToken memory token,\n        int64 initialTotalSupply,\n        int32 decimals\n    )\n        internal\n        nonEmptyExpiry(token)\n        returns (int responseCode, address tokenAddress)\n    {\n        (bool success, bytes memory result) = precompileAddress.call{\n            value: msg.value\n        }(\n            abi.encodeWithSelector(\n                IHederaTokenService.createFungibleToken.selector,\n                token,\n                initialTotalSupply,\n                decimals\n            )\n        );\n\n        (responseCode, tokenAddress) = success\n            ? abi.decode(result, (int32, address))\n            : (HederaTokenService.UNKNOWN_CODE, address(0));\n    }\n\n    /// Transfers tokens where the calling account/contract is implicitly the first entry in the token transfer list,\n    /// where the amount is the value needed to zero balance the transfers. Regular signing rules apply for sending\n    /// (positive amount) or receiving (negative amount)\n    /// @param token The token to transfer to/from\n    /// @param sender The sender for the transaction\n    /// @param receiver The receiver of the transaction\n    /// @param amount Non-negative value to send. a negative value will result in a failure.\n    function transferToken(\n        address token,\n        address sender,\n        address receiver,\n        int64 amount\n    ) internal returns (int responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(\n                IHederaTokenService.transferToken.selector,\n                token,\n                sender,\n                receiver,\n                amount\n            )\n        );\n        responseCode = success\n            ? abi.decode(result, (int32))\n            : HederaTokenService.UNKNOWN_CODE;\n    }\n\n    /// Operation to update token keys\n    /// @param token The token address\n    /// @param keys The token keys\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateTokenKeys(address token, IHederaTokenService.TokenKey[] memory keys)\n    internal returns (int64 responseCode){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.updateTokenKeys.selector, token, keys));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaTokenService.UNKNOWN_CODE;\n    }\n\n}\n",
            "codeOnlyTokens": 697,
            "startLine": 77,
            "endLine": 160,
            "type": ".sol_part_2",
            "isOversized": false
          }
        ],
        "groupedChunks": [
          {
            "combinedText": "// File: lib/layer-zero/hts/HederaTokenService.sol\n// Relevant file context:\n// Type: .sol\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.5.0 <0.9.0;\npragma experimental ABIEncoderV2;\n\nimport \"./IHederaTokenService.sol\";\n\nabstract contract HederaTokenService {\n    // all response codes are defined here https://github.com/hashgraph/hedera-smart-contracts/blob/main/contracts/system-contracts/HederaResponseCodes.sol\n    int32 constant UNKNOWN_CODE = 21;\n    int32 constant SUCCESS_CODE = 22;\n\n    address constant precompileAddress = address(0x167);\n    // 90 days in seconds\n    int32 constant defaultAutoRenewPeriod = 7776000;\n\n    modifier nonEmptyExpiry(IHederaTokenService.HederaToken memory token) {\n        if (token.expiry.second == 0 && token.expiry.autoRenewPeriod == 0) {\n            token.expiry.autoRenewPeriod = defaultAutoRenewPeriod;\n        }\n        _;\n    }\n\n    /// Generic event\n    event CallResponseEvent(bool, bytes);\n\n    /// Mints an amount of the token to the defined treasury account\n    /// @param token The token for which to mint tokens. If token does not exist, transaction results in\n    ///              INVALID_TOKEN_ID\n    /// @param amount Applicable to tokens of type FUNGIBLE_COMMON. The amount to mint to the Treasury Account.\n    ///               Amount must be a positive non-zero number represented in the lowest denomination of the\n    ///               token. The new supply must be lower than 2^63.\n    /// @param metadata Applicable to tokens of type NON_FUNGIBLE_UNIQUE. A list of metadata that are being created.\n    ///                 Maximum allowed size of each metadata is 100 bytes\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return newTotalSupply The new supply of tokens. For NFTs it is the total count of NFTs\n    /// @return serialNumbers If the token is an NFT the newly generate serial numbers, otherwise empty.\n    function mintToken(\n        address token,\n        int64 amount,\n        bytes[] memory metadata\n    )\n        internal\n        returns (\n            int responseCode,\n            int64 newTotalSupply,\n            int64[] memory serialNumbers\n        )\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(\n                IHederaTokenService.mintToken.selector,\n                token,\n                amount,\n                metadata\n            )\n        );\n        (responseCode, newTotalSupply, serialNumbers) = success\n            ? abi.decode(result, (int32, int64, int64[]))\n            : (HederaTokenService.UNKNOWN_CODE, int64(0), new int64[](0));\n    }\n\n    /// Burns an amount of the token from the defined treasury account\n    /// @param token The token for which to burn tokens. If token does not exist, transaction results in\n    ///              INVALID_TOKEN_ID\n    /// @param amount  Applicable to tokens of type FUNGIBLE_COMMON. The amount to burn from the Treasury Account.\n    ///                Amount must be a positive non-zero number, not bigger than the token balance of the treasury\n    ///                account (0; balance], represented in the lowest denomination.\n    /// @param serialNumbers Applicable to tokens of type NON_FUNGIBLE_UNIQUE. The list of serial numbers to be burned.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return newTotalSupply The new supply of tokens. For NFTs it is the total count of NFTs\n    function burnToken(\n        address token,\n        int64 amount,\n        int64[] memory serialNumbers\n    ) internal returns (int responseCode, int64 newTotalSupply) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(\n                IHederaTokenService.burnToken.selector,\n                token,\n                amount,\n                serialNumbers\n            )\n        );\n        (responseCode, newTotalSupply) = success\n            ? abi.decode(result, (int32, int64))\n            : (HederaTokenService.UNKNOWN_CODE, int64(0));\n    }\n\n    /// Creates a Fungible Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @param initialTotalSupply Specifies the initial supply of tokens to be put in circulation. The\n    /// initial supply is sent to the Treasury Account. The supply is in the lowest denomination possible.\n    /// @param decimals the number of decimal places a token is divisible by\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createFungibleToken(\n        IHederaTokenService.HederaToken memory token,\n        int64 initialTotalSupply,\n        int32 decimals\n    )\n        internal\n        nonEmptyExpiry(token)\n        returns (int responseCode, address tokenAddress)\n    {\n        (bool success, bytes memory result) = precompileAddress.call{\n            value: msg.value\n        }(\n            abi.encodeWithSelector(\n                IHederaTokenService.createFungibleToken.selector,\n                token,\n                initialTotalSupply,\n                decimals\n            )\n        );\n\n        (responseCode, tokenAddress) = success\n            ? abi.decode(result, (int32, address))\n            : (HederaTokenService.UNKNOWN_CODE, address(0));\n    }\n\n    /// Transfers tokens where the calling account/contract is implicitly the first entry in the token transfer list,\n    /// where the amount is the value needed to zero balance the transfers. Regular signing rules apply for sending\n    /// (positive amount) or receiving (negative amount)\n    /// @param token The token to transfer to/from\n    /// @param sender The sender for the transaction\n    /// @param receiver The receiver of the transaction\n    /// @param amount Non-negative value to send. a negative value will result in a failure.\n    function transferToken(\n        address token,\n        address sender,\n        address receiver,\n        int64 amount\n    ) internal returns (int responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(\n                IHederaTokenService.transferToken.selector,\n                token,\n                sender,\n                receiver,\n                amount\n            )\n        );\n        responseCode = success\n            ? abi.decode(result, (int32))\n            : HederaTokenService.UNKNOWN_CODE;\n    }\n\n    /// Operation to update token keys\n    /// @param token The token address\n    /// @param keys The token keys\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateTokenKeys(address token, IHederaTokenService.TokenKey[] memory keys)\n    internal returns (int64 responseCode){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.updateTokenKeys.selector, token, keys));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaTokenService.UNKNOWN_CODE;\n    }\n\n}\n",
            "totalTokens": 1528,
            "chunks": [
              {
                "originalText": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.5.0 <0.9.0;\npragma experimental ABIEncoderV2;\n\nimport \"./IHederaTokenService.sol\";\n\nabstract contract HederaTokenService {\n    // all response codes are defined here https://github.com/hashgraph/hedera-smart-contracts/blob/main/contracts/system-contracts/HederaResponseCodes.sol\n    int32 constant UNKNOWN_CODE = 21;\n    int32 constant SUCCESS_CODE = 22;\n\n    address constant precompileAddress = address(0x167);\n    // 90 days in seconds\n    int32 constant defaultAutoRenewPeriod = 7776000;\n\n    modifier nonEmptyExpiry(IHederaTokenService.HederaToken memory token) {\n        if (token.expiry.second == 0 && token.expiry.autoRenewPeriod == 0) {\n            token.expiry.autoRenewPeriod = defaultAutoRenewPeriod;\n        }\n        _;\n    }\n\n    /// Generic event\n    event CallResponseEvent(bool, bytes);\n\n    /// Mints an amount of the token to the defined treasury account\n    /// @param token The token for which to mint tokens. If token does not exist, transaction results in\n    ///              INVALID_TOKEN_ID\n    /// @param amount Applicable to tokens of type FUNGIBLE_COMMON. The amount to mint to the Treasury Account.\n    ///               Amount must be a positive non-zero number represented in the lowest denomination of the\n    ///               token. The new supply must be lower than 2^63.\n    /// @param metadata Applicable to tokens of type NON_FUNGIBLE_UNIQUE. A list of metadata that are being created.\n    ///                 Maximum allowed size of each metadata is 100 bytes\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return newTotalSupply The new supply of tokens. For NFTs it is the total count of NFTs\n    /// @return serialNumbers If the token is an NFT the newly generate serial numbers, otherwise empty.\n    function mintToken(\n        address token,\n        int64 amount,\n        bytes[] memory metadata\n    )\n        internal\n        returns (\n            int responseCode,\n            int64 newTotalSupply,\n            int64[] memory serialNumbers\n        )\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(\n                IHederaTokenService.mintToken.selector,\n                token,\n                amount,\n                metadata\n            )\n        );\n        (responseCode, newTotalSupply, serialNumbers) = success\n            ? abi.decode(result, (int32, int64, int64[]))\n            : (HederaTokenService.UNKNOWN_CODE, int64(0), new int64[](0));\n    }\n\n    /// Burns an amount of the token from the defined treasury account\n    /// @param token The token for which to burn tokens. If token does not exist, transaction results in\n    ///              INVALID_TOKEN_ID\n    /// @param amount  Applicable to tokens of type FUNGIBLE_COMMON. The amount to burn from the Treasury Account.\n    ///                Amount must be a positive non-zero number, not bigger than the token balance of the treasury\n    ///                account (0; balance], represented in the lowest denomination.\n    /// @param serialNumbers Applicable to tokens of type NON_FUNGIBLE_UNIQUE. The list of serial numbers to be burned.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return newTotalSupply The new supply of tokens. For NFTs it is the total count of NFTs\n    function burnToken(\n        address token,\n        int64 amount,\n        int64[] memory serialNumbers\n    ) internal returns (int responseCode, int64 newTotalSupply) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(\n                IHederaTokenService.burnToken.selector,\n                token,\n                amount,\n                serialNumbers\n            )\n        );\n        (responseCode, newTotalSupply) = success\n            ? abi.decode(result, (int32, int64))\n            : (HederaTokenService.UNKNOWN_CODE, int64(0));\n    }\n\n    /// Creates a Fungible Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @param initialTotalSupply Specifies the initial supply of tokens to be put in circulation. The\n    /// initial supply is sent to the Treasury Account. The supply is in the lowest denomination possible.\n    /// @param decimals the number of decimal places a token is divisible by\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createFungibleToken(\n        IHederaTokenService.HederaToken memory token,\n        int64 initialTotalSupply,\n        int32 decimals\n    )\n        internal\n        nonEmptyExpiry(token)\n        returns (int responseCode, address tokenAddress)\n    {\n        (bool success, bytes memory result) = precompileAddress.call{\n            value: msg.value\n        }(\n            abi.encodeWithSelector(\n                IHederaTokenService.createFungibleToken.selector,\n                token,\n                initialTotalSupply,\n                decimals\n            )\n        );\n\n        (responseCode, tokenAddress) = success\n            ? abi.decode(result, (int32, address))\n            : (HederaTokenService.UNKNOWN_CODE, address(0));\n    }\n\n    /// Transfers tokens where the calling account/contract is implicitly the first entry in the token transfer list,\n    /// where the amount is the value needed to zero balance the transfers. Regular signing rules apply for sending\n    /// (positive amount) or receiving (negative amount)\n    /// @param token The token to transfer to/from\n    /// @param sender The sender for the transaction\n    /// @param receiver The receiver of the transaction\n    /// @param amount Non-negative value to send. a negative value will result in a failure.\n    function transferToken(\n        address token,\n        address sender,\n        address receiver,\n        int64 amount\n    ) internal returns (int responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(\n                IHederaTokenService.transferToken.selector,\n                token,\n                sender,\n                receiver,\n                amount\n            )\n        );\n        responseCode = success\n            ? abi.decode(result, (int32))\n            : HederaTokenService.UNKNOWN_CODE;\n    }\n\n    /// Operation to update token keys\n    /// @param token The token address\n    /// @param keys The token keys\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateTokenKeys(address token, IHederaTokenService.TokenKey[] memory keys)\n    internal returns (int64 responseCode){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.updateTokenKeys.selector, token, keys));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaTokenService.UNKNOWN_CODE;\n    }\n\n}\n",
                "codeOnlyTokens": 1501,
                "startLine": 1,
                "endLine": 160,
                "type": "full_file",
                "isOversized": false
              }
            ],
            "startLine": 1,
            "endLine": 160,
            "groupId": 1
          }
        ],
        "oversizedChunks": [],
        "sendStrategy": "full_file",
        "finalTokenCount": 1528,
        "skippedContent": [],
        "contextHeader": "// File: lib/layer-zero/hts/HederaTokenService.sol\n// Relevant file context:\n// Type: .sol\n",
        "tokenBreakdown": {
          "originalFile": 1501,
          "finalSent": 1528,
          "codeTokensInGroups": 1501,
          "fileHeaderTokensInGroups": 27,
          "shellContextTokensInGroups": 0,
          "separatorTokensInGroups": 0,
          "skippedCodeTokens": 0,
          "unprocessedOversizedTokens": 0,
          "totalSavings": -27,
          "savingsPercentage": -1.798800799467022,
          "fileHeaderCount": 1,
          "fileHeaderAvgSize": 27,
          "shellContextCount": 0,
          "shellContextAvgSize": 0,
          "separatorCount": 1,
          "separatorAvgSize": 0
        }
      }
    },
    {
      "filePath": "contracts/system-contracts/hedera-token-service/examples/token-query/TokenQueryContract.sol",
      "totalOriginalTokens": 1578,
      "finalTokenCount": 1609,
      "impactScore": 56,
      "averageComplexity": 8,
      "averageQuality": 7,
      "usage": {
        "prompt_tokens": 1947,
        "completion_tokens": 241,
        "total_tokens": 2188
      },
      "retries": 0,
      "hadError": false,
      "scoredChunkGroups": [
        {
          "groupId": 1,
          "score": {
            "file_path": "contracts/system-contracts/hedera-token-service/examples/token-query/TokenQueryContract.sol",
            "complexity_score": 8,
            "code_quality_score": 7,
            "maintainability_score": 6,
            "best_practices_adherence": 8,
            "web3_pattern_identification": "Checks-Effects-Interactions",
            "hedera_red_flag": {
              "description": "Reverting without an informative message can make debugging harder.",
              "exact_code_snippet": "revert();"
            },
            "hedera_optimization_suggestion": {
              "description": "Using specific error messages for revert statements can aid in debugging and help users understand the failure context.",
              "exact_code_snippet": "revert();"
            },
            "positive_feedback": "The implementation of distinct public methods that trigger appropriate events provides clear feedback for users interacting with the contract.",
            "group_summary": "The TokenQueryContract provides various functionalities to query token properties and status through user-friendly public functions."
          },
          "totalTokens": 1609,
          "usage": {
            "prompt_tokens": 1947,
            "completion_tokens": 241,
            "total_tokens": 2188
          }
        }
      ],
      "chunkingDetails": {
        "filePath": "contracts/system-contracts/hedera-token-service/examples/token-query/TokenQueryContract.sol",
        "totalFileTokens": 1578,
        "chunks": [
          {
            "originalText": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.5.0 <0.9.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../HederaTokenService.sol\";\nimport \"../../ExpiryHelper.sol\";\nimport \"../../KeyHelper.sol\";\n\ncontract TokenQueryContract is HederaTokenService, ExpiryHelper, KeyHelper {\n\n    event ResponseCode(int responseCode);\n    event AllowanceValue(uint256 amount);\n    event ApprovedAddress(address approved);\n    event Approved(bool approved);\n    event Frozen(bool frozen);\n    event KycGranted(bool kycGranted);\n    event TokenCustomFees(IHederaTokenService.FixedFee[] fixedFees, IHederaTokenService.FractionalFee[] fractionalFees, IHederaTokenService.RoyaltyFee[] royaltyFees);\n    event TokenDefaultFreezeStatus(bool defaultFreezeStatus);\n    event TokenDefaultKycStatus(bool defaultKycStatus);\n    event TokenExpiryInfo(IHederaTokenService.Expiry expiryInfo);\n    event FungibleTokenInfo(IHederaTokenService.FungibleTokenInfo tokenInfo);\n    event TokenInfo(IHederaTokenService.TokenInfo tokenInfo);\n    event TokenKey(IHederaTokenService.KeyValue key);\n    event NonFungibleTokenInfo(IHederaTokenService.NonFungibleTokenInfo tokenInfo);\n    event IsToken(bool isToken);\n    event TokenType(int32 tokenType);\n\n    function allowancePublic(address token, address owner, address spender) public returns (int responseCode, uint256 amount) {\n        (responseCode, amount) = HederaTokenService.allowance(token, owner, spender);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert ();\n        }\n\n        emit AllowanceValue(amount);\n    }\n\n    function getApprovedPublic(address token, uint256 serialNumber) public returns (int responseCode, address approved) {\n        (responseCode, approved) = HederaTokenService.getApproved(token, serialNumber);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n\n        emit ApprovedAddress(approved);\n    }\n\n    function isApprovedForAllPublic(address token, address owner, address operator) public returns (int responseCode, bool approved) {\n        (responseCode, approved) = HederaTokenService.isApprovedForAll(token, owner, operator);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n\n        emit Approved(approved);\n    }\n\n    function isFrozenPublic(address token, address account) public returns (int responseCode, bool frozen) {\n        (responseCode, frozen) = HederaTokenService.isFrozen(token, account);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n        emit Frozen(frozen);\n    }\n\n    function isKycPublic(address token, address account) external returns (int64 responseCode, bool kycGranted) {\n        (responseCode, kycGranted) = HederaTokenService.isKyc(token, account);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n\n        emit KycGranted(kycGranted);\n    }\n\n    function getTokenCustomFeesPublic(address token) public returns (\n        int64 responseCode,\n        IHederaTokenService.FixedFee[] memory fixedFees,\n        IHederaTokenService.FractionalFee[] memory fractionalFees,\n        IHederaTokenService.RoyaltyFee[] memory royaltyFees) {\n        (responseCode, fixedFees, fractionalFees, royaltyFees) = HederaTokenService.getTokenCustomFees(token);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n\n        emit TokenCustomFees(fixedFees, fractionalFees, royaltyFees);",
            "codeOnlyTokens": 812,
            "startLine": 1,
            "endLine": 94,
            "type": ".sol_part_1",
            "isOversized": false
          },
          {
            "originalText": "    }\n\n    function getTokenDefaultFreezeStatusPublic(address token) public returns (int responseCode, bool defaultFreezeStatus) {\n        (responseCode, defaultFreezeStatus) = HederaTokenService.getTokenDefaultFreezeStatus(token);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n\n        emit TokenDefaultFreezeStatus(defaultFreezeStatus);\n    }\n\n    function getTokenDefaultKycStatusPublic(address token) public returns (int responseCode, bool defaultKycStatus) {\n        (responseCode, defaultKycStatus) = HederaTokenService.getTokenDefaultKycStatus(token);\n\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n\n        emit TokenDefaultKycStatus(defaultKycStatus);\n    }\n\n    function getTokenExpiryInfoPublic(address token)external returns (int responseCode, IHederaTokenService.Expiry memory expiryInfo) {\n        (responseCode, expiryInfo) = HederaTokenService.getTokenExpiryInfo(token);\n        emit ResponseCode(responseCode);\n\n        if(responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n\n        emit TokenExpiryInfo(expiryInfo);\n    }\n\n    function getFungibleTokenInfoPublic(address token) public returns (int responseCode, IHederaTokenService.FungibleTokenInfo memory tokenInfo) {\n        (responseCode, tokenInfo) = HederaTokenService.getFungibleTokenInfo(token);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n\n        emit FungibleTokenInfo(tokenInfo);\n    }\n\n    function getTokenInfoPublic(address token) public returns (int responseCode, IHederaTokenService.TokenInfo memory tokenInfo) {\n        (responseCode, tokenInfo) = HederaTokenService.getTokenInfo(token);\n\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n\n        emit TokenInfo(tokenInfo);\n    }\n\n    function getTokenKeyPublic(address token, uint keyType)\n    public returns (int64 responseCode, IHederaTokenService.KeyValue memory key) {\n        (responseCode, key) = HederaTokenService.getTokenKey(token, keyType);\n        emit ResponseCode(responseCode);\n\n        if(responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n\n        emit TokenKey(key);\n    }\n\n    function getNonFungibleTokenInfoPublic(address token, int64 serialNumber) public returns (int responseCode, IHederaTokenService.NonFungibleTokenInfo memory tokenInfo) {\n        (responseCode, tokenInfo) = HederaTokenService.getNonFungibleTokenInfo(token, serialNumber);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n\n        emit NonFungibleTokenInfo(tokenInfo);\n    }\n\n    function isTokenPublic(address token) public returns (int64 responseCode, bool isTokenFlag) {\n        (responseCode, isTokenFlag) = HederaTokenService.isToken(token);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n\n        emit IsToken(isTokenFlag);\n    }\n\n    function getTokenTypePublic(address token) public returns (int64 responseCode, int32 tokenType) {\n        (responseCode, tokenType) = HederaTokenService.getTokenType(token);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n\n        emit TokenType(tokenType);\n    }\n}",
            "codeOnlyTokens": 766,
            "startLine": 95,
            "endLine": 198,
            "type": ".sol_part_2",
            "isOversized": false
          }
        ],
        "groupedChunks": [
          {
            "combinedText": "// File: contracts/system-contracts/hedera-token-service/examples/token-query/TokenQueryContract.sol\n// Relevant file context:\n// Type: .sol\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.5.0 <0.9.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../HederaTokenService.sol\";\nimport \"../../ExpiryHelper.sol\";\nimport \"../../KeyHelper.sol\";\n\ncontract TokenQueryContract is HederaTokenService, ExpiryHelper, KeyHelper {\n\n    event ResponseCode(int responseCode);\n    event AllowanceValue(uint256 amount);\n    event ApprovedAddress(address approved);\n    event Approved(bool approved);\n    event Frozen(bool frozen);\n    event KycGranted(bool kycGranted);\n    event TokenCustomFees(IHederaTokenService.FixedFee[] fixedFees, IHederaTokenService.FractionalFee[] fractionalFees, IHederaTokenService.RoyaltyFee[] royaltyFees);\n    event TokenDefaultFreezeStatus(bool defaultFreezeStatus);\n    event TokenDefaultKycStatus(bool defaultKycStatus);\n    event TokenExpiryInfo(IHederaTokenService.Expiry expiryInfo);\n    event FungibleTokenInfo(IHederaTokenService.FungibleTokenInfo tokenInfo);\n    event TokenInfo(IHederaTokenService.TokenInfo tokenInfo);\n    event TokenKey(IHederaTokenService.KeyValue key);\n    event NonFungibleTokenInfo(IHederaTokenService.NonFungibleTokenInfo tokenInfo);\n    event IsToken(bool isToken);\n    event TokenType(int32 tokenType);\n\n    function allowancePublic(address token, address owner, address spender) public returns (int responseCode, uint256 amount) {\n        (responseCode, amount) = HederaTokenService.allowance(token, owner, spender);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert ();\n        }\n\n        emit AllowanceValue(amount);\n    }\n\n    function getApprovedPublic(address token, uint256 serialNumber) public returns (int responseCode, address approved) {\n        (responseCode, approved) = HederaTokenService.getApproved(token, serialNumber);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n\n        emit ApprovedAddress(approved);\n    }\n\n    function isApprovedForAllPublic(address token, address owner, address operator) public returns (int responseCode, bool approved) {\n        (responseCode, approved) = HederaTokenService.isApprovedForAll(token, owner, operator);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n\n        emit Approved(approved);\n    }\n\n    function isFrozenPublic(address token, address account) public returns (int responseCode, bool frozen) {\n        (responseCode, frozen) = HederaTokenService.isFrozen(token, account);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n        emit Frozen(frozen);\n    }\n\n    function isKycPublic(address token, address account) external returns (int64 responseCode, bool kycGranted) {\n        (responseCode, kycGranted) = HederaTokenService.isKyc(token, account);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n\n        emit KycGranted(kycGranted);\n    }\n\n    function getTokenCustomFeesPublic(address token) public returns (\n        int64 responseCode,\n        IHederaTokenService.FixedFee[] memory fixedFees,\n        IHederaTokenService.FractionalFee[] memory fractionalFees,\n        IHederaTokenService.RoyaltyFee[] memory royaltyFees) {\n        (responseCode, fixedFees, fractionalFees, royaltyFees) = HederaTokenService.getTokenCustomFees(token);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n\n        emit TokenCustomFees(fixedFees, fractionalFees, royaltyFees);\n    }\n\n    function getTokenDefaultFreezeStatusPublic(address token) public returns (int responseCode, bool defaultFreezeStatus) {\n        (responseCode, defaultFreezeStatus) = HederaTokenService.getTokenDefaultFreezeStatus(token);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n\n        emit TokenDefaultFreezeStatus(defaultFreezeStatus);\n    }\n\n    function getTokenDefaultKycStatusPublic(address token) public returns (int responseCode, bool defaultKycStatus) {\n        (responseCode, defaultKycStatus) = HederaTokenService.getTokenDefaultKycStatus(token);\n\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n\n        emit TokenDefaultKycStatus(defaultKycStatus);\n    }\n\n    function getTokenExpiryInfoPublic(address token)external returns (int responseCode, IHederaTokenService.Expiry memory expiryInfo) {\n        (responseCode, expiryInfo) = HederaTokenService.getTokenExpiryInfo(token);\n        emit ResponseCode(responseCode);\n\n        if(responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n\n        emit TokenExpiryInfo(expiryInfo);\n    }\n\n    function getFungibleTokenInfoPublic(address token) public returns (int responseCode, IHederaTokenService.FungibleTokenInfo memory tokenInfo) {\n        (responseCode, tokenInfo) = HederaTokenService.getFungibleTokenInfo(token);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n\n        emit FungibleTokenInfo(tokenInfo);\n    }\n\n    function getTokenInfoPublic(address token) public returns (int responseCode, IHederaTokenService.TokenInfo memory tokenInfo) {\n        (responseCode, tokenInfo) = HederaTokenService.getTokenInfo(token);\n\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n\n        emit TokenInfo(tokenInfo);\n    }\n\n    function getTokenKeyPublic(address token, uint keyType)\n    public returns (int64 responseCode, IHederaTokenService.KeyValue memory key) {\n        (responseCode, key) = HederaTokenService.getTokenKey(token, keyType);\n        emit ResponseCode(responseCode);\n\n        if(responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n\n        emit TokenKey(key);\n    }\n\n    function getNonFungibleTokenInfoPublic(address token, int64 serialNumber) public returns (int responseCode, IHederaTokenService.NonFungibleTokenInfo memory tokenInfo) {\n        (responseCode, tokenInfo) = HederaTokenService.getNonFungibleTokenInfo(token, serialNumber);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n\n        emit NonFungibleTokenInfo(tokenInfo);\n    }\n\n    function isTokenPublic(address token) public returns (int64 responseCode, bool isTokenFlag) {\n        (responseCode, isTokenFlag) = HederaTokenService.isToken(token);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n\n        emit IsToken(isTokenFlag);\n    }\n\n    function getTokenTypePublic(address token) public returns (int64 responseCode, int32 tokenType) {\n        (responseCode, tokenType) = HederaTokenService.getTokenType(token);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n\n        emit TokenType(tokenType);\n    }\n}",
            "totalTokens": 1609,
            "chunks": [
              {
                "originalText": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.5.0 <0.9.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../HederaTokenService.sol\";\nimport \"../../ExpiryHelper.sol\";\nimport \"../../KeyHelper.sol\";\n\ncontract TokenQueryContract is HederaTokenService, ExpiryHelper, KeyHelper {\n\n    event ResponseCode(int responseCode);\n    event AllowanceValue(uint256 amount);\n    event ApprovedAddress(address approved);\n    event Approved(bool approved);\n    event Frozen(bool frozen);\n    event KycGranted(bool kycGranted);\n    event TokenCustomFees(IHederaTokenService.FixedFee[] fixedFees, IHederaTokenService.FractionalFee[] fractionalFees, IHederaTokenService.RoyaltyFee[] royaltyFees);\n    event TokenDefaultFreezeStatus(bool defaultFreezeStatus);\n    event TokenDefaultKycStatus(bool defaultKycStatus);\n    event TokenExpiryInfo(IHederaTokenService.Expiry expiryInfo);\n    event FungibleTokenInfo(IHederaTokenService.FungibleTokenInfo tokenInfo);\n    event TokenInfo(IHederaTokenService.TokenInfo tokenInfo);\n    event TokenKey(IHederaTokenService.KeyValue key);\n    event NonFungibleTokenInfo(IHederaTokenService.NonFungibleTokenInfo tokenInfo);\n    event IsToken(bool isToken);\n    event TokenType(int32 tokenType);\n\n    function allowancePublic(address token, address owner, address spender) public returns (int responseCode, uint256 amount) {\n        (responseCode, amount) = HederaTokenService.allowance(token, owner, spender);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert ();\n        }\n\n        emit AllowanceValue(amount);\n    }\n\n    function getApprovedPublic(address token, uint256 serialNumber) public returns (int responseCode, address approved) {\n        (responseCode, approved) = HederaTokenService.getApproved(token, serialNumber);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n\n        emit ApprovedAddress(approved);\n    }\n\n    function isApprovedForAllPublic(address token, address owner, address operator) public returns (int responseCode, bool approved) {\n        (responseCode, approved) = HederaTokenService.isApprovedForAll(token, owner, operator);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n\n        emit Approved(approved);\n    }\n\n    function isFrozenPublic(address token, address account) public returns (int responseCode, bool frozen) {\n        (responseCode, frozen) = HederaTokenService.isFrozen(token, account);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n        emit Frozen(frozen);\n    }\n\n    function isKycPublic(address token, address account) external returns (int64 responseCode, bool kycGranted) {\n        (responseCode, kycGranted) = HederaTokenService.isKyc(token, account);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n\n        emit KycGranted(kycGranted);\n    }\n\n    function getTokenCustomFeesPublic(address token) public returns (\n        int64 responseCode,\n        IHederaTokenService.FixedFee[] memory fixedFees,\n        IHederaTokenService.FractionalFee[] memory fractionalFees,\n        IHederaTokenService.RoyaltyFee[] memory royaltyFees) {\n        (responseCode, fixedFees, fractionalFees, royaltyFees) = HederaTokenService.getTokenCustomFees(token);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n\n        emit TokenCustomFees(fixedFees, fractionalFees, royaltyFees);\n    }\n\n    function getTokenDefaultFreezeStatusPublic(address token) public returns (int responseCode, bool defaultFreezeStatus) {\n        (responseCode, defaultFreezeStatus) = HederaTokenService.getTokenDefaultFreezeStatus(token);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n\n        emit TokenDefaultFreezeStatus(defaultFreezeStatus);\n    }\n\n    function getTokenDefaultKycStatusPublic(address token) public returns (int responseCode, bool defaultKycStatus) {\n        (responseCode, defaultKycStatus) = HederaTokenService.getTokenDefaultKycStatus(token);\n\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n\n        emit TokenDefaultKycStatus(defaultKycStatus);\n    }\n\n    function getTokenExpiryInfoPublic(address token)external returns (int responseCode, IHederaTokenService.Expiry memory expiryInfo) {\n        (responseCode, expiryInfo) = HederaTokenService.getTokenExpiryInfo(token);\n        emit ResponseCode(responseCode);\n\n        if(responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n\n        emit TokenExpiryInfo(expiryInfo);\n    }\n\n    function getFungibleTokenInfoPublic(address token) public returns (int responseCode, IHederaTokenService.FungibleTokenInfo memory tokenInfo) {\n        (responseCode, tokenInfo) = HederaTokenService.getFungibleTokenInfo(token);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n\n        emit FungibleTokenInfo(tokenInfo);\n    }\n\n    function getTokenInfoPublic(address token) public returns (int responseCode, IHederaTokenService.TokenInfo memory tokenInfo) {\n        (responseCode, tokenInfo) = HederaTokenService.getTokenInfo(token);\n\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n\n        emit TokenInfo(tokenInfo);\n    }\n\n    function getTokenKeyPublic(address token, uint keyType)\n    public returns (int64 responseCode, IHederaTokenService.KeyValue memory key) {\n        (responseCode, key) = HederaTokenService.getTokenKey(token, keyType);\n        emit ResponseCode(responseCode);\n\n        if(responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n\n        emit TokenKey(key);\n    }\n\n    function getNonFungibleTokenInfoPublic(address token, int64 serialNumber) public returns (int responseCode, IHederaTokenService.NonFungibleTokenInfo memory tokenInfo) {\n        (responseCode, tokenInfo) = HederaTokenService.getNonFungibleTokenInfo(token, serialNumber);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n\n        emit NonFungibleTokenInfo(tokenInfo);\n    }\n\n    function isTokenPublic(address token) public returns (int64 responseCode, bool isTokenFlag) {\n        (responseCode, isTokenFlag) = HederaTokenService.isToken(token);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n\n        emit IsToken(isTokenFlag);\n    }\n\n    function getTokenTypePublic(address token) public returns (int64 responseCode, int32 tokenType) {\n        (responseCode, tokenType) = HederaTokenService.getTokenType(token);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n\n        emit TokenType(tokenType);\n    }\n}",
                "codeOnlyTokens": 1578,
                "startLine": 1,
                "endLine": 198,
                "type": "full_file",
                "isOversized": false
              }
            ],
            "startLine": 1,
            "endLine": 198,
            "groupId": 1
          }
        ],
        "oversizedChunks": [],
        "sendStrategy": "full_file",
        "finalTokenCount": 1609,
        "skippedContent": [],
        "contextHeader": "// File: contracts/system-contracts/hedera-token-service/examples/token-query/TokenQueryContract.sol\n// Relevant file context:\n// Type: .sol\n",
        "tokenBreakdown": {
          "originalFile": 1578,
          "finalSent": 1609,
          "codeTokensInGroups": 1578,
          "fileHeaderTokensInGroups": 31,
          "shellContextTokensInGroups": 0,
          "separatorTokensInGroups": 0,
          "skippedCodeTokens": 0,
          "unprocessedOversizedTokens": 0,
          "totalSavings": -31,
          "savingsPercentage": -1.964512040557668,
          "fileHeaderCount": 1,
          "fileHeaderAvgSize": 31,
          "shellContextCount": 0,
          "shellContextAvgSize": 0,
          "separatorCount": 1,
          "separatorAvgSize": 0
        }
      }
    },
    {
      "filePath": "contracts/system-contracts/hedera-token-service/examples/token-create/TokenCreateContract.sol",
      "totalOriginalTokens": 3650,
      "finalTokenCount": 3800,
      "impactScore": 53.66666666666667,
      "averageComplexity": 7,
      "averageQuality": 8,
      "usage": {
        "prompt_tokens": 5791,
        "completion_tokens": 537,
        "total_tokens": 6328
      },
      "retries": 0,
      "hadError": false,
      "scoredChunkGroups": [
        {
          "groupId": 1,
          "score": {
            "complexity_score": 7,
            "code_quality_score": 8,
            "maintainability_score": 7,
            "best_practices_adherence": 8,
            "web3_pattern_identification": "Checks-Effects-Interactions",
            "hedera_red_flag": {
              "description": "The revert on failure does not provide specific error information, which may hinder debugging.",
              "exact_code_snippet": "revert ();"
            },
            "hedera_optimization_suggestion": {
              "description": "Instead of creating a new TokenKey array for each function, consider creating a private function that consolidates this functionality to reduce code duplication.",
              "exact_code_snippet": "IHederaTokenService.TokenKey[] memory keys = new IHederaTokenService.TokenKey[](6);"
            },
            "positive_feedback": "The use of the `getSingleKey` helper function effectively abstracts the key management, making the code cleaner and reducing repetition.",
            "group_summary": "This contract contains multiple functions to create fungible and non-fungible tokens on the Hedera network, utilizing the Hedera Token Service for various admin key configurations and fee structures."
          },
          "totalTokens": 2493,
          "usage": {
            "prompt_tokens": 3475,
            "completion_tokens": 248,
            "total_tokens": 3723,
            "prompt_tokens_details": {
              "cached_tokens": 0,
              "audio_tokens": 0
            },
            "completion_tokens_details": {
              "reasoning_tokens": 0,
              "audio_tokens": 0,
              "accepted_prediction_tokens": 0,
              "rejected_prediction_tokens": 0
            }
          }
        },
        {
          "groupId": 2,
          "score": {
            "complexity_score": 7,
            "code_quality_score": 8,
            "maintainability_score": 7,
            "best_practices_adherence": 8,
            "web3_pattern_identification": "Checks-Effects-Interactions",
            "hedera_red_flag": {
              "description": "The error handling in the revert conditions does not provide feedback on the failure reason, which could be crucial for debugging.",
              "exact_code_snippet": "revert();"
            },
            "hedera_optimization_suggestion": {
              "description": "Consider combining the token creation and fee specification processes to streamline logic, reducing the overhead of multiple function calls.",
              "exact_code_snippet": "IHederaTokenService.HederaToken memory token = IHederaTokenService.HederaToken(name, symbol, treasury, memo, finiteTotalSupplyType, maxSupply, freezeDefaultStatus, keys, expiry);"
            },
            "positive_feedback": "The use of custom keys and fee structures in the token creation showcases a strong understanding of Hedera's capabilities, making the contract flexible and powerful.",
            "group_summary": "This code provides implementation for creating and managing both fungible and non-fungible tokens on the Hedera network, including functionality for minting, associating tokens, and granting KYC approvals, all while leveraging Hedera's smart contract services."
          },
          "totalTokens": 1307,
          "usage": {
            "prompt_tokens": 2316,
            "completion_tokens": 289,
            "total_tokens": 2605,
            "prompt_tokens_details": {
              "cached_tokens": 0,
              "audio_tokens": 0
            },
            "completion_tokens_details": {
              "reasoning_tokens": 0,
              "audio_tokens": 0,
              "accepted_prediction_tokens": 0,
              "rejected_prediction_tokens": 0
            }
          }
        }
      ],
      "chunkingDetails": {
        "filePath": "contracts/system-contracts/hedera-token-service/examples/token-create/TokenCreateContract.sol",
        "totalFileTokens": 3650,
        "chunks": [
          {
            "originalText": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.5.0 <0.9.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../HederaTokenService.sol\";\nimport \"../../ExpiryHelper.sol\";\nimport \"../../KeyHelper.sol\";\n\ncontract TokenCreateContract is HederaTokenService, ExpiryHelper, KeyHelper {\n\n    string name = \"tokenName\";\n    string symbol = \"tokenSymbol\";\n    string memo = \"memo\";\n    int64 initialTotalSupply = 10000000000;\n    int64 maxSupply = 20000000000;\n    int32 decimals = 0;\n    bool freezeDefaultStatus = false;\n    bool finiteTotalSupplyType = true;\n\n    event ResponseCode(int responseCode);\n    event CreatedToken(address tokenAddress);\n    event MintedToken(int64 newTotalSupply, int64[] serialNumbers);\n    event KycGranted(bool kycGranted);\n\n    function createFungibleTokenPublic(\n        address treasury\n    ) public payable {\n        IHederaTokenService.TokenKey[] memory keys = new IHederaTokenService.TokenKey[](6);\n        keys[0] = getSingleKey(KeyType.ADMIN, KeyType.PAUSE, KeyValueType.INHERIT_ACCOUNT_KEY, bytes(\"\"));\n        keys[1] = getSingleKey(KeyType.KYC, KeyValueType.INHERIT_ACCOUNT_KEY, bytes(\"\"));\n        keys[2] = getSingleKey(KeyType.FREEZE, KeyValueType.INHERIT_ACCOUNT_KEY, bytes(\"\"));\n        keys[3] = getSingleKey(KeyType.WIPE, KeyValueType.INHERIT_ACCOUNT_KEY, bytes(\"\"));\n        keys[4] = getSingleKey(KeyType.SUPPLY, KeyValueType.INHERIT_ACCOUNT_KEY, bytes(\"\"));\n        keys[5] = getSingleKey(KeyType.FEE, KeyValueType.INHERIT_ACCOUNT_KEY, bytes(\"\"));\n\n        IHederaTokenService.Expiry memory expiry = IHederaTokenService.Expiry(\n            0, treasury, 8000000\n        );\n\n        IHederaTokenService.HederaToken memory token = IHederaTokenService.HederaToken(\n            name, symbol, treasury, memo, finiteTotalSupplyType, maxSupply, freezeDefaultStatus, keys, expiry\n        );\n\n        (int responseCode, address tokenAddress) =\n        HederaTokenService.createFungibleToken(token, initialTotalSupply, decimals);\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert ();\n        }\n\n        emit CreatedToken(tokenAddress);\n    }\n\n    function createFungibleTokenWithSECP256K1AdminKeyPublic(\n        address treasury, bytes memory adminKey\n    ) public payable returns (address) {\n        IHederaTokenService.TokenKey[] memory keys = new IHederaTokenService.TokenKey[](6);\n        keys[0] = getSingleKey(KeyType.ADMIN, KeyType.PAUSE, KeyValueType.SECP256K1, adminKey);\n        keys[1] = getSingleKey(KeyType.KYC, KeyValueType.SECP256K1, adminKey);\n        keys[2] = getSingleKey(KeyType.FREEZE, KeyValueType.SECP256K1, adminKey);\n        keys[3] = getSingleKey(KeyType.SUPPLY, KeyValueType.SECP256K1, adminKey);\n        keys[4] = getSingleKey(KeyType.WIPE, KeyValueType.SECP256K1, adminKey);\n        keys[5] = getSingleKey(KeyType.FEE, KeyValueType.SECP256K1, adminKey);\n\n        IHederaTokenService.Expiry memory expiry = IHederaTokenService.Expiry(\n            0, treasury, 8000000\n        );\n\n        IHederaTokenService.HederaToken memory token = IHederaTokenService.HederaToken(",
            "codeOnlyTokens": 800,
            "startLine": 1,
            "endLine": 68,
            "type": ".sol_part_1",
            "isOversized": false
          },
          {
            "originalText": "            name, symbol, treasury, memo, finiteTotalSupplyType, maxSupply, freezeDefaultStatus, keys, expiry\n        );\n\n        (int responseCode, address tokenAddress) =\n        HederaTokenService.createFungibleToken(token, initialTotalSupply, decimals);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert ();\n        }\n\n        emit CreatedToken(tokenAddress);\n\n        return tokenAddress;\n    }\n\n    function createFungibleTokenWithSECP256K1AdminKeyAssociateAndTransferToAddressPublic(address treasury, bytes memory adminKey, int64 amount) public payable {\n        address tokenAddress = this.createFungibleTokenWithSECP256K1AdminKeyPublic{value : msg.value}(treasury, adminKey);\n        this.associateTokenPublic(msg.sender, tokenAddress);\n        this.grantTokenKycPublic(tokenAddress, msg.sender);\n        HederaTokenService.transferToken(tokenAddress, address(this), msg.sender, amount);\n    }\n\n    function createFungibleTokenWithSECP256K1AdminKeyWithoutKYCPublic(\n        address treasury, bytes memory adminKey\n    ) public payable returns (address) {\n        IHederaTokenService.TokenKey[] memory keys = new IHederaTokenService.TokenKey[](4);\n        keys[0] = getSingleKey(KeyType.ADMIN, KeyType.PAUSE, KeyValueType.SECP256K1, adminKey);\n        keys[1] = getSingleKey(KeyType.FREEZE, KeyValueType.SECP256K1, adminKey);\n        keys[2] = getSingleKey(KeyType.SUPPLY, KeyValueType.SECP256K1, adminKey);\n        keys[3] = getSingleKey(KeyType.WIPE, KeyValueType.SECP256K1, adminKey);\n\n        IHederaTokenService.Expiry memory expiry = IHederaTokenService.Expiry(\n            0, treasury, 8000000\n        );\n\n        IHederaTokenService.HederaToken memory token = IHederaTokenService.HederaToken(\n            name, symbol, treasury, memo, finiteTotalSupplyType, maxSupply, freezeDefaultStatus, keys, expiry\n        );\n\n        (int responseCode, address tokenAddress) =\n        HederaTokenService.createFungibleToken(token, initialTotalSupply, decimals);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert ();\n        }\n\n        emit CreatedToken(tokenAddress);\n\n        return tokenAddress;\n    }\n\n    function createFungibleTokenWithCustomFeesPublic(\n        address treasury,\n        address fixedFeeTokenAddress\n    ) public payable {\n        IHederaTokenService.TokenKey[] memory keys = new IHederaTokenService.TokenKey[](1);\n        keys[0] = getSingleKey(KeyType.ADMIN, KeyType.ADMIN, KeyValueType.INHERIT_ACCOUNT_KEY, bytes(\"\"));\n\n        IHederaTokenService.Expiry memory expiry = IHederaTokenService.Expiry(\n            0, treasury, 8000000\n        );\n\n        IHederaTokenService.HederaToken memory token = IHederaTokenService.HederaToken(\n            name, symbol, treasury, memo, finiteTotalSupplyType, maxSupply, false, keys, expiry\n        );\n\n        IHederaTokenService.FixedFee[] memory fixedFees = new IHederaTokenService.FixedFee[](1);\n        fixedFees[0] = IHederaTokenService.FixedFee(1, fixedFeeTokenAddress, false, false, treasury);\n\n        IHederaTokenService.FractionalFee[] memory fractionalFees = new IHederaTokenService.FractionalFee[](1);\n        fractionalFees[0] = IHederaTokenService.FractionalFee(4, 5, 10, 30, false, treasury);\n\n        (int responseCode, address tokenAddress) =",
            "codeOnlyTokens": 800,
            "startLine": 69,
            "endLine": 141,
            "type": ".sol_part_2",
            "isOversized": false
          },
          {
            "originalText": "        HederaTokenService.createFungibleTokenWithCustomFees(token, initialTotalSupply, decimals, fixedFees, fractionalFees);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert ();\n        }\n\n        emit CreatedToken(tokenAddress);\n    }\n\n    function createNonFungibleTokenPublic(\n        address treasury\n    ) public payable {\n        IHederaTokenService.TokenKey[] memory keys = new IHederaTokenService.TokenKey[](5);\n        keys[0] = getSingleKey(KeyType.ADMIN, KeyType.PAUSE, KeyValueType.INHERIT_ACCOUNT_KEY, bytes(\"\"));\n        keys[1] = getSingleKey(KeyType.KYC, KeyValueType.INHERIT_ACCOUNT_KEY, bytes(\"\"));\n        keys[2] = getSingleKey(KeyType.FREEZE, KeyValueType.INHERIT_ACCOUNT_KEY, bytes(\"\"));\n        keys[3] = getSingleKey(KeyType.SUPPLY, KeyValueType.INHERIT_ACCOUNT_KEY, bytes(\"\"));\n        keys[4] = getSingleKey(KeyType.WIPE, KeyValueType.INHERIT_ACCOUNT_KEY, bytes(\"\"));\n\n        IHederaTokenService.Expiry memory expiry = IHederaTokenService.Expiry(\n            0, treasury, 8000000\n        );\n\n        IHederaTokenService.HederaToken memory token = IHederaTokenService.HederaToken(\n            name, symbol, treasury, memo, finiteTotalSupplyType, maxSupply, freezeDefaultStatus, keys, expiry\n        );\n\n        (int responseCode, address tokenAddress) =\n        HederaTokenService.createNonFungibleToken(token);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert ();\n        }\n\n        emit CreatedToken(tokenAddress);\n    }\n\n    function createNonFungibleTokenWithSECP256K1AdminKeyPublic(\n        address treasury, bytes memory adminKey\n    ) public payable {\n        IHederaTokenService.TokenKey[] memory keys = new IHederaTokenService.TokenKey[](6);\n        keys[0] = getSingleKey(KeyType.ADMIN, KeyType.PAUSE, KeyValueType.SECP256K1, adminKey);\n        keys[1] = getSingleKey(KeyType.KYC, KeyValueType.SECP256K1, adminKey);\n        keys[2] = getSingleKey(KeyType.FREEZE, KeyValueType.SECP256K1, adminKey);\n        keys[3] = getSingleKey(KeyType.SUPPLY, KeyValueType.SECP256K1, adminKey);\n        keys[4] = getSingleKey(KeyType.WIPE, KeyValueType.SECP256K1, adminKey);\n        keys[5] = getSingleKey(KeyType.FEE, KeyValueType.SECP256K1, adminKey);\n\n        IHederaTokenService.Expiry memory expiry = IHederaTokenService.Expiry(\n            0, treasury, 8000000\n        );\n\n        IHederaTokenService.HederaToken memory token = IHederaTokenService.HederaToken(\n            name, symbol, treasury, memo, finiteTotalSupplyType, maxSupply, freezeDefaultStatus, keys, expiry\n        );\n\n        (int responseCode, address tokenAddress) =\n        HederaTokenService.createNonFungibleToken(token);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert ();\n        }\n\n        emit CreatedToken(tokenAddress);\n    }\n\n    function createNonFungibleTokenWithSECP256K1AdminKeyWithoutKYCPublic(\n        address treasury, bytes memory adminKey\n    ) public payable {\n        IHederaTokenService.TokenKey[] memory keys = new IHederaTokenService.TokenKey[](4);\n        keys[0] = getSingleKey(KeyType.ADMIN, KeyType.PAUSE, KeyValueType.SECP256K1, adminKey);",
            "codeOnlyTokens": 809,
            "startLine": 142,
            "endLine": 213,
            "type": ".sol_part_3",
            "isOversized": false
          },
          {
            "originalText": "        keys[1] = getSingleKey(KeyType.FREEZE, KeyValueType.SECP256K1, adminKey);\n        keys[2] = getSingleKey(KeyType.SUPPLY, KeyValueType.SECP256K1, adminKey);\n        keys[3] = getSingleKey(KeyType.WIPE, KeyValueType.SECP256K1, adminKey);\n\n        IHederaTokenService.Expiry memory expiry = IHederaTokenService.Expiry(\n            0, treasury, 8000000\n        );\n\n        IHederaTokenService.HederaToken memory token = IHederaTokenService.HederaToken(\n            name, symbol, treasury, memo, finiteTotalSupplyType, maxSupply, freezeDefaultStatus, keys, expiry\n        );\n\n        (int responseCode, address tokenAddress) =\n        HederaTokenService.createNonFungibleToken(token);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert ();\n        }\n\n        emit CreatedToken(tokenAddress);\n    }\n\n    function createNonFungibleTokenWithCustomFeesPublic(\n        address treasury,\n        address fixedFeeTokenAddress\n    ) public payable {\n        IHederaTokenService.TokenKey[] memory keys = new IHederaTokenService.TokenKey[](5);\n        keys[0] = getSingleKey(KeyType.ADMIN, KeyType.PAUSE, KeyValueType.INHERIT_ACCOUNT_KEY, bytes(\"\"));\n        keys[1] = getSingleKey(KeyType.KYC, KeyValueType.INHERIT_ACCOUNT_KEY, bytes(\"\"));\n        keys[2] = getSingleKey(KeyType.FREEZE, KeyValueType.INHERIT_ACCOUNT_KEY, bytes(\"\"));\n        keys[3] = getSingleKey(KeyType.SUPPLY, KeyValueType.INHERIT_ACCOUNT_KEY, bytes(\"\"));\n        keys[4] = getSingleKey(KeyType.WIPE, KeyValueType.INHERIT_ACCOUNT_KEY, bytes(\"\"));\n\n        IHederaTokenService.Expiry memory expiry = IHederaTokenService.Expiry(\n            0, treasury, 8000000\n        );\n\n        IHederaTokenService.HederaToken memory token = IHederaTokenService.HederaToken(\n            name, symbol, treasury, memo, finiteTotalSupplyType, maxSupply, freezeDefaultStatus, keys, expiry\n        );\n\n        IHederaTokenService.FixedFee[] memory fixedFees = new IHederaTokenService.FixedFee[](1);\n        fixedFees[0] = IHederaTokenService.FixedFee(1, fixedFeeTokenAddress, false, false, treasury);\n\n        IHederaTokenService.RoyaltyFee[] memory royaltyFees = new IHederaTokenService.RoyaltyFee[](1);\n        royaltyFees[0] = IHederaTokenService.RoyaltyFee(4, 5, 10, fixedFeeTokenAddress, false, treasury);\n\n        (int responseCode, address tokenAddress) =\n        HederaTokenService.createNonFungibleTokenWithCustomFees(token, fixedFees, royaltyFees);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert ();\n        }\n\n        emit CreatedToken(tokenAddress);\n    }\n\n    function mintTokenPublic(address token, int64 amount, bytes[] memory metadata) public\n    returns (int responseCode, int64 newTotalSupply, int64[] memory serialNumbers)  {\n        (responseCode, newTotalSupply, serialNumbers) = HederaTokenService.mintToken(token, amount, metadata);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n\n        emit MintedToken(newTotalSupply, serialNumbers);\n    }\n\n    function mintTokenToAddressPublic(address token, int64 amount, bytes[] memory metadata) public\n    returns (int responseCode, int64 newTotalSupply, int64[] memory serialNumbers)  {",
            "codeOnlyTokens": 803,
            "startLine": 214,
            "endLine": 284,
            "type": ".sol_part_4",
            "isOversized": false
          },
          {
            "originalText": "        (responseCode, newTotalSupply, serialNumbers) = HederaTokenService.mintToken(token, amount, metadata);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n\n        emit MintedToken(newTotalSupply, serialNumbers);\n\n        HederaTokenService.transferNFT(token, address(this), msg.sender, serialNumbers[0]);\n    }\n\n    function associateTokensPublic(address account, address[] memory tokens) external returns (int256 responseCode) {\n        (responseCode) = HederaTokenService.associateTokens(account, tokens);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert ();\n        }\n    }\n\n    function associateTokenPublic(address account, address token) public returns (int responseCode) {\n        responseCode = HederaTokenService.associateToken(account, token);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert ();\n        }\n    }\n\n    function grantTokenKycPublic(address token, address account) external returns (int64 responseCode) {\n        (responseCode) = HederaTokenService.grantTokenKyc(token, account);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n    }\n\n    //Adding this function to showcase token functionality in extended updateTokenInfo test suite\n    function updateTokenInfoPublic(address token, IHederaTokenService.HederaToken memory tokenInfo)external returns (int responseCode) {\n        (responseCode) = HederaTokenService.updateTokenInfo(token, tokenInfo);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n    }\n\n    function approvePublic(address token, address spender, uint256 amount) public returns (int responseCode) {\n    responseCode = HederaTokenService.approve(token, spender, amount);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert ();\n        }\n    }\n}\n",
            "codeOnlyTokens": 438,
            "startLine": 285,
            "endLine": 343,
            "type": ".sol_part_5",
            "isOversized": false
          }
        ],
        "groupedChunks": [
          {
            "combinedText": "// File: contracts/system-contracts/hedera-token-service/examples/token-create/TokenCreateContract.sol\n// Relevant file context:\n// Type: .sol\n\n\n// --- Next chunk ---\n\n// Lines 1-68 (.sol_part_1)\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.5.0 <0.9.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../HederaTokenService.sol\";\nimport \"../../ExpiryHelper.sol\";\nimport \"../../KeyHelper.sol\";\n\ncontract TokenCreateContract is HederaTokenService, ExpiryHelper, KeyHelper {\n\n    string name = \"tokenName\";\n    string symbol = \"tokenSymbol\";\n    string memo = \"memo\";\n    int64 initialTotalSupply = 10000000000;\n    int64 maxSupply = 20000000000;\n    int32 decimals = 0;\n    bool freezeDefaultStatus = false;\n    bool finiteTotalSupplyType = true;\n\n    event ResponseCode(int responseCode);\n    event CreatedToken(address tokenAddress);\n    event MintedToken(int64 newTotalSupply, int64[] serialNumbers);\n    event KycGranted(bool kycGranted);\n\n    function createFungibleTokenPublic(\n        address treasury\n    ) public payable {\n        IHederaTokenService.TokenKey[] memory keys = new IHederaTokenService.TokenKey[](6);\n        keys[0] = getSingleKey(KeyType.ADMIN, KeyType.PAUSE, KeyValueType.INHERIT_ACCOUNT_KEY, bytes(\"\"));\n        keys[1] = getSingleKey(KeyType.KYC, KeyValueType.INHERIT_ACCOUNT_KEY, bytes(\"\"));\n        keys[2] = getSingleKey(KeyType.FREEZE, KeyValueType.INHERIT_ACCOUNT_KEY, bytes(\"\"));\n        keys[3] = getSingleKey(KeyType.WIPE, KeyValueType.INHERIT_ACCOUNT_KEY, bytes(\"\"));\n        keys[4] = getSingleKey(KeyType.SUPPLY, KeyValueType.INHERIT_ACCOUNT_KEY, bytes(\"\"));\n        keys[5] = getSingleKey(KeyType.FEE, KeyValueType.INHERIT_ACCOUNT_KEY, bytes(\"\"));\n\n        IHederaTokenService.Expiry memory expiry = IHederaTokenService.Expiry(\n            0, treasury, 8000000\n        );\n\n        IHederaTokenService.HederaToken memory token = IHederaTokenService.HederaToken(\n            name, symbol, treasury, memo, finiteTotalSupplyType, maxSupply, freezeDefaultStatus, keys, expiry\n        );\n\n        (int responseCode, address tokenAddress) =\n        HederaTokenService.createFungibleToken(token, initialTotalSupply, decimals);\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert ();\n        }\n\n        emit CreatedToken(tokenAddress);\n    }\n\n    function createFungibleTokenWithSECP256K1AdminKeyPublic(\n        address treasury, bytes memory adminKey\n    ) public payable returns (address) {\n        IHederaTokenService.TokenKey[] memory keys = new IHederaTokenService.TokenKey[](6);\n        keys[0] = getSingleKey(KeyType.ADMIN, KeyType.PAUSE, KeyValueType.SECP256K1, adminKey);\n        keys[1] = getSingleKey(KeyType.KYC, KeyValueType.SECP256K1, adminKey);\n        keys[2] = getSingleKey(KeyType.FREEZE, KeyValueType.SECP256K1, adminKey);\n        keys[3] = getSingleKey(KeyType.SUPPLY, KeyValueType.SECP256K1, adminKey);\n        keys[4] = getSingleKey(KeyType.WIPE, KeyValueType.SECP256K1, adminKey);\n        keys[5] = getSingleKey(KeyType.FEE, KeyValueType.SECP256K1, adminKey);\n\n        IHederaTokenService.Expiry memory expiry = IHederaTokenService.Expiry(\n            0, treasury, 8000000\n        );\n\n        IHederaTokenService.HederaToken memory token = IHederaTokenService.HederaToken(\n\n// --- Next chunk ---\n\n// Lines 69-141 (.sol_part_2)\n            name, symbol, treasury, memo, finiteTotalSupplyType, maxSupply, freezeDefaultStatus, keys, expiry\n        );\n\n        (int responseCode, address tokenAddress) =\n        HederaTokenService.createFungibleToken(token, initialTotalSupply, decimals);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert ();\n        }\n\n        emit CreatedToken(tokenAddress);\n\n        return tokenAddress;\n    }\n\n    function createFungibleTokenWithSECP256K1AdminKeyAssociateAndTransferToAddressPublic(address treasury, bytes memory adminKey, int64 amount) public payable {\n        address tokenAddress = this.createFungibleTokenWithSECP256K1AdminKeyPublic{value : msg.value}(treasury, adminKey);\n        this.associateTokenPublic(msg.sender, tokenAddress);\n        this.grantTokenKycPublic(tokenAddress, msg.sender);\n        HederaTokenService.transferToken(tokenAddress, address(this), msg.sender, amount);\n    }\n\n    function createFungibleTokenWithSECP256K1AdminKeyWithoutKYCPublic(\n        address treasury, bytes memory adminKey\n    ) public payable returns (address) {\n        IHederaTokenService.TokenKey[] memory keys = new IHederaTokenService.TokenKey[](4);\n        keys[0] = getSingleKey(KeyType.ADMIN, KeyType.PAUSE, KeyValueType.SECP256K1, adminKey);\n        keys[1] = getSingleKey(KeyType.FREEZE, KeyValueType.SECP256K1, adminKey);\n        keys[2] = getSingleKey(KeyType.SUPPLY, KeyValueType.SECP256K1, adminKey);\n        keys[3] = getSingleKey(KeyType.WIPE, KeyValueType.SECP256K1, adminKey);\n\n        IHederaTokenService.Expiry memory expiry = IHederaTokenService.Expiry(\n            0, treasury, 8000000\n        );\n\n        IHederaTokenService.HederaToken memory token = IHederaTokenService.HederaToken(\n            name, symbol, treasury, memo, finiteTotalSupplyType, maxSupply, freezeDefaultStatus, keys, expiry\n        );\n\n        (int responseCode, address tokenAddress) =\n        HederaTokenService.createFungibleToken(token, initialTotalSupply, decimals);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert ();\n        }\n\n        emit CreatedToken(tokenAddress);\n\n        return tokenAddress;\n    }\n\n    function createFungibleTokenWithCustomFeesPublic(\n        address treasury,\n        address fixedFeeTokenAddress\n    ) public payable {\n        IHederaTokenService.TokenKey[] memory keys = new IHederaTokenService.TokenKey[](1);\n        keys[0] = getSingleKey(KeyType.ADMIN, KeyType.ADMIN, KeyValueType.INHERIT_ACCOUNT_KEY, bytes(\"\"));\n\n        IHederaTokenService.Expiry memory expiry = IHederaTokenService.Expiry(\n            0, treasury, 8000000\n        );\n\n        IHederaTokenService.HederaToken memory token = IHederaTokenService.HederaToken(\n            name, symbol, treasury, memo, finiteTotalSupplyType, maxSupply, false, keys, expiry\n        );\n\n        IHederaTokenService.FixedFee[] memory fixedFees = new IHederaTokenService.FixedFee[](1);\n        fixedFees[0] = IHederaTokenService.FixedFee(1, fixedFeeTokenAddress, false, false, treasury);\n\n        IHederaTokenService.FractionalFee[] memory fractionalFees = new IHederaTokenService.FractionalFee[](1);\n        fractionalFees[0] = IHederaTokenService.FractionalFee(4, 5, 10, 30, false, treasury);\n\n        (int responseCode, address tokenAddress) =\n\n// --- Next chunk ---\n\n// Lines 142-213 (.sol_part_3)\n        HederaTokenService.createFungibleTokenWithCustomFees(token, initialTotalSupply, decimals, fixedFees, fractionalFees);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert ();\n        }\n\n        emit CreatedToken(tokenAddress);\n    }\n\n    function createNonFungibleTokenPublic(\n        address treasury\n    ) public payable {\n        IHederaTokenService.TokenKey[] memory keys = new IHederaTokenService.TokenKey[](5);\n        keys[0] = getSingleKey(KeyType.ADMIN, KeyType.PAUSE, KeyValueType.INHERIT_ACCOUNT_KEY, bytes(\"\"));\n        keys[1] = getSingleKey(KeyType.KYC, KeyValueType.INHERIT_ACCOUNT_KEY, bytes(\"\"));\n        keys[2] = getSingleKey(KeyType.FREEZE, KeyValueType.INHERIT_ACCOUNT_KEY, bytes(\"\"));\n        keys[3] = getSingleKey(KeyType.SUPPLY, KeyValueType.INHERIT_ACCOUNT_KEY, bytes(\"\"));\n        keys[4] = getSingleKey(KeyType.WIPE, KeyValueType.INHERIT_ACCOUNT_KEY, bytes(\"\"));\n\n        IHederaTokenService.Expiry memory expiry = IHederaTokenService.Expiry(\n            0, treasury, 8000000\n        );\n\n        IHederaTokenService.HederaToken memory token = IHederaTokenService.HederaToken(\n            name, symbol, treasury, memo, finiteTotalSupplyType, maxSupply, freezeDefaultStatus, keys, expiry\n        );\n\n        (int responseCode, address tokenAddress) =\n        HederaTokenService.createNonFungibleToken(token);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert ();\n        }\n\n        emit CreatedToken(tokenAddress);\n    }\n\n    function createNonFungibleTokenWithSECP256K1AdminKeyPublic(\n        address treasury, bytes memory adminKey\n    ) public payable {\n        IHederaTokenService.TokenKey[] memory keys = new IHederaTokenService.TokenKey[](6);\n        keys[0] = getSingleKey(KeyType.ADMIN, KeyType.PAUSE, KeyValueType.SECP256K1, adminKey);\n        keys[1] = getSingleKey(KeyType.KYC, KeyValueType.SECP256K1, adminKey);\n        keys[2] = getSingleKey(KeyType.FREEZE, KeyValueType.SECP256K1, adminKey);\n        keys[3] = getSingleKey(KeyType.SUPPLY, KeyValueType.SECP256K1, adminKey);\n        keys[4] = getSingleKey(KeyType.WIPE, KeyValueType.SECP256K1, adminKey);\n        keys[5] = getSingleKey(KeyType.FEE, KeyValueType.SECP256K1, adminKey);\n\n        IHederaTokenService.Expiry memory expiry = IHederaTokenService.Expiry(\n            0, treasury, 8000000\n        );\n\n        IHederaTokenService.HederaToken memory token = IHederaTokenService.HederaToken(\n            name, symbol, treasury, memo, finiteTotalSupplyType, maxSupply, freezeDefaultStatus, keys, expiry\n        );\n\n        (int responseCode, address tokenAddress) =\n        HederaTokenService.createNonFungibleToken(token);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert ();\n        }\n\n        emit CreatedToken(tokenAddress);\n    }\n\n    function createNonFungibleTokenWithSECP256K1AdminKeyWithoutKYCPublic(\n        address treasury, bytes memory adminKey\n    ) public payable {\n        IHederaTokenService.TokenKey[] memory keys = new IHederaTokenService.TokenKey[](4);\n        keys[0] = getSingleKey(KeyType.ADMIN, KeyType.PAUSE, KeyValueType.SECP256K1, adminKey);",
            "totalTokens": 2493,
            "chunks": [
              {
                "originalText": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.5.0 <0.9.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../HederaTokenService.sol\";\nimport \"../../ExpiryHelper.sol\";\nimport \"../../KeyHelper.sol\";\n\ncontract TokenCreateContract is HederaTokenService, ExpiryHelper, KeyHelper {\n\n    string name = \"tokenName\";\n    string symbol = \"tokenSymbol\";\n    string memo = \"memo\";\n    int64 initialTotalSupply = 10000000000;\n    int64 maxSupply = 20000000000;\n    int32 decimals = 0;\n    bool freezeDefaultStatus = false;\n    bool finiteTotalSupplyType = true;\n\n    event ResponseCode(int responseCode);\n    event CreatedToken(address tokenAddress);\n    event MintedToken(int64 newTotalSupply, int64[] serialNumbers);\n    event KycGranted(bool kycGranted);\n\n    function createFungibleTokenPublic(\n        address treasury\n    ) public payable {\n        IHederaTokenService.TokenKey[] memory keys = new IHederaTokenService.TokenKey[](6);\n        keys[0] = getSingleKey(KeyType.ADMIN, KeyType.PAUSE, KeyValueType.INHERIT_ACCOUNT_KEY, bytes(\"\"));\n        keys[1] = getSingleKey(KeyType.KYC, KeyValueType.INHERIT_ACCOUNT_KEY, bytes(\"\"));\n        keys[2] = getSingleKey(KeyType.FREEZE, KeyValueType.INHERIT_ACCOUNT_KEY, bytes(\"\"));\n        keys[3] = getSingleKey(KeyType.WIPE, KeyValueType.INHERIT_ACCOUNT_KEY, bytes(\"\"));\n        keys[4] = getSingleKey(KeyType.SUPPLY, KeyValueType.INHERIT_ACCOUNT_KEY, bytes(\"\"));\n        keys[5] = getSingleKey(KeyType.FEE, KeyValueType.INHERIT_ACCOUNT_KEY, bytes(\"\"));\n\n        IHederaTokenService.Expiry memory expiry = IHederaTokenService.Expiry(\n            0, treasury, 8000000\n        );\n\n        IHederaTokenService.HederaToken memory token = IHederaTokenService.HederaToken(\n            name, symbol, treasury, memo, finiteTotalSupplyType, maxSupply, freezeDefaultStatus, keys, expiry\n        );\n\n        (int responseCode, address tokenAddress) =\n        HederaTokenService.createFungibleToken(token, initialTotalSupply, decimals);\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert ();\n        }\n\n        emit CreatedToken(tokenAddress);\n    }\n\n    function createFungibleTokenWithSECP256K1AdminKeyPublic(\n        address treasury, bytes memory adminKey\n    ) public payable returns (address) {\n        IHederaTokenService.TokenKey[] memory keys = new IHederaTokenService.TokenKey[](6);\n        keys[0] = getSingleKey(KeyType.ADMIN, KeyType.PAUSE, KeyValueType.SECP256K1, adminKey);\n        keys[1] = getSingleKey(KeyType.KYC, KeyValueType.SECP256K1, adminKey);\n        keys[2] = getSingleKey(KeyType.FREEZE, KeyValueType.SECP256K1, adminKey);\n        keys[3] = getSingleKey(KeyType.SUPPLY, KeyValueType.SECP256K1, adminKey);\n        keys[4] = getSingleKey(KeyType.WIPE, KeyValueType.SECP256K1, adminKey);\n        keys[5] = getSingleKey(KeyType.FEE, KeyValueType.SECP256K1, adminKey);\n\n        IHederaTokenService.Expiry memory expiry = IHederaTokenService.Expiry(\n            0, treasury, 8000000\n        );\n\n        IHederaTokenService.HederaToken memory token = IHederaTokenService.HederaToken(",
                "codeOnlyTokens": 800,
                "startLine": 1,
                "endLine": 68,
                "type": ".sol_part_1",
                "isOversized": false
              },
              {
                "originalText": "            name, symbol, treasury, memo, finiteTotalSupplyType, maxSupply, freezeDefaultStatus, keys, expiry\n        );\n\n        (int responseCode, address tokenAddress) =\n        HederaTokenService.createFungibleToken(token, initialTotalSupply, decimals);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert ();\n        }\n\n        emit CreatedToken(tokenAddress);\n\n        return tokenAddress;\n    }\n\n    function createFungibleTokenWithSECP256K1AdminKeyAssociateAndTransferToAddressPublic(address treasury, bytes memory adminKey, int64 amount) public payable {\n        address tokenAddress = this.createFungibleTokenWithSECP256K1AdminKeyPublic{value : msg.value}(treasury, adminKey);\n        this.associateTokenPublic(msg.sender, tokenAddress);\n        this.grantTokenKycPublic(tokenAddress, msg.sender);\n        HederaTokenService.transferToken(tokenAddress, address(this), msg.sender, amount);\n    }\n\n    function createFungibleTokenWithSECP256K1AdminKeyWithoutKYCPublic(\n        address treasury, bytes memory adminKey\n    ) public payable returns (address) {\n        IHederaTokenService.TokenKey[] memory keys = new IHederaTokenService.TokenKey[](4);\n        keys[0] = getSingleKey(KeyType.ADMIN, KeyType.PAUSE, KeyValueType.SECP256K1, adminKey);\n        keys[1] = getSingleKey(KeyType.FREEZE, KeyValueType.SECP256K1, adminKey);\n        keys[2] = getSingleKey(KeyType.SUPPLY, KeyValueType.SECP256K1, adminKey);\n        keys[3] = getSingleKey(KeyType.WIPE, KeyValueType.SECP256K1, adminKey);\n\n        IHederaTokenService.Expiry memory expiry = IHederaTokenService.Expiry(\n            0, treasury, 8000000\n        );\n\n        IHederaTokenService.HederaToken memory token = IHederaTokenService.HederaToken(\n            name, symbol, treasury, memo, finiteTotalSupplyType, maxSupply, freezeDefaultStatus, keys, expiry\n        );\n\n        (int responseCode, address tokenAddress) =\n        HederaTokenService.createFungibleToken(token, initialTotalSupply, decimals);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert ();\n        }\n\n        emit CreatedToken(tokenAddress);\n\n        return tokenAddress;\n    }\n\n    function createFungibleTokenWithCustomFeesPublic(\n        address treasury,\n        address fixedFeeTokenAddress\n    ) public payable {\n        IHederaTokenService.TokenKey[] memory keys = new IHederaTokenService.TokenKey[](1);\n        keys[0] = getSingleKey(KeyType.ADMIN, KeyType.ADMIN, KeyValueType.INHERIT_ACCOUNT_KEY, bytes(\"\"));\n\n        IHederaTokenService.Expiry memory expiry = IHederaTokenService.Expiry(\n            0, treasury, 8000000\n        );\n\n        IHederaTokenService.HederaToken memory token = IHederaTokenService.HederaToken(\n            name, symbol, treasury, memo, finiteTotalSupplyType, maxSupply, false, keys, expiry\n        );\n\n        IHederaTokenService.FixedFee[] memory fixedFees = new IHederaTokenService.FixedFee[](1);\n        fixedFees[0] = IHederaTokenService.FixedFee(1, fixedFeeTokenAddress, false, false, treasury);\n\n        IHederaTokenService.FractionalFee[] memory fractionalFees = new IHederaTokenService.FractionalFee[](1);\n        fractionalFees[0] = IHederaTokenService.FractionalFee(4, 5, 10, 30, false, treasury);\n\n        (int responseCode, address tokenAddress) =",
                "codeOnlyTokens": 800,
                "startLine": 69,
                "endLine": 141,
                "type": ".sol_part_2",
                "isOversized": false
              },
              {
                "originalText": "        HederaTokenService.createFungibleTokenWithCustomFees(token, initialTotalSupply, decimals, fixedFees, fractionalFees);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert ();\n        }\n\n        emit CreatedToken(tokenAddress);\n    }\n\n    function createNonFungibleTokenPublic(\n        address treasury\n    ) public payable {\n        IHederaTokenService.TokenKey[] memory keys = new IHederaTokenService.TokenKey[](5);\n        keys[0] = getSingleKey(KeyType.ADMIN, KeyType.PAUSE, KeyValueType.INHERIT_ACCOUNT_KEY, bytes(\"\"));\n        keys[1] = getSingleKey(KeyType.KYC, KeyValueType.INHERIT_ACCOUNT_KEY, bytes(\"\"));\n        keys[2] = getSingleKey(KeyType.FREEZE, KeyValueType.INHERIT_ACCOUNT_KEY, bytes(\"\"));\n        keys[3] = getSingleKey(KeyType.SUPPLY, KeyValueType.INHERIT_ACCOUNT_KEY, bytes(\"\"));\n        keys[4] = getSingleKey(KeyType.WIPE, KeyValueType.INHERIT_ACCOUNT_KEY, bytes(\"\"));\n\n        IHederaTokenService.Expiry memory expiry = IHederaTokenService.Expiry(\n            0, treasury, 8000000\n        );\n\n        IHederaTokenService.HederaToken memory token = IHederaTokenService.HederaToken(\n            name, symbol, treasury, memo, finiteTotalSupplyType, maxSupply, freezeDefaultStatus, keys, expiry\n        );\n\n        (int responseCode, address tokenAddress) =\n        HederaTokenService.createNonFungibleToken(token);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert ();\n        }\n\n        emit CreatedToken(tokenAddress);\n    }\n\n    function createNonFungibleTokenWithSECP256K1AdminKeyPublic(\n        address treasury, bytes memory adminKey\n    ) public payable {\n        IHederaTokenService.TokenKey[] memory keys = new IHederaTokenService.TokenKey[](6);\n        keys[0] = getSingleKey(KeyType.ADMIN, KeyType.PAUSE, KeyValueType.SECP256K1, adminKey);\n        keys[1] = getSingleKey(KeyType.KYC, KeyValueType.SECP256K1, adminKey);\n        keys[2] = getSingleKey(KeyType.FREEZE, KeyValueType.SECP256K1, adminKey);\n        keys[3] = getSingleKey(KeyType.SUPPLY, KeyValueType.SECP256K1, adminKey);\n        keys[4] = getSingleKey(KeyType.WIPE, KeyValueType.SECP256K1, adminKey);\n        keys[5] = getSingleKey(KeyType.FEE, KeyValueType.SECP256K1, adminKey);\n\n        IHederaTokenService.Expiry memory expiry = IHederaTokenService.Expiry(\n            0, treasury, 8000000\n        );\n\n        IHederaTokenService.HederaToken memory token = IHederaTokenService.HederaToken(\n            name, symbol, treasury, memo, finiteTotalSupplyType, maxSupply, freezeDefaultStatus, keys, expiry\n        );\n\n        (int responseCode, address tokenAddress) =\n        HederaTokenService.createNonFungibleToken(token);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert ();\n        }\n\n        emit CreatedToken(tokenAddress);\n    }\n\n    function createNonFungibleTokenWithSECP256K1AdminKeyWithoutKYCPublic(\n        address treasury, bytes memory adminKey\n    ) public payable {\n        IHederaTokenService.TokenKey[] memory keys = new IHederaTokenService.TokenKey[](4);\n        keys[0] = getSingleKey(KeyType.ADMIN, KeyType.PAUSE, KeyValueType.SECP256K1, adminKey);",
                "codeOnlyTokens": 809,
                "startLine": 142,
                "endLine": 213,
                "type": ".sol_part_3",
                "isOversized": false
              }
            ],
            "startLine": 1,
            "endLine": 213,
            "groupId": 1
          },
          {
            "combinedText": "// File: contracts/system-contracts/hedera-token-service/examples/token-create/TokenCreateContract.sol\n// Relevant file context:\n// Type: .sol\n\n\n// --- Next chunk ---\n\n// Lines 214-284 (.sol_part_4)\n        keys[1] = getSingleKey(KeyType.FREEZE, KeyValueType.SECP256K1, adminKey);\n        keys[2] = getSingleKey(KeyType.SUPPLY, KeyValueType.SECP256K1, adminKey);\n        keys[3] = getSingleKey(KeyType.WIPE, KeyValueType.SECP256K1, adminKey);\n\n        IHederaTokenService.Expiry memory expiry = IHederaTokenService.Expiry(\n            0, treasury, 8000000\n        );\n\n        IHederaTokenService.HederaToken memory token = IHederaTokenService.HederaToken(\n            name, symbol, treasury, memo, finiteTotalSupplyType, maxSupply, freezeDefaultStatus, keys, expiry\n        );\n\n        (int responseCode, address tokenAddress) =\n        HederaTokenService.createNonFungibleToken(token);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert ();\n        }\n\n        emit CreatedToken(tokenAddress);\n    }\n\n    function createNonFungibleTokenWithCustomFeesPublic(\n        address treasury,\n        address fixedFeeTokenAddress\n    ) public payable {\n        IHederaTokenService.TokenKey[] memory keys = new IHederaTokenService.TokenKey[](5);\n        keys[0] = getSingleKey(KeyType.ADMIN, KeyType.PAUSE, KeyValueType.INHERIT_ACCOUNT_KEY, bytes(\"\"));\n        keys[1] = getSingleKey(KeyType.KYC, KeyValueType.INHERIT_ACCOUNT_KEY, bytes(\"\"));\n        keys[2] = getSingleKey(KeyType.FREEZE, KeyValueType.INHERIT_ACCOUNT_KEY, bytes(\"\"));\n        keys[3] = getSingleKey(KeyType.SUPPLY, KeyValueType.INHERIT_ACCOUNT_KEY, bytes(\"\"));\n        keys[4] = getSingleKey(KeyType.WIPE, KeyValueType.INHERIT_ACCOUNT_KEY, bytes(\"\"));\n\n        IHederaTokenService.Expiry memory expiry = IHederaTokenService.Expiry(\n            0, treasury, 8000000\n        );\n\n        IHederaTokenService.HederaToken memory token = IHederaTokenService.HederaToken(\n            name, symbol, treasury, memo, finiteTotalSupplyType, maxSupply, freezeDefaultStatus, keys, expiry\n        );\n\n        IHederaTokenService.FixedFee[] memory fixedFees = new IHederaTokenService.FixedFee[](1);\n        fixedFees[0] = IHederaTokenService.FixedFee(1, fixedFeeTokenAddress, false, false, treasury);\n\n        IHederaTokenService.RoyaltyFee[] memory royaltyFees = new IHederaTokenService.RoyaltyFee[](1);\n        royaltyFees[0] = IHederaTokenService.RoyaltyFee(4, 5, 10, fixedFeeTokenAddress, false, treasury);\n\n        (int responseCode, address tokenAddress) =\n        HederaTokenService.createNonFungibleTokenWithCustomFees(token, fixedFees, royaltyFees);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert ();\n        }\n\n        emit CreatedToken(tokenAddress);\n    }\n\n    function mintTokenPublic(address token, int64 amount, bytes[] memory metadata) public\n    returns (int responseCode, int64 newTotalSupply, int64[] memory serialNumbers)  {\n        (responseCode, newTotalSupply, serialNumbers) = HederaTokenService.mintToken(token, amount, metadata);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n\n        emit MintedToken(newTotalSupply, serialNumbers);\n    }\n\n    function mintTokenToAddressPublic(address token, int64 amount, bytes[] memory metadata) public\n    returns (int responseCode, int64 newTotalSupply, int64[] memory serialNumbers)  {\n\n// --- Next chunk ---\n\n// Lines 285-343 (.sol_part_5)\n        (responseCode, newTotalSupply, serialNumbers) = HederaTokenService.mintToken(token, amount, metadata);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n\n        emit MintedToken(newTotalSupply, serialNumbers);\n\n        HederaTokenService.transferNFT(token, address(this), msg.sender, serialNumbers[0]);\n    }\n\n    function associateTokensPublic(address account, address[] memory tokens) external returns (int256 responseCode) {\n        (responseCode) = HederaTokenService.associateTokens(account, tokens);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert ();\n        }\n    }\n\n    function associateTokenPublic(address account, address token) public returns (int responseCode) {\n        responseCode = HederaTokenService.associateToken(account, token);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert ();\n        }\n    }\n\n    function grantTokenKycPublic(address token, address account) external returns (int64 responseCode) {\n        (responseCode) = HederaTokenService.grantTokenKyc(token, account);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n    }\n\n    //Adding this function to showcase token functionality in extended updateTokenInfo test suite\n    function updateTokenInfoPublic(address token, IHederaTokenService.HederaToken memory tokenInfo)external returns (int responseCode) {\n        (responseCode) = HederaTokenService.updateTokenInfo(token, tokenInfo);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n    }\n\n    function approvePublic(address token, address spender, uint256 amount) public returns (int responseCode) {\n    responseCode = HederaTokenService.approve(token, spender, amount);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert ();\n        }\n    }\n}\n",
            "totalTokens": 1307,
            "chunks": [
              {
                "originalText": "        keys[1] = getSingleKey(KeyType.FREEZE, KeyValueType.SECP256K1, adminKey);\n        keys[2] = getSingleKey(KeyType.SUPPLY, KeyValueType.SECP256K1, adminKey);\n        keys[3] = getSingleKey(KeyType.WIPE, KeyValueType.SECP256K1, adminKey);\n\n        IHederaTokenService.Expiry memory expiry = IHederaTokenService.Expiry(\n            0, treasury, 8000000\n        );\n\n        IHederaTokenService.HederaToken memory token = IHederaTokenService.HederaToken(\n            name, symbol, treasury, memo, finiteTotalSupplyType, maxSupply, freezeDefaultStatus, keys, expiry\n        );\n\n        (int responseCode, address tokenAddress) =\n        HederaTokenService.createNonFungibleToken(token);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert ();\n        }\n\n        emit CreatedToken(tokenAddress);\n    }\n\n    function createNonFungibleTokenWithCustomFeesPublic(\n        address treasury,\n        address fixedFeeTokenAddress\n    ) public payable {\n        IHederaTokenService.TokenKey[] memory keys = new IHederaTokenService.TokenKey[](5);\n        keys[0] = getSingleKey(KeyType.ADMIN, KeyType.PAUSE, KeyValueType.INHERIT_ACCOUNT_KEY, bytes(\"\"));\n        keys[1] = getSingleKey(KeyType.KYC, KeyValueType.INHERIT_ACCOUNT_KEY, bytes(\"\"));\n        keys[2] = getSingleKey(KeyType.FREEZE, KeyValueType.INHERIT_ACCOUNT_KEY, bytes(\"\"));\n        keys[3] = getSingleKey(KeyType.SUPPLY, KeyValueType.INHERIT_ACCOUNT_KEY, bytes(\"\"));\n        keys[4] = getSingleKey(KeyType.WIPE, KeyValueType.INHERIT_ACCOUNT_KEY, bytes(\"\"));\n\n        IHederaTokenService.Expiry memory expiry = IHederaTokenService.Expiry(\n            0, treasury, 8000000\n        );\n\n        IHederaTokenService.HederaToken memory token = IHederaTokenService.HederaToken(\n            name, symbol, treasury, memo, finiteTotalSupplyType, maxSupply, freezeDefaultStatus, keys, expiry\n        );\n\n        IHederaTokenService.FixedFee[] memory fixedFees = new IHederaTokenService.FixedFee[](1);\n        fixedFees[0] = IHederaTokenService.FixedFee(1, fixedFeeTokenAddress, false, false, treasury);\n\n        IHederaTokenService.RoyaltyFee[] memory royaltyFees = new IHederaTokenService.RoyaltyFee[](1);\n        royaltyFees[0] = IHederaTokenService.RoyaltyFee(4, 5, 10, fixedFeeTokenAddress, false, treasury);\n\n        (int responseCode, address tokenAddress) =\n        HederaTokenService.createNonFungibleTokenWithCustomFees(token, fixedFees, royaltyFees);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert ();\n        }\n\n        emit CreatedToken(tokenAddress);\n    }\n\n    function mintTokenPublic(address token, int64 amount, bytes[] memory metadata) public\n    returns (int responseCode, int64 newTotalSupply, int64[] memory serialNumbers)  {\n        (responseCode, newTotalSupply, serialNumbers) = HederaTokenService.mintToken(token, amount, metadata);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n\n        emit MintedToken(newTotalSupply, serialNumbers);\n    }\n\n    function mintTokenToAddressPublic(address token, int64 amount, bytes[] memory metadata) public\n    returns (int responseCode, int64 newTotalSupply, int64[] memory serialNumbers)  {",
                "codeOnlyTokens": 803,
                "startLine": 214,
                "endLine": 284,
                "type": ".sol_part_4",
                "isOversized": false
              },
              {
                "originalText": "        (responseCode, newTotalSupply, serialNumbers) = HederaTokenService.mintToken(token, amount, metadata);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n\n        emit MintedToken(newTotalSupply, serialNumbers);\n\n        HederaTokenService.transferNFT(token, address(this), msg.sender, serialNumbers[0]);\n    }\n\n    function associateTokensPublic(address account, address[] memory tokens) external returns (int256 responseCode) {\n        (responseCode) = HederaTokenService.associateTokens(account, tokens);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert ();\n        }\n    }\n\n    function associateTokenPublic(address account, address token) public returns (int responseCode) {\n        responseCode = HederaTokenService.associateToken(account, token);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert ();\n        }\n    }\n\n    function grantTokenKycPublic(address token, address account) external returns (int64 responseCode) {\n        (responseCode) = HederaTokenService.grantTokenKyc(token, account);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n    }\n\n    //Adding this function to showcase token functionality in extended updateTokenInfo test suite\n    function updateTokenInfoPublic(address token, IHederaTokenService.HederaToken memory tokenInfo)external returns (int responseCode) {\n        (responseCode) = HederaTokenService.updateTokenInfo(token, tokenInfo);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n    }\n\n    function approvePublic(address token, address spender, uint256 amount) public returns (int responseCode) {\n    responseCode = HederaTokenService.approve(token, spender, amount);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert ();\n        }\n    }\n}\n",
                "codeOnlyTokens": 438,
                "startLine": 285,
                "endLine": 343,
                "type": ".sol_part_5",
                "isOversized": false
              }
            ],
            "startLine": 214,
            "endLine": 343,
            "groupId": 2
          }
        ],
        "oversizedChunks": [],
        "sendStrategy": "multiple_groups",
        "finalTokenCount": 3800,
        "skippedContent": [],
        "contextHeader": "// File: contracts/system-contracts/hedera-token-service/examples/token-create/TokenCreateContract.sol\n// Relevant file context:\n// Type: .sol\n",
        "tokenBreakdown": {
          "originalFile": 3650,
          "finalSent": 3800,
          "codeTokensInGroups": 3650,
          "fileHeaderTokensInGroups": 62,
          "shellContextTokensInGroups": 0,
          "separatorTokensInGroups": 88,
          "skippedCodeTokens": 0,
          "unprocessedOversizedTokens": 0,
          "totalSavings": -150,
          "savingsPercentage": -4.10958904109589,
          "fileHeaderCount": 2,
          "fileHeaderAvgSize": 31,
          "shellContextCount": 0,
          "shellContextAvgSize": 0,
          "separatorCount": 5,
          "separatorAvgSize": 18
        }
      }
    },
    {
      "filePath": "contracts/system-contracts/hedera-token-service/HederaTokenService.sol",
      "totalOriginalTokens": 10352,
      "finalTokenCount": 10724,
      "impactScore": 49.413333333333334,
      "averageComplexity": 6.8,
      "averageQuality": 7.6,
      "usage": {
        "prompt_tokens": 15759,
        "completion_tokens": 1448,
        "total_tokens": 17207
      },
      "retries": 0,
      "hadError": false,
      "scoredChunkGroups": [
        {
          "groupId": 1,
          "score": {
            "complexity_score": 7,
            "code_quality_score": 8,
            "maintainability_score": 7,
            "best_practices_adherence": 8,
            "web3_pattern_identification": "Checks-Effects-Interactions",
            "hedera_red_flag": {
              "description": "There is potential for failed external calls in cryptoTransfer, mintToken, burnToken, associateTokens, and dissociateTokens that may lead to unhandled failure cases without proper checks.",
              "exact_code_snippet": "(bool success, bytes memory result) = precompileAddress.call("
            },
            "hedera_optimization_suggestion": {
              "description": "Consider using `require(success)` or checks to ensure transaction success, which will revert the transaction in case of a failure instead of returning an ambiguous response code.",
              "exact_code_snippet": "(bool success, bytes memory result) = precompileAddress.call("
            },
            "positive_feedback": "The use of the nonEmptyExpiry modifier effectively ensures that tokens have valid expiry periods set, which encourages prudent token management.",
            "group_summary": "This contract provides fundamental operations for managing tokens and their associations in the Hedera Token Service, including creation, transfers, minting, burning, and association of tokens with accounts."
          },
          "totalTokens": 2491,
          "usage": {
            "prompt_tokens": 3471,
            "completion_tokens": 269,
            "total_tokens": 3740,
            "prompt_tokens_details": {
              "cached_tokens": 0,
              "audio_tokens": 0
            },
            "completion_tokens_details": {
              "reasoning_tokens": 0,
              "audio_tokens": 0,
              "accepted_prediction_tokens": 0,
              "rejected_prediction_tokens": 0
            }
          }
        },
        {
          "groupId": 2,
          "score": {
            "complexity_score": 6,
            "code_quality_score": 7,
            "maintainability_score": 6,
            "best_practices_adherence": 8,
            "web3_pattern_identification": "Checks-Effects-Interactions",
            "hedera_red_flag": {
              "description": "Potentially unsafe direct calls to external precompile address without checks can lead to unexpected behavior.",
              "exact_code_snippet": "(bool success, bytes memory result) = precompileAddress.call{value : msg.value}(abi.encodeWithSelector(IHederaTokenService.createFungibleTokenWithCustomFees.selector, token, initialTotalSupply, decimals, fixedFees, fractionalFees));"
            },
            "hedera_optimization_suggestion": {
              "description": "Consider implementing more thorough error handling and logging mechanisms to audit failures accurately, which will ease debugging.",
              "exact_code_snippet": "(bool success, bytes memory result) = precompileAddress.call{value : msg.value}(abi.encodeWithSelector(IHederaTokenService.createFungibleTokenWithCustomFees.selector, token, initialTotalSupply, decimals, fixedFees, fractionalFees));"
            },
            "positive_feedback": "The use of the Hedera precompile for token creation enhances the contract's performance with native support.",
            "group_summary": "This section of the Hedera Token Service contract implements various token management functions, including creating fungible and non-fungible tokens, retrieving token information, setting custom fees, managing allowances, and facilitating transfers among accounts."
          },
          "totalTokens": 2513,
          "usage": {
            "prompt_tokens": 3520,
            "completion_tokens": 323,
            "total_tokens": 3843,
            "prompt_tokens_details": {
              "cached_tokens": 0,
              "audio_tokens": 0
            },
            "completion_tokens_details": {
              "reasoning_tokens": 0,
              "audio_tokens": 0,
              "accepted_prediction_tokens": 0,
              "rejected_prediction_tokens": 0
            }
          }
        },
        {
          "groupId": 3,
          "score": {
            "complexity_score": 7,
            "code_quality_score": 7,
            "maintainability_score": 6,
            "best_practices_adherence": 7,
            "web3_pattern_identification": "Checks-Effects-Interactions",
            "hedera_red_flag": {
              "description": "There is a potential for failure handling when the call to the precompile does not succeed. Explicit error messages or handling of failure cases are not defined, which can lead to uncertainty in the contract's behavior.",
              "exact_code_snippet": "(responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;"
            },
            "hedera_optimization_suggestion": {
              "description": "All function calls to the Hedera precompile have a similar implementation. A wrapper function that handles precompile interaction could reduce code duplication and improve maintainability.",
              "exact_code_snippet": "(bool success, bytes memory result) = precompileAddress.call(abi.encodeWithSelector("
            },
            "positive_feedback": "The use of consistent response codes for various operations (like success codes) is a very good practice, ensuring that the contract's consumers can easily understand the outcomes of their transactions.",
            "group_summary": "This section of the Hedera Token Service contract implements various token management functions, enabling operations such as checking KYC status, freezing accounts, and transferring tokens, aimed at facilitating the management and control of tokens on the Hedera network."
          },
          "totalTokens": 2504,
          "usage": {
            "prompt_tokens": 3518,
            "completion_tokens": 309,
            "total_tokens": 3827,
            "prompt_tokens_details": {
              "cached_tokens": 0,
              "audio_tokens": 0
            },
            "completion_tokens_details": {
              "reasoning_tokens": 0,
              "audio_tokens": 0,
              "accepted_prediction_tokens": 0,
              "rejected_prediction_tokens": 0
            }
          }
        },
        {
          "groupId": 4,
          "score": {
            "complexity_score": 7,
            "code_quality_score": 8,
            "maintainability_score": 7,
            "best_practices_adherence": 8,
            "web3_pattern_identification": "Direct Interaction with Precompile Contracts",
            "hedera_red_flag": {
              "description": "Potential for reentrancy attack as calls to external contracts are made without state changes or checks that reduce the risk.",
              "exact_code_snippet": "(bool success, bytes memory result) = precompileAddress.call("
            },
            "hedera_optimization_suggestion": {
              "description": "Consider using `require(success)` to halt execution immediately after a call failure, saving gas and making error handling more straightforward.",
              "exact_code_snippet": "(responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;"
            },
            "positive_feedback": "Great usage of the `abi.encodeWithSelector` pattern to handle method calls dynamically, enhancing flexibility in contract interactions.",
            "group_summary": "This section of the Hedera Token Service contract deals with various token management operations such as transferring NFTs, pausing/unpausing tokens, wiping token accounts, and retrieving token metadata through direct interactions with Hedera's precompiled contracts."
          },
          "totalTokens": 2513,
          "usage": {
            "prompt_tokens": 3530,
            "completion_tokens": 268,
            "total_tokens": 3798,
            "prompt_tokens_details": {
              "cached_tokens": 0,
              "audio_tokens": 0
            },
            "completion_tokens_details": {
              "reasoning_tokens": 0,
              "audio_tokens": 0,
              "accepted_prediction_tokens": 0,
              "rejected_prediction_tokens": 0
            }
          }
        },
        {
          "groupId": 5,
          "score": {
            "complexity_score": 7,
            "code_quality_score": 8,
            "maintainability_score": 7,
            "best_practices_adherence": 7,
            "web3_pattern_identification": "Direct contract interaction via precompiled contracts",
            "hedera_red_flag": {
              "description": "Lack of error handling for the case when the precompiled contract call fails.",
              "exact_code_snippet": "(responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;"
            },
            "hedera_optimization_suggestion": {
              "description": "Consider checking the result of the precompiled contract call for errors and handling them more explicitly rather than defaulting to UNKNOWN, which can obscure issues.",
              "exact_code_snippet": "(responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;"
            },
            "positive_feedback": "The use of precompile contracts to handle token airdrop functionality is an excellent demonstration of leveraging Hedera's architecture for efficient transactions.",
            "group_summary": "This section of the Hedera Token Service contract implements airdrop functionality, allowing for the distribution and management of pending airdrops while also supporting the rejection of tokens, thus facilitating advanced token management features for Hedera dApps."
          },
          "totalTokens": 703,
          "usage": {
            "prompt_tokens": 1720,
            "completion_tokens": 279,
            "total_tokens": 1999,
            "prompt_tokens_details": {
              "cached_tokens": 0,
              "audio_tokens": 0
            },
            "completion_tokens_details": {
              "reasoning_tokens": 0,
              "audio_tokens": 0,
              "accepted_prediction_tokens": 0,
              "rejected_prediction_tokens": 0
            }
          }
        }
      ],
      "chunkingDetails": {
        "filePath": "contracts/system-contracts/hedera-token-service/HederaTokenService.sol",
        "totalFileTokens": 10352,
        "chunks": [
          {
            "originalText": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.5.0 <0.9.0;\npragma experimental ABIEncoderV2;\n\nimport \"../HederaResponseCodes.sol\";\nimport \"./IHederaTokenService.sol\";\n\nabstract contract HederaTokenService {\n    address constant precompileAddress = address(0x167);\n    // 90 days in seconds\n    int32 constant defaultAutoRenewPeriod = 7776000;\n\n    modifier nonEmptyExpiry(IHederaTokenService.HederaToken memory token)\n    {\n        if (token.expiry.second == 0 && token.expiry.autoRenewPeriod == 0) {\n            token.expiry.autoRenewPeriod = defaultAutoRenewPeriod;\n        }\n        _;\n    }\n\n    /// Generic event\n    event CallResponseEvent(bool, bytes);\n\n    /// Performs transfers among combinations of tokens and hbars\n    /// @param transferList the list of hbar transfers to do\n    /// @param tokenTransfers the list of transfers to do\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @custom:version 0.3.0 the signature of the previous version was cryptoTransfer(TokenTransferList[] memory tokenTransfers)\n    function cryptoTransfer(IHederaTokenService.TransferList memory transferList, IHederaTokenService.TokenTransferList[] memory tokenTransfers) internal\n    returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.cryptoTransfer.selector, transferList, tokenTransfers));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Mints an amount of the token to the defined treasury account\n    /// @param token The token for which to mint tokens. If token does not exist, transaction results in\n    ///              INVALID_TOKEN_ID\n    /// @param amount Applicable to tokens of type FUNGIBLE_COMMON. The amount to mint to the Treasury Account.\n    ///               Amount must be a positive non-zero number represented in the lowest denomination of the\n    ///               token. The new supply must be lower than 2^63.\n    /// @param metadata Applicable to tokens of type NON_FUNGIBLE_UNIQUE. A list of metadata that are being created.\n    ///                 Maximum allowed size of each metadata is 100 bytes\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return newTotalSupply The new supply of tokens. For NFTs it is the total count of NFTs\n    /// @return serialNumbers If the token is an NFT the newly generate serial numbers, otherwise empty.\n    function mintToken(address token, int64 amount, bytes[] memory metadata) internal\n    returns (int responseCode, int64 newTotalSupply, int64[] memory serialNumbers)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.mintToken.selector,\n            token, amount, metadata));\n        (responseCode, newTotalSupply, serialNumbers) =\n        success\n        ? abi.decode(result, (int32, int64, int64[]))\n        : (HederaResponseCodes.UNKNOWN, int64(0), new int64[](0));\n    }\n\n    /// Burns an amount of the token from the defined treasury account\n    /// @param token The token for which to burn tokens. If token does not exist, transaction results in\n    ///              INVALID_TOKEN_ID\n    /// @param amount  Applicable to tokens of type FUNGIBLE_COMMON. The amount to burn from the Treasury Account.\n    ///                Amount must be a positive non-zero number, not bigger than the token balance of the treasury\n    ///                account (0; balance], represented in the lowest denomination.",
            "codeOnlyTokens": 807,
            "startLine": 1,
            "endLine": 65,
            "type": ".sol_part_1",
            "isOversized": false
          },
          {
            "originalText": "    /// @param serialNumbers Applicable to tokens of type NON_FUNGIBLE_UNIQUE. The list of serial numbers to be burned.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return newTotalSupply The new supply of tokens. For NFTs it is the total count of NFTs\n    function burnToken(address token, int64 amount, int64[] memory serialNumbers) internal\n    returns (int responseCode, int64 newTotalSupply)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.burnToken.selector,\n            token, amount, serialNumbers));\n        (responseCode, newTotalSupply) =\n        success\n        ? abi.decode(result, (int32, int64))\n        : (HederaResponseCodes.UNKNOWN, int64(0));\n    }\n\n    ///  Associates the provided account with the provided tokens. Must be signed by the provided\n    ///  Account's key or called from the accounts contract key\n    ///  If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.\n    ///  If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.\n    ///  If any of the provided tokens is not found, the transaction will resolve to INVALID_TOKEN_REF.\n    ///  If any of the provided tokens has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.\n    ///  If an association between the provided account and any of the tokens already exists, the\n    ///  transaction will resolve to TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT.\n    ///  If the provided account's associations count exceed the constraint of maximum token associations\n    ///    per account, the transaction will resolve to TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED.\n    ///  On success, associations between the provided account and tokens are made and the account is\n    ///    ready to interact with the tokens.\n    /// @param account The account to be associated with the provided tokens\n    /// @param tokens The tokens to be associated with the provided account. In the case of NON_FUNGIBLE_UNIQUE\n    ///               Type, once an account is associated, it can hold any number of NFTs (serial numbers) of that\n    ///               token type\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function associateTokens(address account, address[] memory tokens) internal returns (int responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.associateTokens.selector,\n            account, tokens));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    function associateToken(address account, address token) internal returns (int responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.associateToken.selector,\n            account, token));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Dissociates the provided account with the provided tokens. Must be signed by the provided\n    /// Account's key.\n    /// If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.\n    /// If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.\n    /// If any of the provided tokens is not found, the transaction will resolve to INVALID_TOKEN_REF.\n    /// If any of the provided tokens has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.\n    /// If an association between the provided account and any of the tokens does not exist, the\n    /// transaction will resolve to TOKEN_NOT_ASSOCIATED_TO_ACCOUNT.",
            "codeOnlyTokens": 801,
            "startLine": 66,
            "endLine": 119,
            "type": ".sol_part_2",
            "isOversized": false
          },
          {
            "originalText": "    /// If a token has not been deleted and has not expired, and the user has a nonzero balance, the\n    /// transaction will resolve to TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES.\n    /// If a <b>fungible token</b> has expired, the user can disassociate even if their token balance is\n    /// not zero.\n    /// If a <b>non fungible token</b> has expired, the user can <b>not</b> disassociate if their token\n    /// balance is not zero. The transaction will resolve to TRANSACTION_REQUIRED_ZERO_TOKEN_BALANCES.\n    /// On success, associations between the provided account and tokens are removed.\n    /// @param account The account to be dissociated from the provided tokens\n    /// @param tokens The tokens to be dissociated from the provided account.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function dissociateTokens(address account, address[] memory tokens) internal returns (int responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.dissociateTokens.selector,\n            account, tokens));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    function dissociateToken(address account, address token) internal returns (int responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.dissociateToken.selector,\n            account, token));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Creates a Fungible Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @param initialTotalSupply Specifies the initial supply of tokens to be put in circulation. The\n    /// initial supply is sent to the Treasury Account. The supply is in the lowest denomination possible.\n    /// @param decimals the number of decimal places a token is divisible by\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createFungibleToken(\n        IHederaTokenService.HederaToken memory token,\n        int64 initialTotalSupply,\n        int32 decimals) nonEmptyExpiry(token)\n    internal returns (int responseCode, address tokenAddress) {\n        (bool success, bytes memory result) = precompileAddress.call{value : msg.value}(\n            abi.encodeWithSelector(IHederaTokenService.createFungibleToken.selector,\n            token, initialTotalSupply, decimals));\n\n\n        (responseCode, tokenAddress) = success ? abi.decode(result, (int32, address)) : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Creates a Fungible Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @param initialTotalSupply Specifies the initial supply of tokens to be put in circulation. The\n    /// initial supply is sent to the Treasury Account. The supply is in the lowest denomination possible.\n    /// @param decimals the number of decimal places a token is divisible by\n    /// @param fixedFees list of fixed fees to apply to the token\n    /// @param fractionalFees list of fractional fees to apply to the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createFungibleTokenWithCustomFees(\n        IHederaTokenService.HederaToken memory token,\n        int64 initialTotalSupply,\n        int32 decimals,\n        IHederaTokenService.FixedFee[] memory fixedFees,",
            "codeOnlyTokens": 803,
            "startLine": 120,
            "endLine": 177,
            "type": ".sol_part_3",
            "isOversized": false
          },
          {
            "originalText": "        IHederaTokenService.FractionalFee[] memory fractionalFees) nonEmptyExpiry(token)\n    internal returns (int responseCode, address tokenAddress) {\n        (bool success, bytes memory result) = precompileAddress.call{value : msg.value}(\n            abi.encodeWithSelector(IHederaTokenService.createFungibleTokenWithCustomFees.selector,\n            token, initialTotalSupply, decimals, fixedFees, fractionalFees));\n        (responseCode, tokenAddress) = success ? abi.decode(result, (int32, address)) : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Creates an Non Fungible Unique Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createNonFungibleToken(IHederaTokenService.HederaToken memory token) nonEmptyExpiry(token)\n    internal returns (int responseCode, address tokenAddress) {\n        (bool success, bytes memory result) = precompileAddress.call{value : msg.value}(\n            abi.encodeWithSelector(IHederaTokenService.createNonFungibleToken.selector, token));\n        (responseCode, tokenAddress) = success ? abi.decode(result, (int32, address)) : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Creates an Non Fungible Unique Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @param fixedFees list of fixed fees to apply to the token\n    /// @param royaltyFees list of royalty fees to apply to the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createNonFungibleTokenWithCustomFees(\n        IHederaTokenService.HederaToken memory token,\n        IHederaTokenService.FixedFee[] memory fixedFees,\n        IHederaTokenService.RoyaltyFee[] memory royaltyFees) nonEmptyExpiry(token)\n    internal returns (int responseCode, address tokenAddress) {\n        (bool success, bytes memory result) = precompileAddress.call{value : msg.value}(\n            abi.encodeWithSelector(IHederaTokenService.createNonFungibleTokenWithCustomFees.selector,\n            token, fixedFees, royaltyFees));\n        (responseCode, tokenAddress) = success ? abi.decode(result, (int32, address)) : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Retrieves fungible specific token info for a fungible token\n    /// @param token The ID of the token as a solidity address\n    /// @dev This function reverts if the call is not successful\n    function getFungibleTokenInfo(address token) internal returns (int responseCode, IHederaTokenService.FungibleTokenInfo memory tokenInfo) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getFungibleTokenInfo.selector, token));\n        IHederaTokenService.FungibleTokenInfo memory defaultTokenInfo;\n        (responseCode, tokenInfo) = success ? abi.decode(result, (int32, IHederaTokenService.FungibleTokenInfo)) : (HederaResponseCodes.UNKNOWN, defaultTokenInfo);\n    }\n\n    /// Retrieves general token info for a given token\n    /// @param token The ID of the token as a solidity address\n    /// @dev This function reverts if the call is not successful\n    function getTokenInfo(address token) internal returns (int responseCode, IHederaTokenService.TokenInfo memory tokenInfo) {\n        (bool success, bytes memory result) = precompileAddress.call(",
            "codeOnlyTokens": 813,
            "startLine": 178,
            "endLine": 228,
            "type": ".sol_part_4",
            "isOversized": false
          },
          {
            "originalText": "            abi.encodeWithSelector(IHederaTokenService.getTokenInfo.selector, token));\n        IHederaTokenService.TokenInfo memory defaultTokenInfo;\n        (responseCode, tokenInfo) = success ? abi.decode(result, (int32, IHederaTokenService.TokenInfo)) : (HederaResponseCodes.UNKNOWN, defaultTokenInfo);\n    }\n\n    /// Retrieves non-fungible specific token info for a given NFT\n    /// @param token The ID of the token as a solidity address\n    /// @dev This function reverts if the call is not successful\n    function getNonFungibleTokenInfo(address token, int64 serialNumber) internal returns (int responseCode, IHederaTokenService.NonFungibleTokenInfo memory tokenInfo) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getNonFungibleTokenInfo.selector, token, serialNumber));\n        IHederaTokenService.NonFungibleTokenInfo memory defaultTokenInfo;\n        (responseCode, tokenInfo) = success ? abi.decode(result, (int32, IHederaTokenService.NonFungibleTokenInfo)) : (HederaResponseCodes.UNKNOWN, defaultTokenInfo);\n    }\n\n    /// Query token custom fees\n    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return fixedFees Set of fixed fees for `token`\n    /// @return fractionalFees Set of fractional fees for `token`\n    /// @return royaltyFees Set of royalty fees for `token`\n    /// @dev This function reverts if the call is not successful\n    function getTokenCustomFees(address token) internal returns (int64 responseCode,\n        IHederaTokenService.FixedFee[] memory fixedFees,\n        IHederaTokenService.FractionalFee[] memory fractionalFees,\n        IHederaTokenService.RoyaltyFee[] memory royaltyFees) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getTokenCustomFees.selector, token));\n        IHederaTokenService.FixedFee[] memory defaultFixedFees;\n        IHederaTokenService.FractionalFee[] memory defaultFractionalFees;\n        IHederaTokenService.RoyaltyFee[] memory defaultRoyaltyFees;\n        (responseCode, fixedFees, fractionalFees, royaltyFees) =\n        success ? abi.decode\n        (result, (int32, IHederaTokenService.FixedFee[], IHederaTokenService.FractionalFee[], IHederaTokenService.RoyaltyFee[]))\n        : (HederaResponseCodes.UNKNOWN, defaultFixedFees, defaultFractionalFees, defaultRoyaltyFees);\n    }\n\n    /// Allows spender to withdraw from your account multiple times, up to the value amount. If this function is called\n    /// again it overwrites the current allowance with value.\n    /// Only Applicable to Fungible Tokens\n    /// @param token The hedera token address to approve\n    /// @param spender the account authorized to spend\n    /// @param amount the amount of tokens authorized to spend.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function approve(address token, address spender, uint256 amount) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.approve.selector,\n            token, spender, amount));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Transfers `amount` tokens from `from` to `to` using the\n    //  allowance mechanism. `amount` is then deducted from the caller's allowance.",
            "codeOnlyTokens": 805,
            "startLine": 229,
            "endLine": 282,
            "type": ".sol_part_5",
            "isOversized": false
          },
          {
            "originalText": "    /// Only applicable to fungible tokens\n    /// @param token The address of the fungible Hedera token to transfer\n    /// @param from The account address of the owner of the token, on the behalf of which to transfer `amount` tokens\n    /// @param to The account address of the receiver of the `amount` tokens\n    /// @param amount The amount of tokens to transfer from `from` to `to`\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function transferFrom(address token, address from, address to, uint256 amount) external returns (int64 responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.transferFrom.selector,\n            token, from, to, amount));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Transfers `serialNumber` of `token` from `from` to `to` using the allowance mechanism.\n    /// Only applicable to NFT tokens\n    /// @param token The address of the non-fungible Hedera token to transfer\n    /// @param from The account address of the owner of `serialNumber` of `token`\n    /// @param to The account address of the receiver of `serialNumber`\n    /// @param serialNumber The NFT serial number to transfer\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function transferFromNFT(address token, address from, address to, uint256 serialNumber) external returns (int64 responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.transferFromNFT.selector,\n            token, from, to, serialNumber));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Returns the amount which spender is still allowed to withdraw from owner.\n    /// Only Applicable to Fungible Tokens\n    /// @param token The Hedera token address to check the allowance of\n    /// @param owner the owner of the tokens to be spent\n    /// @param spender the spender of the tokens\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function allowance(address token, address owner, address spender) internal returns (int responseCode, uint256 amount)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.allowance.selector,\n            token, owner, spender));\n        (responseCode, amount) = success ? abi.decode(result, (int32, uint256)) : (HederaResponseCodes.UNKNOWN, 0);\n    }\n\n    /// Allow or reaffirm the approved address to transfer an NFT the approved address does not own.\n    /// Only Applicable to NFT Tokens\n    /// @param token The Hedera NFT token address to approve\n    /// @param approved The new approved NFT controller.  To revoke approvals pass in the zero address.\n    /// @param serialNumber The NFT serial number  to approve\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function approveNFT(address token, address approved, uint256 serialNumber) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.approveNFT.selector,\n            token, approved, serialNumber));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Get the approved address for a single NFT\n    /// Only Applicable to NFT Tokens\n    /// @param token The Hedera NFT token address to check approval",
            "codeOnlyTokens": 813,
            "startLine": 283,
            "endLine": 342,
            "type": ".sol_part_6",
            "isOversized": false
          },
          {
            "originalText": "    /// @param serialNumber The NFT to find the approved address for\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return approved The approved address for this NFT, or the zero address if there is none\n    function getApproved(address token, uint256 serialNumber) internal returns (int responseCode, address approved)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getApproved.selector,\n            token, serialNumber));\n        (responseCode, approved) =\n        success\n        ? abi.decode(result, (int32, address))\n        : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Query if token account is frozen\n    /// @param token The token address to check\n    /// @param account The account address associated with the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return frozen True if `account` is frozen for `token`\n    /// @dev This function reverts if the call is not successful\n    function isFrozen(address token, address account) internal returns (int64 responseCode, bool frozen){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.isFrozen.selector, token, account));\n        (responseCode, frozen) = success ? abi.decode(result, (int32, bool)) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Query if token account has kyc granted\n    /// @param token The token address to check\n    /// @param account The account address associated with the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return kycGranted True if `account` has kyc granted for `token`\n    /// @dev This function reverts if the call is not successful\n    function isKyc(address token, address account) internal returns (int64 responseCode, bool kycGranted){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.isKyc.selector, token, account));\n        (responseCode, kycGranted) = success ? abi.decode(result, (int32, bool)) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Operation to freeze token account\n    /// @param token The token address\n    /// @param account The account address to be frozen\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function freezeToken(address token, address account) internal returns (int64 responseCode){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.freezeToken.selector, token, account));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to unfreeze token account\n    /// @param token The token address\n    /// @param account The account address to be unfrozen\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function unfreezeToken(address token, address account) internal returns (int64 responseCode){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.unfreezeToken.selector, token, account));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to grant kyc to token account\n    /// @param token The token address\n    /// @param account The account address to grant kyc",
            "codeOnlyTokens": 804,
            "startLine": 343,
            "endLine": 403,
            "type": ".sol_part_7",
            "isOversized": false
          },
          {
            "originalText": "    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function grantTokenKyc(address token, address account) internal returns (int64 responseCode){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.grantTokenKyc.selector, token, account));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to revoke kyc to token account\n    /// @param token The token address\n    /// @param account The account address to revoke kyc\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function revokeTokenKyc(address token, address account) internal returns (int64 responseCode){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.revokeTokenKyc.selector, token, account));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Enable or disable approval for a third party (\"operator\") to manage\n    ///  all of `msg.sender`'s assets\n    /// @param token The Hedera NFT token address to approve\n    /// @param operator Address to add to the set of authorized operators\n    /// @param approved True if the operator is approved, false to revoke approval\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function setApprovalForAll(address token, address operator, bool approved) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.setApprovalForAll.selector,\n            token, operator, approved));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Query if an address is an authorized operator for another address\n    /// Only Applicable to NFT Tokens\n    /// @param token The Hedera NFT token address to approve\n    /// @param owner The address that owns the NFTs\n    /// @param operator The address that acts on behalf of the owner\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return approved True if `operator` is an approved operator for `owner`, false otherwise\n    function isApprovedForAll(address token, address owner, address operator) internal returns (int responseCode, bool approved)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.isApprovedForAll.selector,\n            token, owner, operator));\n        (responseCode, approved) =\n        success\n        ? abi.decode(result, (int32, bool))\n        : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Query token default freeze status\n    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return defaultFreezeStatus True if `token` default freeze status is frozen.\n    /// @dev This function reverts if the call is not successful\n    function getTokenDefaultFreezeStatus(address token) internal returns (int responseCode, bool defaultFreezeStatus) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getTokenDefaultFreezeStatus.selector, token));\n        (responseCode, defaultFreezeStatus) = success ? abi.decode(result, (int32, bool)) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Query token default kyc status",
            "codeOnlyTokens": 803,
            "startLine": 404,
            "endLine": 464,
            "type": ".sol_part_8",
            "isOversized": false
          },
          {
            "originalText": "    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return defaultKycStatus True if `token` default kyc status is KycNotApplicable and false if Revoked.\n    /// @dev This function reverts if the call is not successful\n    function getTokenDefaultKycStatus(address token) internal returns (int responseCode, bool defaultKycStatus) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getTokenDefaultKycStatus.selector, token));\n        (responseCode, defaultKycStatus) = success ? abi.decode(result, (int32, bool)) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /**********************\n     * ABI v1 calls       *\n     **********************/\n\n    /// Initiates a Fungible Token Transfer\n    /// @param token The ID of the token as a solidity address\n    /// @param accountIds account to do a transfer to/from\n    /// @param amounts The amount from the accountId at the same index\n    function transferTokens(address token, address[] memory accountIds, int64[] memory amounts) internal\n    returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.transferTokens.selector,\n            token, accountIds, amounts));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Initiates a Non-Fungable Token Transfer\n    /// @param token The ID of the token as a solidity address\n    /// @param sender the sender of an nft\n    /// @param receiver the receiver of the nft sent by the same index at sender\n    /// @param serialNumber the serial number of the nft sent by the same index at sender\n    function transferNFTs(address token, address[] memory sender, address[] memory receiver, int64[] memory serialNumber)\n    internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.transferNFTs.selector,\n            token, sender, receiver, serialNumber));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Transfers tokens where the calling account/contract is implicitly the first entry in the token transfer list,\n    /// where the amount is the value needed to zero balance the transfers. Regular signing rules apply for sending\n    /// (positive amount) or receiving (negative amount)\n    /// @param token The token to transfer to/from\n    /// @param sender The sender for the transaction\n    /// @param receiver The receiver of the transaction\n    /// @param amount Non-negative value to send. a negative value will result in a failure.\n    function transferToken(address token, address sender, address receiver, int64 amount) internal\n    returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.transferToken.selector,\n            token, sender, receiver, amount));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Transfers tokens where the calling account/contract is implicitly the first entry in the token transfer list,\n    /// where the amount is the value needed to zero balance the transfers. Regular signing rules apply for sending\n    /// (positive amount) or receiving (negative amount)\n    /// @param token The token to transfer to/from\n    /// @param sender The sender for the transaction\n    /// @param receiver The receiver of the transaction\n    /// @param serialNumber The serial number of the NFT to transfer.",
            "codeOnlyTokens": 812,
            "startLine": 465,
            "endLine": 528,
            "type": ".sol_part_9",
            "isOversized": false
          },
          {
            "originalText": "    function transferNFT(address token, address sender, address receiver, int64 serialNumber) internal\n    returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.transferNFT.selector,\n            token, sender, receiver, serialNumber));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to pause token\n    /// @param token The token address to be paused\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function pauseToken(address token) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.pauseToken.selector, token));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to unpause token\n    /// @param token The token address to be unpaused\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function unpauseToken(address token) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.unpauseToken.selector, token));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to wipe fungible tokens from account\n    /// @param token The token address\n    /// @param account The account address to revoke kyc\n    /// @param amount The number of tokens to wipe\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function wipeTokenAccount(address token, address account, int64 amount) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.wipeTokenAccount.selector, token, account, amount));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to wipe non fungible tokens from account\n    /// @param token The token address\n    /// @param account The account address to revoke kyc\n    /// @param  serialNumbers The serial numbers of token to wipe\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function wipeTokenAccountNFT(address token, address account, int64[] memory serialNumbers) internal\n    returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.wipeTokenAccountNFT.selector, token, account, serialNumbers));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to delete token\n    /// @param token The token address\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function deleteToken(address token) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.deleteToken.selector, token));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to update token keys\n    /// @param token The token address\n    /// @param keys The token keys\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateTokenKeys(address token, IHederaTokenService.TokenKey[] memory keys)",
            "codeOnlyTokens": 816,
            "startLine": 529,
            "endLine": 597,
            "type": ".sol_part_10",
            "isOversized": false
          },
          {
            "originalText": "    internal returns (int64 responseCode){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.updateTokenKeys.selector, token, keys));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Query token KeyValue\n    /// @param token The token address to check\n    /// @param keyType The keyType of the desired KeyValue\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return key KeyValue info for key of type `keyType`\n    /// @dev This function reverts if the call is not successful\n    function getTokenKey(address token, uint keyType)\n    internal returns (int64 responseCode, IHederaTokenService.KeyValue memory key){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getTokenKey.selector, token, keyType));\n        IHederaTokenService.KeyValue memory defaultKeyValueInfo;\n        (responseCode, key) = success ? abi.decode(result, (int32,IHederaTokenService.KeyValue) ) : (HederaResponseCodes.UNKNOWN, defaultKeyValueInfo);\n    }\n\n\n    /// Query if valid token found for the given address\n    /// @param token The token address\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return isTokenFlag True if valid token found for the given address\n    /// @dev This function reverts if the call is not successful\n    function isToken(address token) internal returns (int64 responseCode, bool isTokenFlag) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.isToken.selector, token));\n        (responseCode, isTokenFlag) = success ? abi.decode(result, (int32, bool)) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Query to return the token type for a given address\n    /// @param token The token address\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenType the token type. 0 is FUNGIBLE_COMMON, 1 is NON_FUNGIBLE_UNIQUE, -1 is UNRECOGNIZED\n    /// @dev This function reverts if the call is not successful\n    function getTokenType(address token) internal returns (int64 responseCode, int32 tokenType) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getTokenType.selector, token));\n        (responseCode, tokenType) = success ? abi.decode(result, (int32, int32)) : (HederaResponseCodes.UNKNOWN, - 1);\n    }\n\n    /// Operation to get token expiry info\n    /// @param token The token address\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return expiryInfo The expiry info of the token\n    /// @dev This function reverts if the call is not successful\n    function getTokenExpiryInfo(address token) internal returns (int responseCode, IHederaTokenService.Expiry memory expiryInfo){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getTokenExpiryInfo.selector, token));\n        IHederaTokenService.Expiry memory defaultExpiryInfo;\n        (responseCode, expiryInfo) = success ? abi.decode(result, (int32, IHederaTokenService.Expiry)) : (HederaResponseCodes.UNKNOWN, defaultExpiryInfo);",
            "codeOnlyTokens": 808,
            "startLine": 598,
            "endLine": 650,
            "type": ".sol_part_11",
            "isOversized": false
          },
          {
            "originalText": "    }\n\n    /// Operation to update token expiry info\n    /// @param token The token address\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateTokenExpiryInfo(address token, IHederaTokenService.Expiry memory expiryInfo) internal returns (int responseCode){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.updateTokenExpiryInfo.selector, token, expiryInfo));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to update token info\n    /// @param token The token address\n    /// @param tokenInfo The hedera token info to update token with\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateTokenInfo(address token, IHederaTokenService.HederaToken memory tokenInfo) internal returns (int responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.updateTokenInfo.selector, token, tokenInfo));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Redirect for token\n    /// @param token The token address\n    /// @param encodedFunctionSelector The function selector from the ERC20 interface + the bytes input for the function called\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return response The result of the call that had been encoded and sent for execution.\n    function redirectForToken(address token, bytes memory encodedFunctionSelector) external returns (int responseCode, bytes memory response) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.redirectForToken.selector, token, encodedFunctionSelector)\n        );\n\n        emit CallResponseEvent(success, result);\n        (responseCode, response) = success ? (HederaResponseCodes.SUCCESS, result) : (HederaResponseCodes.UNKNOWN, bytes(\"\"));\n    }\n\n    /// Update the custom fees for a fungible token\n    /// @param token The token address\n    /// @param fixedFees Set of fixed fees for `token`\n    /// @param fractionalFees Set of fractional fees for `token`\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateFungibleTokenCustomFees(address token,  IHederaTokenService.FixedFee[] memory fixedFees, IHederaTokenService.FractionalFee[] memory fractionalFees) internal returns (int64 responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.updateFungibleTokenCustomFees.selector, token, fixedFees, fractionalFees));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Update the custom fees for a non-fungible token\n    /// @param token The token address\n    /// @param fixedFees Set of fixed fees for `token`\n    /// @param royaltyFees Set of royalty fees for `token`\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateNonFungibleTokenCustomFees(address token, IHederaTokenService.FixedFee[] memory fixedFees, IHederaTokenService.RoyaltyFee[] memory royaltyFees) internal returns (int64 responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.updateNonFungibleTokenCustomFees.selector, token, fixedFees, royaltyFees));",
            "codeOnlyTokens": 808,
            "startLine": 651,
            "endLine": 704,
            "type": ".sol_part_12",
            "isOversized": false
          },
          {
            "originalText": "        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// @notice Airdrop one or more tokens to one or more accounts\n    /// @param tokenTransfers Array of token transfer lists containing token addresses and recipient details\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function airdropTokens(IHederaTokenService.TokenTransferList[] memory tokenTransfers) internal returns (int64 responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.airdropTokens.selector, tokenTransfers));\n\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// @notice Cancels pending airdrops that have not yet been claimed\n    /// @param pendingAirdrops Array of pending airdrops to cancel\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function cancelAirdrops(IHederaTokenService.PendingAirdrop[] memory pendingAirdrops) internal returns (int64 responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.cancelAirdrops.selector, pendingAirdrops)\n        );\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// @notice Claims pending airdrops that were sent to the calling account\n    /// @param pendingAirdrops Array of pending airdrops to claim\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function claimAirdrops(IHederaTokenService.PendingAirdrop[] memory pendingAirdrops) internal returns (int64 responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.claimAirdrops.selector, pendingAirdrops)\n        );\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// @notice Rejects one or more tokens by transferring their full balance from the requesting account to the treasury\n    /// @param rejectingAddress The address rejecting the tokens\n    /// @param ftAddresses Array of fungible token addresses to reject\n    /// @param nftIds Array of NFT IDs to reject\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function rejectTokens(address rejectingAddress, address[] memory ftAddresses, IHederaTokenService.NftID[] memory nftIds) internal returns (int64 responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.rejectTokens.selector, rejectingAddress, ftAddresses, nftIds)\n        );\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n}\n",
            "codeOnlyTokens": 656,
            "startLine": 705,
            "endLine": 750,
            "type": ".sol_part_13",
            "isOversized": false
          }
        ],
        "groupedChunks": [
          {
            "combinedText": "// File: contracts/system-contracts/hedera-token-service/HederaTokenService.sol\n// Relevant file context:\n// Type: .sol\n\n\n// --- Next chunk ---\n\n// Lines 1-65 (.sol_part_1)\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.5.0 <0.9.0;\npragma experimental ABIEncoderV2;\n\nimport \"../HederaResponseCodes.sol\";\nimport \"./IHederaTokenService.sol\";\n\nabstract contract HederaTokenService {\n    address constant precompileAddress = address(0x167);\n    // 90 days in seconds\n    int32 constant defaultAutoRenewPeriod = 7776000;\n\n    modifier nonEmptyExpiry(IHederaTokenService.HederaToken memory token)\n    {\n        if (token.expiry.second == 0 && token.expiry.autoRenewPeriod == 0) {\n            token.expiry.autoRenewPeriod = defaultAutoRenewPeriod;\n        }\n        _;\n    }\n\n    /// Generic event\n    event CallResponseEvent(bool, bytes);\n\n    /// Performs transfers among combinations of tokens and hbars\n    /// @param transferList the list of hbar transfers to do\n    /// @param tokenTransfers the list of transfers to do\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @custom:version 0.3.0 the signature of the previous version was cryptoTransfer(TokenTransferList[] memory tokenTransfers)\n    function cryptoTransfer(IHederaTokenService.TransferList memory transferList, IHederaTokenService.TokenTransferList[] memory tokenTransfers) internal\n    returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.cryptoTransfer.selector, transferList, tokenTransfers));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Mints an amount of the token to the defined treasury account\n    /// @param token The token for which to mint tokens. If token does not exist, transaction results in\n    ///              INVALID_TOKEN_ID\n    /// @param amount Applicable to tokens of type FUNGIBLE_COMMON. The amount to mint to the Treasury Account.\n    ///               Amount must be a positive non-zero number represented in the lowest denomination of the\n    ///               token. The new supply must be lower than 2^63.\n    /// @param metadata Applicable to tokens of type NON_FUNGIBLE_UNIQUE. A list of metadata that are being created.\n    ///                 Maximum allowed size of each metadata is 100 bytes\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return newTotalSupply The new supply of tokens. For NFTs it is the total count of NFTs\n    /// @return serialNumbers If the token is an NFT the newly generate serial numbers, otherwise empty.\n    function mintToken(address token, int64 amount, bytes[] memory metadata) internal\n    returns (int responseCode, int64 newTotalSupply, int64[] memory serialNumbers)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.mintToken.selector,\n            token, amount, metadata));\n        (responseCode, newTotalSupply, serialNumbers) =\n        success\n        ? abi.decode(result, (int32, int64, int64[]))\n        : (HederaResponseCodes.UNKNOWN, int64(0), new int64[](0));\n    }\n\n    /// Burns an amount of the token from the defined treasury account\n    /// @param token The token for which to burn tokens. If token does not exist, transaction results in\n    ///              INVALID_TOKEN_ID\n    /// @param amount  Applicable to tokens of type FUNGIBLE_COMMON. The amount to burn from the Treasury Account.\n    ///                Amount must be a positive non-zero number, not bigger than the token balance of the treasury\n    ///                account (0; balance], represented in the lowest denomination.\n\n// --- Next chunk ---\n\n// Lines 66-119 (.sol_part_2)\n    /// @param serialNumbers Applicable to tokens of type NON_FUNGIBLE_UNIQUE. The list of serial numbers to be burned.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return newTotalSupply The new supply of tokens. For NFTs it is the total count of NFTs\n    function burnToken(address token, int64 amount, int64[] memory serialNumbers) internal\n    returns (int responseCode, int64 newTotalSupply)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.burnToken.selector,\n            token, amount, serialNumbers));\n        (responseCode, newTotalSupply) =\n        success\n        ? abi.decode(result, (int32, int64))\n        : (HederaResponseCodes.UNKNOWN, int64(0));\n    }\n\n    ///  Associates the provided account with the provided tokens. Must be signed by the provided\n    ///  Account's key or called from the accounts contract key\n    ///  If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.\n    ///  If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.\n    ///  If any of the provided tokens is not found, the transaction will resolve to INVALID_TOKEN_REF.\n    ///  If any of the provided tokens has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.\n    ///  If an association between the provided account and any of the tokens already exists, the\n    ///  transaction will resolve to TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT.\n    ///  If the provided account's associations count exceed the constraint of maximum token associations\n    ///    per account, the transaction will resolve to TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED.\n    ///  On success, associations between the provided account and tokens are made and the account is\n    ///    ready to interact with the tokens.\n    /// @param account The account to be associated with the provided tokens\n    /// @param tokens The tokens to be associated with the provided account. In the case of NON_FUNGIBLE_UNIQUE\n    ///               Type, once an account is associated, it can hold any number of NFTs (serial numbers) of that\n    ///               token type\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function associateTokens(address account, address[] memory tokens) internal returns (int responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.associateTokens.selector,\n            account, tokens));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    function associateToken(address account, address token) internal returns (int responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.associateToken.selector,\n            account, token));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Dissociates the provided account with the provided tokens. Must be signed by the provided\n    /// Account's key.\n    /// If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.\n    /// If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.\n    /// If any of the provided tokens is not found, the transaction will resolve to INVALID_TOKEN_REF.\n    /// If any of the provided tokens has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.\n    /// If an association between the provided account and any of the tokens does not exist, the\n    /// transaction will resolve to TOKEN_NOT_ASSOCIATED_TO_ACCOUNT.\n\n// --- Next chunk ---\n\n// Lines 120-177 (.sol_part_3)\n    /// If a token has not been deleted and has not expired, and the user has a nonzero balance, the\n    /// transaction will resolve to TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES.\n    /// If a <b>fungible token</b> has expired, the user can disassociate even if their token balance is\n    /// not zero.\n    /// If a <b>non fungible token</b> has expired, the user can <b>not</b> disassociate if their token\n    /// balance is not zero. The transaction will resolve to TRANSACTION_REQUIRED_ZERO_TOKEN_BALANCES.\n    /// On success, associations between the provided account and tokens are removed.\n    /// @param account The account to be dissociated from the provided tokens\n    /// @param tokens The tokens to be dissociated from the provided account.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function dissociateTokens(address account, address[] memory tokens) internal returns (int responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.dissociateTokens.selector,\n            account, tokens));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    function dissociateToken(address account, address token) internal returns (int responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.dissociateToken.selector,\n            account, token));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Creates a Fungible Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @param initialTotalSupply Specifies the initial supply of tokens to be put in circulation. The\n    /// initial supply is sent to the Treasury Account. The supply is in the lowest denomination possible.\n    /// @param decimals the number of decimal places a token is divisible by\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createFungibleToken(\n        IHederaTokenService.HederaToken memory token,\n        int64 initialTotalSupply,\n        int32 decimals) nonEmptyExpiry(token)\n    internal returns (int responseCode, address tokenAddress) {\n        (bool success, bytes memory result) = precompileAddress.call{value : msg.value}(\n            abi.encodeWithSelector(IHederaTokenService.createFungibleToken.selector,\n            token, initialTotalSupply, decimals));\n\n\n        (responseCode, tokenAddress) = success ? abi.decode(result, (int32, address)) : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Creates a Fungible Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @param initialTotalSupply Specifies the initial supply of tokens to be put in circulation. The\n    /// initial supply is sent to the Treasury Account. The supply is in the lowest denomination possible.\n    /// @param decimals the number of decimal places a token is divisible by\n    /// @param fixedFees list of fixed fees to apply to the token\n    /// @param fractionalFees list of fractional fees to apply to the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createFungibleTokenWithCustomFees(\n        IHederaTokenService.HederaToken memory token,\n        int64 initialTotalSupply,\n        int32 decimals,\n        IHederaTokenService.FixedFee[] memory fixedFees,",
            "totalTokens": 2491,
            "chunks": [
              {
                "originalText": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.5.0 <0.9.0;\npragma experimental ABIEncoderV2;\n\nimport \"../HederaResponseCodes.sol\";\nimport \"./IHederaTokenService.sol\";\n\nabstract contract HederaTokenService {\n    address constant precompileAddress = address(0x167);\n    // 90 days in seconds\n    int32 constant defaultAutoRenewPeriod = 7776000;\n\n    modifier nonEmptyExpiry(IHederaTokenService.HederaToken memory token)\n    {\n        if (token.expiry.second == 0 && token.expiry.autoRenewPeriod == 0) {\n            token.expiry.autoRenewPeriod = defaultAutoRenewPeriod;\n        }\n        _;\n    }\n\n    /// Generic event\n    event CallResponseEvent(bool, bytes);\n\n    /// Performs transfers among combinations of tokens and hbars\n    /// @param transferList the list of hbar transfers to do\n    /// @param tokenTransfers the list of transfers to do\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @custom:version 0.3.0 the signature of the previous version was cryptoTransfer(TokenTransferList[] memory tokenTransfers)\n    function cryptoTransfer(IHederaTokenService.TransferList memory transferList, IHederaTokenService.TokenTransferList[] memory tokenTransfers) internal\n    returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.cryptoTransfer.selector, transferList, tokenTransfers));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Mints an amount of the token to the defined treasury account\n    /// @param token The token for which to mint tokens. If token does not exist, transaction results in\n    ///              INVALID_TOKEN_ID\n    /// @param amount Applicable to tokens of type FUNGIBLE_COMMON. The amount to mint to the Treasury Account.\n    ///               Amount must be a positive non-zero number represented in the lowest denomination of the\n    ///               token. The new supply must be lower than 2^63.\n    /// @param metadata Applicable to tokens of type NON_FUNGIBLE_UNIQUE. A list of metadata that are being created.\n    ///                 Maximum allowed size of each metadata is 100 bytes\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return newTotalSupply The new supply of tokens. For NFTs it is the total count of NFTs\n    /// @return serialNumbers If the token is an NFT the newly generate serial numbers, otherwise empty.\n    function mintToken(address token, int64 amount, bytes[] memory metadata) internal\n    returns (int responseCode, int64 newTotalSupply, int64[] memory serialNumbers)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.mintToken.selector,\n            token, amount, metadata));\n        (responseCode, newTotalSupply, serialNumbers) =\n        success\n        ? abi.decode(result, (int32, int64, int64[]))\n        : (HederaResponseCodes.UNKNOWN, int64(0), new int64[](0));\n    }\n\n    /// Burns an amount of the token from the defined treasury account\n    /// @param token The token for which to burn tokens. If token does not exist, transaction results in\n    ///              INVALID_TOKEN_ID\n    /// @param amount  Applicable to tokens of type FUNGIBLE_COMMON. The amount to burn from the Treasury Account.\n    ///                Amount must be a positive non-zero number, not bigger than the token balance of the treasury\n    ///                account (0; balance], represented in the lowest denomination.",
                "codeOnlyTokens": 807,
                "startLine": 1,
                "endLine": 65,
                "type": ".sol_part_1",
                "isOversized": false
              },
              {
                "originalText": "    /// @param serialNumbers Applicable to tokens of type NON_FUNGIBLE_UNIQUE. The list of serial numbers to be burned.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return newTotalSupply The new supply of tokens. For NFTs it is the total count of NFTs\n    function burnToken(address token, int64 amount, int64[] memory serialNumbers) internal\n    returns (int responseCode, int64 newTotalSupply)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.burnToken.selector,\n            token, amount, serialNumbers));\n        (responseCode, newTotalSupply) =\n        success\n        ? abi.decode(result, (int32, int64))\n        : (HederaResponseCodes.UNKNOWN, int64(0));\n    }\n\n    ///  Associates the provided account with the provided tokens. Must be signed by the provided\n    ///  Account's key or called from the accounts contract key\n    ///  If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.\n    ///  If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.\n    ///  If any of the provided tokens is not found, the transaction will resolve to INVALID_TOKEN_REF.\n    ///  If any of the provided tokens has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.\n    ///  If an association between the provided account and any of the tokens already exists, the\n    ///  transaction will resolve to TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT.\n    ///  If the provided account's associations count exceed the constraint of maximum token associations\n    ///    per account, the transaction will resolve to TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED.\n    ///  On success, associations between the provided account and tokens are made and the account is\n    ///    ready to interact with the tokens.\n    /// @param account The account to be associated with the provided tokens\n    /// @param tokens The tokens to be associated with the provided account. In the case of NON_FUNGIBLE_UNIQUE\n    ///               Type, once an account is associated, it can hold any number of NFTs (serial numbers) of that\n    ///               token type\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function associateTokens(address account, address[] memory tokens) internal returns (int responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.associateTokens.selector,\n            account, tokens));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    function associateToken(address account, address token) internal returns (int responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.associateToken.selector,\n            account, token));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Dissociates the provided account with the provided tokens. Must be signed by the provided\n    /// Account's key.\n    /// If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.\n    /// If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.\n    /// If any of the provided tokens is not found, the transaction will resolve to INVALID_TOKEN_REF.\n    /// If any of the provided tokens has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.\n    /// If an association between the provided account and any of the tokens does not exist, the\n    /// transaction will resolve to TOKEN_NOT_ASSOCIATED_TO_ACCOUNT.",
                "codeOnlyTokens": 801,
                "startLine": 66,
                "endLine": 119,
                "type": ".sol_part_2",
                "isOversized": false
              },
              {
                "originalText": "    /// If a token has not been deleted and has not expired, and the user has a nonzero balance, the\n    /// transaction will resolve to TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES.\n    /// If a <b>fungible token</b> has expired, the user can disassociate even if their token balance is\n    /// not zero.\n    /// If a <b>non fungible token</b> has expired, the user can <b>not</b> disassociate if their token\n    /// balance is not zero. The transaction will resolve to TRANSACTION_REQUIRED_ZERO_TOKEN_BALANCES.\n    /// On success, associations between the provided account and tokens are removed.\n    /// @param account The account to be dissociated from the provided tokens\n    /// @param tokens The tokens to be dissociated from the provided account.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function dissociateTokens(address account, address[] memory tokens) internal returns (int responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.dissociateTokens.selector,\n            account, tokens));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    function dissociateToken(address account, address token) internal returns (int responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.dissociateToken.selector,\n            account, token));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Creates a Fungible Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @param initialTotalSupply Specifies the initial supply of tokens to be put in circulation. The\n    /// initial supply is sent to the Treasury Account. The supply is in the lowest denomination possible.\n    /// @param decimals the number of decimal places a token is divisible by\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createFungibleToken(\n        IHederaTokenService.HederaToken memory token,\n        int64 initialTotalSupply,\n        int32 decimals) nonEmptyExpiry(token)\n    internal returns (int responseCode, address tokenAddress) {\n        (bool success, bytes memory result) = precompileAddress.call{value : msg.value}(\n            abi.encodeWithSelector(IHederaTokenService.createFungibleToken.selector,\n            token, initialTotalSupply, decimals));\n\n\n        (responseCode, tokenAddress) = success ? abi.decode(result, (int32, address)) : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Creates a Fungible Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @param initialTotalSupply Specifies the initial supply of tokens to be put in circulation. The\n    /// initial supply is sent to the Treasury Account. The supply is in the lowest denomination possible.\n    /// @param decimals the number of decimal places a token is divisible by\n    /// @param fixedFees list of fixed fees to apply to the token\n    /// @param fractionalFees list of fractional fees to apply to the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createFungibleTokenWithCustomFees(\n        IHederaTokenService.HederaToken memory token,\n        int64 initialTotalSupply,\n        int32 decimals,\n        IHederaTokenService.FixedFee[] memory fixedFees,",
                "codeOnlyTokens": 803,
                "startLine": 120,
                "endLine": 177,
                "type": ".sol_part_3",
                "isOversized": false
              }
            ],
            "startLine": 1,
            "endLine": 177,
            "groupId": 1
          },
          {
            "combinedText": "// File: contracts/system-contracts/hedera-token-service/HederaTokenService.sol\n// Relevant file context:\n// Type: .sol\n\n\n// --- Next chunk ---\n\n// Lines 178-228 (.sol_part_4)\n        IHederaTokenService.FractionalFee[] memory fractionalFees) nonEmptyExpiry(token)\n    internal returns (int responseCode, address tokenAddress) {\n        (bool success, bytes memory result) = precompileAddress.call{value : msg.value}(\n            abi.encodeWithSelector(IHederaTokenService.createFungibleTokenWithCustomFees.selector,\n            token, initialTotalSupply, decimals, fixedFees, fractionalFees));\n        (responseCode, tokenAddress) = success ? abi.decode(result, (int32, address)) : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Creates an Non Fungible Unique Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createNonFungibleToken(IHederaTokenService.HederaToken memory token) nonEmptyExpiry(token)\n    internal returns (int responseCode, address tokenAddress) {\n        (bool success, bytes memory result) = precompileAddress.call{value : msg.value}(\n            abi.encodeWithSelector(IHederaTokenService.createNonFungibleToken.selector, token));\n        (responseCode, tokenAddress) = success ? abi.decode(result, (int32, address)) : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Creates an Non Fungible Unique Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @param fixedFees list of fixed fees to apply to the token\n    /// @param royaltyFees list of royalty fees to apply to the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createNonFungibleTokenWithCustomFees(\n        IHederaTokenService.HederaToken memory token,\n        IHederaTokenService.FixedFee[] memory fixedFees,\n        IHederaTokenService.RoyaltyFee[] memory royaltyFees) nonEmptyExpiry(token)\n    internal returns (int responseCode, address tokenAddress) {\n        (bool success, bytes memory result) = precompileAddress.call{value : msg.value}(\n            abi.encodeWithSelector(IHederaTokenService.createNonFungibleTokenWithCustomFees.selector,\n            token, fixedFees, royaltyFees));\n        (responseCode, tokenAddress) = success ? abi.decode(result, (int32, address)) : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Retrieves fungible specific token info for a fungible token\n    /// @param token The ID of the token as a solidity address\n    /// @dev This function reverts if the call is not successful\n    function getFungibleTokenInfo(address token) internal returns (int responseCode, IHederaTokenService.FungibleTokenInfo memory tokenInfo) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getFungibleTokenInfo.selector, token));\n        IHederaTokenService.FungibleTokenInfo memory defaultTokenInfo;\n        (responseCode, tokenInfo) = success ? abi.decode(result, (int32, IHederaTokenService.FungibleTokenInfo)) : (HederaResponseCodes.UNKNOWN, defaultTokenInfo);\n    }\n\n    /// Retrieves general token info for a given token\n    /// @param token The ID of the token as a solidity address\n    /// @dev This function reverts if the call is not successful\n    function getTokenInfo(address token) internal returns (int responseCode, IHederaTokenService.TokenInfo memory tokenInfo) {\n        (bool success, bytes memory result) = precompileAddress.call(\n\n// --- Next chunk ---\n\n// Lines 229-282 (.sol_part_5)\n            abi.encodeWithSelector(IHederaTokenService.getTokenInfo.selector, token));\n        IHederaTokenService.TokenInfo memory defaultTokenInfo;\n        (responseCode, tokenInfo) = success ? abi.decode(result, (int32, IHederaTokenService.TokenInfo)) : (HederaResponseCodes.UNKNOWN, defaultTokenInfo);\n    }\n\n    /// Retrieves non-fungible specific token info for a given NFT\n    /// @param token The ID of the token as a solidity address\n    /// @dev This function reverts if the call is not successful\n    function getNonFungibleTokenInfo(address token, int64 serialNumber) internal returns (int responseCode, IHederaTokenService.NonFungibleTokenInfo memory tokenInfo) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getNonFungibleTokenInfo.selector, token, serialNumber));\n        IHederaTokenService.NonFungibleTokenInfo memory defaultTokenInfo;\n        (responseCode, tokenInfo) = success ? abi.decode(result, (int32, IHederaTokenService.NonFungibleTokenInfo)) : (HederaResponseCodes.UNKNOWN, defaultTokenInfo);\n    }\n\n    /// Query token custom fees\n    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return fixedFees Set of fixed fees for `token`\n    /// @return fractionalFees Set of fractional fees for `token`\n    /// @return royaltyFees Set of royalty fees for `token`\n    /// @dev This function reverts if the call is not successful\n    function getTokenCustomFees(address token) internal returns (int64 responseCode,\n        IHederaTokenService.FixedFee[] memory fixedFees,\n        IHederaTokenService.FractionalFee[] memory fractionalFees,\n        IHederaTokenService.RoyaltyFee[] memory royaltyFees) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getTokenCustomFees.selector, token));\n        IHederaTokenService.FixedFee[] memory defaultFixedFees;\n        IHederaTokenService.FractionalFee[] memory defaultFractionalFees;\n        IHederaTokenService.RoyaltyFee[] memory defaultRoyaltyFees;\n        (responseCode, fixedFees, fractionalFees, royaltyFees) =\n        success ? abi.decode\n        (result, (int32, IHederaTokenService.FixedFee[], IHederaTokenService.FractionalFee[], IHederaTokenService.RoyaltyFee[]))\n        : (HederaResponseCodes.UNKNOWN, defaultFixedFees, defaultFractionalFees, defaultRoyaltyFees);\n    }\n\n    /// Allows spender to withdraw from your account multiple times, up to the value amount. If this function is called\n    /// again it overwrites the current allowance with value.\n    /// Only Applicable to Fungible Tokens\n    /// @param token The hedera token address to approve\n    /// @param spender the account authorized to spend\n    /// @param amount the amount of tokens authorized to spend.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function approve(address token, address spender, uint256 amount) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.approve.selector,\n            token, spender, amount));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Transfers `amount` tokens from `from` to `to` using the\n    //  allowance mechanism. `amount` is then deducted from the caller's allowance.\n\n// --- Next chunk ---\n\n// Lines 283-342 (.sol_part_6)\n    /// Only applicable to fungible tokens\n    /// @param token The address of the fungible Hedera token to transfer\n    /// @param from The account address of the owner of the token, on the behalf of which to transfer `amount` tokens\n    /// @param to The account address of the receiver of the `amount` tokens\n    /// @param amount The amount of tokens to transfer from `from` to `to`\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function transferFrom(address token, address from, address to, uint256 amount) external returns (int64 responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.transferFrom.selector,\n            token, from, to, amount));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Transfers `serialNumber` of `token` from `from` to `to` using the allowance mechanism.\n    /// Only applicable to NFT tokens\n    /// @param token The address of the non-fungible Hedera token to transfer\n    /// @param from The account address of the owner of `serialNumber` of `token`\n    /// @param to The account address of the receiver of `serialNumber`\n    /// @param serialNumber The NFT serial number to transfer\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function transferFromNFT(address token, address from, address to, uint256 serialNumber) external returns (int64 responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.transferFromNFT.selector,\n            token, from, to, serialNumber));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Returns the amount which spender is still allowed to withdraw from owner.\n    /// Only Applicable to Fungible Tokens\n    /// @param token The Hedera token address to check the allowance of\n    /// @param owner the owner of the tokens to be spent\n    /// @param spender the spender of the tokens\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function allowance(address token, address owner, address spender) internal returns (int responseCode, uint256 amount)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.allowance.selector,\n            token, owner, spender));\n        (responseCode, amount) = success ? abi.decode(result, (int32, uint256)) : (HederaResponseCodes.UNKNOWN, 0);\n    }\n\n    /// Allow or reaffirm the approved address to transfer an NFT the approved address does not own.\n    /// Only Applicable to NFT Tokens\n    /// @param token The Hedera NFT token address to approve\n    /// @param approved The new approved NFT controller.  To revoke approvals pass in the zero address.\n    /// @param serialNumber The NFT serial number  to approve\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function approveNFT(address token, address approved, uint256 serialNumber) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.approveNFT.selector,\n            token, approved, serialNumber));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Get the approved address for a single NFT\n    /// Only Applicable to NFT Tokens\n    /// @param token The Hedera NFT token address to check approval",
            "totalTokens": 2513,
            "chunks": [
              {
                "originalText": "        IHederaTokenService.FractionalFee[] memory fractionalFees) nonEmptyExpiry(token)\n    internal returns (int responseCode, address tokenAddress) {\n        (bool success, bytes memory result) = precompileAddress.call{value : msg.value}(\n            abi.encodeWithSelector(IHederaTokenService.createFungibleTokenWithCustomFees.selector,\n            token, initialTotalSupply, decimals, fixedFees, fractionalFees));\n        (responseCode, tokenAddress) = success ? abi.decode(result, (int32, address)) : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Creates an Non Fungible Unique Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createNonFungibleToken(IHederaTokenService.HederaToken memory token) nonEmptyExpiry(token)\n    internal returns (int responseCode, address tokenAddress) {\n        (bool success, bytes memory result) = precompileAddress.call{value : msg.value}(\n            abi.encodeWithSelector(IHederaTokenService.createNonFungibleToken.selector, token));\n        (responseCode, tokenAddress) = success ? abi.decode(result, (int32, address)) : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Creates an Non Fungible Unique Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @param fixedFees list of fixed fees to apply to the token\n    /// @param royaltyFees list of royalty fees to apply to the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createNonFungibleTokenWithCustomFees(\n        IHederaTokenService.HederaToken memory token,\n        IHederaTokenService.FixedFee[] memory fixedFees,\n        IHederaTokenService.RoyaltyFee[] memory royaltyFees) nonEmptyExpiry(token)\n    internal returns (int responseCode, address tokenAddress) {\n        (bool success, bytes memory result) = precompileAddress.call{value : msg.value}(\n            abi.encodeWithSelector(IHederaTokenService.createNonFungibleTokenWithCustomFees.selector,\n            token, fixedFees, royaltyFees));\n        (responseCode, tokenAddress) = success ? abi.decode(result, (int32, address)) : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Retrieves fungible specific token info for a fungible token\n    /// @param token The ID of the token as a solidity address\n    /// @dev This function reverts if the call is not successful\n    function getFungibleTokenInfo(address token) internal returns (int responseCode, IHederaTokenService.FungibleTokenInfo memory tokenInfo) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getFungibleTokenInfo.selector, token));\n        IHederaTokenService.FungibleTokenInfo memory defaultTokenInfo;\n        (responseCode, tokenInfo) = success ? abi.decode(result, (int32, IHederaTokenService.FungibleTokenInfo)) : (HederaResponseCodes.UNKNOWN, defaultTokenInfo);\n    }\n\n    /// Retrieves general token info for a given token\n    /// @param token The ID of the token as a solidity address\n    /// @dev This function reverts if the call is not successful\n    function getTokenInfo(address token) internal returns (int responseCode, IHederaTokenService.TokenInfo memory tokenInfo) {\n        (bool success, bytes memory result) = precompileAddress.call(",
                "codeOnlyTokens": 813,
                "startLine": 178,
                "endLine": 228,
                "type": ".sol_part_4",
                "isOversized": false
              },
              {
                "originalText": "            abi.encodeWithSelector(IHederaTokenService.getTokenInfo.selector, token));\n        IHederaTokenService.TokenInfo memory defaultTokenInfo;\n        (responseCode, tokenInfo) = success ? abi.decode(result, (int32, IHederaTokenService.TokenInfo)) : (HederaResponseCodes.UNKNOWN, defaultTokenInfo);\n    }\n\n    /// Retrieves non-fungible specific token info for a given NFT\n    /// @param token The ID of the token as a solidity address\n    /// @dev This function reverts if the call is not successful\n    function getNonFungibleTokenInfo(address token, int64 serialNumber) internal returns (int responseCode, IHederaTokenService.NonFungibleTokenInfo memory tokenInfo) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getNonFungibleTokenInfo.selector, token, serialNumber));\n        IHederaTokenService.NonFungibleTokenInfo memory defaultTokenInfo;\n        (responseCode, tokenInfo) = success ? abi.decode(result, (int32, IHederaTokenService.NonFungibleTokenInfo)) : (HederaResponseCodes.UNKNOWN, defaultTokenInfo);\n    }\n\n    /// Query token custom fees\n    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return fixedFees Set of fixed fees for `token`\n    /// @return fractionalFees Set of fractional fees for `token`\n    /// @return royaltyFees Set of royalty fees for `token`\n    /// @dev This function reverts if the call is not successful\n    function getTokenCustomFees(address token) internal returns (int64 responseCode,\n        IHederaTokenService.FixedFee[] memory fixedFees,\n        IHederaTokenService.FractionalFee[] memory fractionalFees,\n        IHederaTokenService.RoyaltyFee[] memory royaltyFees) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getTokenCustomFees.selector, token));\n        IHederaTokenService.FixedFee[] memory defaultFixedFees;\n        IHederaTokenService.FractionalFee[] memory defaultFractionalFees;\n        IHederaTokenService.RoyaltyFee[] memory defaultRoyaltyFees;\n        (responseCode, fixedFees, fractionalFees, royaltyFees) =\n        success ? abi.decode\n        (result, (int32, IHederaTokenService.FixedFee[], IHederaTokenService.FractionalFee[], IHederaTokenService.RoyaltyFee[]))\n        : (HederaResponseCodes.UNKNOWN, defaultFixedFees, defaultFractionalFees, defaultRoyaltyFees);\n    }\n\n    /// Allows spender to withdraw from your account multiple times, up to the value amount. If this function is called\n    /// again it overwrites the current allowance with value.\n    /// Only Applicable to Fungible Tokens\n    /// @param token The hedera token address to approve\n    /// @param spender the account authorized to spend\n    /// @param amount the amount of tokens authorized to spend.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function approve(address token, address spender, uint256 amount) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.approve.selector,\n            token, spender, amount));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Transfers `amount` tokens from `from` to `to` using the\n    //  allowance mechanism. `amount` is then deducted from the caller's allowance.",
                "codeOnlyTokens": 805,
                "startLine": 229,
                "endLine": 282,
                "type": ".sol_part_5",
                "isOversized": false
              },
              {
                "originalText": "    /// Only applicable to fungible tokens\n    /// @param token The address of the fungible Hedera token to transfer\n    /// @param from The account address of the owner of the token, on the behalf of which to transfer `amount` tokens\n    /// @param to The account address of the receiver of the `amount` tokens\n    /// @param amount The amount of tokens to transfer from `from` to `to`\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function transferFrom(address token, address from, address to, uint256 amount) external returns (int64 responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.transferFrom.selector,\n            token, from, to, amount));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Transfers `serialNumber` of `token` from `from` to `to` using the allowance mechanism.\n    /// Only applicable to NFT tokens\n    /// @param token The address of the non-fungible Hedera token to transfer\n    /// @param from The account address of the owner of `serialNumber` of `token`\n    /// @param to The account address of the receiver of `serialNumber`\n    /// @param serialNumber The NFT serial number to transfer\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function transferFromNFT(address token, address from, address to, uint256 serialNumber) external returns (int64 responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.transferFromNFT.selector,\n            token, from, to, serialNumber));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Returns the amount which spender is still allowed to withdraw from owner.\n    /// Only Applicable to Fungible Tokens\n    /// @param token The Hedera token address to check the allowance of\n    /// @param owner the owner of the tokens to be spent\n    /// @param spender the spender of the tokens\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function allowance(address token, address owner, address spender) internal returns (int responseCode, uint256 amount)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.allowance.selector,\n            token, owner, spender));\n        (responseCode, amount) = success ? abi.decode(result, (int32, uint256)) : (HederaResponseCodes.UNKNOWN, 0);\n    }\n\n    /// Allow or reaffirm the approved address to transfer an NFT the approved address does not own.\n    /// Only Applicable to NFT Tokens\n    /// @param token The Hedera NFT token address to approve\n    /// @param approved The new approved NFT controller.  To revoke approvals pass in the zero address.\n    /// @param serialNumber The NFT serial number  to approve\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function approveNFT(address token, address approved, uint256 serialNumber) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.approveNFT.selector,\n            token, approved, serialNumber));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Get the approved address for a single NFT\n    /// Only Applicable to NFT Tokens\n    /// @param token The Hedera NFT token address to check approval",
                "codeOnlyTokens": 813,
                "startLine": 283,
                "endLine": 342,
                "type": ".sol_part_6",
                "isOversized": false
              }
            ],
            "startLine": 178,
            "endLine": 342,
            "groupId": 2
          },
          {
            "combinedText": "// File: contracts/system-contracts/hedera-token-service/HederaTokenService.sol\n// Relevant file context:\n// Type: .sol\n\n\n// --- Next chunk ---\n\n// Lines 343-403 (.sol_part_7)\n    /// @param serialNumber The NFT to find the approved address for\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return approved The approved address for this NFT, or the zero address if there is none\n    function getApproved(address token, uint256 serialNumber) internal returns (int responseCode, address approved)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getApproved.selector,\n            token, serialNumber));\n        (responseCode, approved) =\n        success\n        ? abi.decode(result, (int32, address))\n        : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Query if token account is frozen\n    /// @param token The token address to check\n    /// @param account The account address associated with the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return frozen True if `account` is frozen for `token`\n    /// @dev This function reverts if the call is not successful\n    function isFrozen(address token, address account) internal returns (int64 responseCode, bool frozen){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.isFrozen.selector, token, account));\n        (responseCode, frozen) = success ? abi.decode(result, (int32, bool)) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Query if token account has kyc granted\n    /// @param token The token address to check\n    /// @param account The account address associated with the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return kycGranted True if `account` has kyc granted for `token`\n    /// @dev This function reverts if the call is not successful\n    function isKyc(address token, address account) internal returns (int64 responseCode, bool kycGranted){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.isKyc.selector, token, account));\n        (responseCode, kycGranted) = success ? abi.decode(result, (int32, bool)) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Operation to freeze token account\n    /// @param token The token address\n    /// @param account The account address to be frozen\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function freezeToken(address token, address account) internal returns (int64 responseCode){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.freezeToken.selector, token, account));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to unfreeze token account\n    /// @param token The token address\n    /// @param account The account address to be unfrozen\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function unfreezeToken(address token, address account) internal returns (int64 responseCode){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.unfreezeToken.selector, token, account));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to grant kyc to token account\n    /// @param token The token address\n    /// @param account The account address to grant kyc\n\n// --- Next chunk ---\n\n// Lines 404-464 (.sol_part_8)\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function grantTokenKyc(address token, address account) internal returns (int64 responseCode){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.grantTokenKyc.selector, token, account));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to revoke kyc to token account\n    /// @param token The token address\n    /// @param account The account address to revoke kyc\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function revokeTokenKyc(address token, address account) internal returns (int64 responseCode){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.revokeTokenKyc.selector, token, account));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Enable or disable approval for a third party (\"operator\") to manage\n    ///  all of `msg.sender`'s assets\n    /// @param token The Hedera NFT token address to approve\n    /// @param operator Address to add to the set of authorized operators\n    /// @param approved True if the operator is approved, false to revoke approval\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function setApprovalForAll(address token, address operator, bool approved) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.setApprovalForAll.selector,\n            token, operator, approved));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Query if an address is an authorized operator for another address\n    /// Only Applicable to NFT Tokens\n    /// @param token The Hedera NFT token address to approve\n    /// @param owner The address that owns the NFTs\n    /// @param operator The address that acts on behalf of the owner\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return approved True if `operator` is an approved operator for `owner`, false otherwise\n    function isApprovedForAll(address token, address owner, address operator) internal returns (int responseCode, bool approved)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.isApprovedForAll.selector,\n            token, owner, operator));\n        (responseCode, approved) =\n        success\n        ? abi.decode(result, (int32, bool))\n        : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Query token default freeze status\n    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return defaultFreezeStatus True if `token` default freeze status is frozen.\n    /// @dev This function reverts if the call is not successful\n    function getTokenDefaultFreezeStatus(address token) internal returns (int responseCode, bool defaultFreezeStatus) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getTokenDefaultFreezeStatus.selector, token));\n        (responseCode, defaultFreezeStatus) = success ? abi.decode(result, (int32, bool)) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Query token default kyc status\n\n// --- Next chunk ---\n\n// Lines 465-528 (.sol_part_9)\n    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return defaultKycStatus True if `token` default kyc status is KycNotApplicable and false if Revoked.\n    /// @dev This function reverts if the call is not successful\n    function getTokenDefaultKycStatus(address token) internal returns (int responseCode, bool defaultKycStatus) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getTokenDefaultKycStatus.selector, token));\n        (responseCode, defaultKycStatus) = success ? abi.decode(result, (int32, bool)) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /**********************\n     * ABI v1 calls       *\n     **********************/\n\n    /// Initiates a Fungible Token Transfer\n    /// @param token The ID of the token as a solidity address\n    /// @param accountIds account to do a transfer to/from\n    /// @param amounts The amount from the accountId at the same index\n    function transferTokens(address token, address[] memory accountIds, int64[] memory amounts) internal\n    returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.transferTokens.selector,\n            token, accountIds, amounts));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Initiates a Non-Fungable Token Transfer\n    /// @param token The ID of the token as a solidity address\n    /// @param sender the sender of an nft\n    /// @param receiver the receiver of the nft sent by the same index at sender\n    /// @param serialNumber the serial number of the nft sent by the same index at sender\n    function transferNFTs(address token, address[] memory sender, address[] memory receiver, int64[] memory serialNumber)\n    internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.transferNFTs.selector,\n            token, sender, receiver, serialNumber));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Transfers tokens where the calling account/contract is implicitly the first entry in the token transfer list,\n    /// where the amount is the value needed to zero balance the transfers. Regular signing rules apply for sending\n    /// (positive amount) or receiving (negative amount)\n    /// @param token The token to transfer to/from\n    /// @param sender The sender for the transaction\n    /// @param receiver The receiver of the transaction\n    /// @param amount Non-negative value to send. a negative value will result in a failure.\n    function transferToken(address token, address sender, address receiver, int64 amount) internal\n    returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.transferToken.selector,\n            token, sender, receiver, amount));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Transfers tokens where the calling account/contract is implicitly the first entry in the token transfer list,\n    /// where the amount is the value needed to zero balance the transfers. Regular signing rules apply for sending\n    /// (positive amount) or receiving (negative amount)\n    /// @param token The token to transfer to/from\n    /// @param sender The sender for the transaction\n    /// @param receiver The receiver of the transaction\n    /// @param serialNumber The serial number of the NFT to transfer.",
            "totalTokens": 2504,
            "chunks": [
              {
                "originalText": "    /// @param serialNumber The NFT to find the approved address for\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return approved The approved address for this NFT, or the zero address if there is none\n    function getApproved(address token, uint256 serialNumber) internal returns (int responseCode, address approved)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getApproved.selector,\n            token, serialNumber));\n        (responseCode, approved) =\n        success\n        ? abi.decode(result, (int32, address))\n        : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Query if token account is frozen\n    /// @param token The token address to check\n    /// @param account The account address associated with the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return frozen True if `account` is frozen for `token`\n    /// @dev This function reverts if the call is not successful\n    function isFrozen(address token, address account) internal returns (int64 responseCode, bool frozen){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.isFrozen.selector, token, account));\n        (responseCode, frozen) = success ? abi.decode(result, (int32, bool)) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Query if token account has kyc granted\n    /// @param token The token address to check\n    /// @param account The account address associated with the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return kycGranted True if `account` has kyc granted for `token`\n    /// @dev This function reverts if the call is not successful\n    function isKyc(address token, address account) internal returns (int64 responseCode, bool kycGranted){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.isKyc.selector, token, account));\n        (responseCode, kycGranted) = success ? abi.decode(result, (int32, bool)) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Operation to freeze token account\n    /// @param token The token address\n    /// @param account The account address to be frozen\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function freezeToken(address token, address account) internal returns (int64 responseCode){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.freezeToken.selector, token, account));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to unfreeze token account\n    /// @param token The token address\n    /// @param account The account address to be unfrozen\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function unfreezeToken(address token, address account) internal returns (int64 responseCode){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.unfreezeToken.selector, token, account));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to grant kyc to token account\n    /// @param token The token address\n    /// @param account The account address to grant kyc",
                "codeOnlyTokens": 804,
                "startLine": 343,
                "endLine": 403,
                "type": ".sol_part_7",
                "isOversized": false
              },
              {
                "originalText": "    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function grantTokenKyc(address token, address account) internal returns (int64 responseCode){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.grantTokenKyc.selector, token, account));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to revoke kyc to token account\n    /// @param token The token address\n    /// @param account The account address to revoke kyc\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function revokeTokenKyc(address token, address account) internal returns (int64 responseCode){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.revokeTokenKyc.selector, token, account));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Enable or disable approval for a third party (\"operator\") to manage\n    ///  all of `msg.sender`'s assets\n    /// @param token The Hedera NFT token address to approve\n    /// @param operator Address to add to the set of authorized operators\n    /// @param approved True if the operator is approved, false to revoke approval\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function setApprovalForAll(address token, address operator, bool approved) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.setApprovalForAll.selector,\n            token, operator, approved));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Query if an address is an authorized operator for another address\n    /// Only Applicable to NFT Tokens\n    /// @param token The Hedera NFT token address to approve\n    /// @param owner The address that owns the NFTs\n    /// @param operator The address that acts on behalf of the owner\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return approved True if `operator` is an approved operator for `owner`, false otherwise\n    function isApprovedForAll(address token, address owner, address operator) internal returns (int responseCode, bool approved)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.isApprovedForAll.selector,\n            token, owner, operator));\n        (responseCode, approved) =\n        success\n        ? abi.decode(result, (int32, bool))\n        : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Query token default freeze status\n    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return defaultFreezeStatus True if `token` default freeze status is frozen.\n    /// @dev This function reverts if the call is not successful\n    function getTokenDefaultFreezeStatus(address token) internal returns (int responseCode, bool defaultFreezeStatus) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getTokenDefaultFreezeStatus.selector, token));\n        (responseCode, defaultFreezeStatus) = success ? abi.decode(result, (int32, bool)) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Query token default kyc status",
                "codeOnlyTokens": 803,
                "startLine": 404,
                "endLine": 464,
                "type": ".sol_part_8",
                "isOversized": false
              },
              {
                "originalText": "    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return defaultKycStatus True if `token` default kyc status is KycNotApplicable and false if Revoked.\n    /// @dev This function reverts if the call is not successful\n    function getTokenDefaultKycStatus(address token) internal returns (int responseCode, bool defaultKycStatus) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getTokenDefaultKycStatus.selector, token));\n        (responseCode, defaultKycStatus) = success ? abi.decode(result, (int32, bool)) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /**********************\n     * ABI v1 calls       *\n     **********************/\n\n    /// Initiates a Fungible Token Transfer\n    /// @param token The ID of the token as a solidity address\n    /// @param accountIds account to do a transfer to/from\n    /// @param amounts The amount from the accountId at the same index\n    function transferTokens(address token, address[] memory accountIds, int64[] memory amounts) internal\n    returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.transferTokens.selector,\n            token, accountIds, amounts));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Initiates a Non-Fungable Token Transfer\n    /// @param token The ID of the token as a solidity address\n    /// @param sender the sender of an nft\n    /// @param receiver the receiver of the nft sent by the same index at sender\n    /// @param serialNumber the serial number of the nft sent by the same index at sender\n    function transferNFTs(address token, address[] memory sender, address[] memory receiver, int64[] memory serialNumber)\n    internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.transferNFTs.selector,\n            token, sender, receiver, serialNumber));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Transfers tokens where the calling account/contract is implicitly the first entry in the token transfer list,\n    /// where the amount is the value needed to zero balance the transfers. Regular signing rules apply for sending\n    /// (positive amount) or receiving (negative amount)\n    /// @param token The token to transfer to/from\n    /// @param sender The sender for the transaction\n    /// @param receiver The receiver of the transaction\n    /// @param amount Non-negative value to send. a negative value will result in a failure.\n    function transferToken(address token, address sender, address receiver, int64 amount) internal\n    returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.transferToken.selector,\n            token, sender, receiver, amount));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Transfers tokens where the calling account/contract is implicitly the first entry in the token transfer list,\n    /// where the amount is the value needed to zero balance the transfers. Regular signing rules apply for sending\n    /// (positive amount) or receiving (negative amount)\n    /// @param token The token to transfer to/from\n    /// @param sender The sender for the transaction\n    /// @param receiver The receiver of the transaction\n    /// @param serialNumber The serial number of the NFT to transfer.",
                "codeOnlyTokens": 812,
                "startLine": 465,
                "endLine": 528,
                "type": ".sol_part_9",
                "isOversized": false
              }
            ],
            "startLine": 343,
            "endLine": 528,
            "groupId": 3
          },
          {
            "combinedText": "// File: contracts/system-contracts/hedera-token-service/HederaTokenService.sol\n// Relevant file context:\n// Type: .sol\n\n\n// --- Next chunk ---\n\n// Lines 529-597 (.sol_part_10)\n    function transferNFT(address token, address sender, address receiver, int64 serialNumber) internal\n    returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.transferNFT.selector,\n            token, sender, receiver, serialNumber));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to pause token\n    /// @param token The token address to be paused\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function pauseToken(address token) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.pauseToken.selector, token));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to unpause token\n    /// @param token The token address to be unpaused\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function unpauseToken(address token) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.unpauseToken.selector, token));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to wipe fungible tokens from account\n    /// @param token The token address\n    /// @param account The account address to revoke kyc\n    /// @param amount The number of tokens to wipe\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function wipeTokenAccount(address token, address account, int64 amount) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.wipeTokenAccount.selector, token, account, amount));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to wipe non fungible tokens from account\n    /// @param token The token address\n    /// @param account The account address to revoke kyc\n    /// @param  serialNumbers The serial numbers of token to wipe\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function wipeTokenAccountNFT(address token, address account, int64[] memory serialNumbers) internal\n    returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.wipeTokenAccountNFT.selector, token, account, serialNumbers));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to delete token\n    /// @param token The token address\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function deleteToken(address token) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.deleteToken.selector, token));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to update token keys\n    /// @param token The token address\n    /// @param keys The token keys\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateTokenKeys(address token, IHederaTokenService.TokenKey[] memory keys)\n\n// --- Next chunk ---\n\n// Lines 598-650 (.sol_part_11)\n    internal returns (int64 responseCode){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.updateTokenKeys.selector, token, keys));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Query token KeyValue\n    /// @param token The token address to check\n    /// @param keyType The keyType of the desired KeyValue\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return key KeyValue info for key of type `keyType`\n    /// @dev This function reverts if the call is not successful\n    function getTokenKey(address token, uint keyType)\n    internal returns (int64 responseCode, IHederaTokenService.KeyValue memory key){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getTokenKey.selector, token, keyType));\n        IHederaTokenService.KeyValue memory defaultKeyValueInfo;\n        (responseCode, key) = success ? abi.decode(result, (int32,IHederaTokenService.KeyValue) ) : (HederaResponseCodes.UNKNOWN, defaultKeyValueInfo);\n    }\n\n\n    /// Query if valid token found for the given address\n    /// @param token The token address\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return isTokenFlag True if valid token found for the given address\n    /// @dev This function reverts if the call is not successful\n    function isToken(address token) internal returns (int64 responseCode, bool isTokenFlag) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.isToken.selector, token));\n        (responseCode, isTokenFlag) = success ? abi.decode(result, (int32, bool)) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Query to return the token type for a given address\n    /// @param token The token address\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenType the token type. 0 is FUNGIBLE_COMMON, 1 is NON_FUNGIBLE_UNIQUE, -1 is UNRECOGNIZED\n    /// @dev This function reverts if the call is not successful\n    function getTokenType(address token) internal returns (int64 responseCode, int32 tokenType) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getTokenType.selector, token));\n        (responseCode, tokenType) = success ? abi.decode(result, (int32, int32)) : (HederaResponseCodes.UNKNOWN, - 1);\n    }\n\n    /// Operation to get token expiry info\n    /// @param token The token address\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return expiryInfo The expiry info of the token\n    /// @dev This function reverts if the call is not successful\n    function getTokenExpiryInfo(address token) internal returns (int responseCode, IHederaTokenService.Expiry memory expiryInfo){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getTokenExpiryInfo.selector, token));\n        IHederaTokenService.Expiry memory defaultExpiryInfo;\n        (responseCode, expiryInfo) = success ? abi.decode(result, (int32, IHederaTokenService.Expiry)) : (HederaResponseCodes.UNKNOWN, defaultExpiryInfo);\n\n// --- Next chunk ---\n\n// Lines 651-704 (.sol_part_12)\n    }\n\n    /// Operation to update token expiry info\n    /// @param token The token address\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateTokenExpiryInfo(address token, IHederaTokenService.Expiry memory expiryInfo) internal returns (int responseCode){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.updateTokenExpiryInfo.selector, token, expiryInfo));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to update token info\n    /// @param token The token address\n    /// @param tokenInfo The hedera token info to update token with\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateTokenInfo(address token, IHederaTokenService.HederaToken memory tokenInfo) internal returns (int responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.updateTokenInfo.selector, token, tokenInfo));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Redirect for token\n    /// @param token The token address\n    /// @param encodedFunctionSelector The function selector from the ERC20 interface + the bytes input for the function called\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return response The result of the call that had been encoded and sent for execution.\n    function redirectForToken(address token, bytes memory encodedFunctionSelector) external returns (int responseCode, bytes memory response) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.redirectForToken.selector, token, encodedFunctionSelector)\n        );\n\n        emit CallResponseEvent(success, result);\n        (responseCode, response) = success ? (HederaResponseCodes.SUCCESS, result) : (HederaResponseCodes.UNKNOWN, bytes(\"\"));\n    }\n\n    /// Update the custom fees for a fungible token\n    /// @param token The token address\n    /// @param fixedFees Set of fixed fees for `token`\n    /// @param fractionalFees Set of fractional fees for `token`\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateFungibleTokenCustomFees(address token,  IHederaTokenService.FixedFee[] memory fixedFees, IHederaTokenService.FractionalFee[] memory fractionalFees) internal returns (int64 responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.updateFungibleTokenCustomFees.selector, token, fixedFees, fractionalFees));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Update the custom fees for a non-fungible token\n    /// @param token The token address\n    /// @param fixedFees Set of fixed fees for `token`\n    /// @param royaltyFees Set of royalty fees for `token`\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateNonFungibleTokenCustomFees(address token, IHederaTokenService.FixedFee[] memory fixedFees, IHederaTokenService.RoyaltyFee[] memory royaltyFees) internal returns (int64 responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.updateNonFungibleTokenCustomFees.selector, token, fixedFees, royaltyFees));",
            "totalTokens": 2513,
            "chunks": [
              {
                "originalText": "    function transferNFT(address token, address sender, address receiver, int64 serialNumber) internal\n    returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.transferNFT.selector,\n            token, sender, receiver, serialNumber));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to pause token\n    /// @param token The token address to be paused\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function pauseToken(address token) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.pauseToken.selector, token));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to unpause token\n    /// @param token The token address to be unpaused\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function unpauseToken(address token) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.unpauseToken.selector, token));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to wipe fungible tokens from account\n    /// @param token The token address\n    /// @param account The account address to revoke kyc\n    /// @param amount The number of tokens to wipe\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function wipeTokenAccount(address token, address account, int64 amount) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.wipeTokenAccount.selector, token, account, amount));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to wipe non fungible tokens from account\n    /// @param token The token address\n    /// @param account The account address to revoke kyc\n    /// @param  serialNumbers The serial numbers of token to wipe\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function wipeTokenAccountNFT(address token, address account, int64[] memory serialNumbers) internal\n    returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.wipeTokenAccountNFT.selector, token, account, serialNumbers));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to delete token\n    /// @param token The token address\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function deleteToken(address token) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.deleteToken.selector, token));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to update token keys\n    /// @param token The token address\n    /// @param keys The token keys\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateTokenKeys(address token, IHederaTokenService.TokenKey[] memory keys)",
                "codeOnlyTokens": 816,
                "startLine": 529,
                "endLine": 597,
                "type": ".sol_part_10",
                "isOversized": false
              },
              {
                "originalText": "    internal returns (int64 responseCode){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.updateTokenKeys.selector, token, keys));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Query token KeyValue\n    /// @param token The token address to check\n    /// @param keyType The keyType of the desired KeyValue\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return key KeyValue info for key of type `keyType`\n    /// @dev This function reverts if the call is not successful\n    function getTokenKey(address token, uint keyType)\n    internal returns (int64 responseCode, IHederaTokenService.KeyValue memory key){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getTokenKey.selector, token, keyType));\n        IHederaTokenService.KeyValue memory defaultKeyValueInfo;\n        (responseCode, key) = success ? abi.decode(result, (int32,IHederaTokenService.KeyValue) ) : (HederaResponseCodes.UNKNOWN, defaultKeyValueInfo);\n    }\n\n\n    /// Query if valid token found for the given address\n    /// @param token The token address\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return isTokenFlag True if valid token found for the given address\n    /// @dev This function reverts if the call is not successful\n    function isToken(address token) internal returns (int64 responseCode, bool isTokenFlag) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.isToken.selector, token));\n        (responseCode, isTokenFlag) = success ? abi.decode(result, (int32, bool)) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Query to return the token type for a given address\n    /// @param token The token address\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenType the token type. 0 is FUNGIBLE_COMMON, 1 is NON_FUNGIBLE_UNIQUE, -1 is UNRECOGNIZED\n    /// @dev This function reverts if the call is not successful\n    function getTokenType(address token) internal returns (int64 responseCode, int32 tokenType) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getTokenType.selector, token));\n        (responseCode, tokenType) = success ? abi.decode(result, (int32, int32)) : (HederaResponseCodes.UNKNOWN, - 1);\n    }\n\n    /// Operation to get token expiry info\n    /// @param token The token address\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return expiryInfo The expiry info of the token\n    /// @dev This function reverts if the call is not successful\n    function getTokenExpiryInfo(address token) internal returns (int responseCode, IHederaTokenService.Expiry memory expiryInfo){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getTokenExpiryInfo.selector, token));\n        IHederaTokenService.Expiry memory defaultExpiryInfo;\n        (responseCode, expiryInfo) = success ? abi.decode(result, (int32, IHederaTokenService.Expiry)) : (HederaResponseCodes.UNKNOWN, defaultExpiryInfo);",
                "codeOnlyTokens": 808,
                "startLine": 598,
                "endLine": 650,
                "type": ".sol_part_11",
                "isOversized": false
              },
              {
                "originalText": "    }\n\n    /// Operation to update token expiry info\n    /// @param token The token address\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateTokenExpiryInfo(address token, IHederaTokenService.Expiry memory expiryInfo) internal returns (int responseCode){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.updateTokenExpiryInfo.selector, token, expiryInfo));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to update token info\n    /// @param token The token address\n    /// @param tokenInfo The hedera token info to update token with\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateTokenInfo(address token, IHederaTokenService.HederaToken memory tokenInfo) internal returns (int responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.updateTokenInfo.selector, token, tokenInfo));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Redirect for token\n    /// @param token The token address\n    /// @param encodedFunctionSelector The function selector from the ERC20 interface + the bytes input for the function called\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return response The result of the call that had been encoded and sent for execution.\n    function redirectForToken(address token, bytes memory encodedFunctionSelector) external returns (int responseCode, bytes memory response) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.redirectForToken.selector, token, encodedFunctionSelector)\n        );\n\n        emit CallResponseEvent(success, result);\n        (responseCode, response) = success ? (HederaResponseCodes.SUCCESS, result) : (HederaResponseCodes.UNKNOWN, bytes(\"\"));\n    }\n\n    /// Update the custom fees for a fungible token\n    /// @param token The token address\n    /// @param fixedFees Set of fixed fees for `token`\n    /// @param fractionalFees Set of fractional fees for `token`\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateFungibleTokenCustomFees(address token,  IHederaTokenService.FixedFee[] memory fixedFees, IHederaTokenService.FractionalFee[] memory fractionalFees) internal returns (int64 responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.updateFungibleTokenCustomFees.selector, token, fixedFees, fractionalFees));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Update the custom fees for a non-fungible token\n    /// @param token The token address\n    /// @param fixedFees Set of fixed fees for `token`\n    /// @param royaltyFees Set of royalty fees for `token`\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateNonFungibleTokenCustomFees(address token, IHederaTokenService.FixedFee[] memory fixedFees, IHederaTokenService.RoyaltyFee[] memory royaltyFees) internal returns (int64 responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.updateNonFungibleTokenCustomFees.selector, token, fixedFees, royaltyFees));",
                "codeOnlyTokens": 808,
                "startLine": 651,
                "endLine": 704,
                "type": ".sol_part_12",
                "isOversized": false
              }
            ],
            "startLine": 529,
            "endLine": 704,
            "groupId": 4
          },
          {
            "combinedText": "// File: contracts/system-contracts/hedera-token-service/HederaTokenService.sol\n// Relevant file context:\n// Type: .sol\n\n\n// --- Next chunk ---\n\n// Lines 705-750 (.sol_part_13)\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// @notice Airdrop one or more tokens to one or more accounts\n    /// @param tokenTransfers Array of token transfer lists containing token addresses and recipient details\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function airdropTokens(IHederaTokenService.TokenTransferList[] memory tokenTransfers) internal returns (int64 responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.airdropTokens.selector, tokenTransfers));\n\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// @notice Cancels pending airdrops that have not yet been claimed\n    /// @param pendingAirdrops Array of pending airdrops to cancel\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function cancelAirdrops(IHederaTokenService.PendingAirdrop[] memory pendingAirdrops) internal returns (int64 responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.cancelAirdrops.selector, pendingAirdrops)\n        );\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// @notice Claims pending airdrops that were sent to the calling account\n    /// @param pendingAirdrops Array of pending airdrops to claim\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function claimAirdrops(IHederaTokenService.PendingAirdrop[] memory pendingAirdrops) internal returns (int64 responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.claimAirdrops.selector, pendingAirdrops)\n        );\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// @notice Rejects one or more tokens by transferring their full balance from the requesting account to the treasury\n    /// @param rejectingAddress The address rejecting the tokens\n    /// @param ftAddresses Array of fungible token addresses to reject\n    /// @param nftIds Array of NFT IDs to reject\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function rejectTokens(address rejectingAddress, address[] memory ftAddresses, IHederaTokenService.NftID[] memory nftIds) internal returns (int64 responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.rejectTokens.selector, rejectingAddress, ftAddresses, nftIds)\n        );\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n}\n",
            "totalTokens": 703,
            "chunks": [
              {
                "originalText": "        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// @notice Airdrop one or more tokens to one or more accounts\n    /// @param tokenTransfers Array of token transfer lists containing token addresses and recipient details\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function airdropTokens(IHederaTokenService.TokenTransferList[] memory tokenTransfers) internal returns (int64 responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.airdropTokens.selector, tokenTransfers));\n\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// @notice Cancels pending airdrops that have not yet been claimed\n    /// @param pendingAirdrops Array of pending airdrops to cancel\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function cancelAirdrops(IHederaTokenService.PendingAirdrop[] memory pendingAirdrops) internal returns (int64 responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.cancelAirdrops.selector, pendingAirdrops)\n        );\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// @notice Claims pending airdrops that were sent to the calling account\n    /// @param pendingAirdrops Array of pending airdrops to claim\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function claimAirdrops(IHederaTokenService.PendingAirdrop[] memory pendingAirdrops) internal returns (int64 responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.claimAirdrops.selector, pendingAirdrops)\n        );\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// @notice Rejects one or more tokens by transferring their full balance from the requesting account to the treasury\n    /// @param rejectingAddress The address rejecting the tokens\n    /// @param ftAddresses Array of fungible token addresses to reject\n    /// @param nftIds Array of NFT IDs to reject\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function rejectTokens(address rejectingAddress, address[] memory ftAddresses, IHederaTokenService.NftID[] memory nftIds) internal returns (int64 responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.rejectTokens.selector, rejectingAddress, ftAddresses, nftIds)\n        );\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n}\n",
                "codeOnlyTokens": 656,
                "startLine": 705,
                "endLine": 750,
                "type": ".sol_part_13",
                "isOversized": false
              }
            ],
            "startLine": 705,
            "endLine": 750,
            "groupId": 5
          }
        ],
        "oversizedChunks": [],
        "sendStrategy": "multiple_groups",
        "finalTokenCount": 10724,
        "skippedContent": [],
        "contextHeader": "// File: contracts/system-contracts/hedera-token-service/HederaTokenService.sol\n// Relevant file context:\n// Type: .sol\n",
        "tokenBreakdown": {
          "originalFile": 10352,
          "finalSent": 10724,
          "codeTokensInGroups": 10349,
          "fileHeaderTokensInGroups": 145,
          "shellContextTokensInGroups": 0,
          "separatorTokensInGroups": 230,
          "skippedCodeTokens": 0,
          "unprocessedOversizedTokens": 0,
          "totalSavings": -372,
          "savingsPercentage": -3.593508500772798,
          "fileHeaderCount": 5,
          "fileHeaderAvgSize": 29,
          "shellContextCount": 0,
          "shellContextAvgSize": 0,
          "separatorCount": 13,
          "separatorAvgSize": 18
        }
      }
    },
    {
      "filePath": "contracts/system-contracts/hedera-account-service/HederaAccountService.sol",
      "totalOriginalTokens": 1632,
      "finalTokenCount": 1661,
      "impactScore": 49,
      "averageComplexity": 7,
      "averageQuality": 7,
      "usage": {
        "prompt_tokens": 2010,
        "completion_tokens": 241,
        "total_tokens": 2251
      },
      "retries": 0,
      "hadError": false,
      "scoredChunkGroups": [
        {
          "groupId": 1,
          "score": {
            "file_path": "contracts/system-contracts/hedera-account-service/HederaAccountService.sol",
            "complexity_score": 7,
            "code_quality_score": 8,
            "maintainability_score": 7,
            "best_practices_adherence": 6,
            "web3_pattern_identification": "Precompile Interaction",
            "hedera_red_flag": {
              "description": "Potential unhandled case in the response decoding which may lead to incorrect data handling.",
              "exact_code_snippet": "(responseCode, amount) = success ? abi.decode(result, (int32, int256)) : (HederaResponseCodes.UNKNOWN, (int256)(0));"
            },
            "hedera_optimization_suggestion": {
              "description": "Consider adding a check before decoding results to verify the length of the response data.",
              "exact_code_snippet": "(responseCode, amount) = success ? abi.decode(result, (int32, int256)) : (HederaResponseCodes.UNKNOWN, (int256)(0));"
            },
            "positive_feedback": "The use of precompile address for efficient interaction with Hedera's services is well implemented.",
            "group_summary": "This contract provides utility functions for interacting with Hedera account services, including token allowances and address alias resolutions."
          },
          "totalTokens": 1661,
          "usage": {
            "prompt_tokens": 2010,
            "completion_tokens": 241,
            "total_tokens": 2251
          }
        }
      ],
      "chunkingDetails": {
        "filePath": "contracts/system-contracts/hedera-account-service/HederaAccountService.sol",
        "totalFileTokens": 1632,
        "chunks": [
          {
            "originalText": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.5.0 <0.9.0;\npragma experimental ABIEncoderV2;\n\nimport \"../HederaResponseCodes.sol\";\nimport \"./IHederaAccountService.sol\";\n\nabstract contract HederaAccountService {\n    address constant HASPrecompileAddress = address(0x16a);\n\n    /// Returns the amount of hbars that the spender has been authorized to spend on behalf of the owner.\n    /// @param owner The account that has authorized the spender\n    /// @param spender The account that has been authorized by the owner\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return amount The amount of hbar that the spender has been authorized to spend on behalf of the owner.\n    function hbarAllowance(address owner, address spender) internal returns (int64 responseCode, int256 amount)\n    {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.hbarAllowance.selector,\n                owner, spender));\n        (responseCode, amount) = success ? abi.decode(result, (int32, int256)) : (HederaResponseCodes.UNKNOWN, (int256)(0));\n    }\n\n\n    /// Allows spender to withdraw hbars from the owner account multiple times, up to the value amount. If this function is called\n    /// again it overwrites the current allowance with the new amount.\n    /// @param owner The owner of the hbars\n    /// @param spender the account address authorized to spend\n    /// @param amount the amount of hbars authorized to spend.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function hbarApprove(address owner, address spender, int256 amount) internal returns (int64 responseCode)\n    {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.hbarApprove.selector,\n                owner, spender, amount));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Returns the EVM address alias for a given Hedera account.\n    /// @param accountNumAlias The Hedera account number alias to lookup. Must satisfy all of the following:\n    ///                         - Must be in long-zero format (0x000...0<account_num>)\n    ///                         - Must reference an existing Hedera account\n    ///                         - Referenced account must have an associated EVM address alias\n    /// @return responseCode The response code indicating the status of the request:\n    ///                         - SUCCESS (22) if successful\n    ///                         - INVALID_ACCOUNT_ID (15) if any validation of the accountNumAlias fails\n    ///                         - UNKNOWN (21) if the precompile call fails\n    /// @return evmAddressAlias The EVM address alias associated with the Hedera account, or address(0) if the request fails\n    function getEvmAddressAlias(address accountNumAlias) internal returns (int64 responseCode, address evmAddressAlias) \n    {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.getEvmAddressAlias.selector, accountNumAlias));\n        (responseCode, evmAddressAlias) = success ? abi.decode(result, (int32, address)) : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Returns the Hedera Account ID (as account num alias) for the given EVM address alias\n    /// @param evmAddressAlias The EVM address alias to get the Hedera account for. Must satisfy all of the following:\n    ///                         - Must be in EVM format (not a long-zero address)",
            "codeOnlyTokens": 805,
            "startLine": 1,
            "endLine": 58,
            "type": ".sol_part_1",
            "isOversized": false
          },
          {
            "originalText": "    ///                         - Must reference an existing Hedera account\n    ///                         - Referenced account must have an associated account num alias (long-zero format)\n    /// @return responseCode The response code indicating the status of the request:\n    ///                         - SUCCESS (22) if successful\n    ///                         - INVALID_SOLIDITY_ADDRESS (29) if any validation of the evmAddressAlias fails\n    ///                         - UNKNOWN (21) if the precompile call fails\n    /// @return accountNumAlias The Hedera account's num alias in long-zero format, or address(0) if the request fails\n    function getHederaAccountNumAlias(address evmAddressAlias) internal returns (int64 responseCode, address accountNumAlias) {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.getHederaAccountNumAlias.selector, evmAddressAlias));\n        (responseCode, accountNumAlias) = success ? abi.decode(result, (int32, address)) : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Returns true iff a Hedera account num alias or EVM address alias.\n    /// @param addr Some 20-byte address.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return response true iff addr is a Hedera account num alias or an EVM address alias (and false otherwise).\n    function isValidAlias(address addr) internal returns (int64 responseCode, bool response) {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.isValidAlias.selector, addr));\n        (responseCode, response) = success ? (HederaResponseCodes.SUCCESS, abi.decode(result, (bool))) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Determines if the signature is valid for the given message hash and account.\n    /// It is assumed that the signature is composed of a single EDCSA or ED25519 key.\n    /// @param account The account to check the signature against\n    /// @param messageHash The hash of the message to check the signature against\n    /// @param signature The signature to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return authorized True if the signature is valid, false otherwise\n    function isAuthorizedRaw(address account, bytes memory messageHash, bytes memory signature) internal returns (int64 responseCode, bool authorized) {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.isAuthorizedRaw.selector,\n                account, messageHash, signature));\n        (responseCode, authorized) = success ? (HederaResponseCodes.SUCCESS, abi.decode(result, (bool))) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Determines if the signature is valid for the given message and account.\n    /// It is assumed that the signature is composed of a possibly complex cryptographic key.\n    /// @param account The account to check the signature against.\n    /// @param message The message to check the signature against.\n    /// @param signature The signature to check encoded as bytes.\n    /// @return responseCode The response code for the status of the request.  SUCCESS is 22.\n    /// @return authorized True if the signature is valid, false otherwise.\n    function isAuthorized(address account, bytes memory message, bytes memory signature) internal returns (int64 responseCode, bool authorized) {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.isAuthorized.selector,\n                account, message, signature));\n        (responseCode, authorized) = success ? abi.decode(result, (int32, bool)) : (HederaResponseCodes.UNKNOWN, false);",
            "codeOnlyTokens": 824,
            "startLine": 59,
            "endLine": 107,
            "type": ".sol_part_2",
            "isOversized": false
          },
          {
            "originalText": "    }\n}\n",
            "codeOnlyTokens": 3,
            "startLine": 108,
            "endLine": 110,
            "type": ".sol_part_3",
            "isOversized": false
          }
        ],
        "groupedChunks": [
          {
            "combinedText": "// File: contracts/system-contracts/hedera-account-service/HederaAccountService.sol\n// Relevant file context:\n// Type: .sol\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.5.0 <0.9.0;\npragma experimental ABIEncoderV2;\n\nimport \"../HederaResponseCodes.sol\";\nimport \"./IHederaAccountService.sol\";\n\nabstract contract HederaAccountService {\n    address constant HASPrecompileAddress = address(0x16a);\n\n    /// Returns the amount of hbars that the spender has been authorized to spend on behalf of the owner.\n    /// @param owner The account that has authorized the spender\n    /// @param spender The account that has been authorized by the owner\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return amount The amount of hbar that the spender has been authorized to spend on behalf of the owner.\n    function hbarAllowance(address owner, address spender) internal returns (int64 responseCode, int256 amount)\n    {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.hbarAllowance.selector,\n                owner, spender));\n        (responseCode, amount) = success ? abi.decode(result, (int32, int256)) : (HederaResponseCodes.UNKNOWN, (int256)(0));\n    }\n\n\n    /// Allows spender to withdraw hbars from the owner account multiple times, up to the value amount. If this function is called\n    /// again it overwrites the current allowance with the new amount.\n    /// @param owner The owner of the hbars\n    /// @param spender the account address authorized to spend\n    /// @param amount the amount of hbars authorized to spend.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function hbarApprove(address owner, address spender, int256 amount) internal returns (int64 responseCode)\n    {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.hbarApprove.selector,\n                owner, spender, amount));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Returns the EVM address alias for a given Hedera account.\n    /// @param accountNumAlias The Hedera account number alias to lookup. Must satisfy all of the following:\n    ///                         - Must be in long-zero format (0x000...0<account_num>)\n    ///                         - Must reference an existing Hedera account\n    ///                         - Referenced account must have an associated EVM address alias\n    /// @return responseCode The response code indicating the status of the request:\n    ///                         - SUCCESS (22) if successful\n    ///                         - INVALID_ACCOUNT_ID (15) if any validation of the accountNumAlias fails\n    ///                         - UNKNOWN (21) if the precompile call fails\n    /// @return evmAddressAlias The EVM address alias associated with the Hedera account, or address(0) if the request fails\n    function getEvmAddressAlias(address accountNumAlias) internal returns (int64 responseCode, address evmAddressAlias) \n    {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.getEvmAddressAlias.selector, accountNumAlias));\n        (responseCode, evmAddressAlias) = success ? abi.decode(result, (int32, address)) : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Returns the Hedera Account ID (as account num alias) for the given EVM address alias\n    /// @param evmAddressAlias The EVM address alias to get the Hedera account for. Must satisfy all of the following:\n    ///                         - Must be in EVM format (not a long-zero address)\n    ///                         - Must reference an existing Hedera account\n    ///                         - Referenced account must have an associated account num alias (long-zero format)\n    /// @return responseCode The response code indicating the status of the request:\n    ///                         - SUCCESS (22) if successful\n    ///                         - INVALID_SOLIDITY_ADDRESS (29) if any validation of the evmAddressAlias fails\n    ///                         - UNKNOWN (21) if the precompile call fails\n    /// @return accountNumAlias The Hedera account's num alias in long-zero format, or address(0) if the request fails\n    function getHederaAccountNumAlias(address evmAddressAlias) internal returns (int64 responseCode, address accountNumAlias) {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.getHederaAccountNumAlias.selector, evmAddressAlias));\n        (responseCode, accountNumAlias) = success ? abi.decode(result, (int32, address)) : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Returns true iff a Hedera account num alias or EVM address alias.\n    /// @param addr Some 20-byte address.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return response true iff addr is a Hedera account num alias or an EVM address alias (and false otherwise).\n    function isValidAlias(address addr) internal returns (int64 responseCode, bool response) {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.isValidAlias.selector, addr));\n        (responseCode, response) = success ? (HederaResponseCodes.SUCCESS, abi.decode(result, (bool))) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Determines if the signature is valid for the given message hash and account.\n    /// It is assumed that the signature is composed of a single EDCSA or ED25519 key.\n    /// @param account The account to check the signature against\n    /// @param messageHash The hash of the message to check the signature against\n    /// @param signature The signature to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return authorized True if the signature is valid, false otherwise\n    function isAuthorizedRaw(address account, bytes memory messageHash, bytes memory signature) internal returns (int64 responseCode, bool authorized) {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.isAuthorizedRaw.selector,\n                account, messageHash, signature));\n        (responseCode, authorized) = success ? (HederaResponseCodes.SUCCESS, abi.decode(result, (bool))) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Determines if the signature is valid for the given message and account.\n    /// It is assumed that the signature is composed of a possibly complex cryptographic key.\n    /// @param account The account to check the signature against.\n    /// @param message The message to check the signature against.\n    /// @param signature The signature to check encoded as bytes.\n    /// @return responseCode The response code for the status of the request.  SUCCESS is 22.\n    /// @return authorized True if the signature is valid, false otherwise.\n    function isAuthorized(address account, bytes memory message, bytes memory signature) internal returns (int64 responseCode, bool authorized) {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.isAuthorized.selector,\n                account, message, signature));\n        (responseCode, authorized) = success ? abi.decode(result, (int32, bool)) : (HederaResponseCodes.UNKNOWN, false);\n    }\n}\n",
            "totalTokens": 1661,
            "chunks": [
              {
                "originalText": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.5.0 <0.9.0;\npragma experimental ABIEncoderV2;\n\nimport \"../HederaResponseCodes.sol\";\nimport \"./IHederaAccountService.sol\";\n\nabstract contract HederaAccountService {\n    address constant HASPrecompileAddress = address(0x16a);\n\n    /// Returns the amount of hbars that the spender has been authorized to spend on behalf of the owner.\n    /// @param owner The account that has authorized the spender\n    /// @param spender The account that has been authorized by the owner\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return amount The amount of hbar that the spender has been authorized to spend on behalf of the owner.\n    function hbarAllowance(address owner, address spender) internal returns (int64 responseCode, int256 amount)\n    {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.hbarAllowance.selector,\n                owner, spender));\n        (responseCode, amount) = success ? abi.decode(result, (int32, int256)) : (HederaResponseCodes.UNKNOWN, (int256)(0));\n    }\n\n\n    /// Allows spender to withdraw hbars from the owner account multiple times, up to the value amount. If this function is called\n    /// again it overwrites the current allowance with the new amount.\n    /// @param owner The owner of the hbars\n    /// @param spender the account address authorized to spend\n    /// @param amount the amount of hbars authorized to spend.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function hbarApprove(address owner, address spender, int256 amount) internal returns (int64 responseCode)\n    {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.hbarApprove.selector,\n                owner, spender, amount));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Returns the EVM address alias for a given Hedera account.\n    /// @param accountNumAlias The Hedera account number alias to lookup. Must satisfy all of the following:\n    ///                         - Must be in long-zero format (0x000...0<account_num>)\n    ///                         - Must reference an existing Hedera account\n    ///                         - Referenced account must have an associated EVM address alias\n    /// @return responseCode The response code indicating the status of the request:\n    ///                         - SUCCESS (22) if successful\n    ///                         - INVALID_ACCOUNT_ID (15) if any validation of the accountNumAlias fails\n    ///                         - UNKNOWN (21) if the precompile call fails\n    /// @return evmAddressAlias The EVM address alias associated with the Hedera account, or address(0) if the request fails\n    function getEvmAddressAlias(address accountNumAlias) internal returns (int64 responseCode, address evmAddressAlias) \n    {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.getEvmAddressAlias.selector, accountNumAlias));\n        (responseCode, evmAddressAlias) = success ? abi.decode(result, (int32, address)) : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Returns the Hedera Account ID (as account num alias) for the given EVM address alias\n    /// @param evmAddressAlias The EVM address alias to get the Hedera account for. Must satisfy all of the following:\n    ///                         - Must be in EVM format (not a long-zero address)\n    ///                         - Must reference an existing Hedera account\n    ///                         - Referenced account must have an associated account num alias (long-zero format)\n    /// @return responseCode The response code indicating the status of the request:\n    ///                         - SUCCESS (22) if successful\n    ///                         - INVALID_SOLIDITY_ADDRESS (29) if any validation of the evmAddressAlias fails\n    ///                         - UNKNOWN (21) if the precompile call fails\n    /// @return accountNumAlias The Hedera account's num alias in long-zero format, or address(0) if the request fails\n    function getHederaAccountNumAlias(address evmAddressAlias) internal returns (int64 responseCode, address accountNumAlias) {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.getHederaAccountNumAlias.selector, evmAddressAlias));\n        (responseCode, accountNumAlias) = success ? abi.decode(result, (int32, address)) : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Returns true iff a Hedera account num alias or EVM address alias.\n    /// @param addr Some 20-byte address.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return response true iff addr is a Hedera account num alias or an EVM address alias (and false otherwise).\n    function isValidAlias(address addr) internal returns (int64 responseCode, bool response) {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.isValidAlias.selector, addr));\n        (responseCode, response) = success ? (HederaResponseCodes.SUCCESS, abi.decode(result, (bool))) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Determines if the signature is valid for the given message hash and account.\n    /// It is assumed that the signature is composed of a single EDCSA or ED25519 key.\n    /// @param account The account to check the signature against\n    /// @param messageHash The hash of the message to check the signature against\n    /// @param signature The signature to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return authorized True if the signature is valid, false otherwise\n    function isAuthorizedRaw(address account, bytes memory messageHash, bytes memory signature) internal returns (int64 responseCode, bool authorized) {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.isAuthorizedRaw.selector,\n                account, messageHash, signature));\n        (responseCode, authorized) = success ? (HederaResponseCodes.SUCCESS, abi.decode(result, (bool))) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Determines if the signature is valid for the given message and account.\n    /// It is assumed that the signature is composed of a possibly complex cryptographic key.\n    /// @param account The account to check the signature against.\n    /// @param message The message to check the signature against.\n    /// @param signature The signature to check encoded as bytes.\n    /// @return responseCode The response code for the status of the request.  SUCCESS is 22.\n    /// @return authorized True if the signature is valid, false otherwise.\n    function isAuthorized(address account, bytes memory message, bytes memory signature) internal returns (int64 responseCode, bool authorized) {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.isAuthorized.selector,\n                account, message, signature));\n        (responseCode, authorized) = success ? abi.decode(result, (int32, bool)) : (HederaResponseCodes.UNKNOWN, false);\n    }\n}\n",
                "codeOnlyTokens": 1632,
                "startLine": 1,
                "endLine": 110,
                "type": "full_file",
                "isOversized": false
              }
            ],
            "startLine": 1,
            "endLine": 110,
            "groupId": 1
          }
        ],
        "oversizedChunks": [],
        "sendStrategy": "full_file",
        "finalTokenCount": 1661,
        "skippedContent": [],
        "contextHeader": "// File: contracts/system-contracts/hedera-account-service/HederaAccountService.sol\n// Relevant file context:\n// Type: .sol\n",
        "tokenBreakdown": {
          "originalFile": 1632,
          "finalSent": 1661,
          "codeTokensInGroups": 1632,
          "fileHeaderTokensInGroups": 29,
          "shellContextTokensInGroups": 0,
          "separatorTokensInGroups": 0,
          "skippedCodeTokens": 0,
          "unprocessedOversizedTokens": 0,
          "totalSavings": -29,
          "savingsPercentage": -1.7769607843137254,
          "fileHeaderCount": 1,
          "fileHeaderAvgSize": 29,
          "shellContextCount": 0,
          "shellContextAvgSize": 0,
          "separatorCount": 1,
          "separatorAvgSize": 0
        }
      }
    },
    {
      "filePath": "system-contract-dapp-playground/src/api/hedera/index.ts",
      "totalOriginalTokens": 565,
      "finalTokenCount": 592,
      "impactScore": 46.66666666666667,
      "averageComplexity": 7,
      "averageQuality": 6.666666666666667,
      "usage": {
        "prompt_tokens": 778,
        "completion_tokens": 177,
        "total_tokens": 955
      },
      "retries": 0,
      "hadError": false,
      "scoredChunkGroups": [
        {
          "groupId": 1,
          "score": {
            "file_path": "system-contract-dapp-playground/src/api/hedera/index.ts",
            "complexity_score": 7,
            "code_quality_score": 7,
            "maintainability_score": 6,
            "best_practices_adherence": 7,
            "web3_pattern_identification": "Contract Factory Pattern",
            "hedera_red_flag": {
              "description": "Lack of error handling for missing contract ABI or bytecode could lead to unexpected failures.",
              "exact_code_snippet": "const contract = new ContractFactory(JSON.stringify(contractABI), contractBytecode, walletSigner);"
            },
            "hedera_optimization_suggestion": {
              "description": "Consider implementing checks for the validity of parameters before proceeding with the contract deployment to reduce transaction failures.",
              "exact_code_snippet": "if (walletProvider.err || !walletProvider.walletProvider) {...}"
            },
            "positive_feedback": "The caching of transaction results demonstrates a thoughtful user experience and performance consideration in your Hedera dApp.",
            "group_summary": "This TypeScript function manages the deployment of smart contracts to the Hedera network, providing essential error handling and transaction management."
          },
          "totalTokens": 592,
          "usage": {
            "prompt_tokens": 778,
            "completion_tokens": 177,
            "total_tokens": 955
          }
        }
      ],
      "chunkingDetails": {
        "filePath": "system-contract-dapp-playground/src/api/hedera/index.ts",
        "totalFileTokens": 565,
        "chunks": [
          {
            "originalText": "// SPDX-License-Identifier: Apache-2.0\n\nimport { ContractFactory } from 'ethers';\nimport { getWalletProvider } from '../wallet';\nimport { ITransactionResult } from '@/types/contract-interactions/shared';\nimport { IContractABI, IHederaSmartContractResult } from '@/types/common';\nimport { HEDERA_TRANSACTION_RESULT_STORAGE_KEYS } from '@/utils/common/constants';\n\n/**\n * @dev deploys smart contract to Hedera network\n *\n * @params contractABI: IContractABI\n *\n * @params contractBytecode: string\n *\n * @return Promise<IHederaSmartContractResult>\n *\n * @resource https://github.com/ed-marquez/hedera-example-metamask-counter-dapp/blob/master/src/components/hedera/contractDeploy.js\n */\nexport const deploySmartContract = async (\n  contractABI: IContractABI[],\n  contractBytecode: string,\n  params: any[]\n): Promise<IHederaSmartContractResult> => {\n  // states\n  const transactionResultStorageKey = HEDERA_TRANSACTION_RESULT_STORAGE_KEYS['CONTRACT-CREATE'];\n\n  // get contract create transactions from localStorage\n  const cachedCreateTransactions = localStorage.getItem(transactionResultStorageKey);\n  const contractCreateTransactions = cachedCreateTransactions ? JSON.parse(cachedCreateTransactions) : [];\n\n  // get signer\n  const walletProvider = getWalletProvider();\n  if (walletProvider.err || !walletProvider.walletProvider) {\n    return { err: walletProvider.err };\n  }\n  const walletSigner = await walletProvider.walletProvider.getSigner();\n\n  // Deploy smart contract\n  try {\n    // prepare gaslimit\n    const gasLimit = 4_000_000;\n\n    // get contract from contract factory\n    const contract = new ContractFactory(JSON.stringify(contractABI), contractBytecode, walletSigner);\n\n    // execute deploy transaction\n    const contractDeployTx = await contract.deploy(...params, {\n      gasLimit,\n    });\n\n    // get contractAddress\n    const contractAddress = await contractDeployTx.getAddress();\n\n    // retrieve transaction receipt\n    const txReceipt = contractDeployTx.deploymentTransaction();\n\n    // prepare create transaction result\n    if (txReceipt) {\n      const createTransactionResult: ITransactionResult = {\n        status: 'success',\n        transactionResultStorageKey,\n        transactionTimeStamp: Date.now(),\n        txHash: txReceipt.hash as string,\n        transactionType: 'CONTRACT-CREATE',\n        sessionedContractAddress: contractAddress,\n      };\n      contractCreateTransactions.push(createTransactionResult);\n      localStorage.setItem(transactionResultStorageKey, JSON.stringify(contractCreateTransactions));\n    }\n\n    return { contractAddress };\n  } catch (err) {\n    console.error(err);\n    return { err };\n  }\n};\n",
            "codeOnlyTokens": 565,
            "startLine": 1,
            "endLine": 78,
            "type": ".ts",
            "isOversized": false
          }
        ],
        "groupedChunks": [
          {
            "combinedText": "// File: system-contract-dapp-playground/src/api/hedera/index.ts\n// Relevant file context:\n// Type: .ts\n// SPDX-License-Identifier: Apache-2.0\n\nimport { ContractFactory } from 'ethers';\nimport { getWalletProvider } from '../wallet';\nimport { ITransactionResult } from '@/types/contract-interactions/shared';\nimport { IContractABI, IHederaSmartContractResult } from '@/types/common';\nimport { HEDERA_TRANSACTION_RESULT_STORAGE_KEYS } from '@/utils/common/constants';\n\n/**\n * @dev deploys smart contract to Hedera network\n *\n * @params contractABI: IContractABI\n *\n * @params contractBytecode: string\n *\n * @return Promise<IHederaSmartContractResult>\n *\n * @resource https://github.com/ed-marquez/hedera-example-metamask-counter-dapp/blob/master/src/components/hedera/contractDeploy.js\n */\nexport const deploySmartContract = async (\n  contractABI: IContractABI[],\n  contractBytecode: string,\n  params: any[]\n): Promise<IHederaSmartContractResult> => {\n  // states\n  const transactionResultStorageKey = HEDERA_TRANSACTION_RESULT_STORAGE_KEYS['CONTRACT-CREATE'];\n\n  // get contract create transactions from localStorage\n  const cachedCreateTransactions = localStorage.getItem(transactionResultStorageKey);\n  const contractCreateTransactions = cachedCreateTransactions ? JSON.parse(cachedCreateTransactions) : [];\n\n  // get signer\n  const walletProvider = getWalletProvider();\n  if (walletProvider.err || !walletProvider.walletProvider) {\n    return { err: walletProvider.err };\n  }\n  const walletSigner = await walletProvider.walletProvider.getSigner();\n\n  // Deploy smart contract\n  try {\n    // prepare gaslimit\n    const gasLimit = 4_000_000;\n\n    // get contract from contract factory\n    const contract = new ContractFactory(JSON.stringify(contractABI), contractBytecode, walletSigner);\n\n    // execute deploy transaction\n    const contractDeployTx = await contract.deploy(...params, {\n      gasLimit,\n    });\n\n    // get contractAddress\n    const contractAddress = await contractDeployTx.getAddress();\n\n    // retrieve transaction receipt\n    const txReceipt = contractDeployTx.deploymentTransaction();\n\n    // prepare create transaction result\n    if (txReceipt) {\n      const createTransactionResult: ITransactionResult = {\n        status: 'success',\n        transactionResultStorageKey,\n        transactionTimeStamp: Date.now(),\n        txHash: txReceipt.hash as string,\n        transactionType: 'CONTRACT-CREATE',\n        sessionedContractAddress: contractAddress,\n      };\n      contractCreateTransactions.push(createTransactionResult);\n      localStorage.setItem(transactionResultStorageKey, JSON.stringify(contractCreateTransactions));\n    }\n\n    return { contractAddress };\n  } catch (err) {\n    console.error(err);\n    return { err };\n  }\n};\n",
            "totalTokens": 592,
            "chunks": [
              {
                "originalText": "// SPDX-License-Identifier: Apache-2.0\n\nimport { ContractFactory } from 'ethers';\nimport { getWalletProvider } from '../wallet';\nimport { ITransactionResult } from '@/types/contract-interactions/shared';\nimport { IContractABI, IHederaSmartContractResult } from '@/types/common';\nimport { HEDERA_TRANSACTION_RESULT_STORAGE_KEYS } from '@/utils/common/constants';\n\n/**\n * @dev deploys smart contract to Hedera network\n *\n * @params contractABI: IContractABI\n *\n * @params contractBytecode: string\n *\n * @return Promise<IHederaSmartContractResult>\n *\n * @resource https://github.com/ed-marquez/hedera-example-metamask-counter-dapp/blob/master/src/components/hedera/contractDeploy.js\n */\nexport const deploySmartContract = async (\n  contractABI: IContractABI[],\n  contractBytecode: string,\n  params: any[]\n): Promise<IHederaSmartContractResult> => {\n  // states\n  const transactionResultStorageKey = HEDERA_TRANSACTION_RESULT_STORAGE_KEYS['CONTRACT-CREATE'];\n\n  // get contract create transactions from localStorage\n  const cachedCreateTransactions = localStorage.getItem(transactionResultStorageKey);\n  const contractCreateTransactions = cachedCreateTransactions ? JSON.parse(cachedCreateTransactions) : [];\n\n  // get signer\n  const walletProvider = getWalletProvider();\n  if (walletProvider.err || !walletProvider.walletProvider) {\n    return { err: walletProvider.err };\n  }\n  const walletSigner = await walletProvider.walletProvider.getSigner();\n\n  // Deploy smart contract\n  try {\n    // prepare gaslimit\n    const gasLimit = 4_000_000;\n\n    // get contract from contract factory\n    const contract = new ContractFactory(JSON.stringify(contractABI), contractBytecode, walletSigner);\n\n    // execute deploy transaction\n    const contractDeployTx = await contract.deploy(...params, {\n      gasLimit,\n    });\n\n    // get contractAddress\n    const contractAddress = await contractDeployTx.getAddress();\n\n    // retrieve transaction receipt\n    const txReceipt = contractDeployTx.deploymentTransaction();\n\n    // prepare create transaction result\n    if (txReceipt) {\n      const createTransactionResult: ITransactionResult = {\n        status: 'success',\n        transactionResultStorageKey,\n        transactionTimeStamp: Date.now(),\n        txHash: txReceipt.hash as string,\n        transactionType: 'CONTRACT-CREATE',\n        sessionedContractAddress: contractAddress,\n      };\n      contractCreateTransactions.push(createTransactionResult);\n      localStorage.setItem(transactionResultStorageKey, JSON.stringify(contractCreateTransactions));\n    }\n\n    return { contractAddress };\n  } catch (err) {\n    console.error(err);\n    return { err };\n  }\n};\n",
                "codeOnlyTokens": 565,
                "startLine": 1,
                "endLine": 78,
                "type": "full_file",
                "isOversized": false
              }
            ],
            "startLine": 1,
            "endLine": 78,
            "groupId": 1
          }
        ],
        "oversizedChunks": [],
        "sendStrategy": "full_file",
        "finalTokenCount": 592,
        "skippedContent": [],
        "contextHeader": "// File: system-contract-dapp-playground/src/api/hedera/index.ts\n// Relevant file context:\n// Type: .ts\n",
        "tokenBreakdown": {
          "originalFile": 565,
          "finalSent": 592,
          "codeTokensInGroups": 565,
          "fileHeaderTokensInGroups": 27,
          "shellContextTokensInGroups": 0,
          "separatorTokensInGroups": 0,
          "skippedCodeTokens": 0,
          "unprocessedOversizedTokens": 0,
          "totalSavings": -27,
          "savingsPercentage": -4.778761061946903,
          "fileHeaderCount": 1,
          "fileHeaderAvgSize": 27,
          "shellContextCount": 0,
          "shellContextAvgSize": 0,
          "separatorCount": 1,
          "separatorAvgSize": 0
        }
      }
    },
    {
      "filePath": "lib/layer-zero/hts/IHederaTokenService.sol",
      "totalOriginalTokens": 2047,
      "finalTokenCount": 2075,
      "impactScore": 46,
      "averageComplexity": 6,
      "averageQuality": 7.666666666666667,
      "usage": {
        "prompt_tokens": 2511,
        "completion_tokens": 233,
        "total_tokens": 2744
      },
      "retries": 0,
      "hadError": false,
      "scoredChunkGroups": [
        {
          "groupId": 1,
          "score": {
            "file_path": "lib/layer-zero/hts/IHederaTokenService.sol",
            "complexity_score": 6,
            "code_quality_score": 8,
            "maintainability_score": 7,
            "best_practices_adherence": 8,
            "web3_pattern_identification": "Interface Segregation",
            "hedera_red_flag": {
              "description": "",
              "exact_code_snippet": ""
            },
            "hedera_optimization_suggestion": {
              "description": "",
              "exact_code_snippet": ""
            },
            "positive_feedback": "The use of detailed comments to explain the purpose of each struct and function enhances understanding and clarity for future developers.",
            "group_summary": "This interface defines the essential properties and methods for the Hedera Token Service, facilitating operations such as minting, burning, and transferring tokens."
          },
          "totalTokens": 2075,
          "usage": {
            "prompt_tokens": 2511,
            "completion_tokens": 233,
            "total_tokens": 2744
          }
        }
      ],
      "chunkingDetails": {
        "filePath": "lib/layer-zero/hts/IHederaTokenService.sol",
        "totalFileTokens": 2047,
        "chunks": [
          {
            "originalText": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.9 <0.9.0;\npragma experimental ABIEncoderV2;\n\ninterface IHederaTokenService {\n    /// Expiry properties of a Hedera token - second, autoRenewAccount, autoRenewPeriod\n    struct Expiry {\n        // The epoch second at which the token should expire; if an auto-renew account and period are\n        // specified, this is coerced to the current epoch second plus the autoRenewPeriod\n        int64 second;\n        // ID of an account which will be automatically charged to renew the token's expiration, at\n        // autoRenewPeriod interval, expressed as a solidity address\n        address autoRenewAccount;\n        // The interval at which the auto-renew account will be charged to extend the token's expiry\n        int64 autoRenewPeriod;\n    }\n\n    /// A Key can be a public key from either the Ed25519 or ECDSA(secp256k1) signature schemes, where\n    /// in the ECDSA(secp256k1) case we require the 33-byte compressed form of the public key. We call\n    /// these public keys <b>primitive keys</b>.\n    /// A Key can also be the ID of a smart contract instance, which is then authorized to perform any\n    /// precompiled contract action that requires this key to sign.\n    /// Note that when a Key is a smart contract ID, it <i>doesn't</i> mean the contract with that ID\n    /// will actually create a cryptographic signature. It only means that when the contract calls a\n    /// precompiled contract, the resulting \"child transaction\" will be authorized to perform any action\n    /// controlled by the Key.\n    /// Exactly one of the possible values should be populated in order for the Key to be valid.\n    struct KeyValue {\n        // if set to true, the key of the calling Hedera account will be inherited as the token key\n        bool inheritAccountKey;\n        // smart contract instance that is authorized as if it had signed with a key\n        address contractId;\n        // Ed25519 public key bytes\n        bytes ed25519;\n        // Compressed ECDSA(secp256k1) public key bytes\n        bytes ECDSA_secp256k1;\n        // A smart contract that, if the recipient of the active message frame, should be treated\n        // as having signed. (Note this does not mean the <i>code being executed in the frame</i>\n        // will belong to the given contract, since it could be running another contract's code via\n        // <tt>delegatecall</tt>. So setting this key is a more permissive version of setting the\n        // contractID key, which also requires the code in the active message frame belong to the\n        // the contract with the given id.)\n        address delegatableContractId;\n    }\n\n    /// A list of token key types the key should be applied to and the value of the key\n    struct TokenKey {\n        // bit field representing the key type. Keys of all types that have corresponding bits set to 1\n        // will be created for the token.\n        // 0th bit: adminKey\n        // 1st bit: kycKey\n        // 2nd bit: freezeKey\n        // 3rd bit: wipeKey\n        // 4th bit: supplyKey\n        // 5th bit: feeScheduleKey\n        // 6th bit: pauseKey\n        // 7th bit: ignored\n        uint keyType;\n        // the value that will be set to the key type\n        KeyValue key;\n    }\n\n    /// Basic properties of a Hedera Token - name, symbol, memo, tokenSupplyType, maxSupply,\n    /// treasury, freezeDefault. These properties are related both to Fungible and NFT token types.",
            "codeOnlyTokens": 818,
            "startLine": 1,
            "endLine": 64,
            "type": ".sol_part_1",
            "isOversized": false
          },
          {
            "originalText": "    struct HederaToken {\n        // The publicly visible name of the token. The token name is specified as a Unicode string.\n        // Its UTF-8 encoding cannot exceed 100 bytes, and cannot contain the 0 byte (NUL).\n        string name;\n        // The publicly visible token symbol. The token symbol is specified as a Unicode string.\n        // Its UTF-8 encoding cannot exceed 100 bytes, and cannot contain the 0 byte (NUL).\n        string symbol;\n        // The ID of the account which will act as a treasury for the token as a solidity address.\n        // This account will receive the specified initial supply or the newly minted NFTs in\n        // the case for NON_FUNGIBLE_UNIQUE Type\n        address treasury;\n        // The memo associated with the token (UTF-8 encoding max 100 bytes)\n        string memo;\n        // IWA compatibility. Specified the token supply type. Defaults to INFINITE\n        bool tokenSupplyType;\n        // IWA Compatibility. Depends on TokenSupplyType. For tokens of type FUNGIBLE_COMMON - the\n        // maximum number of tokens that can be in circulation. For tokens of type NON_FUNGIBLE_UNIQUE -\n        // the maximum number of NFTs (serial numbers) that can be minted. This field can never be changed!\n        int64 maxSupply;\n        // The default Freeze status (frozen or unfrozen) of Hedera accounts relative to this token. If\n        // true, an account must be unfrozen before it can receive the token\n        bool freezeDefault;\n        // list of keys to set to the token\n        TokenKey[] tokenKeys;\n        // expiry properties of a Hedera token - second, autoRenewAccount, autoRenewPeriod\n        Expiry expiry;\n    }\n\n    /**********************\n     * Direct HTS Calls   *\n     **********************/\n\n    /// Mints an amount of the token to the defined treasury account\n    /// @param token The token for which to mint tokens. If token does not exist, transaction results in\n    ///              INVALID_TOKEN_ID\n    /// @param amount Applicable to tokens of type FUNGIBLE_COMMON. The amount to mint to the Treasury Account.\n    ///               Amount must be a positive non-zero number represented in the lowest denomination of the\n    ///               token. The new supply must be lower than 2^63.\n    /// @param metadata Applicable to tokens of type NON_FUNGIBLE_UNIQUE. A list of metadata that are being created.\n    ///                 Maximum allowed size of each metadata is 100 bytes\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return newTotalSupply The new supply of tokens. For NFTs it is the total count of NFTs\n    /// @return serialNumbers If the token is an NFT the newly generate serial numbers, othersise empty.\n    function mintToken(\n        address token,\n        int64 amount,\n        bytes[] memory metadata\n    )\n        external\n        returns (\n            int64 responseCode,\n            int64 newTotalSupply,\n            int64[] memory serialNumbers\n        );\n\n    /// Burns an amount of the token from the defined treasury account\n    /// @param token The token for which to burn tokens. If token does not exist, transaction results in\n    ///              INVALID_TOKEN_ID\n    /// @param amount  Applicable to tokens of type FUNGIBLE_COMMON. The amount to burn from the Treasury Account.\n    ///                Amount must be a positive non-zero number, not bigger than the token balance of the treasury\n    ///                account (0; balance], represented in the lowest denomination.\n    /// @param serialNumbers Applicable to tokens of type NON_FUNGIBLE_UNIQUE. The list of serial numbers to be burned.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return newTotalSupply The new supply of tokens. For NFTs it is the total count of NFTs",
            "codeOnlyTokens": 821,
            "startLine": 65,
            "endLine": 128,
            "type": ".sol_part_2",
            "isOversized": false
          },
          {
            "originalText": "    function burnToken(\n        address token,\n        int64 amount,\n        int64[] memory serialNumbers\n    ) external returns (int64 responseCode, int64 newTotalSupply);\n\n    /// Creates a Fungible Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @param initialTotalSupply Specifies the initial supply of tokens to be put in circulation. The\n    /// initial supply is sent to the Treasury Account. The supply is in the lowest denomination possible.\n    /// @param decimals the number of decimal places a token is divisible by\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createFungibleToken(\n        HederaToken memory token,\n        int64 initialTotalSupply,\n        int32 decimals\n    ) external payable returns (int64 responseCode, address tokenAddress);\n\n    /// Transfers tokens where the calling account/contract is implicitly the first entry in the token transfer list,\n    /// where the amount is the value needed to zero balance the transfers. Regular signing rules apply for sending\n    /// (positive amount) or receiving (negative amount)\n    /// @param token The token to transfer to/from\n    /// @param sender The sender for the transaction\n    /// @param recipient The receiver of the transaction\n    /// @param amount Non-negative value to send. a negative value will result in a failure.\n    function transferToken(\n        address token,\n        address sender,\n        address recipient,\n        int64 amount\n    ) external returns (int64 responseCode);\n\n    /// Operation to update token keys\n    /// @param token The token address\n    /// @param keys The token keys\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateTokenKeys(address token, TokenKey[] memory keys) external returns (int64 responseCode);\n}\n",
            "codeOnlyTokens": 407,
            "startLine": 129,
            "endLine": 168,
            "type": ".sol_part_3",
            "isOversized": false
          }
        ],
        "groupedChunks": [
          {
            "combinedText": "// File: lib/layer-zero/hts/IHederaTokenService.sol\n// Relevant file context:\n// Type: .sol\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.9 <0.9.0;\npragma experimental ABIEncoderV2;\n\ninterface IHederaTokenService {\n    /// Expiry properties of a Hedera token - second, autoRenewAccount, autoRenewPeriod\n    struct Expiry {\n        // The epoch second at which the token should expire; if an auto-renew account and period are\n        // specified, this is coerced to the current epoch second plus the autoRenewPeriod\n        int64 second;\n        // ID of an account which will be automatically charged to renew the token's expiration, at\n        // autoRenewPeriod interval, expressed as a solidity address\n        address autoRenewAccount;\n        // The interval at which the auto-renew account will be charged to extend the token's expiry\n        int64 autoRenewPeriod;\n    }\n\n    /// A Key can be a public key from either the Ed25519 or ECDSA(secp256k1) signature schemes, where\n    /// in the ECDSA(secp256k1) case we require the 33-byte compressed form of the public key. We call\n    /// these public keys <b>primitive keys</b>.\n    /// A Key can also be the ID of a smart contract instance, which is then authorized to perform any\n    /// precompiled contract action that requires this key to sign.\n    /// Note that when a Key is a smart contract ID, it <i>doesn't</i> mean the contract with that ID\n    /// will actually create a cryptographic signature. It only means that when the contract calls a\n    /// precompiled contract, the resulting \"child transaction\" will be authorized to perform any action\n    /// controlled by the Key.\n    /// Exactly one of the possible values should be populated in order for the Key to be valid.\n    struct KeyValue {\n        // if set to true, the key of the calling Hedera account will be inherited as the token key\n        bool inheritAccountKey;\n        // smart contract instance that is authorized as if it had signed with a key\n        address contractId;\n        // Ed25519 public key bytes\n        bytes ed25519;\n        // Compressed ECDSA(secp256k1) public key bytes\n        bytes ECDSA_secp256k1;\n        // A smart contract that, if the recipient of the active message frame, should be treated\n        // as having signed. (Note this does not mean the <i>code being executed in the frame</i>\n        // will belong to the given contract, since it could be running another contract's code via\n        // <tt>delegatecall</tt>. So setting this key is a more permissive version of setting the\n        // contractID key, which also requires the code in the active message frame belong to the\n        // the contract with the given id.)\n        address delegatableContractId;\n    }\n\n    /// A list of token key types the key should be applied to and the value of the key\n    struct TokenKey {\n        // bit field representing the key type. Keys of all types that have corresponding bits set to 1\n        // will be created for the token.\n        // 0th bit: adminKey\n        // 1st bit: kycKey\n        // 2nd bit: freezeKey\n        // 3rd bit: wipeKey\n        // 4th bit: supplyKey\n        // 5th bit: feeScheduleKey\n        // 6th bit: pauseKey\n        // 7th bit: ignored\n        uint keyType;\n        // the value that will be set to the key type\n        KeyValue key;\n    }\n\n    /// Basic properties of a Hedera Token - name, symbol, memo, tokenSupplyType, maxSupply,\n    /// treasury, freezeDefault. These properties are related both to Fungible and NFT token types.\n    struct HederaToken {\n        // The publicly visible name of the token. The token name is specified as a Unicode string.\n        // Its UTF-8 encoding cannot exceed 100 bytes, and cannot contain the 0 byte (NUL).\n        string name;\n        // The publicly visible token symbol. The token symbol is specified as a Unicode string.\n        // Its UTF-8 encoding cannot exceed 100 bytes, and cannot contain the 0 byte (NUL).\n        string symbol;\n        // The ID of the account which will act as a treasury for the token as a solidity address.\n        // This account will receive the specified initial supply or the newly minted NFTs in\n        // the case for NON_FUNGIBLE_UNIQUE Type\n        address treasury;\n        // The memo associated with the token (UTF-8 encoding max 100 bytes)\n        string memo;\n        // IWA compatibility. Specified the token supply type. Defaults to INFINITE\n        bool tokenSupplyType;\n        // IWA Compatibility. Depends on TokenSupplyType. For tokens of type FUNGIBLE_COMMON - the\n        // maximum number of tokens that can be in circulation. For tokens of type NON_FUNGIBLE_UNIQUE -\n        // the maximum number of NFTs (serial numbers) that can be minted. This field can never be changed!\n        int64 maxSupply;\n        // The default Freeze status (frozen or unfrozen) of Hedera accounts relative to this token. If\n        // true, an account must be unfrozen before it can receive the token\n        bool freezeDefault;\n        // list of keys to set to the token\n        TokenKey[] tokenKeys;\n        // expiry properties of a Hedera token - second, autoRenewAccount, autoRenewPeriod\n        Expiry expiry;\n    }\n\n    /**********************\n     * Direct HTS Calls   *\n     **********************/\n\n    /// Mints an amount of the token to the defined treasury account\n    /// @param token The token for which to mint tokens. If token does not exist, transaction results in\n    ///              INVALID_TOKEN_ID\n    /// @param amount Applicable to tokens of type FUNGIBLE_COMMON. The amount to mint to the Treasury Account.\n    ///               Amount must be a positive non-zero number represented in the lowest denomination of the\n    ///               token. The new supply must be lower than 2^63.\n    /// @param metadata Applicable to tokens of type NON_FUNGIBLE_UNIQUE. A list of metadata that are being created.\n    ///                 Maximum allowed size of each metadata is 100 bytes\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return newTotalSupply The new supply of tokens. For NFTs it is the total count of NFTs\n    /// @return serialNumbers If the token is an NFT the newly generate serial numbers, othersise empty.\n    function mintToken(\n        address token,\n        int64 amount,\n        bytes[] memory metadata\n    )\n        external\n        returns (\n            int64 responseCode,\n            int64 newTotalSupply,\n            int64[] memory serialNumbers\n        );\n\n    /// Burns an amount of the token from the defined treasury account\n    /// @param token The token for which to burn tokens. If token does not exist, transaction results in\n    ///              INVALID_TOKEN_ID\n    /// @param amount  Applicable to tokens of type FUNGIBLE_COMMON. The amount to burn from the Treasury Account.\n    ///                Amount must be a positive non-zero number, not bigger than the token balance of the treasury\n    ///                account (0; balance], represented in the lowest denomination.\n    /// @param serialNumbers Applicable to tokens of type NON_FUNGIBLE_UNIQUE. The list of serial numbers to be burned.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return newTotalSupply The new supply of tokens. For NFTs it is the total count of NFTs\n    function burnToken(\n        address token,\n        int64 amount,\n        int64[] memory serialNumbers\n    ) external returns (int64 responseCode, int64 newTotalSupply);\n\n    /// Creates a Fungible Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @param initialTotalSupply Specifies the initial supply of tokens to be put in circulation. The\n    /// initial supply is sent to the Treasury Account. The supply is in the lowest denomination possible.\n    /// @param decimals the number of decimal places a token is divisible by\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createFungibleToken(\n        HederaToken memory token,\n        int64 initialTotalSupply,\n        int32 decimals\n    ) external payable returns (int64 responseCode, address tokenAddress);\n\n    /// Transfers tokens where the calling account/contract is implicitly the first entry in the token transfer list,\n    /// where the amount is the value needed to zero balance the transfers. Regular signing rules apply for sending\n    /// (positive amount) or receiving (negative amount)\n    /// @param token The token to transfer to/from\n    /// @param sender The sender for the transaction\n    /// @param recipient The receiver of the transaction\n    /// @param amount Non-negative value to send. a negative value will result in a failure.\n    function transferToken(\n        address token,\n        address sender,\n        address recipient,\n        int64 amount\n    ) external returns (int64 responseCode);\n\n    /// Operation to update token keys\n    /// @param token The token address\n    /// @param keys The token keys\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateTokenKeys(address token, TokenKey[] memory keys) external returns (int64 responseCode);\n}\n",
            "totalTokens": 2075,
            "chunks": [
              {
                "originalText": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.9 <0.9.0;\npragma experimental ABIEncoderV2;\n\ninterface IHederaTokenService {\n    /// Expiry properties of a Hedera token - second, autoRenewAccount, autoRenewPeriod\n    struct Expiry {\n        // The epoch second at which the token should expire; if an auto-renew account and period are\n        // specified, this is coerced to the current epoch second plus the autoRenewPeriod\n        int64 second;\n        // ID of an account which will be automatically charged to renew the token's expiration, at\n        // autoRenewPeriod interval, expressed as a solidity address\n        address autoRenewAccount;\n        // The interval at which the auto-renew account will be charged to extend the token's expiry\n        int64 autoRenewPeriod;\n    }\n\n    /// A Key can be a public key from either the Ed25519 or ECDSA(secp256k1) signature schemes, where\n    /// in the ECDSA(secp256k1) case we require the 33-byte compressed form of the public key. We call\n    /// these public keys <b>primitive keys</b>.\n    /// A Key can also be the ID of a smart contract instance, which is then authorized to perform any\n    /// precompiled contract action that requires this key to sign.\n    /// Note that when a Key is a smart contract ID, it <i>doesn't</i> mean the contract with that ID\n    /// will actually create a cryptographic signature. It only means that when the contract calls a\n    /// precompiled contract, the resulting \"child transaction\" will be authorized to perform any action\n    /// controlled by the Key.\n    /// Exactly one of the possible values should be populated in order for the Key to be valid.\n    struct KeyValue {\n        // if set to true, the key of the calling Hedera account will be inherited as the token key\n        bool inheritAccountKey;\n        // smart contract instance that is authorized as if it had signed with a key\n        address contractId;\n        // Ed25519 public key bytes\n        bytes ed25519;\n        // Compressed ECDSA(secp256k1) public key bytes\n        bytes ECDSA_secp256k1;\n        // A smart contract that, if the recipient of the active message frame, should be treated\n        // as having signed. (Note this does not mean the <i>code being executed in the frame</i>\n        // will belong to the given contract, since it could be running another contract's code via\n        // <tt>delegatecall</tt>. So setting this key is a more permissive version of setting the\n        // contractID key, which also requires the code in the active message frame belong to the\n        // the contract with the given id.)\n        address delegatableContractId;\n    }\n\n    /// A list of token key types the key should be applied to and the value of the key\n    struct TokenKey {\n        // bit field representing the key type. Keys of all types that have corresponding bits set to 1\n        // will be created for the token.\n        // 0th bit: adminKey\n        // 1st bit: kycKey\n        // 2nd bit: freezeKey\n        // 3rd bit: wipeKey\n        // 4th bit: supplyKey\n        // 5th bit: feeScheduleKey\n        // 6th bit: pauseKey\n        // 7th bit: ignored\n        uint keyType;\n        // the value that will be set to the key type\n        KeyValue key;\n    }\n\n    /// Basic properties of a Hedera Token - name, symbol, memo, tokenSupplyType, maxSupply,\n    /// treasury, freezeDefault. These properties are related both to Fungible and NFT token types.\n    struct HederaToken {\n        // The publicly visible name of the token. The token name is specified as a Unicode string.\n        // Its UTF-8 encoding cannot exceed 100 bytes, and cannot contain the 0 byte (NUL).\n        string name;\n        // The publicly visible token symbol. The token symbol is specified as a Unicode string.\n        // Its UTF-8 encoding cannot exceed 100 bytes, and cannot contain the 0 byte (NUL).\n        string symbol;\n        // The ID of the account which will act as a treasury for the token as a solidity address.\n        // This account will receive the specified initial supply or the newly minted NFTs in\n        // the case for NON_FUNGIBLE_UNIQUE Type\n        address treasury;\n        // The memo associated with the token (UTF-8 encoding max 100 bytes)\n        string memo;\n        // IWA compatibility. Specified the token supply type. Defaults to INFINITE\n        bool tokenSupplyType;\n        // IWA Compatibility. Depends on TokenSupplyType. For tokens of type FUNGIBLE_COMMON - the\n        // maximum number of tokens that can be in circulation. For tokens of type NON_FUNGIBLE_UNIQUE -\n        // the maximum number of NFTs (serial numbers) that can be minted. This field can never be changed!\n        int64 maxSupply;\n        // The default Freeze status (frozen or unfrozen) of Hedera accounts relative to this token. If\n        // true, an account must be unfrozen before it can receive the token\n        bool freezeDefault;\n        // list of keys to set to the token\n        TokenKey[] tokenKeys;\n        // expiry properties of a Hedera token - second, autoRenewAccount, autoRenewPeriod\n        Expiry expiry;\n    }\n\n    /**********************\n     * Direct HTS Calls   *\n     **********************/\n\n    /// Mints an amount of the token to the defined treasury account\n    /// @param token The token for which to mint tokens. If token does not exist, transaction results in\n    ///              INVALID_TOKEN_ID\n    /// @param amount Applicable to tokens of type FUNGIBLE_COMMON. The amount to mint to the Treasury Account.\n    ///               Amount must be a positive non-zero number represented in the lowest denomination of the\n    ///               token. The new supply must be lower than 2^63.\n    /// @param metadata Applicable to tokens of type NON_FUNGIBLE_UNIQUE. A list of metadata that are being created.\n    ///                 Maximum allowed size of each metadata is 100 bytes\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return newTotalSupply The new supply of tokens. For NFTs it is the total count of NFTs\n    /// @return serialNumbers If the token is an NFT the newly generate serial numbers, othersise empty.\n    function mintToken(\n        address token,\n        int64 amount,\n        bytes[] memory metadata\n    )\n        external\n        returns (\n            int64 responseCode,\n            int64 newTotalSupply,\n            int64[] memory serialNumbers\n        );\n\n    /// Burns an amount of the token from the defined treasury account\n    /// @param token The token for which to burn tokens. If token does not exist, transaction results in\n    ///              INVALID_TOKEN_ID\n    /// @param amount  Applicable to tokens of type FUNGIBLE_COMMON. The amount to burn from the Treasury Account.\n    ///                Amount must be a positive non-zero number, not bigger than the token balance of the treasury\n    ///                account (0; balance], represented in the lowest denomination.\n    /// @param serialNumbers Applicable to tokens of type NON_FUNGIBLE_UNIQUE. The list of serial numbers to be burned.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return newTotalSupply The new supply of tokens. For NFTs it is the total count of NFTs\n    function burnToken(\n        address token,\n        int64 amount,\n        int64[] memory serialNumbers\n    ) external returns (int64 responseCode, int64 newTotalSupply);\n\n    /// Creates a Fungible Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @param initialTotalSupply Specifies the initial supply of tokens to be put in circulation. The\n    /// initial supply is sent to the Treasury Account. The supply is in the lowest denomination possible.\n    /// @param decimals the number of decimal places a token is divisible by\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createFungibleToken(\n        HederaToken memory token,\n        int64 initialTotalSupply,\n        int32 decimals\n    ) external payable returns (int64 responseCode, address tokenAddress);\n\n    /// Transfers tokens where the calling account/contract is implicitly the first entry in the token transfer list,\n    /// where the amount is the value needed to zero balance the transfers. Regular signing rules apply for sending\n    /// (positive amount) or receiving (negative amount)\n    /// @param token The token to transfer to/from\n    /// @param sender The sender for the transaction\n    /// @param recipient The receiver of the transaction\n    /// @param amount Non-negative value to send. a negative value will result in a failure.\n    function transferToken(\n        address token,\n        address sender,\n        address recipient,\n        int64 amount\n    ) external returns (int64 responseCode);\n\n    /// Operation to update token keys\n    /// @param token The token address\n    /// @param keys The token keys\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateTokenKeys(address token, TokenKey[] memory keys) external returns (int64 responseCode);\n}\n",
                "codeOnlyTokens": 2047,
                "startLine": 1,
                "endLine": 168,
                "type": "full_file",
                "isOversized": false
              }
            ],
            "startLine": 1,
            "endLine": 168,
            "groupId": 1
          }
        ],
        "oversizedChunks": [],
        "sendStrategy": "full_file",
        "finalTokenCount": 2075,
        "skippedContent": [],
        "contextHeader": "// File: lib/layer-zero/hts/IHederaTokenService.sol\n// Relevant file context:\n// Type: .sol\n",
        "tokenBreakdown": {
          "originalFile": 2047,
          "finalSent": 2075,
          "codeTokensInGroups": 2047,
          "fileHeaderTokensInGroups": 28,
          "shellContextTokensInGroups": 0,
          "separatorTokensInGroups": 0,
          "skippedCodeTokens": 0,
          "unprocessedOversizedTokens": 0,
          "totalSavings": -28,
          "savingsPercentage": -1.3678553981436248,
          "fileHeaderCount": 1,
          "fileHeaderAvgSize": 28,
          "shellContextCount": 0,
          "shellContextAvgSize": 0,
          "separatorCount": 1,
          "separatorAvgSize": 0
        }
      }
    },
    {
      "filePath": "contracts/system-contracts/exchange-rate/ExchangeRateSystemContract.sol",
      "totalOriginalTokens": 191,
      "finalTokenCount": 218,
      "impactScore": 46,
      "averageComplexity": 6,
      "averageQuality": 7.666666666666667,
      "usage": {
        "prompt_tokens": 287,
        "completion_tokens": 177,
        "total_tokens": 464
      },
      "retries": 0,
      "hadError": false,
      "scoredChunkGroups": [
        {
          "groupId": 1,
          "score": {
            "file_path": "contracts/system-contracts/exchange-rate/ExchangeRateSystemContract.sol",
            "complexity_score": 6,
            "code_quality_score": 8,
            "maintainability_score": 6,
            "best_practices_adherence": 9,
            "web3_pattern_identification": "",
            "hedera_red_flag": {
              "description": "The 'invalidCall' function uses a hardcoded precompile address without validation, which may be unsafe.",
              "exact_code_snippet": "address PRECOMPILE_ADDRESS"
            },
            "hedera_optimization_suggestion": {
              "description": "Ensure that the toll value in the constructor is checked against realistic network costs to avoid potential denial of service.",
              "exact_code_snippet": "constructor(uint256 _toll) { toll = _toll; }"
            },
            "positive_feedback": "The gated access method with tolls showcases an innovative approach to funding the Hedera network while controlling access based on payment.",
            "group_summary": "This smart contract extends a self-funding model to handle exchange rates, providing conversion utilities while enforcing fees for access, enhancing the economic model of the application."
          },
          "totalTokens": 218,
          "usage": {
            "prompt_tokens": 287,
            "completion_tokens": 177,
            "total_tokens": 464
          }
        }
      ],
      "chunkingDetails": {
        "filePath": "contracts/system-contracts/exchange-rate/ExchangeRateSystemContract.sol",
        "totalFileTokens": 191,
        "chunks": [
          {
            "originalText": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.5.0 <0.9.0;\n\nimport \"./SelfFunding.sol\";\n\n\ncontract ExchangeRateSystemContract is SelfFunding {\n    // The USD in cents that must be sent as msg.value\n    uint256 toll;\n\n    constructor(uint256 _toll) {\n        toll = _toll;\n    }\n\n    function gatedAccess() external payable costsCents(toll) {\n        // Hope it was worth it!\n    }\n\n    function approxUsdValue() external payable returns (uint256 tinycents) {\n        tinycents = tinybarsToTinycents(msg.value);\n    }\n\n    function invalidCall() external payable {\n        // Should fail, this is not a valid selector \n        (bool success, ) = PRECOMPILE_ADDRESS.call(\n            abi.encodeWithSelector(ExchangeRateSystemContract.approxUsdValue.selector));\n        require(success);\n    }\n}\n",
            "codeOnlyTokens": 191,
            "startLine": 1,
            "endLine": 30,
            "type": ".sol",
            "isOversized": false
          }
        ],
        "groupedChunks": [
          {
            "combinedText": "// File: contracts/system-contracts/exchange-rate/ExchangeRateSystemContract.sol\n// Relevant file context:\n// Type: .sol\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.5.0 <0.9.0;\n\nimport \"./SelfFunding.sol\";\n\n\ncontract ExchangeRateSystemContract is SelfFunding {\n    // The USD in cents that must be sent as msg.value\n    uint256 toll;\n\n    constructor(uint256 _toll) {\n        toll = _toll;\n    }\n\n    function gatedAccess() external payable costsCents(toll) {\n        // Hope it was worth it!\n    }\n\n    function approxUsdValue() external payable returns (uint256 tinycents) {\n        tinycents = tinybarsToTinycents(msg.value);\n    }\n\n    function invalidCall() external payable {\n        // Should fail, this is not a valid selector \n        (bool success, ) = PRECOMPILE_ADDRESS.call(\n            abi.encodeWithSelector(ExchangeRateSystemContract.approxUsdValue.selector));\n        require(success);\n    }\n}\n",
            "totalTokens": 218,
            "chunks": [
              {
                "originalText": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.5.0 <0.9.0;\n\nimport \"./SelfFunding.sol\";\n\n\ncontract ExchangeRateSystemContract is SelfFunding {\n    // The USD in cents that must be sent as msg.value\n    uint256 toll;\n\n    constructor(uint256 _toll) {\n        toll = _toll;\n    }\n\n    function gatedAccess() external payable costsCents(toll) {\n        // Hope it was worth it!\n    }\n\n    function approxUsdValue() external payable returns (uint256 tinycents) {\n        tinycents = tinybarsToTinycents(msg.value);\n    }\n\n    function invalidCall() external payable {\n        // Should fail, this is not a valid selector \n        (bool success, ) = PRECOMPILE_ADDRESS.call(\n            abi.encodeWithSelector(ExchangeRateSystemContract.approxUsdValue.selector));\n        require(success);\n    }\n}\n",
                "codeOnlyTokens": 191,
                "startLine": 1,
                "endLine": 30,
                "type": "full_file",
                "isOversized": false
              }
            ],
            "startLine": 1,
            "endLine": 30,
            "groupId": 1
          }
        ],
        "oversizedChunks": [],
        "sendStrategy": "full_file",
        "finalTokenCount": 218,
        "skippedContent": [],
        "contextHeader": "// File: contracts/system-contracts/exchange-rate/ExchangeRateSystemContract.sol\n// Relevant file context:\n// Type: .sol\n",
        "tokenBreakdown": {
          "originalFile": 191,
          "finalSent": 218,
          "codeTokensInGroups": 191,
          "fileHeaderTokensInGroups": 27,
          "shellContextTokensInGroups": 0,
          "separatorTokensInGroups": 0,
          "skippedCodeTokens": 0,
          "unprocessedOversizedTokens": 0,
          "totalSavings": -27,
          "savingsPercentage": -14.136125654450263,
          "fileHeaderCount": 1,
          "fileHeaderAvgSize": 27,
          "shellContextCount": 0,
          "shellContextAvgSize": 0,
          "separatorCount": 1,
          "separatorAvgSize": 0
        }
      }
    },
    {
      "filePath": "system-contract-dapp-playground/src/components/contract-interaction/hts/token-create-custom/methods/index.tsx",
      "totalOriginalTokens": 256,
      "finalTokenCount": 294,
      "impactScore": 43.33333333333333,
      "averageComplexity": 5,
      "averageQuality": 8.666666666666666,
      "usage": {
        "prompt_tokens": 356,
        "completion_tokens": 241,
        "total_tokens": 597
      },
      "retries": 0,
      "hadError": false,
      "scoredChunkGroups": [
        {
          "groupId": 1,
          "score": {
            "file_path": "system-contract-dapp-playground/src/components/contract-interaction/hts/token-create-custom/methods/index.tsx",
            "complexity_score": 5,
            "code_quality_score": 9,
            "maintainability_score": 8,
            "best_practices_adherence": 9,
            "web3_pattern_identification": "Component Composition",
            "hedera_red_flag": null,
            "hedera_optimization_suggestion": {
              "description": "Consider using a mapping for method components to reduce if-else bloat and improve scalability.",
              "exact_code_snippet": "return (<>{method === 'mint' && <MintHederaToken baseContract={baseContract} />}</>);"
            },
            "positive_feedback": "The modular design with separate components for each function provides excellent clarity and organization.",
            "group_summary": "This React component encapsulates methods for creating and interacting with Hedera tokens while maintaining a clean and structured interface."
          },
          "totalTokens": 294,
          "usage": {
            "prompt_tokens": 356,
            "completion_tokens": 241,
            "total_tokens": 597
          }
        }
      ],
      "chunkingDetails": {
        "filePath": "system-contract-dapp-playground/src/components/contract-interaction/hts/token-create-custom/methods/index.tsx",
        "totalFileTokens": 256,
        "chunks": [
          {
            "originalText": "// SPDX-License-Identifier: Apache-2.0\n\nimport { Contract } from 'ethers';\nimport GrantTokenKYC from './GrantTokenKYC';\nimport MintHederaToken from './MintHederaToken';\nimport FungibleTokenCreate from './FungibleTokenCreate';\nimport AssociateHederaToken from './AssociateHederaToken';\nimport NonFungibleTokenCreate from './NonFungibleTokenCreate';\n\ninterface PageProps {\n  method: string;\n  baseContract: Contract;\n}\n\nconst HederaTokenCreateMethods = ({ baseContract, method }: PageProps) => {\n  return (\n    <>\n      {method === 'mint' && <MintHederaToken baseContract={baseContract} />}\n      {method === 'grantKYC' && <GrantTokenKYC baseContract={baseContract} />}\n      {method === 'tokenAssociation' && <AssociateHederaToken baseContract={baseContract} />}\n      {method === 'fungibleTokenCreate' && <FungibleTokenCreate baseContract={baseContract} />}\n      {method === 'non-fungibleTokenCreate' && <NonFungibleTokenCreate baseContract={baseContract} />}\n    </>\n  );\n};\n\nexport default HederaTokenCreateMethods;\n",
            "codeOnlyTokens": 256,
            "startLine": 1,
            "endLine": 28,
            "type": ".tsx",
            "isOversized": false
          }
        ],
        "groupedChunks": [
          {
            "combinedText": "// File: system-contract-dapp-playground/src/components/contract-interaction/hts/token-create-custom/methods/index.tsx\n// Relevant file context:\n// Type: .tsx\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Contract } from 'ethers';\nimport GrantTokenKYC from './GrantTokenKYC';\nimport MintHederaToken from './MintHederaToken';\nimport FungibleTokenCreate from './FungibleTokenCreate';\nimport AssociateHederaToken from './AssociateHederaToken';\nimport NonFungibleTokenCreate from './NonFungibleTokenCreate';\n\ninterface PageProps {\n  method: string;\n  baseContract: Contract;\n}\n\nconst HederaTokenCreateMethods = ({ baseContract, method }: PageProps) => {\n  return (\n    <>\n      {method === 'mint' && <MintHederaToken baseContract={baseContract} />}\n      {method === 'grantKYC' && <GrantTokenKYC baseContract={baseContract} />}\n      {method === 'tokenAssociation' && <AssociateHederaToken baseContract={baseContract} />}\n      {method === 'fungibleTokenCreate' && <FungibleTokenCreate baseContract={baseContract} />}\n      {method === 'non-fungibleTokenCreate' && <NonFungibleTokenCreate baseContract={baseContract} />}\n    </>\n  );\n};\n\nexport default HederaTokenCreateMethods;\n",
            "totalTokens": 294,
            "chunks": [
              {
                "originalText": "// SPDX-License-Identifier: Apache-2.0\n\nimport { Contract } from 'ethers';\nimport GrantTokenKYC from './GrantTokenKYC';\nimport MintHederaToken from './MintHederaToken';\nimport FungibleTokenCreate from './FungibleTokenCreate';\nimport AssociateHederaToken from './AssociateHederaToken';\nimport NonFungibleTokenCreate from './NonFungibleTokenCreate';\n\ninterface PageProps {\n  method: string;\n  baseContract: Contract;\n}\n\nconst HederaTokenCreateMethods = ({ baseContract, method }: PageProps) => {\n  return (\n    <>\n      {method === 'mint' && <MintHederaToken baseContract={baseContract} />}\n      {method === 'grantKYC' && <GrantTokenKYC baseContract={baseContract} />}\n      {method === 'tokenAssociation' && <AssociateHederaToken baseContract={baseContract} />}\n      {method === 'fungibleTokenCreate' && <FungibleTokenCreate baseContract={baseContract} />}\n      {method === 'non-fungibleTokenCreate' && <NonFungibleTokenCreate baseContract={baseContract} />}\n    </>\n  );\n};\n\nexport default HederaTokenCreateMethods;\n",
                "codeOnlyTokens": 256,
                "startLine": 1,
                "endLine": 28,
                "type": "full_file",
                "isOversized": false
              }
            ],
            "startLine": 1,
            "endLine": 28,
            "groupId": 1
          }
        ],
        "oversizedChunks": [],
        "sendStrategy": "full_file",
        "finalTokenCount": 294,
        "skippedContent": [],
        "contextHeader": "// File: system-contract-dapp-playground/src/components/contract-interaction/hts/token-create-custom/methods/index.tsx\n// Relevant file context:\n// Type: .tsx\n",
        "tokenBreakdown": {
          "originalFile": 256,
          "finalSent": 294,
          "codeTokensInGroups": 256,
          "fileHeaderTokensInGroups": 38,
          "shellContextTokensInGroups": 0,
          "separatorTokensInGroups": 0,
          "skippedCodeTokens": 0,
          "unprocessedOversizedTokens": 0,
          "totalSavings": -38,
          "savingsPercentage": -14.84375,
          "fileHeaderCount": 1,
          "fileHeaderAvgSize": 38,
          "shellContextCount": 0,
          "shellContextAvgSize": 0,
          "separatorCount": 1,
          "separatorAvgSize": 0
        }
      }
    },
    {
      "filePath": "contracts/system-contracts/hedera-token-service/examples/token-transfer/TokenTransferContract.sol",
      "totalOriginalTokens": 937,
      "finalTokenCount": 968,
      "impactScore": 42,
      "averageComplexity": 6,
      "averageQuality": 7,
      "usage": {
        "prompt_tokens": 1273,
        "completion_tokens": 177,
        "total_tokens": 1450
      },
      "retries": 0,
      "hadError": false,
      "scoredChunkGroups": [
        {
          "groupId": 1,
          "score": {
            "file_path": "contracts/system-contracts/hedera-token-service/examples/token-transfer/TokenTransferContract.sol",
            "complexity_score": 6,
            "code_quality_score": 7,
            "maintainability_score": 6,
            "best_practices_adherence": 8,
            "web3_pattern_identification": "Checks-Effects-Interactions",
            "hedera_red_flag": {
              "description": "No visibility modifiers specified on public functions.",
              "exact_code_snippet": "function cryptoTransferPublic(IHederaTokenService.TransferList calldata transferList, IHederaTokenService.TokenTransferList[] calldata tokenTransferList) public returns (int responseCode) {"
            },
            "hedera_optimization_suggestion": {
              "description": "The contract can benefit from a single function that consolidates multiple token transfer calls to reduce gas costs.",
              "exact_code_snippet": "responseCode = HederaTokenService.cryptoTransfer(transferList, tokenTransferList);"
            },
            "positive_feedback": "The use of multiple transfer methods (tokens and NFTs) makes this contract versatile and shows a well-thought-out approach to Hedera's token services.",
            "group_summary": "This contract facilitates various token transfer operations using Hedera's Token Service, enhancing interoperability and user experience."
          },
          "totalTokens": 968,
          "usage": {
            "prompt_tokens": 1273,
            "completion_tokens": 177,
            "total_tokens": 1450
          }
        }
      ],
      "chunkingDetails": {
        "filePath": "contracts/system-contracts/hedera-token-service/examples/token-transfer/TokenTransferContract.sol",
        "totalFileTokens": 937,
        "chunks": [
          {
            "originalText": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.5.0 <0.9.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../HederaTokenService.sol\";\nimport \"../../ExpiryHelper.sol\";\nimport \"../../KeyHelper.sol\";\n\ncontract TokenTransferContract is HederaTokenService, ExpiryHelper, KeyHelper {\n\n    event ResponseCode(int responseCode);\n\n    function cryptoTransferPublic(IHederaTokenService.TransferList calldata transferList, IHederaTokenService.TokenTransferList[] calldata tokenTransferList) public returns (int responseCode) {\n        responseCode = HederaTokenService.cryptoTransfer(transferList, tokenTransferList);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n    }\n\n    function transferTokensPublic(address token, address[] memory accountId, int64[] memory amount) external returns (int256 responseCode) {\n        responseCode = HederaTokenService.transferTokens(token, accountId, amount);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert ();\n        }\n    }\n\n    function transferNFTsPublic(address token, address[] memory sender, address[] memory receiver, int64[] memory serialNumber) external returns (int256 responseCode) {\n        responseCode = HederaTokenService.transferNFTs(token, sender, receiver, serialNumber);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert ();\n        }\n    }\n\n    function transferTokenPublic(address token, address sender, address receiver, int64 amount) public returns (int responseCode) {\n        responseCode = HederaTokenService.transferToken(token, sender, receiver, amount);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n    }\n\n    function transferNFTPublic(address token, address sender, address receiver, int64 serialNumber) public returns (int responseCode) {\n        responseCode = HederaTokenService.transferNFT(token, sender, receiver, serialNumber);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert ();\n        }\n    }\n\n    function transferFromPublic(address token, address from, address to, uint256 amount) public returns (int64 responseCode) {\n        responseCode = this.transferFrom(token, from, to, amount);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert ();\n        }\n    }\n\n    function transferFromNFTPublic(address token, address from, address to, uint256 serialNumber) public returns (int64 responseCode) {\n        responseCode = this.transferFromNFT(token, from, to, serialNumber);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert ();\n        }\n    }\n\n    function setApprovalForAllPublic(address token, address operator, bool approved) public returns (int responseCode) {\n        responseCode = HederaTokenService.setApprovalForAll(token, operator, approved);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n    }\n\n    function approvePublic(address token, address spender, uint256 amount) public returns (int responseCode) {\n    responseCode = HederaTokenService.approve(token, spender, amount);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert ();\n        }\n    }\n\n    function approveNFTPublic(address token, address approved, uint256 serialNumber) public returns (int responseCode) {\n        responseCode = HederaTokenService.approveNFT(token, approved, serialNumber);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {",
            "codeOnlyTokens": 800,
            "startLine": 1,
            "endLine": 98,
            "type": ".sol_part_1",
            "isOversized": false
          },
          {
            "originalText": "            revert ();\n        }\n    }\n\n    function grantTokenKycPublic(address token, address account) external returns (int64 responseCode) {\n        (responseCode) = HederaTokenService.grantTokenKyc(token, account);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n    }\n\n    function associateTokenPublic(address account, address token) public returns (int responseCode) {\n        responseCode = HederaTokenService.associateToken(account, token);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert ();\n        }\n    }\n}\n",
            "codeOnlyTokens": 137,
            "startLine": 99,
            "endLine": 121,
            "type": ".sol_part_2",
            "isOversized": false
          }
        ],
        "groupedChunks": [
          {
            "combinedText": "// File: contracts/system-contracts/hedera-token-service/examples/token-transfer/TokenTransferContract.sol\n// Relevant file context:\n// Type: .sol\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.5.0 <0.9.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../HederaTokenService.sol\";\nimport \"../../ExpiryHelper.sol\";\nimport \"../../KeyHelper.sol\";\n\ncontract TokenTransferContract is HederaTokenService, ExpiryHelper, KeyHelper {\n\n    event ResponseCode(int responseCode);\n\n    function cryptoTransferPublic(IHederaTokenService.TransferList calldata transferList, IHederaTokenService.TokenTransferList[] calldata tokenTransferList) public returns (int responseCode) {\n        responseCode = HederaTokenService.cryptoTransfer(transferList, tokenTransferList);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n    }\n\n    function transferTokensPublic(address token, address[] memory accountId, int64[] memory amount) external returns (int256 responseCode) {\n        responseCode = HederaTokenService.transferTokens(token, accountId, amount);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert ();\n        }\n    }\n\n    function transferNFTsPublic(address token, address[] memory sender, address[] memory receiver, int64[] memory serialNumber) external returns (int256 responseCode) {\n        responseCode = HederaTokenService.transferNFTs(token, sender, receiver, serialNumber);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert ();\n        }\n    }\n\n    function transferTokenPublic(address token, address sender, address receiver, int64 amount) public returns (int responseCode) {\n        responseCode = HederaTokenService.transferToken(token, sender, receiver, amount);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n    }\n\n    function transferNFTPublic(address token, address sender, address receiver, int64 serialNumber) public returns (int responseCode) {\n        responseCode = HederaTokenService.transferNFT(token, sender, receiver, serialNumber);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert ();\n        }\n    }\n\n    function transferFromPublic(address token, address from, address to, uint256 amount) public returns (int64 responseCode) {\n        responseCode = this.transferFrom(token, from, to, amount);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert ();\n        }\n    }\n\n    function transferFromNFTPublic(address token, address from, address to, uint256 serialNumber) public returns (int64 responseCode) {\n        responseCode = this.transferFromNFT(token, from, to, serialNumber);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert ();\n        }\n    }\n\n    function setApprovalForAllPublic(address token, address operator, bool approved) public returns (int responseCode) {\n        responseCode = HederaTokenService.setApprovalForAll(token, operator, approved);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n    }\n\n    function approvePublic(address token, address spender, uint256 amount) public returns (int responseCode) {\n    responseCode = HederaTokenService.approve(token, spender, amount);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert ();\n        }\n    }\n\n    function approveNFTPublic(address token, address approved, uint256 serialNumber) public returns (int responseCode) {\n        responseCode = HederaTokenService.approveNFT(token, approved, serialNumber);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert ();\n        }\n    }\n\n    function grantTokenKycPublic(address token, address account) external returns (int64 responseCode) {\n        (responseCode) = HederaTokenService.grantTokenKyc(token, account);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n    }\n\n    function associateTokenPublic(address account, address token) public returns (int responseCode) {\n        responseCode = HederaTokenService.associateToken(account, token);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert ();\n        }\n    }\n}\n",
            "totalTokens": 968,
            "chunks": [
              {
                "originalText": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.5.0 <0.9.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../HederaTokenService.sol\";\nimport \"../../ExpiryHelper.sol\";\nimport \"../../KeyHelper.sol\";\n\ncontract TokenTransferContract is HederaTokenService, ExpiryHelper, KeyHelper {\n\n    event ResponseCode(int responseCode);\n\n    function cryptoTransferPublic(IHederaTokenService.TransferList calldata transferList, IHederaTokenService.TokenTransferList[] calldata tokenTransferList) public returns (int responseCode) {\n        responseCode = HederaTokenService.cryptoTransfer(transferList, tokenTransferList);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n    }\n\n    function transferTokensPublic(address token, address[] memory accountId, int64[] memory amount) external returns (int256 responseCode) {\n        responseCode = HederaTokenService.transferTokens(token, accountId, amount);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert ();\n        }\n    }\n\n    function transferNFTsPublic(address token, address[] memory sender, address[] memory receiver, int64[] memory serialNumber) external returns (int256 responseCode) {\n        responseCode = HederaTokenService.transferNFTs(token, sender, receiver, serialNumber);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert ();\n        }\n    }\n\n    function transferTokenPublic(address token, address sender, address receiver, int64 amount) public returns (int responseCode) {\n        responseCode = HederaTokenService.transferToken(token, sender, receiver, amount);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n    }\n\n    function transferNFTPublic(address token, address sender, address receiver, int64 serialNumber) public returns (int responseCode) {\n        responseCode = HederaTokenService.transferNFT(token, sender, receiver, serialNumber);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert ();\n        }\n    }\n\n    function transferFromPublic(address token, address from, address to, uint256 amount) public returns (int64 responseCode) {\n        responseCode = this.transferFrom(token, from, to, amount);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert ();\n        }\n    }\n\n    function transferFromNFTPublic(address token, address from, address to, uint256 serialNumber) public returns (int64 responseCode) {\n        responseCode = this.transferFromNFT(token, from, to, serialNumber);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert ();\n        }\n    }\n\n    function setApprovalForAllPublic(address token, address operator, bool approved) public returns (int responseCode) {\n        responseCode = HederaTokenService.setApprovalForAll(token, operator, approved);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n    }\n\n    function approvePublic(address token, address spender, uint256 amount) public returns (int responseCode) {\n    responseCode = HederaTokenService.approve(token, spender, amount);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert ();\n        }\n    }\n\n    function approveNFTPublic(address token, address approved, uint256 serialNumber) public returns (int responseCode) {\n        responseCode = HederaTokenService.approveNFT(token, approved, serialNumber);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert ();\n        }\n    }\n\n    function grantTokenKycPublic(address token, address account) external returns (int64 responseCode) {\n        (responseCode) = HederaTokenService.grantTokenKyc(token, account);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert();\n        }\n    }\n\n    function associateTokenPublic(address account, address token) public returns (int responseCode) {\n        responseCode = HederaTokenService.associateToken(account, token);\n        emit ResponseCode(responseCode);\n\n        if (responseCode != HederaResponseCodes.SUCCESS) {\n            revert ();\n        }\n    }\n}\n",
                "codeOnlyTokens": 937,
                "startLine": 1,
                "endLine": 121,
                "type": "full_file",
                "isOversized": false
              }
            ],
            "startLine": 1,
            "endLine": 121,
            "groupId": 1
          }
        ],
        "oversizedChunks": [],
        "sendStrategy": "full_file",
        "finalTokenCount": 968,
        "skippedContent": [],
        "contextHeader": "// File: contracts/system-contracts/hedera-token-service/examples/token-transfer/TokenTransferContract.sol\n// Relevant file context:\n// Type: .sol\n",
        "tokenBreakdown": {
          "originalFile": 937,
          "finalSent": 968,
          "codeTokensInGroups": 937,
          "fileHeaderTokensInGroups": 31,
          "shellContextTokensInGroups": 0,
          "separatorTokensInGroups": 0,
          "skippedCodeTokens": 0,
          "unprocessedOversizedTokens": 0,
          "totalSavings": -31,
          "savingsPercentage": -3.3084311632870866,
          "fileHeaderCount": 1,
          "fileHeaderAvgSize": 31,
          "shellContextCount": 0,
          "shellContextAvgSize": 0,
          "separatorCount": 1,
          "separatorAvgSize": 0
        }
      }
    },
    {
      "filePath": "contracts/system-contracts/exchange-rate/IExchangeRate.sol",
      "totalOriginalTokens": 366,
      "finalTokenCount": 391,
      "impactScore": 41.66666666666667,
      "averageComplexity": 5,
      "averageQuality": 8.333333333333334,
      "usage": {
        "prompt_tokens": 514,
        "completion_tokens": 177,
        "total_tokens": 691
      },
      "retries": 0,
      "hadError": false,
      "scoredChunkGroups": [
        {
          "groupId": 1,
          "score": {
            "file_path": "contracts/system-contracts/exchange-rate/IExchangeRate.sol",
            "complexity_score": 5,
            "code_quality_score": 9,
            "maintainability_score": 8,
            "best_practices_adherence": 8,
            "web3_pattern_identification": "",
            "hedera_red_flag": null,
            "hedera_optimization_suggestion": null,
            "positive_feedback": "The contract's purpose is clearly defined, providing essential conversions that enhance economic interactions on the Hedera network.",
            "group_summary": "This interface provides functions to convert tinycents and tinybars, which are essential for managing costs associated with transactions on the Hedera network."
          },
          "totalTokens": 391,
          "usage": {
            "prompt_tokens": 514,
            "completion_tokens": 177,
            "total_tokens": 691
          }
        }
      ],
      "chunkingDetails": {
        "filePath": "contracts/system-contracts/exchange-rate/IExchangeRate.sol",
        "totalFileTokens": 366,
        "chunks": [
          {
            "originalText": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.9 <0.9.0;\n\ninterface IExchangeRate {\n    // Given a value in tinycents (1e-8 US cents or 1e-10 USD), returns the\n    // equivalent value in tinybars (1e-8 HBAR) at the current exchange rate\n    // stored in system file 0.0.112.\n    //\n    // This rate is a weighted median of the the recent\" HBAR-USD exchange\n    // rate on major exchanges, but should _not_ be treated as a live price\n    // oracle! It is important primarily because the network will use it to\n    // compute the tinybar fees for the active transaction.\n    //\n    // So a \"self-funding\" contract can use this rate to compute how much\n    // tinybar its users must send to cover the Hedera fees for the transaction.\n    function tinycentsToTinybars(uint256 tinycents) external returns (uint256);\n\n    // Given a value in tinybars (1e-8 HBAR), returns the equivalent value in\n    // tinycents (1e-8 US cents or 1e-10 USD) at the current exchange rate\n    // stored in system file 0.0.112.\n    //\n    // This rate tracks the the HBAR-USD rate on public exchanges, but\n    // should _not_ be treated as a live price oracle! This conversion is\n    // less likely to be needed than the above conversion from tinycent to\n    // tinybars, but we include it for completeness.\n    function tinybarsToTinycents(uint256 tinybars) external returns (uint256);\n}\n",
            "codeOnlyTokens": 366,
            "startLine": 1,
            "endLine": 28,
            "type": ".sol",
            "isOversized": false
          }
        ],
        "groupedChunks": [
          {
            "combinedText": "// File: contracts/system-contracts/exchange-rate/IExchangeRate.sol\n// Relevant file context:\n// Type: .sol\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.9 <0.9.0;\n\ninterface IExchangeRate {\n    // Given a value in tinycents (1e-8 US cents or 1e-10 USD), returns the\n    // equivalent value in tinybars (1e-8 HBAR) at the current exchange rate\n    // stored in system file 0.0.112.\n    //\n    // This rate is a weighted median of the the recent\" HBAR-USD exchange\n    // rate on major exchanges, but should _not_ be treated as a live price\n    // oracle! It is important primarily because the network will use it to\n    // compute the tinybar fees for the active transaction.\n    //\n    // So a \"self-funding\" contract can use this rate to compute how much\n    // tinybar its users must send to cover the Hedera fees for the transaction.\n    function tinycentsToTinybars(uint256 tinycents) external returns (uint256);\n\n    // Given a value in tinybars (1e-8 HBAR), returns the equivalent value in\n    // tinycents (1e-8 US cents or 1e-10 USD) at the current exchange rate\n    // stored in system file 0.0.112.\n    //\n    // This rate tracks the the HBAR-USD rate on public exchanges, but\n    // should _not_ be treated as a live price oracle! This conversion is\n    // less likely to be needed than the above conversion from tinycent to\n    // tinybars, but we include it for completeness.\n    function tinybarsToTinycents(uint256 tinybars) external returns (uint256);\n}\n",
            "totalTokens": 391,
            "chunks": [
              {
                "originalText": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.9 <0.9.0;\n\ninterface IExchangeRate {\n    // Given a value in tinycents (1e-8 US cents or 1e-10 USD), returns the\n    // equivalent value in tinybars (1e-8 HBAR) at the current exchange rate\n    // stored in system file 0.0.112.\n    //\n    // This rate is a weighted median of the the recent\" HBAR-USD exchange\n    // rate on major exchanges, but should _not_ be treated as a live price\n    // oracle! It is important primarily because the network will use it to\n    // compute the tinybar fees for the active transaction.\n    //\n    // So a \"self-funding\" contract can use this rate to compute how much\n    // tinybar its users must send to cover the Hedera fees for the transaction.\n    function tinycentsToTinybars(uint256 tinycents) external returns (uint256);\n\n    // Given a value in tinybars (1e-8 HBAR), returns the equivalent value in\n    // tinycents (1e-8 US cents or 1e-10 USD) at the current exchange rate\n    // stored in system file 0.0.112.\n    //\n    // This rate tracks the the HBAR-USD rate on public exchanges, but\n    // should _not_ be treated as a live price oracle! This conversion is\n    // less likely to be needed than the above conversion from tinycent to\n    // tinybars, but we include it for completeness.\n    function tinybarsToTinycents(uint256 tinybars) external returns (uint256);\n}\n",
                "codeOnlyTokens": 366,
                "startLine": 1,
                "endLine": 28,
                "type": "full_file",
                "isOversized": false
              }
            ],
            "startLine": 1,
            "endLine": 28,
            "groupId": 1
          }
        ],
        "oversizedChunks": [],
        "sendStrategy": "full_file",
        "finalTokenCount": 391,
        "skippedContent": [],
        "contextHeader": "// File: contracts/system-contracts/exchange-rate/IExchangeRate.sol\n// Relevant file context:\n// Type: .sol\n",
        "tokenBreakdown": {
          "originalFile": 366,
          "finalSent": 391,
          "codeTokensInGroups": 366,
          "fileHeaderTokensInGroups": 25,
          "shellContextTokensInGroups": 0,
          "separatorTokensInGroups": 0,
          "skippedCodeTokens": 0,
          "unprocessedOversizedTokens": 0,
          "totalSavings": -25,
          "savingsPercentage": -6.830601092896176,
          "fileHeaderCount": 1,
          "fileHeaderAvgSize": 25,
          "shellContextCount": 0,
          "shellContextAvgSize": 0,
          "separatorCount": 1,
          "separatorAvgSize": 0
        }
      }
    },
    {
      "filePath": "contracts/system-contracts/pseudo-random-number-generator/PrngSystemContract.sol",
      "totalOriginalTokens": 170,
      "finalTokenCount": 200,
      "impactScore": 36.666666666666664,
      "averageComplexity": 5,
      "averageQuality": 7.333333333333333,
      "usage": {
        "prompt_tokens": 242,
        "completion_tokens": 233,
        "total_tokens": 475
      },
      "retries": 0,
      "hadError": false,
      "scoredChunkGroups": [
        {
          "groupId": 1,
          "score": {
            "file_path": "contracts/system-contracts/pseudo-random-number-generator/PrngSystemContract.sol",
            "complexity_score": 5,
            "code_quality_score": 7,
            "maintainability_score": 7,
            "best_practices_adherence": 8,
            "web3_pattern_identification": "Use of Precompiled Contracts",
            "hedera_red_flag": {
              "description": "The potential exposure of the `PRECOMPILE_ADDRESS` could lead to misuse if not properly secured.",
              "exact_code_snippet": "address constant PRECOMPILE_ADDRESS = address(0x169);"
            },
            "hedera_optimization_suggestion": {
              "description": "Consider implementing further validation checks to ensure that the retrieved pseudo-random seed meets specific criteria before use.",
              "exact_code_snippet": "return (success, result);"
            },
            "positive_feedback": "The use of events for emitting the pseudo-random seed allows for effective tracking and debugging.",
            "group_summary": "This contract interacts with the Hedera precompiled pseudo-random number generator to return a random seed for use in applications."
          },
          "totalTokens": 200,
          "usage": {
            "prompt_tokens": 242,
            "completion_tokens": 233,
            "total_tokens": 475
          }
        }
      ],
      "chunkingDetails": {
        "filePath": "contracts/system-contracts/pseudo-random-number-generator/PrngSystemContract.sol",
        "totalFileTokens": 170,
        "chunks": [
          {
            "originalText": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.5.0 <0.9.0;\n\nimport \"./IPrngSystemContract.sol\";\n\ncontract PrngSystemContract {\n    event PseudoRandomSeed(bytes32 seedBytes);\n\n    // Prng system contract address with ContractID 0.0.361\n    address constant PRECOMPILE_ADDRESS = address(0x169);\n\n    function getPseudorandomSeed() external returns (bytes32 seedBytes) {\n        (bool success, bytes memory result) = PRECOMPILE_ADDRESS.call(\n            abi.encodeWithSelector(IPrngSystemContract.getPseudorandomSeed.selector));\n        require(success, \"PRNG system call failed\");\n        seedBytes = abi.decode(result, (bytes32));\n        emit PseudoRandomSeed(seedBytes);\n    }\n}\n",
            "codeOnlyTokens": 170,
            "startLine": 1,
            "endLine": 20,
            "type": ".sol",
            "isOversized": false
          }
        ],
        "groupedChunks": [
          {
            "combinedText": "// File: contracts/system-contracts/pseudo-random-number-generator/PrngSystemContract.sol\n// Relevant file context:\n// Type: .sol\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.5.0 <0.9.0;\n\nimport \"./IPrngSystemContract.sol\";\n\ncontract PrngSystemContract {\n    event PseudoRandomSeed(bytes32 seedBytes);\n\n    // Prng system contract address with ContractID 0.0.361\n    address constant PRECOMPILE_ADDRESS = address(0x169);\n\n    function getPseudorandomSeed() external returns (bytes32 seedBytes) {\n        (bool success, bytes memory result) = PRECOMPILE_ADDRESS.call(\n            abi.encodeWithSelector(IPrngSystemContract.getPseudorandomSeed.selector));\n        require(success, \"PRNG system call failed\");\n        seedBytes = abi.decode(result, (bytes32));\n        emit PseudoRandomSeed(seedBytes);\n    }\n}\n",
            "totalTokens": 200,
            "chunks": [
              {
                "originalText": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.5.0 <0.9.0;\n\nimport \"./IPrngSystemContract.sol\";\n\ncontract PrngSystemContract {\n    event PseudoRandomSeed(bytes32 seedBytes);\n\n    // Prng system contract address with ContractID 0.0.361\n    address constant PRECOMPILE_ADDRESS = address(0x169);\n\n    function getPseudorandomSeed() external returns (bytes32 seedBytes) {\n        (bool success, bytes memory result) = PRECOMPILE_ADDRESS.call(\n            abi.encodeWithSelector(IPrngSystemContract.getPseudorandomSeed.selector));\n        require(success, \"PRNG system call failed\");\n        seedBytes = abi.decode(result, (bytes32));\n        emit PseudoRandomSeed(seedBytes);\n    }\n}\n",
                "codeOnlyTokens": 170,
                "startLine": 1,
                "endLine": 20,
                "type": "full_file",
                "isOversized": false
              }
            ],
            "startLine": 1,
            "endLine": 20,
            "groupId": 1
          }
        ],
        "oversizedChunks": [],
        "sendStrategy": "full_file",
        "finalTokenCount": 200,
        "skippedContent": [],
        "contextHeader": "// File: contracts/system-contracts/pseudo-random-number-generator/PrngSystemContract.sol\n// Relevant file context:\n// Type: .sol\n",
        "tokenBreakdown": {
          "originalFile": 170,
          "finalSent": 200,
          "codeTokensInGroups": 170,
          "fileHeaderTokensInGroups": 30,
          "shellContextTokensInGroups": 0,
          "separatorTokensInGroups": 0,
          "skippedCodeTokens": 0,
          "unprocessedOversizedTokens": 0,
          "totalSavings": -30,
          "savingsPercentage": -17.647058823529413,
          "fileHeaderCount": 1,
          "fileHeaderAvgSize": 30,
          "shellContextCount": 0,
          "shellContextAvgSize": 0,
          "separatorCount": 1,
          "separatorAvgSize": 0
        }
      }
    },
    {
      "filePath": "contracts/system-contracts/hedera-account-service/IHederaAccountService.sol",
      "totalOriginalTokens": 894,
      "finalTokenCount": 924,
      "impactScore": 35,
      "averageComplexity": 5,
      "averageQuality": 7,
      "usage": {
        "prompt_tokens": 1215,
        "completion_tokens": 177,
        "total_tokens": 1392
      },
      "retries": 0,
      "hadError": false,
      "scoredChunkGroups": [
        {
          "groupId": 1,
          "score": {
            "file_path": "contracts/system-contracts/hedera-account-service/IHederaAccountService.sol",
            "complexity_score": 5,
            "code_quality_score": 8,
            "maintainability_score": 7,
            "best_practices_adherence": 6,
            "web3_pattern_identification": "",
            "hedera_red_flag": null,
            "hedera_optimization_suggestion": null,
            "positive_feedback": "The clarity of interface definitions allows for easy integration in Hedera applications.",
            "group_summary": "This interface describes account-related functionalities within the Hedera network, focusing on authorization and allowance features."
          },
          "totalTokens": 924,
          "usage": {
            "prompt_tokens": 1215,
            "completion_tokens": 177,
            "total_tokens": 1392
          }
        }
      ],
      "chunkingDetails": {
        "filePath": "contracts/system-contracts/hedera-account-service/IHederaAccountService.sol",
        "totalFileTokens": 894,
        "chunks": [
          {
            "originalText": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.9 <0.9.0;\npragma experimental ABIEncoderV2;\n\ninterface IHederaAccountService {\n\n    /// Returns the amount of hbars that the spender has been authorized to spend on behalf of the owner.\n    /// @param owner The account that has authorized the spender\n    /// @param spender The account that has been authorized by the owner\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return amount The amount of hbar that the spender has been authorized to spend on behalf of the owner.\n    function hbarAllowance(address owner, address spender)\n    external\n    returns (int64 responseCode, int256 amount);\n\n    /// Allows spender to withdraw hbars from the owner account multiple times, up to the value amount. If this function is called\n    /// again it overwrites the current allowance with the new amount.\n    /// @param owner The owner of the hbars\n    /// @param spender the account address authorized to spend\n    /// @param amount the amount of hbars authorized to spend.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function hbarApprove(\n        address owner,\n        address spender,\n        int256 amount\n    ) external returns (int64 responseCode);\n\n    // Returns the EVM address alias for the given Hedera account.\n    /// @param accountNumAlias The Hedera account to get the EVM address alias for.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return evmAddressAlias The EVM address alias for the given Hedera account.\n    function getEvmAddressAlias(address accountNumAlias) external\n        returns (int64 responseCode, address evmAddressAlias);\n\n    /// Returns the Hedera Account ID (as account num alias) for the given EVM address alias\n    /// @param evmAddressAlias The EVM address alias to get the Hedera account for.\n    /// @return responseCode The response code for the status of the request.  SUCCESS is 22.\n    /// @return accountNumAlias The Hedera account's num for the given EVM address alias.\n    function getHederaAccountNumAlias(address evmAddressAlias) external\n        returns (int64 responseCode, address accountNumAlias);\n\n    /// Returns true iff a Hedera account num alias or EVM address alias.\n    /// @param addr Some 20-byte address.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return response true iff addr is a Hedera account num alias or an EVM address alias (and false otherwise).\n    function isValidAlias(address addr) external returns (int64 responseCode, bool response);\n\n    /// Determines if the signature is valid for the given message hash and account.\n    /// It is assumed that the signature is composed of a single EDCSA or ED25519 key.\n    /// @param account The account to check the signature against.\n    /// @param messageHash The hash of the message to check the signature against.\n    /// @param signature The signature to check.\n    /// @return responseCode The response code for the status of the request.  SUCCESS is 22.\n    /// @return authorized True if the signature is valid, false otherwise.\n    function isAuthorizedRaw(\n        address account,\n        bytes memory messageHash,\n        bytes memory signature\n    ) external returns (int64 responseCode, bool authorized);\n\n    /// Determines if the signature is valid for the given message and account.\n    /// It is assumed that the signature is composed of a possibly complex cryptographic key.\n    /// @param account The account to check the signature against.\n    /// @param message The message to check the signature against.",
            "codeOnlyTokens": 811,
            "startLine": 1,
            "endLine": 64,
            "type": ".sol_part_1",
            "isOversized": false
          },
          {
            "originalText": "    /// @param signature The signature to check encoded as bytes.\n    /// @return responseCode The response code for the status of the request.  SUCCESS is 22.\n    /// @return authorized True if the signature is valid, false otherwise.\n    function isAuthorized(\n        address account,\n        bytes memory message,\n        bytes memory signature\n    ) external returns (int64 responseCode, bool authorized);\n}\n",
            "codeOnlyTokens": 83,
            "startLine": 65,
            "endLine": 74,
            "type": ".sol_part_2",
            "isOversized": false
          }
        ],
        "groupedChunks": [
          {
            "combinedText": "// File: contracts/system-contracts/hedera-account-service/IHederaAccountService.sol\n// Relevant file context:\n// Type: .sol\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.9 <0.9.0;\npragma experimental ABIEncoderV2;\n\ninterface IHederaAccountService {\n\n    /// Returns the amount of hbars that the spender has been authorized to spend on behalf of the owner.\n    /// @param owner The account that has authorized the spender\n    /// @param spender The account that has been authorized by the owner\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return amount The amount of hbar that the spender has been authorized to spend on behalf of the owner.\n    function hbarAllowance(address owner, address spender)\n    external\n    returns (int64 responseCode, int256 amount);\n\n    /// Allows spender to withdraw hbars from the owner account multiple times, up to the value amount. If this function is called\n    /// again it overwrites the current allowance with the new amount.\n    /// @param owner The owner of the hbars\n    /// @param spender the account address authorized to spend\n    /// @param amount the amount of hbars authorized to spend.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function hbarApprove(\n        address owner,\n        address spender,\n        int256 amount\n    ) external returns (int64 responseCode);\n\n    // Returns the EVM address alias for the given Hedera account.\n    /// @param accountNumAlias The Hedera account to get the EVM address alias for.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return evmAddressAlias The EVM address alias for the given Hedera account.\n    function getEvmAddressAlias(address accountNumAlias) external\n        returns (int64 responseCode, address evmAddressAlias);\n\n    /// Returns the Hedera Account ID (as account num alias) for the given EVM address alias\n    /// @param evmAddressAlias The EVM address alias to get the Hedera account for.\n    /// @return responseCode The response code for the status of the request.  SUCCESS is 22.\n    /// @return accountNumAlias The Hedera account's num for the given EVM address alias.\n    function getHederaAccountNumAlias(address evmAddressAlias) external\n        returns (int64 responseCode, address accountNumAlias);\n\n    /// Returns true iff a Hedera account num alias or EVM address alias.\n    /// @param addr Some 20-byte address.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return response true iff addr is a Hedera account num alias or an EVM address alias (and false otherwise).\n    function isValidAlias(address addr) external returns (int64 responseCode, bool response);\n\n    /// Determines if the signature is valid for the given message hash and account.\n    /// It is assumed that the signature is composed of a single EDCSA or ED25519 key.\n    /// @param account The account to check the signature against.\n    /// @param messageHash The hash of the message to check the signature against.\n    /// @param signature The signature to check.\n    /// @return responseCode The response code for the status of the request.  SUCCESS is 22.\n    /// @return authorized True if the signature is valid, false otherwise.\n    function isAuthorizedRaw(\n        address account,\n        bytes memory messageHash,\n        bytes memory signature\n    ) external returns (int64 responseCode, bool authorized);\n\n    /// Determines if the signature is valid for the given message and account.\n    /// It is assumed that the signature is composed of a possibly complex cryptographic key.\n    /// @param account The account to check the signature against.\n    /// @param message The message to check the signature against.\n    /// @param signature The signature to check encoded as bytes.\n    /// @return responseCode The response code for the status of the request.  SUCCESS is 22.\n    /// @return authorized True if the signature is valid, false otherwise.\n    function isAuthorized(\n        address account,\n        bytes memory message,\n        bytes memory signature\n    ) external returns (int64 responseCode, bool authorized);\n}\n",
            "totalTokens": 924,
            "chunks": [
              {
                "originalText": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.9 <0.9.0;\npragma experimental ABIEncoderV2;\n\ninterface IHederaAccountService {\n\n    /// Returns the amount of hbars that the spender has been authorized to spend on behalf of the owner.\n    /// @param owner The account that has authorized the spender\n    /// @param spender The account that has been authorized by the owner\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return amount The amount of hbar that the spender has been authorized to spend on behalf of the owner.\n    function hbarAllowance(address owner, address spender)\n    external\n    returns (int64 responseCode, int256 amount);\n\n    /// Allows spender to withdraw hbars from the owner account multiple times, up to the value amount. If this function is called\n    /// again it overwrites the current allowance with the new amount.\n    /// @param owner The owner of the hbars\n    /// @param spender the account address authorized to spend\n    /// @param amount the amount of hbars authorized to spend.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function hbarApprove(\n        address owner,\n        address spender,\n        int256 amount\n    ) external returns (int64 responseCode);\n\n    // Returns the EVM address alias for the given Hedera account.\n    /// @param accountNumAlias The Hedera account to get the EVM address alias for.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return evmAddressAlias The EVM address alias for the given Hedera account.\n    function getEvmAddressAlias(address accountNumAlias) external\n        returns (int64 responseCode, address evmAddressAlias);\n\n    /// Returns the Hedera Account ID (as account num alias) for the given EVM address alias\n    /// @param evmAddressAlias The EVM address alias to get the Hedera account for.\n    /// @return responseCode The response code for the status of the request.  SUCCESS is 22.\n    /// @return accountNumAlias The Hedera account's num for the given EVM address alias.\n    function getHederaAccountNumAlias(address evmAddressAlias) external\n        returns (int64 responseCode, address accountNumAlias);\n\n    /// Returns true iff a Hedera account num alias or EVM address alias.\n    /// @param addr Some 20-byte address.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return response true iff addr is a Hedera account num alias or an EVM address alias (and false otherwise).\n    function isValidAlias(address addr) external returns (int64 responseCode, bool response);\n\n    /// Determines if the signature is valid for the given message hash and account.\n    /// It is assumed that the signature is composed of a single EDCSA or ED25519 key.\n    /// @param account The account to check the signature against.\n    /// @param messageHash The hash of the message to check the signature against.\n    /// @param signature The signature to check.\n    /// @return responseCode The response code for the status of the request.  SUCCESS is 22.\n    /// @return authorized True if the signature is valid, false otherwise.\n    function isAuthorizedRaw(\n        address account,\n        bytes memory messageHash,\n        bytes memory signature\n    ) external returns (int64 responseCode, bool authorized);\n\n    /// Determines if the signature is valid for the given message and account.\n    /// It is assumed that the signature is composed of a possibly complex cryptographic key.\n    /// @param account The account to check the signature against.\n    /// @param message The message to check the signature against.\n    /// @param signature The signature to check encoded as bytes.\n    /// @return responseCode The response code for the status of the request.  SUCCESS is 22.\n    /// @return authorized True if the signature is valid, false otherwise.\n    function isAuthorized(\n        address account,\n        bytes memory message,\n        bytes memory signature\n    ) external returns (int64 responseCode, bool authorized);\n}\n",
                "codeOnlyTokens": 894,
                "startLine": 1,
                "endLine": 74,
                "type": "full_file",
                "isOversized": false
              }
            ],
            "startLine": 1,
            "endLine": 74,
            "groupId": 1
          }
        ],
        "oversizedChunks": [],
        "sendStrategy": "full_file",
        "finalTokenCount": 924,
        "skippedContent": [],
        "contextHeader": "// File: contracts/system-contracts/hedera-account-service/IHederaAccountService.sol\n// Relevant file context:\n// Type: .sol\n",
        "tokenBreakdown": {
          "originalFile": 894,
          "finalSent": 924,
          "codeTokensInGroups": 894,
          "fileHeaderTokensInGroups": 30,
          "shellContextTokensInGroups": 0,
          "separatorTokensInGroups": 0,
          "skippedCodeTokens": 0,
          "unprocessedOversizedTokens": 0,
          "totalSavings": -30,
          "savingsPercentage": -3.3557046979865772,
          "fileHeaderCount": 1,
          "fileHeaderAvgSize": 30,
          "shellContextCount": 0,
          "shellContextAvgSize": 0,
          "separatorCount": 1,
          "separatorAvgSize": 0
        }
      }
    },
    {
      "filePath": "contracts/system-contracts/pseudo-random-number-generator/IPrngSystemContract.sol",
      "totalOriginalTokens": 103,
      "finalTokenCount": 133,
      "impactScore": 29.333333333333332,
      "averageComplexity": 4,
      "averageQuality": 7.333333333333333,
      "usage": {
        "prompt_tokens": 175,
        "completion_tokens": 177,
        "total_tokens": 352
      },
      "retries": 0,
      "hadError": false,
      "scoredChunkGroups": [
        {
          "groupId": 1,
          "score": {
            "file_path": "contracts/system-contracts/pseudo-random-number-generator/IPrngSystemContract.sol",
            "complexity_score": 4,
            "code_quality_score": 8,
            "maintainability_score": 7,
            "best_practices_adherence": 7,
            "web3_pattern_identification": "",
            "hedera_red_flag": null,
            "hedera_optimization_suggestion": null,
            "positive_feedback": "The contract's purpose of generating pseudorandom numbers is critical for various applications, showcasing foresight for developers leveraging randomness.",
            "group_summary": "This interface defines a contract for generating pseudorandom numbers on the Hedera network, critical for applications requiring non-deterministic behavior."
          },
          "totalTokens": 133,
          "usage": {
            "prompt_tokens": 175,
            "completion_tokens": 177,
            "total_tokens": 352
          }
        }
      ],
      "chunkingDetails": {
        "filePath": "contracts/system-contracts/pseudo-random-number-generator/IPrngSystemContract.sol",
        "totalFileTokens": 103,
        "chunks": [
          {
            "originalText": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.9 <0.9.0;\n\ninterface IPrngSystemContract {\n    // Generates a 256-bit pseudorandom seed using the first 256-bits of running hash of n-3 transaction record.\n    // Users can generate a pseudorandom number in a specified range using the seed by (integer value of seed % range)\n    function getPseudorandomSeed() external returns (bytes32);\n}\n",
            "codeOnlyTokens": 103,
            "startLine": 1,
            "endLine": 9,
            "type": ".sol",
            "isOversized": false
          }
        ],
        "groupedChunks": [
          {
            "combinedText": "// File: contracts/system-contracts/pseudo-random-number-generator/IPrngSystemContract.sol\n// Relevant file context:\n// Type: .sol\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.9 <0.9.0;\n\ninterface IPrngSystemContract {\n    // Generates a 256-bit pseudorandom seed using the first 256-bits of running hash of n-3 transaction record.\n    // Users can generate a pseudorandom number in a specified range using the seed by (integer value of seed % range)\n    function getPseudorandomSeed() external returns (bytes32);\n}\n",
            "totalTokens": 133,
            "chunks": [
              {
                "originalText": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.9 <0.9.0;\n\ninterface IPrngSystemContract {\n    // Generates a 256-bit pseudorandom seed using the first 256-bits of running hash of n-3 transaction record.\n    // Users can generate a pseudorandom number in a specified range using the seed by (integer value of seed % range)\n    function getPseudorandomSeed() external returns (bytes32);\n}\n",
                "codeOnlyTokens": 103,
                "startLine": 1,
                "endLine": 9,
                "type": "full_file",
                "isOversized": false
              }
            ],
            "startLine": 1,
            "endLine": 9,
            "groupId": 1
          }
        ],
        "oversizedChunks": [],
        "sendStrategy": "full_file",
        "finalTokenCount": 133,
        "skippedContent": [],
        "contextHeader": "// File: contracts/system-contracts/pseudo-random-number-generator/IPrngSystemContract.sol\n// Relevant file context:\n// Type: .sol\n",
        "tokenBreakdown": {
          "originalFile": 103,
          "finalSent": 133,
          "codeTokensInGroups": 103,
          "fileHeaderTokensInGroups": 30,
          "shellContextTokensInGroups": 0,
          "separatorTokensInGroups": 0,
          "skippedCodeTokens": 0,
          "unprocessedOversizedTokens": 0,
          "totalSavings": -30,
          "savingsPercentage": -29.126213592233007,
          "fileHeaderCount": 1,
          "fileHeaderAvgSize": 30,
          "shellContextCount": 0,
          "shellContextAvgSize": 0,
          "separatorCount": 1,
          "separatorAvgSize": 0
        }
      }
    },
    {
      "filePath": "README.md",
      "totalOriginalTokens": 1095,
      "finalTokenCount": 1111,
      "impactScore": 17,
      "averageComplexity": 3,
      "averageQuality": 5.666666666666667,
      "usage": {
        "prompt_tokens": 1344,
        "completion_tokens": 233,
        "total_tokens": 1577
      },
      "retries": 0,
      "hadError": false,
      "scoredChunkGroups": [
        {
          "groupId": 1,
          "score": {
            "file_path": "README.md",
            "complexity_score": 3,
            "code_quality_score": 6,
            "maintainability_score": 6,
            "best_practices_adherence": 5,
            "web3_pattern_identification": "Documentation Best Practices",
            "hedera_red_flag": {
              "description": "General caution about lack of audits adds unnecessary stress; specifying this could confuse developers unfamiliar with the nuances of security.",
              "exact_code_snippet": ":warning: :bangbang: ***All examples and contracts in this repository are exploration code and have NOT been audited. Use them at your own risk!*** :bangbang: :warning:"
            },
            "hedera_optimization_suggestion": {
              "description": "Clarifying the need for caution and providing context for why the code is unaudited could enhance understanding without causing unnecessary alarm.",
              "exact_code_snippet": ":warning: :bangbang: ***All examples and contracts in this repository are exploration code and have NOT been audited. Use them at your own risk!*** :bangbang: :warning:"
            },
            "positive_feedback": "Provides a comprehensive overview of Hedera's smart contract system, linking necessary resources effectively.",
            "group_summary": "The README serves as a reference guide to the Hedera network's smart contracts, detailing interfaces, functionalities, and safety guidelines."
          },
          "totalTokens": 1111,
          "usage": {
            "prompt_tokens": 1344,
            "completion_tokens": 233,
            "total_tokens": 1577
          }
        }
      ],
      "chunkingDetails": {
        "filePath": "README.md",
        "totalFileTokens": 1095,
        "chunks": [
          {
            "originalText": ":warning: :bangbang: ***All examples and contracts in this repository are exploration code and have NOT been audited. Use them at your own risk!*** :bangbang: :warning:\n\n# Hedera Smart Contracts\n\nReference library for Smart Contracts utilized by the Hedera network with supporting files and examples.\n\n## Overview\n\nThe Hedera network utilizes system contracts at a reserved contract address on the EVM to surface HAPI service functionality through EVM processed transactions.\nThese system contracts are precompiled smart contracts whose function selectors are mapped to defined network logic.\nIn this way EVM users can utilize exposed HAPI features natively in their smart contracts.\n\nThe system contract functions are defined in this library and implemented by the [Hedera Services](https://github.com/hashgraph/hedera-services) repo as part of consensus node functionality.\n\n### Hedera Token Service (HTS) System Contract\n\nThe Hedera Token Service (HTS) functionality is defined by the [IHederaTokenService.sol](contracts/system-contracts/hedera-token-service/IHederaTokenService.sol) interface smart contract as defined in [HIP 206](https://hips.hedera.com/hip/hip-206), [HIP 376](https://hips.hedera.com/hip/hip-376) and [HIP 514](https://hips.hedera.com/hip/hip-514). The contract is exposed via the `0x167` address.\nReference smart contracts to call these functions as well as examples can be found under [contracts/system-contracts/hedera-token-service](contracts/system-contracts/hedera-token-service)\n\nFor further details on methods, hashes and availability please refer to [HTS System Contract Methods](contracts/system-contracts/hedera-token-service/README.md)\n\n- Solidity files updated on April 20, 2022 to add token create support\n- Solidity files updated on Jan 18, 2022\n\n### Hedera Account Service (HAS) System Contract\n\nThe Hedera Account Service (HAS) functionality is defined by the [IHederaAccountService.sol](contracts/system-contracts/hedera-account-service/IHederaAccountService.sol) interface smart contract as defined in [HIP 632](https://hips.hedera.com/hip/hip-632) and [HIP 906](https://hips.hedera.com/hip/hip-906). The contract is exposed via the `0x16a` address.\nReference smart contracts to call these functions as well as examples can be found under [contracts/system-contracts/hedera-account-service](contracts/system-contracts/hedera-account-service)\n\nFor further details on methods, hashes and availability please refer to [HAS System Contract Methods](contracts/system-contracts/hedera-account-service/README.md)\n\n### Exchange Rate System Contract\n\nThe Exchange Rate functionality is defined by the [IExchangeRate.sol](contracts/system-contracts/exchange-rate/IExchangeRate.sol) interface smart contract as defined in [HIP 475](https://hips.hedera.com/hip/hip-475) and exposed via the `0x168` address.\nReference smart contracts to call these functions as well as examples can be found under [contracts/system-contracts/exchange-rate](contracts/system-contracts/exchange-rate)\n\nFor further details on methods, hashes and availability please refer to [Exchange Rate System Contract Methods](contracts/system-contracts/exchange-rate/README.md)\n\n### Prng System Contract\n\nThe PRNG functionality is defined by the [IPrngSystemContract.sol](contracts/system-contracts/pseudo-random-number-generator/IPrngSystemContract.sol) interface smart contract as defined in [HIP 351](https://hips.hedera.com/hip/hip-351) and exposed via the `0x169` address.\nReference smart contracts to call these functions as well as examples can be found under [contracts/system-contracts/pseudo-random-number-generator](contracts/system-contracts/pseudo-random-number-generator)",
            "codeOnlyTokens": 806,
            "startLine": 1,
            "endLine": 42,
            "type": ".md_part_1",
            "isOversized": false
          },
          {
            "originalText": "\nFor further details on methods, hashes and availability please refer to [PRNG System Contract Methods](contracts/system-contracts/pseudo-random-number-generator/README.md)\n\n## Development guidelines\n\nThis project is set up using the Hardhat development environment. To get started, please follow this [test setup guide](./TEST_SETUP.md).\n\nFor using this project as a library in a Foundry project see [Foundry Testing](FOUNDRY_TESTING.md)\n\n## Support\n\nIf you have a question on how to use the product, please see our\n[support guide](https://github.com/hashgraph/.github/blob/main/SUPPORT.md).\n\n## Contributing\n\nContributions are welcome. Please see the\n[contributing guide](https://github.com/hashgraph/.github/blob/main/CONTRIBUTING.md)\nto see how you can get involved.\n\n## Code of Conduct\n\nThis project is governed by the\n[Contributor Covenant Code of Conduct](https://github.com/hashgraph/.github/blob/main/CODE_OF_CONDUCT.md). By\nparticipating, you are expected to uphold this code of conduct. Please report unacceptable behavior\nto [oss@hedera.com](mailto:oss@hedera.com).\n\n## License\n\n[Apache License 2.0](LICENSE)\n\n## Smart contracts - testing\n\n[Smart contracts tests - documentation](https://raw.githubusercontent.com/hashgraph/hedera-smart-contracts/main/test/README.md)\n",
            "codeOnlyTokens": 290,
            "startLine": 43,
            "endLine": 77,
            "type": ".md_part_2",
            "isOversized": false
          }
        ],
        "groupedChunks": [
          {
            "combinedText": "// File: README.md\n// Relevant file context:\n// Type: .md\n:warning: :bangbang: ***All examples and contracts in this repository are exploration code and have NOT been audited. Use them at your own risk!*** :bangbang: :warning:\n\n# Hedera Smart Contracts\n\nReference library for Smart Contracts utilized by the Hedera network with supporting files and examples.\n\n## Overview\n\nThe Hedera network utilizes system contracts at a reserved contract address on the EVM to surface HAPI service functionality through EVM processed transactions.\nThese system contracts are precompiled smart contracts whose function selectors are mapped to defined network logic.\nIn this way EVM users can utilize exposed HAPI features natively in their smart contracts.\n\nThe system contract functions are defined in this library and implemented by the [Hedera Services](https://github.com/hashgraph/hedera-services) repo as part of consensus node functionality.\n\n### Hedera Token Service (HTS) System Contract\n\nThe Hedera Token Service (HTS) functionality is defined by the [IHederaTokenService.sol](contracts/system-contracts/hedera-token-service/IHederaTokenService.sol) interface smart contract as defined in [HIP 206](https://hips.hedera.com/hip/hip-206), [HIP 376](https://hips.hedera.com/hip/hip-376) and [HIP 514](https://hips.hedera.com/hip/hip-514). The contract is exposed via the `0x167` address.\nReference smart contracts to call these functions as well as examples can be found under [contracts/system-contracts/hedera-token-service](contracts/system-contracts/hedera-token-service)\n\nFor further details on methods, hashes and availability please refer to [HTS System Contract Methods](contracts/system-contracts/hedera-token-service/README.md)\n\n- Solidity files updated on April 20, 2022 to add token create support\n- Solidity files updated on Jan 18, 2022\n\n### Hedera Account Service (HAS) System Contract\n\nThe Hedera Account Service (HAS) functionality is defined by the [IHederaAccountService.sol](contracts/system-contracts/hedera-account-service/IHederaAccountService.sol) interface smart contract as defined in [HIP 632](https://hips.hedera.com/hip/hip-632) and [HIP 906](https://hips.hedera.com/hip/hip-906). The contract is exposed via the `0x16a` address.\nReference smart contracts to call these functions as well as examples can be found under [contracts/system-contracts/hedera-account-service](contracts/system-contracts/hedera-account-service)\n\nFor further details on methods, hashes and availability please refer to [HAS System Contract Methods](contracts/system-contracts/hedera-account-service/README.md)\n\n### Exchange Rate System Contract\n\nThe Exchange Rate functionality is defined by the [IExchangeRate.sol](contracts/system-contracts/exchange-rate/IExchangeRate.sol) interface smart contract as defined in [HIP 475](https://hips.hedera.com/hip/hip-475) and exposed via the `0x168` address.\nReference smart contracts to call these functions as well as examples can be found under [contracts/system-contracts/exchange-rate](contracts/system-contracts/exchange-rate)\n\nFor further details on methods, hashes and availability please refer to [Exchange Rate System Contract Methods](contracts/system-contracts/exchange-rate/README.md)\n\n### Prng System Contract\n\nThe PRNG functionality is defined by the [IPrngSystemContract.sol](contracts/system-contracts/pseudo-random-number-generator/IPrngSystemContract.sol) interface smart contract as defined in [HIP 351](https://hips.hedera.com/hip/hip-351) and exposed via the `0x169` address.\nReference smart contracts to call these functions as well as examples can be found under [contracts/system-contracts/pseudo-random-number-generator](contracts/system-contracts/pseudo-random-number-generator)\n\nFor further details on methods, hashes and availability please refer to [PRNG System Contract Methods](contracts/system-contracts/pseudo-random-number-generator/README.md)\n\n## Development guidelines\n\nThis project is set up using the Hardhat development environment. To get started, please follow this [test setup guide](./TEST_SETUP.md).\n\nFor using this project as a library in a Foundry project see [Foundry Testing](FOUNDRY_TESTING.md)\n\n## Support\n\nIf you have a question on how to use the product, please see our\n[support guide](https://github.com/hashgraph/.github/blob/main/SUPPORT.md).\n\n## Contributing\n\nContributions are welcome. Please see the\n[contributing guide](https://github.com/hashgraph/.github/blob/main/CONTRIBUTING.md)\nto see how you can get involved.\n\n## Code of Conduct\n\nThis project is governed by the\n[Contributor Covenant Code of Conduct](https://github.com/hashgraph/.github/blob/main/CODE_OF_CONDUCT.md). By\nparticipating, you are expected to uphold this code of conduct. Please report unacceptable behavior\nto [oss@hedera.com](mailto:oss@hedera.com).\n\n## License\n\n[Apache License 2.0](LICENSE)\n\n## Smart contracts - testing\n\n[Smart contracts tests - documentation](https://raw.githubusercontent.com/hashgraph/hedera-smart-contracts/main/test/README.md)\n",
            "totalTokens": 1111,
            "chunks": [
              {
                "originalText": ":warning: :bangbang: ***All examples and contracts in this repository are exploration code and have NOT been audited. Use them at your own risk!*** :bangbang: :warning:\n\n# Hedera Smart Contracts\n\nReference library for Smart Contracts utilized by the Hedera network with supporting files and examples.\n\n## Overview\n\nThe Hedera network utilizes system contracts at a reserved contract address on the EVM to surface HAPI service functionality through EVM processed transactions.\nThese system contracts are precompiled smart contracts whose function selectors are mapped to defined network logic.\nIn this way EVM users can utilize exposed HAPI features natively in their smart contracts.\n\nThe system contract functions are defined in this library and implemented by the [Hedera Services](https://github.com/hashgraph/hedera-services) repo as part of consensus node functionality.\n\n### Hedera Token Service (HTS) System Contract\n\nThe Hedera Token Service (HTS) functionality is defined by the [IHederaTokenService.sol](contracts/system-contracts/hedera-token-service/IHederaTokenService.sol) interface smart contract as defined in [HIP 206](https://hips.hedera.com/hip/hip-206), [HIP 376](https://hips.hedera.com/hip/hip-376) and [HIP 514](https://hips.hedera.com/hip/hip-514). The contract is exposed via the `0x167` address.\nReference smart contracts to call these functions as well as examples can be found under [contracts/system-contracts/hedera-token-service](contracts/system-contracts/hedera-token-service)\n\nFor further details on methods, hashes and availability please refer to [HTS System Contract Methods](contracts/system-contracts/hedera-token-service/README.md)\n\n- Solidity files updated on April 20, 2022 to add token create support\n- Solidity files updated on Jan 18, 2022\n\n### Hedera Account Service (HAS) System Contract\n\nThe Hedera Account Service (HAS) functionality is defined by the [IHederaAccountService.sol](contracts/system-contracts/hedera-account-service/IHederaAccountService.sol) interface smart contract as defined in [HIP 632](https://hips.hedera.com/hip/hip-632) and [HIP 906](https://hips.hedera.com/hip/hip-906). The contract is exposed via the `0x16a` address.\nReference smart contracts to call these functions as well as examples can be found under [contracts/system-contracts/hedera-account-service](contracts/system-contracts/hedera-account-service)\n\nFor further details on methods, hashes and availability please refer to [HAS System Contract Methods](contracts/system-contracts/hedera-account-service/README.md)\n\n### Exchange Rate System Contract\n\nThe Exchange Rate functionality is defined by the [IExchangeRate.sol](contracts/system-contracts/exchange-rate/IExchangeRate.sol) interface smart contract as defined in [HIP 475](https://hips.hedera.com/hip/hip-475) and exposed via the `0x168` address.\nReference smart contracts to call these functions as well as examples can be found under [contracts/system-contracts/exchange-rate](contracts/system-contracts/exchange-rate)\n\nFor further details on methods, hashes and availability please refer to [Exchange Rate System Contract Methods](contracts/system-contracts/exchange-rate/README.md)\n\n### Prng System Contract\n\nThe PRNG functionality is defined by the [IPrngSystemContract.sol](contracts/system-contracts/pseudo-random-number-generator/IPrngSystemContract.sol) interface smart contract as defined in [HIP 351](https://hips.hedera.com/hip/hip-351) and exposed via the `0x169` address.\nReference smart contracts to call these functions as well as examples can be found under [contracts/system-contracts/pseudo-random-number-generator](contracts/system-contracts/pseudo-random-number-generator)\n\nFor further details on methods, hashes and availability please refer to [PRNG System Contract Methods](contracts/system-contracts/pseudo-random-number-generator/README.md)\n\n## Development guidelines\n\nThis project is set up using the Hardhat development environment. To get started, please follow this [test setup guide](./TEST_SETUP.md).\n\nFor using this project as a library in a Foundry project see [Foundry Testing](FOUNDRY_TESTING.md)\n\n## Support\n\nIf you have a question on how to use the product, please see our\n[support guide](https://github.com/hashgraph/.github/blob/main/SUPPORT.md).\n\n## Contributing\n\nContributions are welcome. Please see the\n[contributing guide](https://github.com/hashgraph/.github/blob/main/CONTRIBUTING.md)\nto see how you can get involved.\n\n## Code of Conduct\n\nThis project is governed by the\n[Contributor Covenant Code of Conduct](https://github.com/hashgraph/.github/blob/main/CODE_OF_CONDUCT.md). By\nparticipating, you are expected to uphold this code of conduct. Please report unacceptable behavior\nto [oss@hedera.com](mailto:oss@hedera.com).\n\n## License\n\n[Apache License 2.0](LICENSE)\n\n## Smart contracts - testing\n\n[Smart contracts tests - documentation](https://raw.githubusercontent.com/hashgraph/hedera-smart-contracts/main/test/README.md)\n",
                "codeOnlyTokens": 1095,
                "startLine": 1,
                "endLine": 77,
                "type": "full_file",
                "isOversized": false
              }
            ],
            "startLine": 1,
            "endLine": 77,
            "groupId": 1
          }
        ],
        "oversizedChunks": [],
        "sendStrategy": "full_file",
        "finalTokenCount": 1111,
        "skippedContent": [],
        "contextHeader": "// File: README.md\n// Relevant file context:\n// Type: .md\n",
        "tokenBreakdown": {
          "originalFile": 1095,
          "finalSent": 1111,
          "codeTokensInGroups": 1095,
          "fileHeaderTokensInGroups": 16,
          "shellContextTokensInGroups": 0,
          "separatorTokensInGroups": 0,
          "skippedCodeTokens": 0,
          "unprocessedOversizedTokens": 0,
          "totalSavings": -16,
          "savingsPercentage": -1.461187214611872,
          "fileHeaderCount": 1,
          "fileHeaderAvgSize": 16,
          "shellContextCount": 0,
          "shellContextAvgSize": 0,
          "separatorCount": 1,
          "separatorAvgSize": 0
        }
      }
    },
    {
      "filePath": "system-contract-dapp-playground/src/app/layout.tsx",
      "totalOriginalTokens": 195,
      "finalTokenCount": 220,
      "impactScore": 14,
      "averageComplexity": 2,
      "averageQuality": 7,
      "usage": {
        "prompt_tokens": 1275,
        "completion_tokens": 152,
        "total_tokens": 1427
      },
      "retries": 1,
      "hadError": false,
      "scoredChunkGroups": [
        {
          "groupId": 1,
          "score": {
            "file_path": "system-contract-dapp-playground/src/app/layout.tsx",
            "complexity_score": 2,
            "code_quality_score": 7,
            "maintainability_score": 6,
            "best_practices_adherence": 8,
            "web3_pattern_identification": "",
            "hedera_red_flag": null,
            "hedera_optimization_suggestion": null,
            "positive_feedback": "Utilizes Chakra UI, which can enhance the UI consistency across the dApp.",
            "group_summary": "This file defines the root layout component for a Hedera dApp, utilizing Chakra UI for styling and metadata for SEO."
          },
          "totalTokens": 220,
          "usage": {
            "prompt_tokens": 1275,
            "completion_tokens": 152,
            "total_tokens": 1427
          }
        }
      ],
      "chunkingDetails": {
        "filePath": "system-contract-dapp-playground/src/app/layout.tsx",
        "totalFileTokens": 195,
        "chunks": [
          {
            "originalText": "// SPDX-License-Identifier: Apache-2.0\n\nimport '@/styles/globals.css';\nimport StyreneAWebFont from '@/fonts';\nimport dappMetadata from '@/utils/common/metadata';\nimport ChakraUIProviders from '@/libs/chakra/provider';\nimport BgGradient from '@/components/background-gradients';\n\n/** @notice Root Layout */\nexport default function RootLayout({ children }: { children: React.ReactNode }) {\n  return (\n    <html lang=\"en\" className={`${StyreneAWebFont.variable}`}>\n      <body className=\"bg-primary font-styrene\">\n        <ChakraUIProviders>\n          <div className=\"relative 2xl:max-w-[100rem] 2xl:mx-auto\">\n            {children}\n            <BgGradient />\n          </div>\n        </ChakraUIProviders>\n      </body>\n    </html>\n  );\n}\n\n/** @notice export metadata for SEO */\nexport const metadata = dappMetadata;\n",
            "codeOnlyTokens": 195,
            "startLine": 1,
            "endLine": 27,
            "type": ".tsx",
            "isOversized": false
          }
        ],
        "groupedChunks": [
          {
            "combinedText": "// File: system-contract-dapp-playground/src/app/layout.tsx\n// Relevant file context:\n// Type: .tsx\n// SPDX-License-Identifier: Apache-2.0\n\nimport '@/styles/globals.css';\nimport StyreneAWebFont from '@/fonts';\nimport dappMetadata from '@/utils/common/metadata';\nimport ChakraUIProviders from '@/libs/chakra/provider';\nimport BgGradient from '@/components/background-gradients';\n\n/** @notice Root Layout */\nexport default function RootLayout({ children }: { children: React.ReactNode }) {\n  return (\n    <html lang=\"en\" className={`${StyreneAWebFont.variable}`}>\n      <body className=\"bg-primary font-styrene\">\n        <ChakraUIProviders>\n          <div className=\"relative 2xl:max-w-[100rem] 2xl:mx-auto\">\n            {children}\n            <BgGradient />\n          </div>\n        </ChakraUIProviders>\n      </body>\n    </html>\n  );\n}\n\n/** @notice export metadata for SEO */\nexport const metadata = dappMetadata;\n",
            "totalTokens": 220,
            "chunks": [
              {
                "originalText": "// SPDX-License-Identifier: Apache-2.0\n\nimport '@/styles/globals.css';\nimport StyreneAWebFont from '@/fonts';\nimport dappMetadata from '@/utils/common/metadata';\nimport ChakraUIProviders from '@/libs/chakra/provider';\nimport BgGradient from '@/components/background-gradients';\n\n/** @notice Root Layout */\nexport default function RootLayout({ children }: { children: React.ReactNode }) {\n  return (\n    <html lang=\"en\" className={`${StyreneAWebFont.variable}`}>\n      <body className=\"bg-primary font-styrene\">\n        <ChakraUIProviders>\n          <div className=\"relative 2xl:max-w-[100rem] 2xl:mx-auto\">\n            {children}\n            <BgGradient />\n          </div>\n        </ChakraUIProviders>\n      </body>\n    </html>\n  );\n}\n\n/** @notice export metadata for SEO */\nexport const metadata = dappMetadata;\n",
                "codeOnlyTokens": 195,
                "startLine": 1,
                "endLine": 27,
                "type": "full_file",
                "isOversized": false
              }
            ],
            "startLine": 1,
            "endLine": 27,
            "groupId": 1
          }
        ],
        "oversizedChunks": [],
        "sendStrategy": "full_file",
        "finalTokenCount": 220,
        "skippedContent": [],
        "contextHeader": "// File: system-contract-dapp-playground/src/app/layout.tsx\n// Relevant file context:\n// Type: .tsx\n",
        "tokenBreakdown": {
          "originalFile": 195,
          "finalSent": 220,
          "codeTokensInGroups": 195,
          "fileHeaderTokensInGroups": 25,
          "shellContextTokensInGroups": 0,
          "separatorTokensInGroups": 0,
          "skippedCodeTokens": 0,
          "unprocessedOversizedTokens": 0,
          "totalSavings": -25,
          "savingsPercentage": -12.82051282051282,
          "fileHeaderCount": 1,
          "fileHeaderAvgSize": 25,
          "shellContextCount": 0,
          "shellContextAvgSize": 0,
          "separatorCount": 1,
          "separatorAvgSize": 0
        }
      }
    },
    {
      "filePath": "lib/layer-zero/README.md",
      "totalOriginalTokens": 1686,
      "finalTokenCount": 1707,
      "impactScore": 12,
      "averageComplexity": 2,
      "averageQuality": 6,
      "usage": {
        "prompt_tokens": 2066,
        "completion_tokens": 233,
        "total_tokens": 2299
      },
      "retries": 0,
      "hadError": false,
      "scoredChunkGroups": [
        {
          "groupId": 1,
          "score": {
            "file_path": "lib/layer-zero/README.md",
            "complexity_score": 2,
            "code_quality_score": 5,
            "maintainability_score": 7,
            "best_practices_adherence": 6,
            "web3_pattern_identification": "",
            "hedera_red_flag": {
              "description": "Lacks clear code implementation, focusing mainly on deployment instructions without practical Solidity code examples.",
              "exact_code_snippet": ""
            },
            "hedera_optimization_suggestion": {
              "description": "Including practical code snippets for LayerZero integration would provide concrete examples, making the documentation more practical.",
              "exact_code_snippet": ""
            },
            "positive_feedback": "The structure of the README allows clear navigation between sections, making it user-friendly.",
            "group_summary": "The README provides an overview of Layer Zero's functionalities and steps to deploy contracts for inter-chain communication."
          },
          "totalTokens": 1707,
          "usage": {
            "prompt_tokens": 2066,
            "completion_tokens": 233,
            "total_tokens": 2299
          }
        }
      ],
      "chunkingDetails": {
        "filePath": "lib/layer-zero/README.md",
        "totalFileTokens": 1686,
        "chunks": [
          {
            "originalText": "# Layer Zero examples\n\n### OApp\n\nMessage-passing interface to send and receive arbitrary pieces of data between contracts existing on different chains.\n\n##### Action steps:\n\n- Deploying the oapp contract on each network we're going to interact\n\n- In order to connect oapps together, we need to set the peer of the target oapp, more info can be found here https://docs.layerzero.network/v2/developers/evm/getting-started#connecting-your-contracts\n\n- Now, we're sending messages from one chain to another and vice versa\n\n- Wait a couple of minutes, the LZ progress can be tracked on https://testnet.layerzeroscan.com/tx/<tx_hash>\n\n- Finally we're checking whether the messages are received on both chains\n\n### OFT\n\nAllows fungible tokens to be transferred across multiple chains.\n\n##### Action steps:\n\n- Deploying OFT tokens which under the hood are ERC20s and contain the messaging between chains functionality provided by LZ\n\n- In order to connect OFTs together, we need to set the peer of the target OFT, more info can be found here https://docs.layerzero.network/v2/developers/evm/getting-started#connecting-your-contracts\n\n- Now, we're sending tokens between chains. That means we're burning tokens on the source chain and minting new ones on the destination chain\n\n- Wait a couple of minutes, the LZ progress can be tracked on https://testnet.layerzeroscan.com/tx/<tx_hash>\n\n- Finally we're checking whether the token balances are as expected on both the source and destination chains.\n\n### OFT Adapter\n\nIf your token already exists on the chain you want to connect, you can deploy the OFT Adapter contract to act as an intermediary lockbox for the token.\n\n##### Action steps:\n\n- Deploying ERC20 tokens on each chain\n\n- Deploying an OFT Adapters which will be used as a lockbox of ERC20s deployed the step above, you can use an already existing HTS token as well\n\n- In order to connect OFT Adapters together, we need to set the peer of the target OFT Adapter, more info can be found here https://docs.layerzero.network/v2/developers/evm/getting-started#connecting-your-contracts\n\n- We're funding the Adapter on both chains with some liquidity and after that we're approving it to spend the signer's token\n\n- Now, we're sending already existing tokens that are used by OFT Adapter between different chains\n\n- Wait a couple of minutes, the LZ progress can be tracked on https://testnet.layerzeroscan.com/tx/<tx_hash>\n\n- Finally we're checking the balances on each chain\n\n### ONFT\n\nAllows non-fungible tokens to be transferred across multiple chains.\n\n##### Action steps:\n\n- Deploying ONFT tokens which under the hood are ERC721s and contain the messaging between chains functionality provided by LZ\n\n- In order to connect ONFTs together, we need to set the peer of the target ONFT, more info can be found here https://docs.layerzero.network/v2/developers/evm/getting-started#connecting-your-contracts\n\n- Now, we're sending NFTs between chains. That means we're burning the NFT on the source chain and minting new one on the destination chain\n\n- Wait a couple of minutes, the LZ progress can be tracked on https://testnet.layerzeroscan.com/tx/<tx_hash>\n\n- Finally we're checking whether the NFTs are transferred successfully\n\n### ONFT Adapter\n\nIf your NFT contract already exists on the chain you want to connect, you can deploy the ONFT Adapter contract to act as an intermediary lockbox.\n\n##### Action steps:\n\n- Deploying ERC721s on each chain we want to connect\n\n- Deploying an ONFT Adapter which will be used as a lockbox of ERC721s deployed the step above\n\n- In order to connect ONFT Adapters together, we need to set the peer of the target ONFT Adapter, more info can be found here https://docs.layerzero.network/v2/developers/evm/getting-started#connecting-your-contracts",
            "codeOnlyTokens": 849,
            "startLine": 1,
            "endLine": 81,
            "type": ".md_part_1",
            "isOversized": false
          },
          {
            "originalText": "\n- First, we have to mint some NFTs on each chain\n\n- Then, we have to approve the Adapter to be able to spend the NFT we want to send to another chain\n\n- Now, we're sending already existing NFTs between chains\n\n- Wait a couple of minutes, the LZ progress can be tracked on https://testnet.layerzeroscan.com/tx/<tx_hash>\n\n- Finally we're checking whether the NFTs are transferred successfully\n\n### HTS Connector\n\nThat's a variant of OFT but using an HTS token. Due to several incompatibilities between ERC20 and HTS tokens, we're not able to use them out of the box. All of them are described in the \"HTS Adapter vs HTS Connector\" section below.\n\n##### Action steps:\n\n- Deploying OFT on an EVM chain and HTS Connector on the Hedera chain. The HTS Connector extends OFTCore and creates HTS token within its constructor. Also, overrides OFTCore _debit and _credit with related HTS mint and burn precompile calls\n\n- In order to connect OFTs together, we need to set the peer of the target OFT, more info can be found here https://docs.layerzero.network/v2/developers/evm/getting-started#connecting-your-contracts\n\n- Approving HTS Connector to use some signer's tokens\n\n- Now, we're sending tokens from an EVM chain to Hedera and receiving HTS tokens and vice versa\n\n- Wait a couple of minutes, the LZ progress can be tracked on https://testnet.layerzeroscan.com/tx/<tx_hash>\n\nFinally we're checking whether the balances are expected on both source and destination chains\n\n### HTS Connector for existing HTS token\n\nThat's a variant of OFT but using an already existing HTS token. Keep in mind that \"supply key\" of the token must contains the HTS Connector contract's address.\n\n##### Action steps:\n\n- Create an HTS token\n\n- Deploying OFT on an EVM chain and HTS Connector on the Hedera chain. The HTS Connector for existing token extends OFTCore and receives the HTS tokens address as constructor parameter. Also, overrides OFTCore _debit and _credit with related HTS mint and burn precompile calls\n\n- In order to connect OFTs together, we need to set the peer of the target OFT, more info can be found here https://docs.layerzero.network/v2/developers/evm/getting-started#connecting-your-contracts\n\n- Adding the HTSConnectorExistingToken contract's address as a supply key of the existing HTS token\n\n- Funding the HTSConnectorExistingToken contract\n\n- Approving HTS Connector to use some signer's tokens\n\n- Now, we're sending tokens from an EVM chain to Hedera and receiving HTS tokens and vice versa\n\n- Wait a couple of minutes, the LZ progress can be tracked on https://testnet.layerzeroscan.com/tx/<tx_hash>\n\n- Finally we're checking whether the balances are expected on both source and destination chains\n\n### Useful information:\n- The addresses of endpoints [here](https://github.com/hashgraph/hedera-json-rpc-relay/blob/1030-lz-setup/tools/layer-zero-example/hardhat.config.js#L60) are the official LZ endpoints. A entire list of LZ supported endpoints can be found on https://docs.layerzero.network/v2/developers/evm/technical-reference/deployed-contracts.\n\n### HTS Adapter vs HTS Connector\n- You could use a HTS Adapter when you already have an existing HTS token on the fly.\n- You could use a HTS Connector when you want to create a new token.\n- You could use a HTS Connector with the existing HTS token but you have to add the HTS Connector contract as the Supply Key of the HTS token in order to execute the needed burnToken/mintToken precompile calls.",
            "codeOnlyTokens": 816,
            "startLine": 82,
            "endLine": 141,
            "type": ".md_part_2",
            "isOversized": false
          },
          {
            "originalText": "- The main reason of using a HTS Connector instead of HTS Adapter is to avoid liquidity logic.\n",
            "codeOnlyTokens": 21,
            "startLine": 142,
            "endLine": 143,
            "type": ".md_part_3",
            "isOversized": false
          }
        ],
        "groupedChunks": [
          {
            "combinedText": "// File: lib/layer-zero/README.md\n// Relevant file context:\n// Type: .md\n# Layer Zero examples\n\n### OApp\n\nMessage-passing interface to send and receive arbitrary pieces of data between contracts existing on different chains.\n\n##### Action steps:\n\n- Deploying the oapp contract on each network we're going to interact\n\n- In order to connect oapps together, we need to set the peer of the target oapp, more info can be found here https://docs.layerzero.network/v2/developers/evm/getting-started#connecting-your-contracts\n\n- Now, we're sending messages from one chain to another and vice versa\n\n- Wait a couple of minutes, the LZ progress can be tracked on https://testnet.layerzeroscan.com/tx/<tx_hash>\n\n- Finally we're checking whether the messages are received on both chains\n\n### OFT\n\nAllows fungible tokens to be transferred across multiple chains.\n\n##### Action steps:\n\n- Deploying OFT tokens which under the hood are ERC20s and contain the messaging between chains functionality provided by LZ\n\n- In order to connect OFTs together, we need to set the peer of the target OFT, more info can be found here https://docs.layerzero.network/v2/developers/evm/getting-started#connecting-your-contracts\n\n- Now, we're sending tokens between chains. That means we're burning tokens on the source chain and minting new ones on the destination chain\n\n- Wait a couple of minutes, the LZ progress can be tracked on https://testnet.layerzeroscan.com/tx/<tx_hash>\n\n- Finally we're checking whether the token balances are as expected on both the source and destination chains.\n\n### OFT Adapter\n\nIf your token already exists on the chain you want to connect, you can deploy the OFT Adapter contract to act as an intermediary lockbox for the token.\n\n##### Action steps:\n\n- Deploying ERC20 tokens on each chain\n\n- Deploying an OFT Adapters which will be used as a lockbox of ERC20s deployed the step above, you can use an already existing HTS token as well\n\n- In order to connect OFT Adapters together, we need to set the peer of the target OFT Adapter, more info can be found here https://docs.layerzero.network/v2/developers/evm/getting-started#connecting-your-contracts\n\n- We're funding the Adapter on both chains with some liquidity and after that we're approving it to spend the signer's token\n\n- Now, we're sending already existing tokens that are used by OFT Adapter between different chains\n\n- Wait a couple of minutes, the LZ progress can be tracked on https://testnet.layerzeroscan.com/tx/<tx_hash>\n\n- Finally we're checking the balances on each chain\n\n### ONFT\n\nAllows non-fungible tokens to be transferred across multiple chains.\n\n##### Action steps:\n\n- Deploying ONFT tokens which under the hood are ERC721s and contain the messaging between chains functionality provided by LZ\n\n- In order to connect ONFTs together, we need to set the peer of the target ONFT, more info can be found here https://docs.layerzero.network/v2/developers/evm/getting-started#connecting-your-contracts\n\n- Now, we're sending NFTs between chains. That means we're burning the NFT on the source chain and minting new one on the destination chain\n\n- Wait a couple of minutes, the LZ progress can be tracked on https://testnet.layerzeroscan.com/tx/<tx_hash>\n\n- Finally we're checking whether the NFTs are transferred successfully\n\n### ONFT Adapter\n\nIf your NFT contract already exists on the chain you want to connect, you can deploy the ONFT Adapter contract to act as an intermediary lockbox.\n\n##### Action steps:\n\n- Deploying ERC721s on each chain we want to connect\n\n- Deploying an ONFT Adapter which will be used as a lockbox of ERC721s deployed the step above\n\n- In order to connect ONFT Adapters together, we need to set the peer of the target ONFT Adapter, more info can be found here https://docs.layerzero.network/v2/developers/evm/getting-started#connecting-your-contracts\n\n- First, we have to mint some NFTs on each chain\n\n- Then, we have to approve the Adapter to be able to spend the NFT we want to send to another chain\n\n- Now, we're sending already existing NFTs between chains\n\n- Wait a couple of minutes, the LZ progress can be tracked on https://testnet.layerzeroscan.com/tx/<tx_hash>\n\n- Finally we're checking whether the NFTs are transferred successfully\n\n### HTS Connector\n\nThat's a variant of OFT but using an HTS token. Due to several incompatibilities between ERC20 and HTS tokens, we're not able to use them out of the box. All of them are described in the \"HTS Adapter vs HTS Connector\" section below.\n\n##### Action steps:\n\n- Deploying OFT on an EVM chain and HTS Connector on the Hedera chain. The HTS Connector extends OFTCore and creates HTS token within its constructor. Also, overrides OFTCore _debit and _credit with related HTS mint and burn precompile calls\n\n- In order to connect OFTs together, we need to set the peer of the target OFT, more info can be found here https://docs.layerzero.network/v2/developers/evm/getting-started#connecting-your-contracts\n\n- Approving HTS Connector to use some signer's tokens\n\n- Now, we're sending tokens from an EVM chain to Hedera and receiving HTS tokens and vice versa\n\n- Wait a couple of minutes, the LZ progress can be tracked on https://testnet.layerzeroscan.com/tx/<tx_hash>\n\nFinally we're checking whether the balances are expected on both source and destination chains\n\n### HTS Connector for existing HTS token\n\nThat's a variant of OFT but using an already existing HTS token. Keep in mind that \"supply key\" of the token must contains the HTS Connector contract's address.\n\n##### Action steps:\n\n- Create an HTS token\n\n- Deploying OFT on an EVM chain and HTS Connector on the Hedera chain. The HTS Connector for existing token extends OFTCore and receives the HTS tokens address as constructor parameter. Also, overrides OFTCore _debit and _credit with related HTS mint and burn precompile calls\n\n- In order to connect OFTs together, we need to set the peer of the target OFT, more info can be found here https://docs.layerzero.network/v2/developers/evm/getting-started#connecting-your-contracts\n\n- Adding the HTSConnectorExistingToken contract's address as a supply key of the existing HTS token\n\n- Funding the HTSConnectorExistingToken contract\n\n- Approving HTS Connector to use some signer's tokens\n\n- Now, we're sending tokens from an EVM chain to Hedera and receiving HTS tokens and vice versa\n\n- Wait a couple of minutes, the LZ progress can be tracked on https://testnet.layerzeroscan.com/tx/<tx_hash>\n\n- Finally we're checking whether the balances are expected on both source and destination chains\n\n### Useful information:\n- The addresses of endpoints [here](https://github.com/hashgraph/hedera-json-rpc-relay/blob/1030-lz-setup/tools/layer-zero-example/hardhat.config.js#L60) are the official LZ endpoints. A entire list of LZ supported endpoints can be found on https://docs.layerzero.network/v2/developers/evm/technical-reference/deployed-contracts.\n\n### HTS Adapter vs HTS Connector\n- You could use a HTS Adapter when you already have an existing HTS token on the fly.\n- You could use a HTS Connector when you want to create a new token.\n- You could use a HTS Connector with the existing HTS token but you have to add the HTS Connector contract as the Supply Key of the HTS token in order to execute the needed burnToken/mintToken precompile calls.\n- The main reason of using a HTS Connector instead of HTS Adapter is to avoid liquidity logic.\n",
            "totalTokens": 1707,
            "chunks": [
              {
                "originalText": "# Layer Zero examples\n\n### OApp\n\nMessage-passing interface to send and receive arbitrary pieces of data between contracts existing on different chains.\n\n##### Action steps:\n\n- Deploying the oapp contract on each network we're going to interact\n\n- In order to connect oapps together, we need to set the peer of the target oapp, more info can be found here https://docs.layerzero.network/v2/developers/evm/getting-started#connecting-your-contracts\n\n- Now, we're sending messages from one chain to another and vice versa\n\n- Wait a couple of minutes, the LZ progress can be tracked on https://testnet.layerzeroscan.com/tx/<tx_hash>\n\n- Finally we're checking whether the messages are received on both chains\n\n### OFT\n\nAllows fungible tokens to be transferred across multiple chains.\n\n##### Action steps:\n\n- Deploying OFT tokens which under the hood are ERC20s and contain the messaging between chains functionality provided by LZ\n\n- In order to connect OFTs together, we need to set the peer of the target OFT, more info can be found here https://docs.layerzero.network/v2/developers/evm/getting-started#connecting-your-contracts\n\n- Now, we're sending tokens between chains. That means we're burning tokens on the source chain and minting new ones on the destination chain\n\n- Wait a couple of minutes, the LZ progress can be tracked on https://testnet.layerzeroscan.com/tx/<tx_hash>\n\n- Finally we're checking whether the token balances are as expected on both the source and destination chains.\n\n### OFT Adapter\n\nIf your token already exists on the chain you want to connect, you can deploy the OFT Adapter contract to act as an intermediary lockbox for the token.\n\n##### Action steps:\n\n- Deploying ERC20 tokens on each chain\n\n- Deploying an OFT Adapters which will be used as a lockbox of ERC20s deployed the step above, you can use an already existing HTS token as well\n\n- In order to connect OFT Adapters together, we need to set the peer of the target OFT Adapter, more info can be found here https://docs.layerzero.network/v2/developers/evm/getting-started#connecting-your-contracts\n\n- We're funding the Adapter on both chains with some liquidity and after that we're approving it to spend the signer's token\n\n- Now, we're sending already existing tokens that are used by OFT Adapter between different chains\n\n- Wait a couple of minutes, the LZ progress can be tracked on https://testnet.layerzeroscan.com/tx/<tx_hash>\n\n- Finally we're checking the balances on each chain\n\n### ONFT\n\nAllows non-fungible tokens to be transferred across multiple chains.\n\n##### Action steps:\n\n- Deploying ONFT tokens which under the hood are ERC721s and contain the messaging between chains functionality provided by LZ\n\n- In order to connect ONFTs together, we need to set the peer of the target ONFT, more info can be found here https://docs.layerzero.network/v2/developers/evm/getting-started#connecting-your-contracts\n\n- Now, we're sending NFTs between chains. That means we're burning the NFT on the source chain and minting new one on the destination chain\n\n- Wait a couple of minutes, the LZ progress can be tracked on https://testnet.layerzeroscan.com/tx/<tx_hash>\n\n- Finally we're checking whether the NFTs are transferred successfully\n\n### ONFT Adapter\n\nIf your NFT contract already exists on the chain you want to connect, you can deploy the ONFT Adapter contract to act as an intermediary lockbox.\n\n##### Action steps:\n\n- Deploying ERC721s on each chain we want to connect\n\n- Deploying an ONFT Adapter which will be used as a lockbox of ERC721s deployed the step above\n\n- In order to connect ONFT Adapters together, we need to set the peer of the target ONFT Adapter, more info can be found here https://docs.layerzero.network/v2/developers/evm/getting-started#connecting-your-contracts\n\n- First, we have to mint some NFTs on each chain\n\n- Then, we have to approve the Adapter to be able to spend the NFT we want to send to another chain\n\n- Now, we're sending already existing NFTs between chains\n\n- Wait a couple of minutes, the LZ progress can be tracked on https://testnet.layerzeroscan.com/tx/<tx_hash>\n\n- Finally we're checking whether the NFTs are transferred successfully\n\n### HTS Connector\n\nThat's a variant of OFT but using an HTS token. Due to several incompatibilities between ERC20 and HTS tokens, we're not able to use them out of the box. All of them are described in the \"HTS Adapter vs HTS Connector\" section below.\n\n##### Action steps:\n\n- Deploying OFT on an EVM chain and HTS Connector on the Hedera chain. The HTS Connector extends OFTCore and creates HTS token within its constructor. Also, overrides OFTCore _debit and _credit with related HTS mint and burn precompile calls\n\n- In order to connect OFTs together, we need to set the peer of the target OFT, more info can be found here https://docs.layerzero.network/v2/developers/evm/getting-started#connecting-your-contracts\n\n- Approving HTS Connector to use some signer's tokens\n\n- Now, we're sending tokens from an EVM chain to Hedera and receiving HTS tokens and vice versa\n\n- Wait a couple of minutes, the LZ progress can be tracked on https://testnet.layerzeroscan.com/tx/<tx_hash>\n\nFinally we're checking whether the balances are expected on both source and destination chains\n\n### HTS Connector for existing HTS token\n\nThat's a variant of OFT but using an already existing HTS token. Keep in mind that \"supply key\" of the token must contains the HTS Connector contract's address.\n\n##### Action steps:\n\n- Create an HTS token\n\n- Deploying OFT on an EVM chain and HTS Connector on the Hedera chain. The HTS Connector for existing token extends OFTCore and receives the HTS tokens address as constructor parameter. Also, overrides OFTCore _debit and _credit with related HTS mint and burn precompile calls\n\n- In order to connect OFTs together, we need to set the peer of the target OFT, more info can be found here https://docs.layerzero.network/v2/developers/evm/getting-started#connecting-your-contracts\n\n- Adding the HTSConnectorExistingToken contract's address as a supply key of the existing HTS token\n\n- Funding the HTSConnectorExistingToken contract\n\n- Approving HTS Connector to use some signer's tokens\n\n- Now, we're sending tokens from an EVM chain to Hedera and receiving HTS tokens and vice versa\n\n- Wait a couple of minutes, the LZ progress can be tracked on https://testnet.layerzeroscan.com/tx/<tx_hash>\n\n- Finally we're checking whether the balances are expected on both source and destination chains\n\n### Useful information:\n- The addresses of endpoints [here](https://github.com/hashgraph/hedera-json-rpc-relay/blob/1030-lz-setup/tools/layer-zero-example/hardhat.config.js#L60) are the official LZ endpoints. A entire list of LZ supported endpoints can be found on https://docs.layerzero.network/v2/developers/evm/technical-reference/deployed-contracts.\n\n### HTS Adapter vs HTS Connector\n- You could use a HTS Adapter when you already have an existing HTS token on the fly.\n- You could use a HTS Connector when you want to create a new token.\n- You could use a HTS Connector with the existing HTS token but you have to add the HTS Connector contract as the Supply Key of the HTS token in order to execute the needed burnToken/mintToken precompile calls.\n- The main reason of using a HTS Connector instead of HTS Adapter is to avoid liquidity logic.\n",
                "codeOnlyTokens": 1686,
                "startLine": 1,
                "endLine": 143,
                "type": "full_file",
                "isOversized": false
              }
            ],
            "startLine": 1,
            "endLine": 143,
            "groupId": 1
          }
        ],
        "oversizedChunks": [],
        "sendStrategy": "full_file",
        "finalTokenCount": 1707,
        "skippedContent": [],
        "contextHeader": "// File: lib/layer-zero/README.md\n// Relevant file context:\n// Type: .md\n",
        "tokenBreakdown": {
          "originalFile": 1686,
          "finalSent": 1707,
          "codeTokensInGroups": 1686,
          "fileHeaderTokensInGroups": 21,
          "shellContextTokensInGroups": 0,
          "separatorTokensInGroups": 0,
          "skippedCodeTokens": 0,
          "unprocessedOversizedTokens": 0,
          "totalSavings": -21,
          "savingsPercentage": -1.2455516014234875,
          "fileHeaderCount": 1,
          "fileHeaderAvgSize": 21,
          "shellContextCount": 0,
          "shellContextAvgSize": 0,
          "separatorCount": 1,
          "separatorAvgSize": 0
        }
      }
    }
  ],
  "finalProjectScore": 7.656088611537796,
  "finalReview": {
    "model": "gemini-2.5-flash",
    "dossierBudget": 16000,
    "strategy": "global_top_impact",
    "filesSentForFinalEval": [
      "contracts/system-contracts/hedera-token-service/IHederaTokenService.sol",
      "lib/layer-zero/hts/HederaTokenService.sol",
      "contracts/system-contracts/hedera-token-service/examples/token-query/TokenQueryContract.sol",
      "contracts/system-contracts/hedera-account-service/HederaAccountService.sol",
      "system-contract-dapp-playground/src/api/hedera/index.ts",
      "contracts/system-contracts/exchange-rate/ExchangeRateSystemContract.sol",
      "system-contract-dapp-playground/src/components/contract-interaction/hts/token-create-custom/methods/index.tsx"
    ],
    "usage": {
      "prompt_tokens": 19398,
      "completion_tokens": 4605,
      "total_tokens": 24003
    },
    "multiplier": 1.08,
    "final_score_multiplier": 1.08,
    "executive_summary": {
      "what_it_is": "This project is a comprehensive reference library and dApp playground demonstrating the utilization of Hedera's native system contracts, primarily the Hedera Token Service (HTS) and Hedera Account Service (HAS), through EVM smart contracts.",
      "how_it_works": "It provides Solidity interfaces and wrapper contracts that abstract the direct interaction with Hedera's precompiled smart contracts using low-level `call` operations and `abi.encodeWithSelector`. A TypeScript-based frontend, utilizing Ethers.js, interacts with these deployed Solidity contracts to showcase token creation, management, and account operations on Hedera.",
      "final_verdict": "This project is an exemplary and highly valuable resource for developers seeking to integrate Hedera's native services via EVM. Its clear structure, correct use of precompile patterns, and practical dApp examples highlight a strong understanding of Hedera's smart contract ecosystem, demonstrating a skilled and methodical approach."
    },
    "detailed_audit": {
      "security_assessment": "The Solidity contracts provided are primarily interfaces and thin wrappers around Hedera's precompiled system contracts. As such, they are largely immune to typical smart contract vulnerabilities like re-entrancy or integer overflows, as the core logic resides within the highly audited Hedera network services. The wrapper contracts correctly check the `success` boolean and `responseCode` from external precompile calls, preventing unexpected behavior from failed operations. Access control is not extensively implemented in these example contracts, which is acceptable for a reference/playground project, but would be critical for production dApps where specific functions might need restricted access.",
      "gas_efficiency_assessment": "The smart contracts interact with Hedera's precompiles using the most gas-efficient method available for EVM contracts (low-level `call` with `abi.encodeWithSelector`). The use of `memory` for large data structures like arrays and structs is appropriate, avoiding unnecessary storage costs. The `TokenQueryContract` emits events for all query results; while this adds minor gas cost for on-chain execution, it is a deliberate and valuable choice for a 'playground' to make off-chain data retrieval easier for dApps via event logs.",
      "sdk_and_hts_usage_assessment": "The project demonstrates excellent usage of the Hedera ecosystem. On-chain, the Solidity wrapper contracts (`HederaTokenService.sol`, `HederaAccountService.sol`) correctly abstract the HTS and HAS precompile interactions, adhering to Hedera's recommended patterns. Off-chain, the TypeScript code utilizes `ethers.js` effectively for contract deployment and interaction, including handling transaction receipts and storing results. The hardcoded `gasLimit` in `deploySmartContract` could be made more flexible for production, but is reasonable for a demo. The overall integration with HTS is central and very well executed.",
      "context_sufficiency_assessment": "The provided code dossier was highly sufficient for a comprehensive audit. It included the core Solidity interfaces, wrapper contracts, key dApp interaction logic, and an example of another system contract integration. The only file that would have provided a more complete picture, though not strictly necessary for the core audit, would be `contracts/system-contracts/exchange-rate/SelfFunding.sol` to understand the `ExchangeRateSystemContract`'s payment mechanism fully.",
      "multiplier_justification": "The project warrants an uplift in its preliminary score due to its outstanding adherence to Hedera EVM best practices and its clear, well-structured implementation. It serves its purpose as a 'reference library' exceptionally well, providing canonical examples for interacting with Hedera's system contracts via EVM. The Solidity code is clean, robust in its precompile error handling, and the dApp integration highlights practical application. The minor points (like event emissions for queries or `int` vs `int64` consistency in one contract) are negligible compared to the overall quality and utility for Hedera development.",
      "score_explanation": "This score signifies that the project is of very high quality, demonstrating a strong grasp of Hedera's smart contract best practices, efficient design patterns, and solid security considerations for its specific domain of interacting with native Hedera services. It is a well-engineered solution that would serve as an excellent foundation or reference for others."
    },
    "inferred_developer_archetype": [
      "Hedera Smart Contract Specialist",
      "dApp Architect",
      "Blockchain Reference Implementer"
    ],
    "hedera_service_integration_score": 9,
    "strategic_next_feature": "Implement and demonstrate Hedera Schedule Service precompile interactions (e.g., scheduling a deferred token transfer) or integrate with the Hedera Consensus Service (HCS) for on-chain message logging.",
    "refined_tech_stack": [
      "Solidity",
      "Hardhat",
      "TypeScript",
      "React",
      "Ethers.js"
    ],
    "holistic_project_summary": "This project stands out as a world-class reference implementation for leveraging Hedera's native services from the EVM. It meticulously showcases how to interact with the HTS and HAS precompiles, offering both robust Solidity wrappers and practical dApp integration. The work is clean, secure by design, and provides immense value for developers building on the Hedera network.",
    "groupsInDossier": 10,
  }
}