// src/lib/dummy-data.ts

import type { ProjectScorecard } from '@/types'; // Assuming you create a types.ts for your interfaces

export const DUMMY_PROJECT_SCORECARD: ProjectScorecard = {
  "runId": "2025-08-06T23-09-35-991Z",
  "repoName": "hedera-smart-contracts",
  "model": "gpt-4o-mini",
  "preliminaryProjectScore": 7.120226149122566,
  "mainDomain": "Hedera dApp",
  "techStack": [
    "Hardhat",
    "Solidity"
  ],
  "projectEssence": "This project is a reference library for Hedera Smart Contracts designed to provide functionalities related to the Hedera Token Service (HTS) and Hedera Account Service (HAS) through precompiled EVM smart contracts. It serves as a developer tool for creating and interacting with smart contracts on the Hedera network, utilizing Solidity and the Hardhat development environment.",
  "profile": {
    "complexity": 6.662863930595412,
    "quality": 7.4736490446263835,
    "maintainability": 6.891057781239351,
    "best_practices": 7.765048242709504
  },
  "usage": {
    "prompt_tokens": 29133,
    "completion_tokens": 2285,
    "total_tokens": 31418
  },
  "totalRetries": 0,
  "totalFailedFiles": 0,
  "warnings": {
    "vendedCodeFlagged": []
  },
  "scoredFiles": [
    {
      "filePath": "contracts/system-contracts/pseudo-random-number-generator/PrngSystemContract.sol",
      "totalOriginalTokens": 170,
      "finalTokenCount": 200,
      "impactScore": 64,
      "averageComplexity": 8,
      "averageQuality": 8,
      "usage": {
        "prompt_tokens": 284,
        "completion_tokens": 127,
        "total_tokens": 411
      },
      "retries": 0,
      "hadError": false,
      "scoredChunkGroups": [
        {
          "groupId": 1,
          "score": {
            "file_path": "contracts/system-contracts/pseudo-random-number-generator/PrngSystemContract.sol",
            "complexity_score": 8,
            "code_quality_score": 8,
            "maintainability_score": 7,
            "best_practices_adherence": 9,
            "positive_feedback": "The event logging for pseudo-random seed ensures transparency and traceability in its usage.",
            "improvement_suggestion": "Consider adding a fallback mechanism in case the precompile call fails.",
            "group_summary": "Contract that interacts with a precompiled contract to generate pseudo-random seeds."
          },
          "totalTokens": 200,
          "usage": {
            "prompt_tokens": 284,
            "completion_tokens": 127,
            "total_tokens": 411
          }
        }
      ],
      "chunkingDetails": {
        "filePath": "contracts/system-contracts/pseudo-random-number-generator/PrngSystemContract.sol",
        "totalFileTokens": 170,
        "chunks": [
          {
            "originalText": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.5.0 <0.9.0;\n\nimport \"./IPrngSystemContract.sol\";\n\ncontract PrngSystemContract {\n    event PseudoRandomSeed(bytes32 seedBytes);\n\n    // Prng system contract address with ContractID 0.0.361\n    address constant PRECOMPILE_ADDRESS = address(0x169);\n\n    function getPseudorandomSeed() external returns (bytes32 seedBytes) {\n        (bool success, bytes memory result) = PRECOMPILE_ADDRESS.call(\n            abi.encodeWithSelector(IPrngSystemContract.getPseudorandomSeed.selector));\n        require(success, \"PRNG system call failed\");\n        seedBytes = abi.decode(result, (bytes32));\n        emit PseudoRandomSeed(seedBytes);\n    }\n}\n",
            "codeOnlyTokens": 170,
            "startLine": 1,
            "endLine": 20,
            "type": ".sol",
            "isOversized": false
          }
        ],
        "groupedChunks": [
          {
            "combinedText": "// File: contracts/system-contracts/pseudo-random-number-generator/PrngSystemContract.sol\n// Relevant file context:\n// Type: .sol\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.5.0 <0.9.0;\n\nimport \"./IPrngSystemContract.sol\";\n\ncontract PrngSystemContract {\n    event PseudoRandomSeed(bytes32 seedBytes);\n\n    // Prng system contract address with ContractID 0.0.361\n    address constant PRECOMPILE_ADDRESS = address(0x169);\n\n    function getPseudorandomSeed() external returns (bytes32 seedBytes) {\n        (bool success, bytes memory result) = PRECOMPILE_ADDRESS.call(\n            abi.encodeWithSelector(IPrngSystemContract.getPseudorandomSeed.selector));\n        require(success, \"PRNG system call failed\");\n        seedBytes = abi.decode(result, (bytes32));\n        emit PseudoRandomSeed(seedBytes);\n    }\n}\n",
            "totalTokens": 200,
            "chunks": [
              {
                "originalText": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.5.0 <0.9.0;\n\nimport \"./IPrngSystemContract.sol\";\n\ncontract PrngSystemContract {\n    event PseudoRandomSeed(bytes32 seedBytes);\n\n    // Prng system contract address with ContractID 0.0.361\n    address constant PRECOMPILE_ADDRESS = address(0x169);\n\n    function getPseudorandomSeed() external returns (bytes32 seedBytes) {\n        (bool success, bytes memory result) = PRECOMPILE_ADDRESS.call(\n            abi.encodeWithSelector(IPrngSystemContract.getPseudorandomSeed.selector));\n        require(success, \"PRNG system call failed\");\n        seedBytes = abi.decode(result, (bytes32));\n        emit PseudoRandomSeed(seedBytes);\n    }\n}\n",
                "codeOnlyTokens": 170,
                "startLine": 1,
                "endLine": 20,
                "type": "full_file",
                "isOversized": false
              }
            ],
            "startLine": 1,
            "endLine": 20,
            "groupId": 1
          }
        ],
        "oversizedChunks": [],
        "sendStrategy": "full_file",
        "finalTokenCount": 200,
        "skippedContent": [],
        "contextHeader": "// File: contracts/system-contracts/pseudo-random-number-generator/PrngSystemContract.sol\n// Relevant file context:\n// Type: .sol\n",
        "tokenBreakdown": {
          "originalFile": 170,
          "finalSent": 200,
          "codeTokensInGroups": 170,
          "fileHeaderTokensInGroups": 30,
          "shellContextTokensInGroups": 0,
          "separatorTokensInGroups": 0,
          "skippedCodeTokens": 0,
          "unprocessedOversizedTokens": 0,
          "totalSavings": -30,
          "savingsPercentage": -17.647058823529413,
          "fileHeaderCount": 1,
          "fileHeaderAvgSize": 30,
          "shellContextCount": 0,
          "shellContextAvgSize": 0,
          "separatorCount": 1,
          "separatorAvgSize": 0
        }
      }
    },
    {
      "filePath": "contracts/system-contracts/hedera-account-service/HederaAccountService.sol",
      "totalOriginalTokens": 1632,
      "finalTokenCount": 1661,
      "impactScore": 53.333333333333336,
      "averageComplexity": 8,
      "averageQuality": 6.666666666666667,
      "usage": {
        "prompt_tokens": 1964,
        "completion_tokens": 140,
        "total_tokens": 2104
      },
      "retries": 0,
      "hadError": false,
      "scoredChunkGroups": [
        {
          "groupId": 1,
          "score": {
            "file_path": "contracts/system-contracts/hedera-account-service/HederaAccountService.sol",
            "complexity_score": 8,
            "code_quality_score": 6,
            "maintainability_score": 6,
            "best_practices_adherence": 8,
            "positive_feedback": "Direct integration with Hedera precompiles shows a strong grasp of Hedera architecture and improves transaction efficiency.",
            "improvement_suggestion": "Consider adding comments regarding the precompile's reliability for improved code documentation.",
            "group_summary": "This contract manages hbar allowances and validates Hedera account aliases integrating with Hedera precompiles."
          },
          "totalTokens": 1661,
          "usage": {
            "prompt_tokens": 1964,
            "completion_tokens": 140,
            "total_tokens": 2104
          }
        }
      ],
      "chunkingDetails": {
        "filePath": "contracts/system-contracts/hedera-account-service/HederaAccountService.sol",
        "totalFileTokens": 1632,
        "chunks": [
          {
            "originalText": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.5.0 <0.9.0;\npragma experimental ABIEncoderV2;\n\nimport \"../HederaResponseCodes.sol\";\nimport \"./IHederaAccountService.sol\";\n\nabstract contract HederaAccountService {\n    address constant HASPrecompileAddress = address(0x16a);\n\n    /// Returns the amount of hbars that the spender has been authorized to spend on behalf of the owner.\n    /// @param owner The account that has authorized the spender\n    /// @param spender The account that has been authorized by the owner\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return amount The amount of hbar that the spender has been authorized to spend on behalf of the owner.\n    function hbarAllowance(address owner, address spender) internal returns (int64 responseCode, int256 amount)\n    {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.hbarAllowance.selector,\n                owner, spender));\n        (responseCode, amount) = success ? abi.decode(result, (int32, int256)) : (HederaResponseCodes.UNKNOWN, (int256)(0));\n    }\n\n\n    /// Allows spender to withdraw hbars from the owner account multiple times, up to the value amount. If this function is called\n    /// again it overwrites the current allowance with the new amount.\n    /// @param owner The owner of the hbars\n    /// @param spender the account address authorized to spend\n    /// @param amount the amount of hbars authorized to spend.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function hbarApprove(address owner, address spender, int256 amount) internal returns (int64 responseCode)\n    {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.hbarApprove.selector,\n                owner, spender, amount));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Returns the EVM address alias for a given Hedera account.\n    /// @param accountNumAlias The Hedera account number alias to lookup. Must satisfy all of the following:\n    ///                         - Must be in long-zero format (0x000...0<account_num>)\n    ///                         - Must reference an existing Hedera account\n    ///                         - Referenced account must have an associated EVM address alias\n    /// @return responseCode The response code indicating the status of the request:\n    ///                         - SUCCESS (22) if successful\n    ///                         - INVALID_ACCOUNT_ID (15) if any validation of the accountNumAlias fails\n    ///                         - UNKNOWN (21) if the precompile call fails\n    /// @return evmAddressAlias The EVM address alias associated with the Hedera account, or address(0) if the request fails\n    function getEvmAddressAlias(address accountNumAlias) internal returns (int64 responseCode, address evmAddressAlias) \n    {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.getEvmAddressAlias.selector, accountNumAlias));\n        (responseCode, evmAddressAlias) = success ? abi.decode(result, (int32, address)) : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Returns the Hedera Account ID (as account num alias) for the given EVM address alias\n    /// @param evmAddressAlias The EVM address alias to get the Hedera account for. Must satisfy all of the following:\n    ///                         - Must be in EVM format (not a long-zero address)",
            "codeOnlyTokens": 805,
            "startLine": 1,
            "endLine": 58,
            "type": ".sol_part_1",
            "isOversized": false
          },
          {
            "originalText": "    ///                         - Must reference an existing Hedera account\n    ///                         - Referenced account must have an associated account num alias (long-zero format)\n    /// @return responseCode The response code indicating the status of the request:\n    ///                         - SUCCESS (22) if successful\n    ///                         - INVALID_SOLIDITY_ADDRESS (29) if any validation of the evmAddressAlias fails\n    ///                         - UNKNOWN (21) if the precompile call fails\n    /// @return accountNumAlias The Hedera account's num alias in long-zero format, or address(0) if the request fails\n    function getHederaAccountNumAlias(address evmAddressAlias) internal returns (int64 responseCode, address accountNumAlias) {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.getHederaAccountNumAlias.selector, evmAddressAlias));\n        (responseCode, accountNumAlias) = success ? abi.decode(result, (int32, address)) : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Returns true iff a Hedera account num alias or EVM address alias.\n    /// @param addr Some 20-byte address.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return response true iff addr is a Hedera account num alias or an EVM address alias (and false otherwise).\n    function isValidAlias(address addr) internal returns (int64 responseCode, bool response) {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.isValidAlias.selector, addr));\n        (responseCode, response) = success ? (HederaResponseCodes.SUCCESS, abi.decode(result, (bool))) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Determines if the signature is valid for the given message hash and account.\n    /// It is assumed that the signature is composed of a single EDCSA or ED25519 key.\n    /// @param account The account to check the signature against\n    /// @param messageHash The hash of the message to check the signature against\n    /// @param signature The signature to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return authorized True if the signature is valid, false otherwise\n    function isAuthorizedRaw(address account, bytes memory messageHash, bytes memory signature) internal returns (int64 responseCode, bool authorized) {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.isAuthorizedRaw.selector,\n                account, messageHash, signature));\n        (responseCode, authorized) = success ? (HederaResponseCodes.SUCCESS, abi.decode(result, (bool))) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Determines if the signature is valid for the given message and account.\n    /// It is assumed that the signature is composed of a possibly complex cryptographic key.\n    /// @param account The account to check the signature against.\n    /// @param message The message to check the signature against.\n    /// @param signature The signature to check encoded as bytes.\n    /// @return responseCode The response code for the status of the request.  SUCCESS is 22.\n    /// @return authorized True if the signature is valid, false otherwise.\n    function isAuthorized(address account, bytes memory message, bytes memory signature) internal returns (int64 responseCode, bool authorized) {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.isAuthorized.selector,\n                account, message, signature));\n        (responseCode, authorized) = success ? abi.decode(result, (int32, bool)) : (HederaResponseCodes.UNKNOWN, false);",
            "codeOnlyTokens": 824,
            "startLine": 59,
            "endLine": 107,
            "type": ".sol_part_2",
            "isOversized": false
          },
          {
            "originalText": "    }\n}\n",
            "codeOnlyTokens": 3,
            "startLine": 108,
            "endLine": 110,
            "type": ".sol_part_3",
            "isOversized": false
          }
        ],
        "groupedChunks": [
          {
            "combinedText": "// File: contracts/system-contracts/hedera-account-service/HederaAccountService.sol\n// Relevant file context:\n// Type: .sol\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.5.0 <0.9.0;\npragma experimental ABIEncoderV2;\n\nimport \"../HederaResponseCodes.sol\";\nimport \"./IHederaAccountService.sol\";\n\nabstract contract HederaAccountService {\n    address constant HASPrecompileAddress = address(0x16a);\n\n    /// Returns the amount of hbars that the spender has been authorized to spend on behalf of the owner.\n    /// @param owner The account that has authorized the spender\n    /// @param spender The account that has been authorized by the owner\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return amount The amount of hbar that the spender has been authorized to spend on behalf of the owner.\n    function hbarAllowance(address owner, address spender) internal returns (int64 responseCode, int256 amount)\n    {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.hbarAllowance.selector,\n                owner, spender));\n        (responseCode, amount) = success ? abi.decode(result, (int32, int256)) : (HederaResponseCodes.UNKNOWN, (int256)(0));\n    }\n\n\n    /// Allows spender to withdraw hbars from the owner account multiple times, up to the value amount. If this function is called\n    /// again it overwrites the current allowance with the new amount.\n    /// @param owner The owner of the hbars\n    /// @param spender the account address authorized to spend\n    /// @param amount the amount of hbars authorized to spend.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function hbarApprove(address owner, address spender, int256 amount) internal returns (int64 responseCode)\n    {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.hbarApprove.selector,\n                owner, spender, amount));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Returns the EVM address alias for a given Hedera account.\n    /// @param accountNumAlias The Hedera account number alias to lookup. Must satisfy all of the following:\n    ///                         - Must be in long-zero format (0x000...0<account_num>)\n    ///                         - Must reference an existing Hedera account\n    ///                         - Referenced account must have an associated EVM address alias\n    /// @return responseCode The response code indicating the status of the request:\n    ///                         - SUCCESS (22) if successful\n    ///                         - INVALID_ACCOUNT_ID (15) if any validation of the accountNumAlias fails\n    ///                         - UNKNOWN (21) if the precompile call fails\n    /// @return evmAddressAlias The EVM address alias associated with the Hedera account, or address(0) if the request fails\n    function getEvmAddressAlias(address accountNumAlias) internal returns (int64 responseCode, address evmAddressAlias) \n    {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.getEvmAddressAlias.selector, accountNumAlias));\n        (responseCode, evmAddressAlias) = success ? abi.decode(result, (int32, address)) : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Returns the Hedera Account ID (as account num alias) for the given EVM address alias\n    /// @param evmAddressAlias The EVM address alias to get the Hedera account for. Must satisfy all of the following:\n    ///                         - Must be in EVM format (not a long-zero address)\n    ///                         - Must reference an existing Hedera account\n    ///                         - Referenced account must have an associated account num alias (long-zero format)\n    /// @return responseCode The response code indicating the status of the request:\n    ///                         - SUCCESS (22) if successful\n    ///                         - INVALID_SOLIDITY_ADDRESS (29) if any validation of the evmAddressAlias fails\n    ///                         - UNKNOWN (21) if the precompile call fails\n    /// @return accountNumAlias The Hedera account's num alias in long-zero format, or address(0) if the request fails\n    function getHederaAccountNumAlias(address evmAddressAlias) internal returns (int64 responseCode, address accountNumAlias) {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.getHederaAccountNumAlias.selector, evmAddressAlias));\n        (responseCode, accountNumAlias) = success ? abi.decode(result, (int32, address)) : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Returns true iff a Hedera account num alias or EVM address alias.\n    /// @param addr Some 20-byte address.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return response true iff addr is a Hedera account num alias or an EVM address alias (and false otherwise).\n    function isValidAlias(address addr) internal returns (int64 responseCode, bool response) {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.isValidAlias.selector, addr));\n        (responseCode, response) = success ? (HederaResponseCodes.SUCCESS, abi.decode(result, (bool))) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Determines if the signature is valid for the given message hash and account.\n    /// It is assumed that the signature is composed of a single EDCSA or ED25519 key.\n    /// @param account The account to check the signature against\n    /// @param messageHash The hash of the message to check the signature against\n    /// @param signature The signature to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return authorized True if the signature is valid, false otherwise\n    function isAuthorizedRaw(address account, bytes memory messageHash, bytes memory signature) internal returns (int64 responseCode, bool authorized) {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.isAuthorizedRaw.selector,\n                account, messageHash, signature));\n        (responseCode, authorized) = success ? (HederaResponseCodes.SUCCESS, abi.decode(result, (bool))) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Determines if the signature is valid for the given message and account.\n    /// It is assumed that the signature is composed of a possibly complex cryptographic key.\n    /// @param account The account to check the signature against.\n    /// @param message The message to check the signature against.\n    /// @param signature The signature to check encoded as bytes.\n    /// @return responseCode The response code for the status of the request.  SUCCESS is 22.\n    /// @return authorized True if the signature is valid, false otherwise.\n    function isAuthorized(address account, bytes memory message, bytes memory signature) internal returns (int64 responseCode, bool authorized) {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.isAuthorized.selector,\n                account, message, signature));\n        (responseCode, authorized) = success ? abi.decode(result, (int32, bool)) : (HederaResponseCodes.UNKNOWN, false);\n    }\n}\n",
            "totalTokens": 1661,
            "chunks": [
              {
                "originalText": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.5.0 <0.9.0;\npragma experimental ABIEncoderV2;\n\nimport \"../HederaResponseCodes.sol\";\nimport \"./IHederaAccountService.sol\";\n\nabstract contract HederaAccountService {\n    address constant HASPrecompileAddress = address(0x16a);\n\n    /// Returns the amount of hbars that the spender has been authorized to spend on behalf of the owner.\n    /// @param owner The account that has authorized the spender\n    /// @param spender The account that has been authorized by the owner\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return amount The amount of hbar that the spender has been authorized to spend on behalf of the owner.\n    function hbarAllowance(address owner, address spender) internal returns (int64 responseCode, int256 amount)\n    {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.hbarAllowance.selector,\n                owner, spender));\n        (responseCode, amount) = success ? abi.decode(result, (int32, int256)) : (HederaResponseCodes.UNKNOWN, (int256)(0));\n    }\n\n\n    /// Allows spender to withdraw hbars from the owner account multiple times, up to the value amount. If this function is called\n    /// again it overwrites the current allowance with the new amount.\n    /// @param owner The owner of the hbars\n    /// @param spender the account address authorized to spend\n    /// @param amount the amount of hbars authorized to spend.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function hbarApprove(address owner, address spender, int256 amount) internal returns (int64 responseCode)\n    {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.hbarApprove.selector,\n                owner, spender, amount));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Returns the EVM address alias for a given Hedera account.\n    /// @param accountNumAlias The Hedera account number alias to lookup. Must satisfy all of the following:\n    ///                         - Must be in long-zero format (0x000...0<account_num>)\n    ///                         - Must reference an existing Hedera account\n    ///                         - Referenced account must have an associated EVM address alias\n    /// @return responseCode The response code indicating the status of the request:\n    ///                         - SUCCESS (22) if successful\n    ///                         - INVALID_ACCOUNT_ID (15) if any validation of the accountNumAlias fails\n    ///                         - UNKNOWN (21) if the precompile call fails\n    /// @return evmAddressAlias The EVM address alias associated with the Hedera account, or address(0) if the request fails\n    function getEvmAddressAlias(address accountNumAlias) internal returns (int64 responseCode, address evmAddressAlias) \n    {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.getEvmAddressAlias.selector, accountNumAlias));\n        (responseCode, evmAddressAlias) = success ? abi.decode(result, (int32, address)) : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Returns the Hedera Account ID (as account num alias) for the given EVM address alias\n    /// @param evmAddressAlias The EVM address alias to get the Hedera account for. Must satisfy all of the following:\n    ///                         - Must be in EVM format (not a long-zero address)\n    ///                         - Must reference an existing Hedera account\n    ///                         - Referenced account must have an associated account num alias (long-zero format)\n    /// @return responseCode The response code indicating the status of the request:\n    ///                         - SUCCESS (22) if successful\n    ///                         - INVALID_SOLIDITY_ADDRESS (29) if any validation of the evmAddressAlias fails\n    ///                         - UNKNOWN (21) if the precompile call fails\n    /// @return accountNumAlias The Hedera account's num alias in long-zero format, or address(0) if the request fails\n    function getHederaAccountNumAlias(address evmAddressAlias) internal returns (int64 responseCode, address accountNumAlias) {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.getHederaAccountNumAlias.selector, evmAddressAlias));\n        (responseCode, accountNumAlias) = success ? abi.decode(result, (int32, address)) : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Returns true iff a Hedera account num alias or EVM address alias.\n    /// @param addr Some 20-byte address.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return response true iff addr is a Hedera account num alias or an EVM address alias (and false otherwise).\n    function isValidAlias(address addr) internal returns (int64 responseCode, bool response) {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.isValidAlias.selector, addr));\n        (responseCode, response) = success ? (HederaResponseCodes.SUCCESS, abi.decode(result, (bool))) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Determines if the signature is valid for the given message hash and account.\n    /// It is assumed that the signature is composed of a single EDCSA or ED25519 key.\n    /// @param account The account to check the signature against\n    /// @param messageHash The hash of the message to check the signature against\n    /// @param signature The signature to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return authorized True if the signature is valid, false otherwise\n    function isAuthorizedRaw(address account, bytes memory messageHash, bytes memory signature) internal returns (int64 responseCode, bool authorized) {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.isAuthorizedRaw.selector,\n                account, messageHash, signature));\n        (responseCode, authorized) = success ? (HederaResponseCodes.SUCCESS, abi.decode(result, (bool))) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Determines if the signature is valid for the given message and account.\n    /// It is assumed that the signature is composed of a possibly complex cryptographic key.\n    /// @param account The account to check the signature against.\n    /// @param message The message to check the signature against.\n    /// @param signature The signature to check encoded as bytes.\n    /// @return responseCode The response code for the status of the request.  SUCCESS is 22.\n    /// @return authorized True if the signature is valid, false otherwise.\n    function isAuthorized(address account, bytes memory message, bytes memory signature) internal returns (int64 responseCode, bool authorized) {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.isAuthorized.selector,\n                account, message, signature));\n        (responseCode, authorized) = success ? abi.decode(result, (int32, bool)) : (HederaResponseCodes.UNKNOWN, false);\n    }\n}\n",
                "codeOnlyTokens": 1632,
                "startLine": 1,
                "endLine": 110,
                "type": "full_file",
                "isOversized": false
              }
            ],
            "startLine": 1,
            "endLine": 110,
            "groupId": 1
          }
        ],
        "oversizedChunks": [],
        "sendStrategy": "full_file",
        "finalTokenCount": 1661,
        "skippedContent": [],
        "contextHeader": "// File: contracts/system-contracts/hedera-account-service/HederaAccountService.sol\n// Relevant file context:\n// Type: .sol\n",
        "tokenBreakdown": {
          "originalFile": 1632,
          "finalSent": 1661,
          "codeTokensInGroups": 1632,
          "fileHeaderTokensInGroups": 29,
          "shellContextTokensInGroups": 0,
          "separatorTokensInGroups": 0,
          "skippedCodeTokens": 0,
          "unprocessedOversizedTokens": 0,
          "totalSavings": -29,
          "savingsPercentage": -1.7769607843137254,
          "fileHeaderCount": 1,
          "fileHeaderAvgSize": 29,
          "shellContextCount": 0,
          "shellContextAvgSize": 0,
          "separatorCount": 1,
          "separatorAvgSize": 0
        }
      }
    },
    {
      "filePath": "contracts/system-contracts/hedera-token-service/HederaTokenService.sol",
      "totalOriginalTokens": 10352,
      "finalTokenCount": 10724,
      "impactScore": 52.733333333333334,
      "averageComplexity": 7,
      "averageQuality": 7.8,
      "usage": {
        "prompt_tokens": 14920,
        "completion_tokens": 604,
        "total_tokens": 15524
      },
      "retries": 0,
      "hadError": false,
      "scoredChunkGroups": [
        {
          "groupId": 1,
          "score": {
            "complexity_score": 7,
            "code_quality_score": 8,
            "maintainability_score": 7,
            "best_practices_adherence": 8,
            "positive_feedback": "The use of modifiers like nonEmptyExpiry helps to enforce token creation rules elegantly.",
            "improvement_suggestion": "Enhance error handling to provide clearer feedback for failed token operations, potentially using custom error types.",
            "group_summary": "This contract facilitates various token operations like minting, burning, and transferring on the Hedera network."
          },
          "totalTokens": 2491,
          "usage": {
            "prompt_tokens": 3321,
            "completion_tokens": 117,
            "total_tokens": 3438,
            "prompt_tokens_details": {
              "cached_tokens": 0,
              "audio_tokens": 0
            },
            "completion_tokens_details": {
              "reasoning_tokens": 0,
              "audio_tokens": 0,
              "accepted_prediction_tokens": 0,
              "rejected_prediction_tokens": 0
            }
          }
        },
        {
          "groupId": 2,
          "score": {
            "complexity_score": 7,
            "code_quality_score": 8,
            "maintainability_score": 7,
            "best_practices_adherence": 8,
            "positive_feedback": "The use of precompile interactions effectively abstracts complex token operations, streamlining the transaction process on Hedera.",
            "improvement_suggestion": "Consider adding events for state changes to enhance tracking and transparency for token operations.",
            "group_summary": "This code facilitates token creation, management, and information retrieval on the Hedera network."
          },
          "totalTokens": 2513,
          "usage": {
            "prompt_tokens": 3355,
            "completion_tokens": 115,
            "total_tokens": 3470,
            "prompt_tokens_details": {
              "cached_tokens": 0,
              "audio_tokens": 0
            },
            "completion_tokens_details": {
              "reasoning_tokens": 0,
              "audio_tokens": 0,
              "accepted_prediction_tokens": 0,
              "rejected_prediction_tokens": 0
            }
          }
        },
        {
          "groupId": 3,
          "score": {
            "complexity_score": 7,
            "code_quality_score": 8,
            "maintainability_score": 7,
            "best_practices_adherence": 8,
            "positive_feedback": "The use of precompile addresses for HTS interactions is efficient and leverages Hedera’s unique architecture effectively.",
            "improvement_suggestion": "Consider implementing error handling mechanisms in a more structured way to improve debugging and maintainability.",
            "group_summary": "Facilitates token management operations like approval, freezing, and transferring tokens on the Hedera network."
          },
          "totalTokens": 2504,
          "usage": {
            "prompt_tokens": 3342,
            "completion_tokens": 121,
            "total_tokens": 3463,
            "prompt_tokens_details": {
              "cached_tokens": 0,
              "audio_tokens": 0
            },
            "completion_tokens_details": {
              "reasoning_tokens": 0,
              "audio_tokens": 0,
              "accepted_prediction_tokens": 0,
              "rejected_prediction_tokens": 0
            }
          }
        },
        {
          "groupId": 4,
          "score": {
            "complexity_score": 8,
            "code_quality_score": 7,
            "maintainability_score": 7,
            "best_practices_adherence": 8,
            "positive_feedback": "The variety of token operations (e.g., pausing, wiping, updating) is well-implemented to utilize Hedera's precompiled functions efficiently.",
            "improvement_suggestion": "Consider adding more detailed error handling for unsuccessful precompile calls to improve robustness.",
            "group_summary": "Facilitates multiple token management operations for Hedera, including transfer, pause, wipe, update, and query functionalities."
          },
          "totalTokens": 2513,
          "usage": {
            "prompt_tokens": 3354,
            "completion_tokens": 131,
            "total_tokens": 3485,
            "prompt_tokens_details": {
              "cached_tokens": 0,
              "audio_tokens": 0
            },
            "completion_tokens_details": {
              "reasoning_tokens": 0,
              "audio_tokens": 0,
              "accepted_prediction_tokens": 0,
              "rejected_prediction_tokens": 0
            }
          }
        },
        {
          "groupId": 5,
          "score": {
            "complexity_score": 6,
            "code_quality_score": 8,
            "maintainability_score": 7,
            "best_practices_adherence": 7,
            "positive_feedback": "The use of precompiled contracts for operations is efficient and leverages Hedera's capabilities effectively.",
            "improvement_suggestion": "Consider adding input validation for arrays in the airdrop and reject functions to prevent potential issues with malformed data.",
            "group_summary": "This code manages token airdrops and rejection processes through Hedera's token service."
          },
          "totalTokens": 703,
          "usage": {
            "prompt_tokens": 1548,
            "completion_tokens": 120,
            "total_tokens": 1668,
            "prompt_tokens_details": {
              "cached_tokens": 0,
              "audio_tokens": 0
            },
            "completion_tokens_details": {
              "reasoning_tokens": 0,
              "audio_tokens": 0,
              "accepted_prediction_tokens": 0,
              "rejected_prediction_tokens": 0
            }
          }
        }
      ],
      "chunkingDetails": {
        "filePath": "contracts/system-contracts/hedera-token-service/HederaTokenService.sol",
        "totalFileTokens": 10352,
        "chunks": [
          {
            "originalText": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.5.0 <0.9.0;\npragma experimental ABIEncoderV2;\n\nimport \"../HederaResponseCodes.sol\";\nimport \"./IHederaTokenService.sol\";\n\nabstract contract HederaTokenService {\n    address constant precompileAddress = address(0x167);\n    // 90 days in seconds\n    int32 constant defaultAutoRenewPeriod = 7776000;\n\n    modifier nonEmptyExpiry(IHederaTokenService.HederaToken memory token)\n    {\n        if (token.expiry.second == 0 && token.expiry.autoRenewPeriod == 0) {\n            token.expiry.autoRenewPeriod = defaultAutoRenewPeriod;\n        }\n        _;\n    }\n\n    /// Generic event\n    event CallResponseEvent(bool, bytes);\n\n    /// Performs transfers among combinations of tokens and hbars\n    /// @param transferList the list of hbar transfers to do\n    /// @param tokenTransfers the list of transfers to do\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @custom:version 0.3.0 the signature of the previous version was cryptoTransfer(TokenTransferList[] memory tokenTransfers)\n    function cryptoTransfer(IHederaTokenService.TransferList memory transferList, IHederaTokenService.TokenTransferList[] memory tokenTransfers) internal\n    returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.cryptoTransfer.selector, transferList, tokenTransfers));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Mints an amount of the token to the defined treasury account\n    /// @param token The token for which to mint tokens. If token does not exist, transaction results in\n    ///              INVALID_TOKEN_ID\n    /// @param amount Applicable to tokens of type FUNGIBLE_COMMON. The amount to mint to the Treasury Account.\n    ///               Amount must be a positive non-zero number represented in the lowest denomination of the\n    ///               token. The new supply must be lower than 2^63.\n    /// @param metadata Applicable to tokens of type NON_FUNGIBLE_UNIQUE. A list of metadata that are being created.\n    ///                 Maximum allowed size of each metadata is 100 bytes\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return newTotalSupply The new supply of tokens. For NFTs it is the total count of NFTs\n    /// @return serialNumbers If the token is an NFT the newly generate serial numbers, otherwise empty.\n    function mintToken(address token, int64 amount, bytes[] memory metadata) internal\n    returns (int responseCode, int64 newTotalSupply, int64[] memory serialNumbers)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.mintToken.selector,\n            token, amount, metadata));\n        (responseCode, newTotalSupply, serialNumbers) =\n        success\n        ? abi.decode(result, (int32, int64, int64[]))\n        : (HederaResponseCodes.UNKNOWN, int64(0), new int64[](0));\n    }\n\n    /// Burns an amount of the token from the defined treasury account\n    /// @param token The token for which to burn tokens. If token does not exist, transaction results in\n    ///              INVALID_TOKEN_ID\n    /// @param amount  Applicable to tokens of type FUNGIBLE_COMMON. The amount to burn from the Treasury Account.\n    ///                Amount must be a positive non-zero number, not bigger than the token balance of the treasury\n    ///                account (0; balance], represented in the lowest denomination.",
            "codeOnlyTokens": 807,
            "startLine": 1,
            "endLine": 65,
            "type": ".sol_part_1",
            "isOversized": false
          },
          {
            "originalText": "    /// @param serialNumbers Applicable to tokens of type NON_FUNGIBLE_UNIQUE. The list of serial numbers to be burned.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return newTotalSupply The new supply of tokens. For NFTs it is the total count of NFTs\n    function burnToken(address token, int64 amount, int64[] memory serialNumbers) internal\n    returns (int responseCode, int64 newTotalSupply)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.burnToken.selector,\n            token, amount, serialNumbers));\n        (responseCode, newTotalSupply) =\n        success\n        ? abi.decode(result, (int32, int64))\n        : (HederaResponseCodes.UNKNOWN, int64(0));\n    }\n\n    ///  Associates the provided account with the provided tokens. Must be signed by the provided\n    ///  Account's key or called from the accounts contract key\n    ///  If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.\n    ///  If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.\n    ///  If any of the provided tokens is not found, the transaction will resolve to INVALID_TOKEN_REF.\n    ///  If any of the provided tokens has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.\n    ///  If an association between the provided account and any of the tokens already exists, the\n    ///  transaction will resolve to TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT.\n    ///  If the provided account's associations count exceed the constraint of maximum token associations\n    ///    per account, the transaction will resolve to TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED.\n    ///  On success, associations between the provided account and tokens are made and the account is\n    ///    ready to interact with the tokens.\n    /// @param account The account to be associated with the provided tokens\n    /// @param tokens The tokens to be associated with the provided account. In the case of NON_FUNGIBLE_UNIQUE\n    ///               Type, once an account is associated, it can hold any number of NFTs (serial numbers) of that\n    ///               token type\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function associateTokens(address account, address[] memory tokens) internal returns (int responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.associateTokens.selector,\n            account, tokens));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    function associateToken(address account, address token) internal returns (int responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.associateToken.selector,\n            account, token));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Dissociates the provided account with the provided tokens. Must be signed by the provided\n    /// Account's key.\n    /// If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.\n    /// If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.\n    /// If any of the provided tokens is not found, the transaction will resolve to INVALID_TOKEN_REF.\n    /// If any of the provided tokens has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.\n    /// If an association between the provided account and any of the tokens does not exist, the\n    /// transaction will resolve to TOKEN_NOT_ASSOCIATED_TO_ACCOUNT.",
            "codeOnlyTokens": 801,
            "startLine": 66,
            "endLine": 119,
            "type": ".sol_part_2",
            "isOversized": false
          },
          {
            "originalText": "    /// If a token has not been deleted and has not expired, and the user has a nonzero balance, the\n    /// transaction will resolve to TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES.\n    /// If a <b>fungible token</b> has expired, the user can disassociate even if their token balance is\n    /// not zero.\n    /// If a <b>non fungible token</b> has expired, the user can <b>not</b> disassociate if their token\n    /// balance is not zero. The transaction will resolve to TRANSACTION_REQUIRED_ZERO_TOKEN_BALANCES.\n    /// On success, associations between the provided account and tokens are removed.\n    /// @param account The account to be dissociated from the provided tokens\n    /// @param tokens The tokens to be dissociated from the provided account.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function dissociateTokens(address account, address[] memory tokens) internal returns (int responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.dissociateTokens.selector,\n            account, tokens));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    function dissociateToken(address account, address token) internal returns (int responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.dissociateToken.selector,\n            account, token));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Creates a Fungible Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @param initialTotalSupply Specifies the initial supply of tokens to be put in circulation. The\n    /// initial supply is sent to the Treasury Account. The supply is in the lowest denomination possible.\n    /// @param decimals the number of decimal places a token is divisible by\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createFungibleToken(\n        IHederaTokenService.HederaToken memory token,\n        int64 initialTotalSupply,\n        int32 decimals) nonEmptyExpiry(token)\n    internal returns (int responseCode, address tokenAddress) {\n        (bool success, bytes memory result) = precompileAddress.call{value : msg.value}(\n            abi.encodeWithSelector(IHederaTokenService.createFungibleToken.selector,\n            token, initialTotalSupply, decimals));\n\n\n        (responseCode, tokenAddress) = success ? abi.decode(result, (int32, address)) : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Creates a Fungible Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @param initialTotalSupply Specifies the initial supply of tokens to be put in circulation. The\n    /// initial supply is sent to the Treasury Account. The supply is in the lowest denomination possible.\n    /// @param decimals the number of decimal places a token is divisible by\n    /// @param fixedFees list of fixed fees to apply to the token\n    /// @param fractionalFees list of fractional fees to apply to the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createFungibleTokenWithCustomFees(\n        IHederaTokenService.HederaToken memory token,\n        int64 initialTotalSupply,\n        int32 decimals,\n        IHederaTokenService.FixedFee[] memory fixedFees,",
            "codeOnlyTokens": 803,
            "startLine": 120,
            "endLine": 177,
            "type": ".sol_part_3",
            "isOversized": false
          },
          {
            "originalText": "        IHederaTokenService.FractionalFee[] memory fractionalFees) nonEmptyExpiry(token)\n    internal returns (int responseCode, address tokenAddress) {\n        (bool success, bytes memory result) = precompileAddress.call{value : msg.value}(\n            abi.encodeWithSelector(IHederaTokenService.createFungibleTokenWithCustomFees.selector,\n            token, initialTotalSupply, decimals, fixedFees, fractionalFees));\n        (responseCode, tokenAddress) = success ? abi.decode(result, (int32, address)) : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Creates an Non Fungible Unique Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createNonFungibleToken(IHederaTokenService.HederaToken memory token) nonEmptyExpiry(token)\n    internal returns (int responseCode, address tokenAddress) {\n        (bool success, bytes memory result) = precompileAddress.call{value : msg.value}(\n            abi.encodeWithSelector(IHederaTokenService.createNonFungibleToken.selector, token));\n        (responseCode, tokenAddress) = success ? abi.decode(result, (int32, address)) : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Creates an Non Fungible Unique Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @param fixedFees list of fixed fees to apply to the token\n    /// @param royaltyFees list of royalty fees to apply to the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createNonFungibleTokenWithCustomFees(\n        IHederaTokenService.HederaToken memory token,\n        IHederaTokenService.FixedFee[] memory fixedFees,\n        IHederaTokenService.RoyaltyFee[] memory royaltyFees) nonEmptyExpiry(token)\n    internal returns (int responseCode, address tokenAddress) {\n        (bool success, bytes memory result) = precompileAddress.call{value : msg.value}(\n            abi.encodeWithSelector(IHederaTokenService.createNonFungibleTokenWithCustomFees.selector,\n            token, fixedFees, royaltyFees));\n        (responseCode, tokenAddress) = success ? abi.decode(result, (int32, address)) : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Retrieves fungible specific token info for a fungible token\n    /// @param token The ID of the token as a solidity address\n    /// @dev This function reverts if the call is not successful\n    function getFungibleTokenInfo(address token) internal returns (int responseCode, IHederaTokenService.FungibleTokenInfo memory tokenInfo) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getFungibleTokenInfo.selector, token));\n        IHederaTokenService.FungibleTokenInfo memory defaultTokenInfo;\n        (responseCode, tokenInfo) = success ? abi.decode(result, (int32, IHederaTokenService.FungibleTokenInfo)) : (HederaResponseCodes.UNKNOWN, defaultTokenInfo);\n    }\n\n    /// Retrieves general token info for a given token\n    /// @param token The ID of the token as a solidity address\n    /// @dev This function reverts if the call is not successful\n    function getTokenInfo(address token) internal returns (int responseCode, IHederaTokenService.TokenInfo memory tokenInfo) {\n        (bool success, bytes memory result) = precompileAddress.call(",
            "codeOnlyTokens": 813,
            "startLine": 178,
            "endLine": 228,
            "type": ".sol_part_4",
            "isOversized": false
          },
          {
            "originalText": "            abi.encodeWithSelector(IHederaTokenService.getTokenInfo.selector, token));\n        IHederaTokenService.TokenInfo memory defaultTokenInfo;\n        (responseCode, tokenInfo) = success ? abi.decode(result, (int32, IHederaTokenService.TokenInfo)) : (HederaResponseCodes.UNKNOWN, defaultTokenInfo);\n    }\n\n    /// Retrieves non-fungible specific token info for a given NFT\n    /// @param token The ID of the token as a solidity address\n    /// @dev This function reverts if the call is not successful\n    function getNonFungibleTokenInfo(address token, int64 serialNumber) internal returns (int responseCode, IHederaTokenService.NonFungibleTokenInfo memory tokenInfo) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getNonFungibleTokenInfo.selector, token, serialNumber));\n        IHederaTokenService.NonFungibleTokenInfo memory defaultTokenInfo;\n        (responseCode, tokenInfo) = success ? abi.decode(result, (int32, IHederaTokenService.NonFungibleTokenInfo)) : (HederaResponseCodes.UNKNOWN, defaultTokenInfo);\n    }\n\n    /// Query token custom fees\n    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return fixedFees Set of fixed fees for `token`\n    /// @return fractionalFees Set of fractional fees for `token`\n    /// @return royaltyFees Set of royalty fees for `token`\n    /// @dev This function reverts if the call is not successful\n    function getTokenCustomFees(address token) internal returns (int64 responseCode,\n        IHederaTokenService.FixedFee[] memory fixedFees,\n        IHederaTokenService.FractionalFee[] memory fractionalFees,\n        IHederaTokenService.RoyaltyFee[] memory royaltyFees) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getTokenCustomFees.selector, token));\n        IHederaTokenService.FixedFee[] memory defaultFixedFees;\n        IHederaTokenService.FractionalFee[] memory defaultFractionalFees;\n        IHederaTokenService.RoyaltyFee[] memory defaultRoyaltyFees;\n        (responseCode, fixedFees, fractionalFees, royaltyFees) =\n        success ? abi.decode\n        (result, (int32, IHederaTokenService.FixedFee[], IHederaTokenService.FractionalFee[], IHederaTokenService.RoyaltyFee[]))\n        : (HederaResponseCodes.UNKNOWN, defaultFixedFees, defaultFractionalFees, defaultRoyaltyFees);\n    }\n\n    /// Allows spender to withdraw from your account multiple times, up to the value amount. If this function is called\n    /// again it overwrites the current allowance with value.\n    /// Only Applicable to Fungible Tokens\n    /// @param token The hedera token address to approve\n    /// @param spender the account authorized to spend\n    /// @param amount the amount of tokens authorized to spend.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function approve(address token, address spender, uint256 amount) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.approve.selector,\n            token, spender, amount));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Transfers `amount` tokens from `from` to `to` using the\n    //  allowance mechanism. `amount` is then deducted from the caller's allowance.",
            "codeOnlyTokens": 805,
            "startLine": 229,
            "endLine": 282,
            "type": ".sol_part_5",
            "isOversized": false
          },
          {
            "originalText": "    /// Only applicable to fungible tokens\n    /// @param token The address of the fungible Hedera token to transfer\n    /// @param from The account address of the owner of the token, on the behalf of which to transfer `amount` tokens\n    /// @param to The account address of the receiver of the `amount` tokens\n    /// @param amount The amount of tokens to transfer from `from` to `to`\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function transferFrom(address token, address from, address to, uint256 amount) external returns (int64 responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.transferFrom.selector,\n            token, from, to, amount));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Transfers `serialNumber` of `token` from `from` to `to` using the allowance mechanism.\n    /// Only applicable to NFT tokens\n    /// @param token The address of the non-fungible Hedera token to transfer\n    /// @param from The account address of the owner of `serialNumber` of `token`\n    /// @param to The account address of the receiver of `serialNumber`\n    /// @param serialNumber The NFT serial number to transfer\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function transferFromNFT(address token, address from, address to, uint256 serialNumber) external returns (int64 responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.transferFromNFT.selector,\n            token, from, to, serialNumber));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Returns the amount which spender is still allowed to withdraw from owner.\n    /// Only Applicable to Fungible Tokens\n    /// @param token The Hedera token address to check the allowance of\n    /// @param owner the owner of the tokens to be spent\n    /// @param spender the spender of the tokens\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function allowance(address token, address owner, address spender) internal returns (int responseCode, uint256 amount)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.allowance.selector,\n            token, owner, spender));\n        (responseCode, amount) = success ? abi.decode(result, (int32, uint256)) : (HederaResponseCodes.UNKNOWN, 0);\n    }\n\n    /// Allow or reaffirm the approved address to transfer an NFT the approved address does not own.\n    /// Only Applicable to NFT Tokens\n    /// @param token The Hedera NFT token address to approve\n    /// @param approved The new approved NFT controller.  To revoke approvals pass in the zero address.\n    /// @param serialNumber The NFT serial number  to approve\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function approveNFT(address token, address approved, uint256 serialNumber) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.approveNFT.selector,\n            token, approved, serialNumber));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Get the approved address for a single NFT\n    /// Only Applicable to NFT Tokens\n    /// @param token The Hedera NFT token address to check approval",
            "codeOnlyTokens": 813,
            "startLine": 283,
            "endLine": 342,
            "type": ".sol_part_6",
            "isOversized": false
          },
          {
            "originalText": "    /// @param serialNumber The NFT to find the approved address for\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return approved The approved address for this NFT, or the zero address if there is none\n    function getApproved(address token, uint256 serialNumber) internal returns (int responseCode, address approved)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getApproved.selector,\n            token, serialNumber));\n        (responseCode, approved) =\n        success\n        ? abi.decode(result, (int32, address))\n        : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Query if token account is frozen\n    /// @param token The token address to check\n    /// @param account The account address associated with the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return frozen True if `account` is frozen for `token`\n    /// @dev This function reverts if the call is not successful\n    function isFrozen(address token, address account) internal returns (int64 responseCode, bool frozen){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.isFrozen.selector, token, account));\n        (responseCode, frozen) = success ? abi.decode(result, (int32, bool)) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Query if token account has kyc granted\n    /// @param token The token address to check\n    /// @param account The account address associated with the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return kycGranted True if `account` has kyc granted for `token`\n    /// @dev This function reverts if the call is not successful\n    function isKyc(address token, address account) internal returns (int64 responseCode, bool kycGranted){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.isKyc.selector, token, account));\n        (responseCode, kycGranted) = success ? abi.decode(result, (int32, bool)) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Operation to freeze token account\n    /// @param token The token address\n    /// @param account The account address to be frozen\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function freezeToken(address token, address account) internal returns (int64 responseCode){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.freezeToken.selector, token, account));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to unfreeze token account\n    /// @param token The token address\n    /// @param account The account address to be unfrozen\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function unfreezeToken(address token, address account) internal returns (int64 responseCode){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.unfreezeToken.selector, token, account));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to grant kyc to token account\n    /// @param token The token address\n    /// @param account The account address to grant kyc",
            "codeOnlyTokens": 804,
            "startLine": 343,
            "endLine": 403,
            "type": ".sol_part_7",
            "isOversized": false
          },
          {
            "originalText": "    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function grantTokenKyc(address token, address account) internal returns (int64 responseCode){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.grantTokenKyc.selector, token, account));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to revoke kyc to token account\n    /// @param token The token address\n    /// @param account The account address to revoke kyc\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function revokeTokenKyc(address token, address account) internal returns (int64 responseCode){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.revokeTokenKyc.selector, token, account));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Enable or disable approval for a third party (\"operator\") to manage\n    ///  all of `msg.sender`'s assets\n    /// @param token The Hedera NFT token address to approve\n    /// @param operator Address to add to the set of authorized operators\n    /// @param approved True if the operator is approved, false to revoke approval\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function setApprovalForAll(address token, address operator, bool approved) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.setApprovalForAll.selector,\n            token, operator, approved));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Query if an address is an authorized operator for another address\n    /// Only Applicable to NFT Tokens\n    /// @param token The Hedera NFT token address to approve\n    /// @param owner The address that owns the NFTs\n    /// @param operator The address that acts on behalf of the owner\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return approved True if `operator` is an approved operator for `owner`, false otherwise\n    function isApprovedForAll(address token, address owner, address operator) internal returns (int responseCode, bool approved)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.isApprovedForAll.selector,\n            token, owner, operator));\n        (responseCode, approved) =\n        success\n        ? abi.decode(result, (int32, bool))\n        : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Query token default freeze status\n    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return defaultFreezeStatus True if `token` default freeze status is frozen.\n    /// @dev This function reverts if the call is not successful\n    function getTokenDefaultFreezeStatus(address token) internal returns (int responseCode, bool defaultFreezeStatus) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getTokenDefaultFreezeStatus.selector, token));\n        (responseCode, defaultFreezeStatus) = success ? abi.decode(result, (int32, bool)) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Query token default kyc status",
            "codeOnlyTokens": 803,
            "startLine": 404,
            "endLine": 464,
            "type": ".sol_part_8",
            "isOversized": false
          },
          {
            "originalText": "    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return defaultKycStatus True if `token` default kyc status is KycNotApplicable and false if Revoked.\n    /// @dev This function reverts if the call is not successful\n    function getTokenDefaultKycStatus(address token) internal returns (int responseCode, bool defaultKycStatus) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getTokenDefaultKycStatus.selector, token));\n        (responseCode, defaultKycStatus) = success ? abi.decode(result, (int32, bool)) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /**********************\n     * ABI v1 calls       *\n     **********************/\n\n    /// Initiates a Fungible Token Transfer\n    /// @param token The ID of the token as a solidity address\n    /// @param accountIds account to do a transfer to/from\n    /// @param amounts The amount from the accountId at the same index\n    function transferTokens(address token, address[] memory accountIds, int64[] memory amounts) internal\n    returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.transferTokens.selector,\n            token, accountIds, amounts));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Initiates a Non-Fungable Token Transfer\n    /// @param token The ID of the token as a solidity address\n    /// @param sender the sender of an nft\n    /// @param receiver the receiver of the nft sent by the same index at sender\n    /// @param serialNumber the serial number of the nft sent by the same index at sender\n    function transferNFTs(address token, address[] memory sender, address[] memory receiver, int64[] memory serialNumber)\n    internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.transferNFTs.selector,\n            token, sender, receiver, serialNumber));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Transfers tokens where the calling account/contract is implicitly the first entry in the token transfer list,\n    /// where the amount is the value needed to zero balance the transfers. Regular signing rules apply for sending\n    /// (positive amount) or receiving (negative amount)\n    /// @param token The token to transfer to/from\n    /// @param sender The sender for the transaction\n    /// @param receiver The receiver of the transaction\n    /// @param amount Non-negative value to send. a negative value will result in a failure.\n    function transferToken(address token, address sender, address receiver, int64 amount) internal\n    returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.transferToken.selector,\n            token, sender, receiver, amount));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Transfers tokens where the calling account/contract is implicitly the first entry in the token transfer list,\n    /// where the amount is the value needed to zero balance the transfers. Regular signing rules apply for sending\n    /// (positive amount) or receiving (negative amount)\n    /// @param token The token to transfer to/from\n    /// @param sender The sender for the transaction\n    /// @param receiver The receiver of the transaction\n    /// @param serialNumber The serial number of the NFT to transfer.",
            "codeOnlyTokens": 812,
            "startLine": 465,
            "endLine": 528,
            "type": ".sol_part_9",
            "isOversized": false
          },
          {
            "originalText": "    function transferNFT(address token, address sender, address receiver, int64 serialNumber) internal\n    returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.transferNFT.selector,\n            token, sender, receiver, serialNumber));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to pause token\n    /// @param token The token address to be paused\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function pauseToken(address token) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.pauseToken.selector, token));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to unpause token\n    /// @param token The token address to be unpaused\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function unpauseToken(address token) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.unpauseToken.selector, token));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to wipe fungible tokens from account\n    /// @param token The token address\n    /// @param account The account address to revoke kyc\n    /// @param amount The number of tokens to wipe\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function wipeTokenAccount(address token, address account, int64 amount) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.wipeTokenAccount.selector, token, account, amount));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to wipe non fungible tokens from account\n    /// @param token The token address\n    /// @param account The account address to revoke kyc\n    /// @param  serialNumbers The serial numbers of token to wipe\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function wipeTokenAccountNFT(address token, address account, int64[] memory serialNumbers) internal\n    returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.wipeTokenAccountNFT.selector, token, account, serialNumbers));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to delete token\n    /// @param token The token address\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function deleteToken(address token) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.deleteToken.selector, token));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to update token keys\n    /// @param token The token address\n    /// @param keys The token keys\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateTokenKeys(address token, IHederaTokenService.TokenKey[] memory keys)",
            "codeOnlyTokens": 816,
            "startLine": 529,
            "endLine": 597,
            "type": ".sol_part_10",
            "isOversized": false
          },
          {
            "originalText": "    internal returns (int64 responseCode){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.updateTokenKeys.selector, token, keys));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Query token KeyValue\n    /// @param token The token address to check\n    /// @param keyType The keyType of the desired KeyValue\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return key KeyValue info for key of type `keyType`\n    /// @dev This function reverts if the call is not successful\n    function getTokenKey(address token, uint keyType)\n    internal returns (int64 responseCode, IHederaTokenService.KeyValue memory key){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getTokenKey.selector, token, keyType));\n        IHederaTokenService.KeyValue memory defaultKeyValueInfo;\n        (responseCode, key) = success ? abi.decode(result, (int32,IHederaTokenService.KeyValue) ) : (HederaResponseCodes.UNKNOWN, defaultKeyValueInfo);\n    }\n\n\n    /// Query if valid token found for the given address\n    /// @param token The token address\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return isTokenFlag True if valid token found for the given address\n    /// @dev This function reverts if the call is not successful\n    function isToken(address token) internal returns (int64 responseCode, bool isTokenFlag) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.isToken.selector, token));\n        (responseCode, isTokenFlag) = success ? abi.decode(result, (int32, bool)) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Query to return the token type for a given address\n    /// @param token The token address\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenType the token type. 0 is FUNGIBLE_COMMON, 1 is NON_FUNGIBLE_UNIQUE, -1 is UNRECOGNIZED\n    /// @dev This function reverts if the call is not successful\n    function getTokenType(address token) internal returns (int64 responseCode, int32 tokenType) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getTokenType.selector, token));\n        (responseCode, tokenType) = success ? abi.decode(result, (int32, int32)) : (HederaResponseCodes.UNKNOWN, - 1);\n    }\n\n    /// Operation to get token expiry info\n    /// @param token The token address\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return expiryInfo The expiry info of the token\n    /// @dev This function reverts if the call is not successful\n    function getTokenExpiryInfo(address token) internal returns (int responseCode, IHederaTokenService.Expiry memory expiryInfo){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getTokenExpiryInfo.selector, token));\n        IHederaTokenService.Expiry memory defaultExpiryInfo;\n        (responseCode, expiryInfo) = success ? abi.decode(result, (int32, IHederaTokenService.Expiry)) : (HederaResponseCodes.UNKNOWN, defaultExpiryInfo);",
            "codeOnlyTokens": 808,
            "startLine": 598,
            "endLine": 650,
            "type": ".sol_part_11",
            "isOversized": false
          },
          {
            "originalText": "    }\n\n    /// Operation to update token expiry info\n    /// @param token The token address\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateTokenExpiryInfo(address token, IHederaTokenService.Expiry memory expiryInfo) internal returns (int responseCode){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.updateTokenExpiryInfo.selector, token, expiryInfo));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to update token info\n    /// @param token The token address\n    /// @param tokenInfo The hedera token info to update token with\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateTokenInfo(address token, IHederaTokenService.HederaToken memory tokenInfo) internal returns (int responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.updateTokenInfo.selector, token, tokenInfo));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Redirect for token\n    /// @param token The token address\n    /// @param encodedFunctionSelector The function selector from the ERC20 interface + the bytes input for the function called\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return response The result of the call that had been encoded and sent for execution.\n    function redirectForToken(address token, bytes memory encodedFunctionSelector) external returns (int responseCode, bytes memory response) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.redirectForToken.selector, token, encodedFunctionSelector)\n        );\n\n        emit CallResponseEvent(success, result);\n        (responseCode, response) = success ? (HederaResponseCodes.SUCCESS, result) : (HederaResponseCodes.UNKNOWN, bytes(\"\"));\n    }\n\n    /// Update the custom fees for a fungible token\n    /// @param token The token address\n    /// @param fixedFees Set of fixed fees for `token`\n    /// @param fractionalFees Set of fractional fees for `token`\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateFungibleTokenCustomFees(address token,  IHederaTokenService.FixedFee[] memory fixedFees, IHederaTokenService.FractionalFee[] memory fractionalFees) internal returns (int64 responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.updateFungibleTokenCustomFees.selector, token, fixedFees, fractionalFees));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Update the custom fees for a non-fungible token\n    /// @param token The token address\n    /// @param fixedFees Set of fixed fees for `token`\n    /// @param royaltyFees Set of royalty fees for `token`\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateNonFungibleTokenCustomFees(address token, IHederaTokenService.FixedFee[] memory fixedFees, IHederaTokenService.RoyaltyFee[] memory royaltyFees) internal returns (int64 responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.updateNonFungibleTokenCustomFees.selector, token, fixedFees, royaltyFees));",
            "codeOnlyTokens": 808,
            "startLine": 651,
            "endLine": 704,
            "type": ".sol_part_12",
            "isOversized": false
          },
          {
            "originalText": "        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// @notice Airdrop one or more tokens to one or more accounts\n    /// @param tokenTransfers Array of token transfer lists containing token addresses and recipient details\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function airdropTokens(IHederaTokenService.TokenTransferList[] memory tokenTransfers) internal returns (int64 responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.airdropTokens.selector, tokenTransfers));\n\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// @notice Cancels pending airdrops that have not yet been claimed\n    /// @param pendingAirdrops Array of pending airdrops to cancel\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function cancelAirdrops(IHederaTokenService.PendingAirdrop[] memory pendingAirdrops) internal returns (int64 responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.cancelAirdrops.selector, pendingAirdrops)\n        );\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// @notice Claims pending airdrops that were sent to the calling account\n    /// @param pendingAirdrops Array of pending airdrops to claim\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function claimAirdrops(IHederaTokenService.PendingAirdrop[] memory pendingAirdrops) internal returns (int64 responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.claimAirdrops.selector, pendingAirdrops)\n        );\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// @notice Rejects one or more tokens by transferring their full balance from the requesting account to the treasury\n    /// @param rejectingAddress The address rejecting the tokens\n    /// @param ftAddresses Array of fungible token addresses to reject\n    /// @param nftIds Array of NFT IDs to reject\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function rejectTokens(address rejectingAddress, address[] memory ftAddresses, IHederaTokenService.NftID[] memory nftIds) internal returns (int64 responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.rejectTokens.selector, rejectingAddress, ftAddresses, nftIds)\n        );\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n}\n",
            "codeOnlyTokens": 656,
            "startLine": 705,
            "endLine": 750,
            "type": ".sol_part_13",
            "isOversized": false
          }
        ],
        "groupedChunks": [
          {
            "combinedText": "// File: contracts/system-contracts/hedera-token-service/HederaTokenService.sol\n// Relevant file context:\n// Type: .sol\n\n\n// --- Next chunk ---\n\n// Lines 1-65 (.sol_part_1)\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.5.0 <0.9.0;\npragma experimental ABIEncoderV2;\n\nimport \"../HederaResponseCodes.sol\";\nimport \"./IHederaTokenService.sol\";\n\nabstract contract HederaTokenService {\n    address constant precompileAddress = address(0x167);\n    // 90 days in seconds\n    int32 constant defaultAutoRenewPeriod = 7776000;\n\n    modifier nonEmptyExpiry(IHederaTokenService.HederaToken memory token)\n    {\n        if (token.expiry.second == 0 && token.expiry.autoRenewPeriod == 0) {\n            token.expiry.autoRenewPeriod = defaultAutoRenewPeriod;\n        }\n        _;\n    }\n\n    /// Generic event\n    event CallResponseEvent(bool, bytes);\n\n    /// Performs transfers among combinations of tokens and hbars\n    /// @param transferList the list of hbar transfers to do\n    /// @param tokenTransfers the list of transfers to do\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @custom:version 0.3.0 the signature of the previous version was cryptoTransfer(TokenTransferList[] memory tokenTransfers)\n    function cryptoTransfer(IHederaTokenService.TransferList memory transferList, IHederaTokenService.TokenTransferList[] memory tokenTransfers) internal\n    returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.cryptoTransfer.selector, transferList, tokenTransfers));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Mints an amount of the token to the defined treasury account\n    /// @param token The token for which to mint tokens. If token does not exist, transaction results in\n    ///              INVALID_TOKEN_ID\n    /// @param amount Applicable to tokens of type FUNGIBLE_COMMON. The amount to mint to the Treasury Account.\n    ///               Amount must be a positive non-zero number represented in the lowest denomination of the\n    ///               token. The new supply must be lower than 2^63.\n    /// @param metadata Applicable to tokens of type NON_FUNGIBLE_UNIQUE. A list of metadata that are being created.\n    ///                 Maximum allowed size of each metadata is 100 bytes\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return newTotalSupply The new supply of tokens. For NFTs it is the total count of NFTs\n    /// @return serialNumbers If the token is an NFT the newly generate serial numbers, otherwise empty.\n    function mintToken(address token, int64 amount, bytes[] memory metadata) internal\n    returns (int responseCode, int64 newTotalSupply, int64[] memory serialNumbers)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.mintToken.selector,\n            token, amount, metadata));\n        (responseCode, newTotalSupply, serialNumbers) =\n        success\n        ? abi.decode(result, (int32, int64, int64[]))\n        : (HederaResponseCodes.UNKNOWN, int64(0), new int64[](0));\n    }\n\n    /// Burns an amount of the token from the defined treasury account\n    /// @param token The token for which to burn tokens. If token does not exist, transaction results in\n    ///              INVALID_TOKEN_ID\n    /// @param amount  Applicable to tokens of type FUNGIBLE_COMMON. The amount to burn from the Treasury Account.\n    ///                Amount must be a positive non-zero number, not bigger than the token balance of the treasury\n    ///                account (0; balance], represented in the lowest denomination.\n\n// --- Next chunk ---\n\n// Lines 66-119 (.sol_part_2)\n    /// @param serialNumbers Applicable to tokens of type NON_FUNGIBLE_UNIQUE. The list of serial numbers to be burned.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return newTotalSupply The new supply of tokens. For NFTs it is the total count of NFTs\n    function burnToken(address token, int64 amount, int64[] memory serialNumbers) internal\n    returns (int responseCode, int64 newTotalSupply)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.burnToken.selector,\n            token, amount, serialNumbers));\n        (responseCode, newTotalSupply) =\n        success\n        ? abi.decode(result, (int32, int64))\n        : (HederaResponseCodes.UNKNOWN, int64(0));\n    }\n\n    ///  Associates the provided account with the provided tokens. Must be signed by the provided\n    ///  Account's key or called from the accounts contract key\n    ///  If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.\n    ///  If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.\n    ///  If any of the provided tokens is not found, the transaction will resolve to INVALID_TOKEN_REF.\n    ///  If any of the provided tokens has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.\n    ///  If an association between the provided account and any of the tokens already exists, the\n    ///  transaction will resolve to TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT.\n    ///  If the provided account's associations count exceed the constraint of maximum token associations\n    ///    per account, the transaction will resolve to TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED.\n    ///  On success, associations between the provided account and tokens are made and the account is\n    ///    ready to interact with the tokens.\n    /// @param account The account to be associated with the provided tokens\n    /// @param tokens The tokens to be associated with the provided account. In the case of NON_FUNGIBLE_UNIQUE\n    ///               Type, once an account is associated, it can hold any number of NFTs (serial numbers) of that\n    ///               token type\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function associateTokens(address account, address[] memory tokens) internal returns (int responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.associateTokens.selector,\n            account, tokens));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    function associateToken(address account, address token) internal returns (int responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.associateToken.selector,\n            account, token));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Dissociates the provided account with the provided tokens. Must be signed by the provided\n    /// Account's key.\n    /// If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.\n    /// If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.\n    /// If any of the provided tokens is not found, the transaction will resolve to INVALID_TOKEN_REF.\n    /// If any of the provided tokens has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.\n    /// If an association between the provided account and any of the tokens does not exist, the\n    /// transaction will resolve to TOKEN_NOT_ASSOCIATED_TO_ACCOUNT.\n\n// --- Next chunk ---\n\n// Lines 120-177 (.sol_part_3)\n    /// If a token has not been deleted and has not expired, and the user has a nonzero balance, the\n    /// transaction will resolve to TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES.\n    /// If a <b>fungible token</b> has expired, the user can disassociate even if their token balance is\n    /// not zero.\n    /// If a <b>non fungible token</b> has expired, the user can <b>not</b> disassociate if their token\n    /// balance is not zero. The transaction will resolve to TRANSACTION_REQUIRED_ZERO_TOKEN_BALANCES.\n    /// On success, associations between the provided account and tokens are removed.\n    /// @param account The account to be dissociated from the provided tokens\n    /// @param tokens The tokens to be dissociated from the provided account.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function dissociateTokens(address account, address[] memory tokens) internal returns (int responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.dissociateTokens.selector,\n            account, tokens));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    function dissociateToken(address account, address token) internal returns (int responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.dissociateToken.selector,\n            account, token));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Creates a Fungible Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @param initialTotalSupply Specifies the initial supply of tokens to be put in circulation. The\n    /// initial supply is sent to the Treasury Account. The supply is in the lowest denomination possible.\n    /// @param decimals the number of decimal places a token is divisible by\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createFungibleToken(\n        IHederaTokenService.HederaToken memory token,\n        int64 initialTotalSupply,\n        int32 decimals) nonEmptyExpiry(token)\n    internal returns (int responseCode, address tokenAddress) {\n        (bool success, bytes memory result) = precompileAddress.call{value : msg.value}(\n            abi.encodeWithSelector(IHederaTokenService.createFungibleToken.selector,\n            token, initialTotalSupply, decimals));\n\n\n        (responseCode, tokenAddress) = success ? abi.decode(result, (int32, address)) : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Creates a Fungible Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @param initialTotalSupply Specifies the initial supply of tokens to be put in circulation. The\n    /// initial supply is sent to the Treasury Account. The supply is in the lowest denomination possible.\n    /// @param decimals the number of decimal places a token is divisible by\n    /// @param fixedFees list of fixed fees to apply to the token\n    /// @param fractionalFees list of fractional fees to apply to the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createFungibleTokenWithCustomFees(\n        IHederaTokenService.HederaToken memory token,\n        int64 initialTotalSupply,\n        int32 decimals,\n        IHederaTokenService.FixedFee[] memory fixedFees,",
            "totalTokens": 2491,
            "chunks": [
              {
                "originalText": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.5.0 <0.9.0;\npragma experimental ABIEncoderV2;\n\nimport \"../HederaResponseCodes.sol\";\nimport \"./IHederaTokenService.sol\";\n\nabstract contract HederaTokenService {\n    address constant precompileAddress = address(0x167);\n    // 90 days in seconds\n    int32 constant defaultAutoRenewPeriod = 7776000;\n\n    modifier nonEmptyExpiry(IHederaTokenService.HederaToken memory token)\n    {\n        if (token.expiry.second == 0 && token.expiry.autoRenewPeriod == 0) {\n            token.expiry.autoRenewPeriod = defaultAutoRenewPeriod;\n        }\n        _;\n    }\n\n    /// Generic event\n    event CallResponseEvent(bool, bytes);\n\n    /// Performs transfers among combinations of tokens and hbars\n    /// @param transferList the list of hbar transfers to do\n    /// @param tokenTransfers the list of transfers to do\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @custom:version 0.3.0 the signature of the previous version was cryptoTransfer(TokenTransferList[] memory tokenTransfers)\n    function cryptoTransfer(IHederaTokenService.TransferList memory transferList, IHederaTokenService.TokenTransferList[] memory tokenTransfers) internal\n    returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.cryptoTransfer.selector, transferList, tokenTransfers));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Mints an amount of the token to the defined treasury account\n    /// @param token The token for which to mint tokens. If token does not exist, transaction results in\n    ///              INVALID_TOKEN_ID\n    /// @param amount Applicable to tokens of type FUNGIBLE_COMMON. The amount to mint to the Treasury Account.\n    ///               Amount must be a positive non-zero number represented in the lowest denomination of the\n    ///               token. The new supply must be lower than 2^63.\n    /// @param metadata Applicable to tokens of type NON_FUNGIBLE_UNIQUE. A list of metadata that are being created.\n    ///                 Maximum allowed size of each metadata is 100 bytes\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return newTotalSupply The new supply of tokens. For NFTs it is the total count of NFTs\n    /// @return serialNumbers If the token is an NFT the newly generate serial numbers, otherwise empty.\n    function mintToken(address token, int64 amount, bytes[] memory metadata) internal\n    returns (int responseCode, int64 newTotalSupply, int64[] memory serialNumbers)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.mintToken.selector,\n            token, amount, metadata));\n        (responseCode, newTotalSupply, serialNumbers) =\n        success\n        ? abi.decode(result, (int32, int64, int64[]))\n        : (HederaResponseCodes.UNKNOWN, int64(0), new int64[](0));\n    }\n\n    /// Burns an amount of the token from the defined treasury account\n    /// @param token The token for which to burn tokens. If token does not exist, transaction results in\n    ///              INVALID_TOKEN_ID\n    /// @param amount  Applicable to tokens of type FUNGIBLE_COMMON. The amount to burn from the Treasury Account.\n    ///                Amount must be a positive non-zero number, not bigger than the token balance of the treasury\n    ///                account (0; balance], represented in the lowest denomination.",
                "codeOnlyTokens": 807,
                "startLine": 1,
                "endLine": 65,
                "type": ".sol_part_1",
                "isOversized": false
              },
              {
                "originalText": "    /// @param serialNumbers Applicable to tokens of type NON_FUNGIBLE_UNIQUE. The list of serial numbers to be burned.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return newTotalSupply The new supply of tokens. For NFTs it is the total count of NFTs\n    function burnToken(address token, int64 amount, int64[] memory serialNumbers) internal\n    returns (int responseCode, int64 newTotalSupply)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.burnToken.selector,\n            token, amount, serialNumbers));\n        (responseCode, newTotalSupply) =\n        success\n        ? abi.decode(result, (int32, int64))\n        : (HederaResponseCodes.UNKNOWN, int64(0));\n    }\n\n    ///  Associates the provided account with the provided tokens. Must be signed by the provided\n    ///  Account's key or called from the accounts contract key\n    ///  If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.\n    ///  If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.\n    ///  If any of the provided tokens is not found, the transaction will resolve to INVALID_TOKEN_REF.\n    ///  If any of the provided tokens has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.\n    ///  If an association between the provided account and any of the tokens already exists, the\n    ///  transaction will resolve to TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT.\n    ///  If the provided account's associations count exceed the constraint of maximum token associations\n    ///    per account, the transaction will resolve to TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED.\n    ///  On success, associations between the provided account and tokens are made and the account is\n    ///    ready to interact with the tokens.\n    /// @param account The account to be associated with the provided tokens\n    /// @param tokens The tokens to be associated with the provided account. In the case of NON_FUNGIBLE_UNIQUE\n    ///               Type, once an account is associated, it can hold any number of NFTs (serial numbers) of that\n    ///               token type\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function associateTokens(address account, address[] memory tokens) internal returns (int responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.associateTokens.selector,\n            account, tokens));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    function associateToken(address account, address token) internal returns (int responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.associateToken.selector,\n            account, token));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Dissociates the provided account with the provided tokens. Must be signed by the provided\n    /// Account's key.\n    /// If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.\n    /// If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.\n    /// If any of the provided tokens is not found, the transaction will resolve to INVALID_TOKEN_REF.\n    /// If any of the provided tokens has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.\n    /// If an association between the provided account and any of the tokens does not exist, the\n    /// transaction will resolve to TOKEN_NOT_ASSOCIATED_TO_ACCOUNT.",
                "codeOnlyTokens": 801,
                "startLine": 66,
                "endLine": 119,
                "type": ".sol_part_2",
                "isOversized": false
              },
              {
                "originalText": "    /// If a token has not been deleted and has not expired, and the user has a nonzero balance, the\n    /// transaction will resolve to TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES.\n    /// If a <b>fungible token</b> has expired, the user can disassociate even if their token balance is\n    /// not zero.\n    /// If a <b>non fungible token</b> has expired, the user can <b>not</b> disassociate if their token\n    /// balance is not zero. The transaction will resolve to TRANSACTION_REQUIRED_ZERO_TOKEN_BALANCES.\n    /// On success, associations between the provided account and tokens are removed.\n    /// @param account The account to be dissociated from the provided tokens\n    /// @param tokens The tokens to be dissociated from the provided account.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function dissociateTokens(address account, address[] memory tokens) internal returns (int responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.dissociateTokens.selector,\n            account, tokens));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    function dissociateToken(address account, address token) internal returns (int responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.dissociateToken.selector,\n            account, token));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Creates a Fungible Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @param initialTotalSupply Specifies the initial supply of tokens to be put in circulation. The\n    /// initial supply is sent to the Treasury Account. The supply is in the lowest denomination possible.\n    /// @param decimals the number of decimal places a token is divisible by\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createFungibleToken(\n        IHederaTokenService.HederaToken memory token,\n        int64 initialTotalSupply,\n        int32 decimals) nonEmptyExpiry(token)\n    internal returns (int responseCode, address tokenAddress) {\n        (bool success, bytes memory result) = precompileAddress.call{value : msg.value}(\n            abi.encodeWithSelector(IHederaTokenService.createFungibleToken.selector,\n            token, initialTotalSupply, decimals));\n\n\n        (responseCode, tokenAddress) = success ? abi.decode(result, (int32, address)) : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Creates a Fungible Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @param initialTotalSupply Specifies the initial supply of tokens to be put in circulation. The\n    /// initial supply is sent to the Treasury Account. The supply is in the lowest denomination possible.\n    /// @param decimals the number of decimal places a token is divisible by\n    /// @param fixedFees list of fixed fees to apply to the token\n    /// @param fractionalFees list of fractional fees to apply to the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createFungibleTokenWithCustomFees(\n        IHederaTokenService.HederaToken memory token,\n        int64 initialTotalSupply,\n        int32 decimals,\n        IHederaTokenService.FixedFee[] memory fixedFees,",
                "codeOnlyTokens": 803,
                "startLine": 120,
                "endLine": 177,
                "type": ".sol_part_3",
                "isOversized": false
              }
            ],
            "startLine": 1,
            "endLine": 177,
            "groupId": 1
          },
          {
            "combinedText": "// File: contracts/system-contracts/hedera-token-service/HederaTokenService.sol\n// Relevant file context:\n// Type: .sol\n\n\n// --- Next chunk ---\n\n// Lines 178-228 (.sol_part_4)\n        IHederaTokenService.FractionalFee[] memory fractionalFees) nonEmptyExpiry(token)\n    internal returns (int responseCode, address tokenAddress) {\n        (bool success, bytes memory result) = precompileAddress.call{value : msg.value}(\n            abi.encodeWithSelector(IHederaTokenService.createFungibleTokenWithCustomFees.selector,\n            token, initialTotalSupply, decimals, fixedFees, fractionalFees));\n        (responseCode, tokenAddress) = success ? abi.decode(result, (int32, address)) : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Creates an Non Fungible Unique Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createNonFungibleToken(IHederaTokenService.HederaToken memory token) nonEmptyExpiry(token)\n    internal returns (int responseCode, address tokenAddress) {\n        (bool success, bytes memory result) = precompileAddress.call{value : msg.value}(\n            abi.encodeWithSelector(IHederaTokenService.createNonFungibleToken.selector, token));\n        (responseCode, tokenAddress) = success ? abi.decode(result, (int32, address)) : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Creates an Non Fungible Unique Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @param fixedFees list of fixed fees to apply to the token\n    /// @param royaltyFees list of royalty fees to apply to the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createNonFungibleTokenWithCustomFees(\n        IHederaTokenService.HederaToken memory token,\n        IHederaTokenService.FixedFee[] memory fixedFees,\n        IHederaTokenService.RoyaltyFee[] memory royaltyFees) nonEmptyExpiry(token)\n    internal returns (int responseCode, address tokenAddress) {\n        (bool success, bytes memory result) = precompileAddress.call{value : msg.value}(\n            abi.encodeWithSelector(IHederaTokenService.createNonFungibleTokenWithCustomFees.selector,\n            token, fixedFees, royaltyFees));\n        (responseCode, tokenAddress) = success ? abi.decode(result, (int32, address)) : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Retrieves fungible specific token info for a fungible token\n    /// @param token The ID of the token as a solidity address\n    /// @dev This function reverts if the call is not successful\n    function getFungibleTokenInfo(address token) internal returns (int responseCode, IHederaTokenService.FungibleTokenInfo memory tokenInfo) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getFungibleTokenInfo.selector, token));\n        IHederaTokenService.FungibleTokenInfo memory defaultTokenInfo;\n        (responseCode, tokenInfo) = success ? abi.decode(result, (int32, IHederaTokenService.FungibleTokenInfo)) : (HederaResponseCodes.UNKNOWN, defaultTokenInfo);\n    }\n\n    /// Retrieves general token info for a given token\n    /// @param token The ID of the token as a solidity address\n    /// @dev This function reverts if the call is not successful\n    function getTokenInfo(address token) internal returns (int responseCode, IHederaTokenService.TokenInfo memory tokenInfo) {\n        (bool success, bytes memory result) = precompileAddress.call(\n\n// --- Next chunk ---\n\n// Lines 229-282 (.sol_part_5)\n            abi.encodeWithSelector(IHederaTokenService.getTokenInfo.selector, token));\n        IHederaTokenService.TokenInfo memory defaultTokenInfo;\n        (responseCode, tokenInfo) = success ? abi.decode(result, (int32, IHederaTokenService.TokenInfo)) : (HederaResponseCodes.UNKNOWN, defaultTokenInfo);\n    }\n\n    /// Retrieves non-fungible specific token info for a given NFT\n    /// @param token The ID of the token as a solidity address\n    /// @dev This function reverts if the call is not successful\n    function getNonFungibleTokenInfo(address token, int64 serialNumber) internal returns (int responseCode, IHederaTokenService.NonFungibleTokenInfo memory tokenInfo) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getNonFungibleTokenInfo.selector, token, serialNumber));\n        IHederaTokenService.NonFungibleTokenInfo memory defaultTokenInfo;\n        (responseCode, tokenInfo) = success ? abi.decode(result, (int32, IHederaTokenService.NonFungibleTokenInfo)) : (HederaResponseCodes.UNKNOWN, defaultTokenInfo);\n    }\n\n    /// Query token custom fees\n    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return fixedFees Set of fixed fees for `token`\n    /// @return fractionalFees Set of fractional fees for `token`\n    /// @return royaltyFees Set of royalty fees for `token`\n    /// @dev This function reverts if the call is not successful\n    function getTokenCustomFees(address token) internal returns (int64 responseCode,\n        IHederaTokenService.FixedFee[] memory fixedFees,\n        IHederaTokenService.FractionalFee[] memory fractionalFees,\n        IHederaTokenService.RoyaltyFee[] memory royaltyFees) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getTokenCustomFees.selector, token));\n        IHederaTokenService.FixedFee[] memory defaultFixedFees;\n        IHederaTokenService.FractionalFee[] memory defaultFractionalFees;\n        IHederaTokenService.RoyaltyFee[] memory defaultRoyaltyFees;\n        (responseCode, fixedFees, fractionalFees, royaltyFees) =\n        success ? abi.decode\n        (result, (int32, IHederaTokenService.FixedFee[], IHederaTokenService.FractionalFee[], IHederaTokenService.RoyaltyFee[]))\n        : (HederaResponseCodes.UNKNOWN, defaultFixedFees, defaultFractionalFees, defaultRoyaltyFees);\n    }\n\n    /// Allows spender to withdraw from your account multiple times, up to the value amount. If this function is called\n    /// again it overwrites the current allowance with value.\n    /// Only Applicable to Fungible Tokens\n    /// @param token The hedera token address to approve\n    /// @param spender the account authorized to spend\n    /// @param amount the amount of tokens authorized to spend.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function approve(address token, address spender, uint256 amount) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.approve.selector,\n            token, spender, amount));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Transfers `amount` tokens from `from` to `to` using the\n    //  allowance mechanism. `amount` is then deducted from the caller's allowance.\n\n// --- Next chunk ---\n\n// Lines 283-342 (.sol_part_6)\n    /// Only applicable to fungible tokens\n    /// @param token The address of the fungible Hedera token to transfer\n    /// @param from The account address of the owner of the token, on the behalf of which to transfer `amount` tokens\n    /// @param to The account address of the receiver of the `amount` tokens\n    /// @param amount The amount of tokens to transfer from `from` to `to`\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function transferFrom(address token, address from, address to, uint256 amount) external returns (int64 responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.transferFrom.selector,\n            token, from, to, amount));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Transfers `serialNumber` of `token` from `from` to `to` using the allowance mechanism.\n    /// Only applicable to NFT tokens\n    /// @param token The address of the non-fungible Hedera token to transfer\n    /// @param from The account address of the owner of `serialNumber` of `token`\n    /// @param to The account address of the receiver of `serialNumber`\n    /// @param serialNumber The NFT serial number to transfer\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function transferFromNFT(address token, address from, address to, uint256 serialNumber) external returns (int64 responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.transferFromNFT.selector,\n            token, from, to, serialNumber));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Returns the amount which spender is still allowed to withdraw from owner.\n    /// Only Applicable to Fungible Tokens\n    /// @param token The Hedera token address to check the allowance of\n    /// @param owner the owner of the tokens to be spent\n    /// @param spender the spender of the tokens\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function allowance(address token, address owner, address spender) internal returns (int responseCode, uint256 amount)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.allowance.selector,\n            token, owner, spender));\n        (responseCode, amount) = success ? abi.decode(result, (int32, uint256)) : (HederaResponseCodes.UNKNOWN, 0);\n    }\n\n    /// Allow or reaffirm the approved address to transfer an NFT the approved address does not own.\n    /// Only Applicable to NFT Tokens\n    /// @param token The Hedera NFT token address to approve\n    /// @param approved The new approved NFT controller.  To revoke approvals pass in the zero address.\n    /// @param serialNumber The NFT serial number  to approve\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function approveNFT(address token, address approved, uint256 serialNumber) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.approveNFT.selector,\n            token, approved, serialNumber));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Get the approved address for a single NFT\n    /// Only Applicable to NFT Tokens\n    /// @param token The Hedera NFT token address to check approval",
            "totalTokens": 2513,
            "chunks": [
              {
                "originalText": "        IHederaTokenService.FractionalFee[] memory fractionalFees) nonEmptyExpiry(token)\n    internal returns (int responseCode, address tokenAddress) {\n        (bool success, bytes memory result) = precompileAddress.call{value : msg.value}(\n            abi.encodeWithSelector(IHederaTokenService.createFungibleTokenWithCustomFees.selector,\n            token, initialTotalSupply, decimals, fixedFees, fractionalFees));\n        (responseCode, tokenAddress) = success ? abi.decode(result, (int32, address)) : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Creates an Non Fungible Unique Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createNonFungibleToken(IHederaTokenService.HederaToken memory token) nonEmptyExpiry(token)\n    internal returns (int responseCode, address tokenAddress) {\n        (bool success, bytes memory result) = precompileAddress.call{value : msg.value}(\n            abi.encodeWithSelector(IHederaTokenService.createNonFungibleToken.selector, token));\n        (responseCode, tokenAddress) = success ? abi.decode(result, (int32, address)) : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Creates an Non Fungible Unique Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @param fixedFees list of fixed fees to apply to the token\n    /// @param royaltyFees list of royalty fees to apply to the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createNonFungibleTokenWithCustomFees(\n        IHederaTokenService.HederaToken memory token,\n        IHederaTokenService.FixedFee[] memory fixedFees,\n        IHederaTokenService.RoyaltyFee[] memory royaltyFees) nonEmptyExpiry(token)\n    internal returns (int responseCode, address tokenAddress) {\n        (bool success, bytes memory result) = precompileAddress.call{value : msg.value}(\n            abi.encodeWithSelector(IHederaTokenService.createNonFungibleTokenWithCustomFees.selector,\n            token, fixedFees, royaltyFees));\n        (responseCode, tokenAddress) = success ? abi.decode(result, (int32, address)) : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Retrieves fungible specific token info for a fungible token\n    /// @param token The ID of the token as a solidity address\n    /// @dev This function reverts if the call is not successful\n    function getFungibleTokenInfo(address token) internal returns (int responseCode, IHederaTokenService.FungibleTokenInfo memory tokenInfo) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getFungibleTokenInfo.selector, token));\n        IHederaTokenService.FungibleTokenInfo memory defaultTokenInfo;\n        (responseCode, tokenInfo) = success ? abi.decode(result, (int32, IHederaTokenService.FungibleTokenInfo)) : (HederaResponseCodes.UNKNOWN, defaultTokenInfo);\n    }\n\n    /// Retrieves general token info for a given token\n    /// @param token The ID of the token as a solidity address\n    /// @dev This function reverts if the call is not successful\n    function getTokenInfo(address token) internal returns (int responseCode, IHederaTokenService.TokenInfo memory tokenInfo) {\n        (bool success, bytes memory result) = precompileAddress.call(",
                "codeOnlyTokens": 813,
                "startLine": 178,
                "endLine": 228,
                "type": ".sol_part_4",
                "isOversized": false
              },
              {
                "originalText": "            abi.encodeWithSelector(IHederaTokenService.getTokenInfo.selector, token));\n        IHederaTokenService.TokenInfo memory defaultTokenInfo;\n        (responseCode, tokenInfo) = success ? abi.decode(result, (int32, IHederaTokenService.TokenInfo)) : (HederaResponseCodes.UNKNOWN, defaultTokenInfo);\n    }\n\n    /// Retrieves non-fungible specific token info for a given NFT\n    /// @param token The ID of the token as a solidity address\n    /// @dev This function reverts if the call is not successful\n    function getNonFungibleTokenInfo(address token, int64 serialNumber) internal returns (int responseCode, IHederaTokenService.NonFungibleTokenInfo memory tokenInfo) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getNonFungibleTokenInfo.selector, token, serialNumber));\n        IHederaTokenService.NonFungibleTokenInfo memory defaultTokenInfo;\n        (responseCode, tokenInfo) = success ? abi.decode(result, (int32, IHederaTokenService.NonFungibleTokenInfo)) : (HederaResponseCodes.UNKNOWN, defaultTokenInfo);\n    }\n\n    /// Query token custom fees\n    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return fixedFees Set of fixed fees for `token`\n    /// @return fractionalFees Set of fractional fees for `token`\n    /// @return royaltyFees Set of royalty fees for `token`\n    /// @dev This function reverts if the call is not successful\n    function getTokenCustomFees(address token) internal returns (int64 responseCode,\n        IHederaTokenService.FixedFee[] memory fixedFees,\n        IHederaTokenService.FractionalFee[] memory fractionalFees,\n        IHederaTokenService.RoyaltyFee[] memory royaltyFees) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getTokenCustomFees.selector, token));\n        IHederaTokenService.FixedFee[] memory defaultFixedFees;\n        IHederaTokenService.FractionalFee[] memory defaultFractionalFees;\n        IHederaTokenService.RoyaltyFee[] memory defaultRoyaltyFees;\n        (responseCode, fixedFees, fractionalFees, royaltyFees) =\n        success ? abi.decode\n        (result, (int32, IHederaTokenService.FixedFee[], IHederaTokenService.FractionalFee[], IHederaTokenService.RoyaltyFee[]))\n        : (HederaResponseCodes.UNKNOWN, defaultFixedFees, defaultFractionalFees, defaultRoyaltyFees);\n    }\n\n    /// Allows spender to withdraw from your account multiple times, up to the value amount. If this function is called\n    /// again it overwrites the current allowance with value.\n    /// Only Applicable to Fungible Tokens\n    /// @param token The hedera token address to approve\n    /// @param spender the account authorized to spend\n    /// @param amount the amount of tokens authorized to spend.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function approve(address token, address spender, uint256 amount) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.approve.selector,\n            token, spender, amount));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Transfers `amount` tokens from `from` to `to` using the\n    //  allowance mechanism. `amount` is then deducted from the caller's allowance.",
                "codeOnlyTokens": 805,
                "startLine": 229,
                "endLine": 282,
                "type": ".sol_part_5",
                "isOversized": false
              },
              {
                "originalText": "    /// Only applicable to fungible tokens\n    /// @param token The address of the fungible Hedera token to transfer\n    /// @param from The account address of the owner of the token, on the behalf of which to transfer `amount` tokens\n    /// @param to The account address of the receiver of the `amount` tokens\n    /// @param amount The amount of tokens to transfer from `from` to `to`\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function transferFrom(address token, address from, address to, uint256 amount) external returns (int64 responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.transferFrom.selector,\n            token, from, to, amount));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Transfers `serialNumber` of `token` from `from` to `to` using the allowance mechanism.\n    /// Only applicable to NFT tokens\n    /// @param token The address of the non-fungible Hedera token to transfer\n    /// @param from The account address of the owner of `serialNumber` of `token`\n    /// @param to The account address of the receiver of `serialNumber`\n    /// @param serialNumber The NFT serial number to transfer\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function transferFromNFT(address token, address from, address to, uint256 serialNumber) external returns (int64 responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.transferFromNFT.selector,\n            token, from, to, serialNumber));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Returns the amount which spender is still allowed to withdraw from owner.\n    /// Only Applicable to Fungible Tokens\n    /// @param token The Hedera token address to check the allowance of\n    /// @param owner the owner of the tokens to be spent\n    /// @param spender the spender of the tokens\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function allowance(address token, address owner, address spender) internal returns (int responseCode, uint256 amount)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.allowance.selector,\n            token, owner, spender));\n        (responseCode, amount) = success ? abi.decode(result, (int32, uint256)) : (HederaResponseCodes.UNKNOWN, 0);\n    }\n\n    /// Allow or reaffirm the approved address to transfer an NFT the approved address does not own.\n    /// Only Applicable to NFT Tokens\n    /// @param token The Hedera NFT token address to approve\n    /// @param approved The new approved NFT controller.  To revoke approvals pass in the zero address.\n    /// @param serialNumber The NFT serial number  to approve\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function approveNFT(address token, address approved, uint256 serialNumber) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.approveNFT.selector,\n            token, approved, serialNumber));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Get the approved address for a single NFT\n    /// Only Applicable to NFT Tokens\n    /// @param token The Hedera NFT token address to check approval",
                "codeOnlyTokens": 813,
                "startLine": 283,
                "endLine": 342,
                "type": ".sol_part_6",
                "isOversized": false
              }
            ],
            "startLine": 178,
            "endLine": 342,
            "groupId": 2
          },
          {
            "combinedText": "// File: contracts/system-contracts/hedera-token-service/HederaTokenService.sol\n// Relevant file context:\n// Type: .sol\n\n\n// --- Next chunk ---\n\n// Lines 343-403 (.sol_part_7)\n    /// @param serialNumber The NFT to find the approved address for\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return approved The approved address for this NFT, or the zero address if there is none\n    function getApproved(address token, uint256 serialNumber) internal returns (int responseCode, address approved)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getApproved.selector,\n            token, serialNumber));\n        (responseCode, approved) =\n        success\n        ? abi.decode(result, (int32, address))\n        : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Query if token account is frozen\n    /// @param token The token address to check\n    /// @param account The account address associated with the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return frozen True if `account` is frozen for `token`\n    /// @dev This function reverts if the call is not successful\n    function isFrozen(address token, address account) internal returns (int64 responseCode, bool frozen){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.isFrozen.selector, token, account));\n        (responseCode, frozen) = success ? abi.decode(result, (int32, bool)) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Query if token account has kyc granted\n    /// @param token The token address to check\n    /// @param account The account address associated with the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return kycGranted True if `account` has kyc granted for `token`\n    /// @dev This function reverts if the call is not successful\n    function isKyc(address token, address account) internal returns (int64 responseCode, bool kycGranted){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.isKyc.selector, token, account));\n        (responseCode, kycGranted) = success ? abi.decode(result, (int32, bool)) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Operation to freeze token account\n    /// @param token The token address\n    /// @param account The account address to be frozen\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function freezeToken(address token, address account) internal returns (int64 responseCode){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.freezeToken.selector, token, account));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to unfreeze token account\n    /// @param token The token address\n    /// @param account The account address to be unfrozen\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function unfreezeToken(address token, address account) internal returns (int64 responseCode){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.unfreezeToken.selector, token, account));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to grant kyc to token account\n    /// @param token The token address\n    /// @param account The account address to grant kyc\n\n// --- Next chunk ---\n\n// Lines 404-464 (.sol_part_8)\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function grantTokenKyc(address token, address account) internal returns (int64 responseCode){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.grantTokenKyc.selector, token, account));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to revoke kyc to token account\n    /// @param token The token address\n    /// @param account The account address to revoke kyc\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function revokeTokenKyc(address token, address account) internal returns (int64 responseCode){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.revokeTokenKyc.selector, token, account));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Enable or disable approval for a third party (\"operator\") to manage\n    ///  all of `msg.sender`'s assets\n    /// @param token The Hedera NFT token address to approve\n    /// @param operator Address to add to the set of authorized operators\n    /// @param approved True if the operator is approved, false to revoke approval\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function setApprovalForAll(address token, address operator, bool approved) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.setApprovalForAll.selector,\n            token, operator, approved));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Query if an address is an authorized operator for another address\n    /// Only Applicable to NFT Tokens\n    /// @param token The Hedera NFT token address to approve\n    /// @param owner The address that owns the NFTs\n    /// @param operator The address that acts on behalf of the owner\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return approved True if `operator` is an approved operator for `owner`, false otherwise\n    function isApprovedForAll(address token, address owner, address operator) internal returns (int responseCode, bool approved)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.isApprovedForAll.selector,\n            token, owner, operator));\n        (responseCode, approved) =\n        success\n        ? abi.decode(result, (int32, bool))\n        : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Query token default freeze status\n    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return defaultFreezeStatus True if `token` default freeze status is frozen.\n    /// @dev This function reverts if the call is not successful\n    function getTokenDefaultFreezeStatus(address token) internal returns (int responseCode, bool defaultFreezeStatus) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getTokenDefaultFreezeStatus.selector, token));\n        (responseCode, defaultFreezeStatus) = success ? abi.decode(result, (int32, bool)) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Query token default kyc status\n\n// --- Next chunk ---\n\n// Lines 465-528 (.sol_part_9)\n    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return defaultKycStatus True if `token` default kyc status is KycNotApplicable and false if Revoked.\n    /// @dev This function reverts if the call is not successful\n    function getTokenDefaultKycStatus(address token) internal returns (int responseCode, bool defaultKycStatus) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getTokenDefaultKycStatus.selector, token));\n        (responseCode, defaultKycStatus) = success ? abi.decode(result, (int32, bool)) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /**********************\n     * ABI v1 calls       *\n     **********************/\n\n    /// Initiates a Fungible Token Transfer\n    /// @param token The ID of the token as a solidity address\n    /// @param accountIds account to do a transfer to/from\n    /// @param amounts The amount from the accountId at the same index\n    function transferTokens(address token, address[] memory accountIds, int64[] memory amounts) internal\n    returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.transferTokens.selector,\n            token, accountIds, amounts));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Initiates a Non-Fungable Token Transfer\n    /// @param token The ID of the token as a solidity address\n    /// @param sender the sender of an nft\n    /// @param receiver the receiver of the nft sent by the same index at sender\n    /// @param serialNumber the serial number of the nft sent by the same index at sender\n    function transferNFTs(address token, address[] memory sender, address[] memory receiver, int64[] memory serialNumber)\n    internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.transferNFTs.selector,\n            token, sender, receiver, serialNumber));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Transfers tokens where the calling account/contract is implicitly the first entry in the token transfer list,\n    /// where the amount is the value needed to zero balance the transfers. Regular signing rules apply for sending\n    /// (positive amount) or receiving (negative amount)\n    /// @param token The token to transfer to/from\n    /// @param sender The sender for the transaction\n    /// @param receiver The receiver of the transaction\n    /// @param amount Non-negative value to send. a negative value will result in a failure.\n    function transferToken(address token, address sender, address receiver, int64 amount) internal\n    returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.transferToken.selector,\n            token, sender, receiver, amount));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Transfers tokens where the calling account/contract is implicitly the first entry in the token transfer list,\n    /// where the amount is the value needed to zero balance the transfers. Regular signing rules apply for sending\n    /// (positive amount) or receiving (negative amount)\n    /// @param token The token to transfer to/from\n    /// @param sender The sender for the transaction\n    /// @param receiver The receiver of the transaction\n    /// @param serialNumber The serial number of the NFT to transfer.",
            "totalTokens": 2504,
            "chunks": [
              {
                "originalText": "    /// @param serialNumber The NFT to find the approved address for\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return approved The approved address for this NFT, or the zero address if there is none\n    function getApproved(address token, uint256 serialNumber) internal returns (int responseCode, address approved)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getApproved.selector,\n            token, serialNumber));\n        (responseCode, approved) =\n        success\n        ? abi.decode(result, (int32, address))\n        : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Query if token account is frozen\n    /// @param token The token address to check\n    /// @param account The account address associated with the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return frozen True if `account` is frozen for `token`\n    /// @dev This function reverts if the call is not successful\n    function isFrozen(address token, address account) internal returns (int64 responseCode, bool frozen){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.isFrozen.selector, token, account));\n        (responseCode, frozen) = success ? abi.decode(result, (int32, bool)) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Query if token account has kyc granted\n    /// @param token The token address to check\n    /// @param account The account address associated with the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return kycGranted True if `account` has kyc granted for `token`\n    /// @dev This function reverts if the call is not successful\n    function isKyc(address token, address account) internal returns (int64 responseCode, bool kycGranted){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.isKyc.selector, token, account));\n        (responseCode, kycGranted) = success ? abi.decode(result, (int32, bool)) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Operation to freeze token account\n    /// @param token The token address\n    /// @param account The account address to be frozen\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function freezeToken(address token, address account) internal returns (int64 responseCode){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.freezeToken.selector, token, account));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to unfreeze token account\n    /// @param token The token address\n    /// @param account The account address to be unfrozen\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function unfreezeToken(address token, address account) internal returns (int64 responseCode){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.unfreezeToken.selector, token, account));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to grant kyc to token account\n    /// @param token The token address\n    /// @param account The account address to grant kyc",
                "codeOnlyTokens": 804,
                "startLine": 343,
                "endLine": 403,
                "type": ".sol_part_7",
                "isOversized": false
              },
              {
                "originalText": "    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function grantTokenKyc(address token, address account) internal returns (int64 responseCode){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.grantTokenKyc.selector, token, account));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to revoke kyc to token account\n    /// @param token The token address\n    /// @param account The account address to revoke kyc\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function revokeTokenKyc(address token, address account) internal returns (int64 responseCode){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.revokeTokenKyc.selector, token, account));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Enable or disable approval for a third party (\"operator\") to manage\n    ///  all of `msg.sender`'s assets\n    /// @param token The Hedera NFT token address to approve\n    /// @param operator Address to add to the set of authorized operators\n    /// @param approved True if the operator is approved, false to revoke approval\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function setApprovalForAll(address token, address operator, bool approved) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.setApprovalForAll.selector,\n            token, operator, approved));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Query if an address is an authorized operator for another address\n    /// Only Applicable to NFT Tokens\n    /// @param token The Hedera NFT token address to approve\n    /// @param owner The address that owns the NFTs\n    /// @param operator The address that acts on behalf of the owner\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return approved True if `operator` is an approved operator for `owner`, false otherwise\n    function isApprovedForAll(address token, address owner, address operator) internal returns (int responseCode, bool approved)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.isApprovedForAll.selector,\n            token, owner, operator));\n        (responseCode, approved) =\n        success\n        ? abi.decode(result, (int32, bool))\n        : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Query token default freeze status\n    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return defaultFreezeStatus True if `token` default freeze status is frozen.\n    /// @dev This function reverts if the call is not successful\n    function getTokenDefaultFreezeStatus(address token) internal returns (int responseCode, bool defaultFreezeStatus) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getTokenDefaultFreezeStatus.selector, token));\n        (responseCode, defaultFreezeStatus) = success ? abi.decode(result, (int32, bool)) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Query token default kyc status",
                "codeOnlyTokens": 803,
                "startLine": 404,
                "endLine": 464,
                "type": ".sol_part_8",
                "isOversized": false
              },
              {
                "originalText": "    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return defaultKycStatus True if `token` default kyc status is KycNotApplicable and false if Revoked.\n    /// @dev This function reverts if the call is not successful\n    function getTokenDefaultKycStatus(address token) internal returns (int responseCode, bool defaultKycStatus) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getTokenDefaultKycStatus.selector, token));\n        (responseCode, defaultKycStatus) = success ? abi.decode(result, (int32, bool)) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /**********************\n     * ABI v1 calls       *\n     **********************/\n\n    /// Initiates a Fungible Token Transfer\n    /// @param token The ID of the token as a solidity address\n    /// @param accountIds account to do a transfer to/from\n    /// @param amounts The amount from the accountId at the same index\n    function transferTokens(address token, address[] memory accountIds, int64[] memory amounts) internal\n    returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.transferTokens.selector,\n            token, accountIds, amounts));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Initiates a Non-Fungable Token Transfer\n    /// @param token The ID of the token as a solidity address\n    /// @param sender the sender of an nft\n    /// @param receiver the receiver of the nft sent by the same index at sender\n    /// @param serialNumber the serial number of the nft sent by the same index at sender\n    function transferNFTs(address token, address[] memory sender, address[] memory receiver, int64[] memory serialNumber)\n    internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.transferNFTs.selector,\n            token, sender, receiver, serialNumber));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Transfers tokens where the calling account/contract is implicitly the first entry in the token transfer list,\n    /// where the amount is the value needed to zero balance the transfers. Regular signing rules apply for sending\n    /// (positive amount) or receiving (negative amount)\n    /// @param token The token to transfer to/from\n    /// @param sender The sender for the transaction\n    /// @param receiver The receiver of the transaction\n    /// @param amount Non-negative value to send. a negative value will result in a failure.\n    function transferToken(address token, address sender, address receiver, int64 amount) internal\n    returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.transferToken.selector,\n            token, sender, receiver, amount));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Transfers tokens where the calling account/contract is implicitly the first entry in the token transfer list,\n    /// where the amount is the value needed to zero balance the transfers. Regular signing rules apply for sending\n    /// (positive amount) or receiving (negative amount)\n    /// @param token The token to transfer to/from\n    /// @param sender The sender for the transaction\n    /// @param receiver The receiver of the transaction\n    /// @param serialNumber The serial number of the NFT to transfer.",
                "codeOnlyTokens": 812,
                "startLine": 465,
                "endLine": 528,
                "type": ".sol_part_9",
                "isOversized": false
              }
            ],
            "startLine": 343,
            "endLine": 528,
            "groupId": 3
          },
          {
            "combinedText": "// File: contracts/system-contracts/hedera-token-service/HederaTokenService.sol\n// Relevant file context:\n// Type: .sol\n\n\n// --- Next chunk ---\n\n// Lines 529-597 (.sol_part_10)\n    function transferNFT(address token, address sender, address receiver, int64 serialNumber) internal\n    returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.transferNFT.selector,\n            token, sender, receiver, serialNumber));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to pause token\n    /// @param token The token address to be paused\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function pauseToken(address token) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.pauseToken.selector, token));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to unpause token\n    /// @param token The token address to be unpaused\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function unpauseToken(address token) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.unpauseToken.selector, token));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to wipe fungible tokens from account\n    /// @param token The token address\n    /// @param account The account address to revoke kyc\n    /// @param amount The number of tokens to wipe\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function wipeTokenAccount(address token, address account, int64 amount) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.wipeTokenAccount.selector, token, account, amount));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to wipe non fungible tokens from account\n    /// @param token The token address\n    /// @param account The account address to revoke kyc\n    /// @param  serialNumbers The serial numbers of token to wipe\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function wipeTokenAccountNFT(address token, address account, int64[] memory serialNumbers) internal\n    returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.wipeTokenAccountNFT.selector, token, account, serialNumbers));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to delete token\n    /// @param token The token address\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function deleteToken(address token) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.deleteToken.selector, token));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to update token keys\n    /// @param token The token address\n    /// @param keys The token keys\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateTokenKeys(address token, IHederaTokenService.TokenKey[] memory keys)\n\n// --- Next chunk ---\n\n// Lines 598-650 (.sol_part_11)\n    internal returns (int64 responseCode){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.updateTokenKeys.selector, token, keys));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Query token KeyValue\n    /// @param token The token address to check\n    /// @param keyType The keyType of the desired KeyValue\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return key KeyValue info for key of type `keyType`\n    /// @dev This function reverts if the call is not successful\n    function getTokenKey(address token, uint keyType)\n    internal returns (int64 responseCode, IHederaTokenService.KeyValue memory key){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getTokenKey.selector, token, keyType));\n        IHederaTokenService.KeyValue memory defaultKeyValueInfo;\n        (responseCode, key) = success ? abi.decode(result, (int32,IHederaTokenService.KeyValue) ) : (HederaResponseCodes.UNKNOWN, defaultKeyValueInfo);\n    }\n\n\n    /// Query if valid token found for the given address\n    /// @param token The token address\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return isTokenFlag True if valid token found for the given address\n    /// @dev This function reverts if the call is not successful\n    function isToken(address token) internal returns (int64 responseCode, bool isTokenFlag) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.isToken.selector, token));\n        (responseCode, isTokenFlag) = success ? abi.decode(result, (int32, bool)) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Query to return the token type for a given address\n    /// @param token The token address\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenType the token type. 0 is FUNGIBLE_COMMON, 1 is NON_FUNGIBLE_UNIQUE, -1 is UNRECOGNIZED\n    /// @dev This function reverts if the call is not successful\n    function getTokenType(address token) internal returns (int64 responseCode, int32 tokenType) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getTokenType.selector, token));\n        (responseCode, tokenType) = success ? abi.decode(result, (int32, int32)) : (HederaResponseCodes.UNKNOWN, - 1);\n    }\n\n    /// Operation to get token expiry info\n    /// @param token The token address\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return expiryInfo The expiry info of the token\n    /// @dev This function reverts if the call is not successful\n    function getTokenExpiryInfo(address token) internal returns (int responseCode, IHederaTokenService.Expiry memory expiryInfo){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getTokenExpiryInfo.selector, token));\n        IHederaTokenService.Expiry memory defaultExpiryInfo;\n        (responseCode, expiryInfo) = success ? abi.decode(result, (int32, IHederaTokenService.Expiry)) : (HederaResponseCodes.UNKNOWN, defaultExpiryInfo);\n\n// --- Next chunk ---\n\n// Lines 651-704 (.sol_part_12)\n    }\n\n    /// Operation to update token expiry info\n    /// @param token The token address\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateTokenExpiryInfo(address token, IHederaTokenService.Expiry memory expiryInfo) internal returns (int responseCode){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.updateTokenExpiryInfo.selector, token, expiryInfo));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to update token info\n    /// @param token The token address\n    /// @param tokenInfo The hedera token info to update token with\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateTokenInfo(address token, IHederaTokenService.HederaToken memory tokenInfo) internal returns (int responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.updateTokenInfo.selector, token, tokenInfo));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Redirect for token\n    /// @param token The token address\n    /// @param encodedFunctionSelector The function selector from the ERC20 interface + the bytes input for the function called\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return response The result of the call that had been encoded and sent for execution.\n    function redirectForToken(address token, bytes memory encodedFunctionSelector) external returns (int responseCode, bytes memory response) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.redirectForToken.selector, token, encodedFunctionSelector)\n        );\n\n        emit CallResponseEvent(success, result);\n        (responseCode, response) = success ? (HederaResponseCodes.SUCCESS, result) : (HederaResponseCodes.UNKNOWN, bytes(\"\"));\n    }\n\n    /// Update the custom fees for a fungible token\n    /// @param token The token address\n    /// @param fixedFees Set of fixed fees for `token`\n    /// @param fractionalFees Set of fractional fees for `token`\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateFungibleTokenCustomFees(address token,  IHederaTokenService.FixedFee[] memory fixedFees, IHederaTokenService.FractionalFee[] memory fractionalFees) internal returns (int64 responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.updateFungibleTokenCustomFees.selector, token, fixedFees, fractionalFees));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Update the custom fees for a non-fungible token\n    /// @param token The token address\n    /// @param fixedFees Set of fixed fees for `token`\n    /// @param royaltyFees Set of royalty fees for `token`\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateNonFungibleTokenCustomFees(address token, IHederaTokenService.FixedFee[] memory fixedFees, IHederaTokenService.RoyaltyFee[] memory royaltyFees) internal returns (int64 responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.updateNonFungibleTokenCustomFees.selector, token, fixedFees, royaltyFees));",
            "totalTokens": 2513,
            "chunks": [
              {
                "originalText": "    function transferNFT(address token, address sender, address receiver, int64 serialNumber) internal\n    returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.transferNFT.selector,\n            token, sender, receiver, serialNumber));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to pause token\n    /// @param token The token address to be paused\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function pauseToken(address token) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.pauseToken.selector, token));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to unpause token\n    /// @param token The token address to be unpaused\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function unpauseToken(address token) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.unpauseToken.selector, token));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to wipe fungible tokens from account\n    /// @param token The token address\n    /// @param account The account address to revoke kyc\n    /// @param amount The number of tokens to wipe\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function wipeTokenAccount(address token, address account, int64 amount) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.wipeTokenAccount.selector, token, account, amount));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to wipe non fungible tokens from account\n    /// @param token The token address\n    /// @param account The account address to revoke kyc\n    /// @param  serialNumbers The serial numbers of token to wipe\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function wipeTokenAccountNFT(address token, address account, int64[] memory serialNumbers) internal\n    returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.wipeTokenAccountNFT.selector, token, account, serialNumbers));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to delete token\n    /// @param token The token address\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function deleteToken(address token) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.deleteToken.selector, token));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to update token keys\n    /// @param token The token address\n    /// @param keys The token keys\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateTokenKeys(address token, IHederaTokenService.TokenKey[] memory keys)",
                "codeOnlyTokens": 816,
                "startLine": 529,
                "endLine": 597,
                "type": ".sol_part_10",
                "isOversized": false
              },
              {
                "originalText": "    internal returns (int64 responseCode){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.updateTokenKeys.selector, token, keys));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Query token KeyValue\n    /// @param token The token address to check\n    /// @param keyType The keyType of the desired KeyValue\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return key KeyValue info for key of type `keyType`\n    /// @dev This function reverts if the call is not successful\n    function getTokenKey(address token, uint keyType)\n    internal returns (int64 responseCode, IHederaTokenService.KeyValue memory key){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getTokenKey.selector, token, keyType));\n        IHederaTokenService.KeyValue memory defaultKeyValueInfo;\n        (responseCode, key) = success ? abi.decode(result, (int32,IHederaTokenService.KeyValue) ) : (HederaResponseCodes.UNKNOWN, defaultKeyValueInfo);\n    }\n\n\n    /// Query if valid token found for the given address\n    /// @param token The token address\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return isTokenFlag True if valid token found for the given address\n    /// @dev This function reverts if the call is not successful\n    function isToken(address token) internal returns (int64 responseCode, bool isTokenFlag) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.isToken.selector, token));\n        (responseCode, isTokenFlag) = success ? abi.decode(result, (int32, bool)) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Query to return the token type for a given address\n    /// @param token The token address\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenType the token type. 0 is FUNGIBLE_COMMON, 1 is NON_FUNGIBLE_UNIQUE, -1 is UNRECOGNIZED\n    /// @dev This function reverts if the call is not successful\n    function getTokenType(address token) internal returns (int64 responseCode, int32 tokenType) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getTokenType.selector, token));\n        (responseCode, tokenType) = success ? abi.decode(result, (int32, int32)) : (HederaResponseCodes.UNKNOWN, - 1);\n    }\n\n    /// Operation to get token expiry info\n    /// @param token The token address\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return expiryInfo The expiry info of the token\n    /// @dev This function reverts if the call is not successful\n    function getTokenExpiryInfo(address token) internal returns (int responseCode, IHederaTokenService.Expiry memory expiryInfo){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getTokenExpiryInfo.selector, token));\n        IHederaTokenService.Expiry memory defaultExpiryInfo;\n        (responseCode, expiryInfo) = success ? abi.decode(result, (int32, IHederaTokenService.Expiry)) : (HederaResponseCodes.UNKNOWN, defaultExpiryInfo);",
                "codeOnlyTokens": 808,
                "startLine": 598,
                "endLine": 650,
                "type": ".sol_part_11",
                "isOversized": false
              },
              {
                "originalText": "    }\n\n    /// Operation to update token expiry info\n    /// @param token The token address\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateTokenExpiryInfo(address token, IHederaTokenService.Expiry memory expiryInfo) internal returns (int responseCode){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.updateTokenExpiryInfo.selector, token, expiryInfo));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to update token info\n    /// @param token The token address\n    /// @param tokenInfo The hedera token info to update token with\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateTokenInfo(address token, IHederaTokenService.HederaToken memory tokenInfo) internal returns (int responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.updateTokenInfo.selector, token, tokenInfo));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Redirect for token\n    /// @param token The token address\n    /// @param encodedFunctionSelector The function selector from the ERC20 interface + the bytes input for the function called\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return response The result of the call that had been encoded and sent for execution.\n    function redirectForToken(address token, bytes memory encodedFunctionSelector) external returns (int responseCode, bytes memory response) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.redirectForToken.selector, token, encodedFunctionSelector)\n        );\n\n        emit CallResponseEvent(success, result);\n        (responseCode, response) = success ? (HederaResponseCodes.SUCCESS, result) : (HederaResponseCodes.UNKNOWN, bytes(\"\"));\n    }\n\n    /// Update the custom fees for a fungible token\n    /// @param token The token address\n    /// @param fixedFees Set of fixed fees for `token`\n    /// @param fractionalFees Set of fractional fees for `token`\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateFungibleTokenCustomFees(address token,  IHederaTokenService.FixedFee[] memory fixedFees, IHederaTokenService.FractionalFee[] memory fractionalFees) internal returns (int64 responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.updateFungibleTokenCustomFees.selector, token, fixedFees, fractionalFees));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Update the custom fees for a non-fungible token\n    /// @param token The token address\n    /// @param fixedFees Set of fixed fees for `token`\n    /// @param royaltyFees Set of royalty fees for `token`\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateNonFungibleTokenCustomFees(address token, IHederaTokenService.FixedFee[] memory fixedFees, IHederaTokenService.RoyaltyFee[] memory royaltyFees) internal returns (int64 responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.updateNonFungibleTokenCustomFees.selector, token, fixedFees, royaltyFees));",
                "codeOnlyTokens": 808,
                "startLine": 651,
                "endLine": 704,
                "type": ".sol_part_12",
                "isOversized": false
              }
            ],
            "startLine": 529,
            "endLine": 704,
            "groupId": 4
          },
          {
            "combinedText": "// File: contracts/system-contracts/hedera-token-service/HederaTokenService.sol\n// Relevant file context:\n// Type: .sol\n\n\n// --- Next chunk ---\n\n// Lines 705-750 (.sol_part_13)\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// @notice Airdrop one or more tokens to one or more accounts\n    /// @param tokenTransfers Array of token transfer lists containing token addresses and recipient details\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function airdropTokens(IHederaTokenService.TokenTransferList[] memory tokenTransfers) internal returns (int64 responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.airdropTokens.selector, tokenTransfers));\n\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// @notice Cancels pending airdrops that have not yet been claimed\n    /// @param pendingAirdrops Array of pending airdrops to cancel\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function cancelAirdrops(IHederaTokenService.PendingAirdrop[] memory pendingAirdrops) internal returns (int64 responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.cancelAirdrops.selector, pendingAirdrops)\n        );\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// @notice Claims pending airdrops that were sent to the calling account\n    /// @param pendingAirdrops Array of pending airdrops to claim\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function claimAirdrops(IHederaTokenService.PendingAirdrop[] memory pendingAirdrops) internal returns (int64 responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.claimAirdrops.selector, pendingAirdrops)\n        );\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// @notice Rejects one or more tokens by transferring their full balance from the requesting account to the treasury\n    /// @param rejectingAddress The address rejecting the tokens\n    /// @param ftAddresses Array of fungible token addresses to reject\n    /// @param nftIds Array of NFT IDs to reject\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function rejectTokens(address rejectingAddress, address[] memory ftAddresses, IHederaTokenService.NftID[] memory nftIds) internal returns (int64 responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.rejectTokens.selector, rejectingAddress, ftAddresses, nftIds)\n        );\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n}\n",
            "totalTokens": 703,
            "chunks": [
              {
                "originalText": "        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// @notice Airdrop one or more tokens to one or more accounts\n    /// @param tokenTransfers Array of token transfer lists containing token addresses and recipient details\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function airdropTokens(IHederaTokenService.TokenTransferList[] memory tokenTransfers) internal returns (int64 responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.airdropTokens.selector, tokenTransfers));\n\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// @notice Cancels pending airdrops that have not yet been claimed\n    /// @param pendingAirdrops Array of pending airdrops to cancel\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function cancelAirdrops(IHederaTokenService.PendingAirdrop[] memory pendingAirdrops) internal returns (int64 responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.cancelAirdrops.selector, pendingAirdrops)\n        );\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// @notice Claims pending airdrops that were sent to the calling account\n    /// @param pendingAirdrops Array of pending airdrops to claim\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function claimAirdrops(IHederaTokenService.PendingAirdrop[] memory pendingAirdrops) internal returns (int64 responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.claimAirdrops.selector, pendingAirdrops)\n        );\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// @notice Rejects one or more tokens by transferring their full balance from the requesting account to the treasury\n    /// @param rejectingAddress The address rejecting the tokens\n    /// @param ftAddresses Array of fungible token addresses to reject\n    /// @param nftIds Array of NFT IDs to reject\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function rejectTokens(address rejectingAddress, address[] memory ftAddresses, IHederaTokenService.NftID[] memory nftIds) internal returns (int64 responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.rejectTokens.selector, rejectingAddress, ftAddresses, nftIds)\n        );\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n}\n",
                "codeOnlyTokens": 656,
                "startLine": 705,
                "endLine": 750,
                "type": ".sol_part_13",
                "isOversized": false
              }
            ],
            "startLine": 705,
            "endLine": 750,
            "groupId": 5
          }
        ],
        "oversizedChunks": [],
        "sendStrategy": "multiple_groups",
        "finalTokenCount": 10724,
        "skippedContent": [],
        "contextHeader": "// File: contracts/system-contracts/hedera-token-service/HederaTokenService.sol\n// Relevant file context:\n// Type: .sol\n",
        "tokenBreakdown": {
          "originalFile": 10352,
          "finalSent": 10724,
          "codeTokensInGroups": 10349,
          "fileHeaderTokensInGroups": 145,
          "shellContextTokensInGroups": 0,
          "separatorTokensInGroups": 230,
          "skippedCodeTokens": 0,
          "unprocessedOversizedTokens": 0,
          "totalSavings": -372,
          "savingsPercentage": -3.593508500772798,
          "fileHeaderCount": 5,
          "fileHeaderAvgSize": 29,
          "shellContextCount": 0,
          "shellContextAvgSize": 0,
          "separatorCount": 13,
          "separatorAvgSize": 18
        }
      }
    },
    {
      "filePath": "scripts/hedera-response-codes-protobuf-parser.js",
      "totalOriginalTokens": 422,
      "finalTokenCount": 447,
      "impactScore": 49,
      "averageComplexity": 7,
      "averageQuality": 7,
      "usage": {
        "prompt_tokens": 634,
        "completion_tokens": 127,
        "total_tokens": 761
      },
      "retries": 0,
      "hadError": false,
      "scoredChunkGroups": [
        {
          "groupId": 1,
          "score": {
            "file_path": "scripts/hedera-response-codes-protobuf-parser.js",
            "complexity_score": 7,
            "code_quality_score": 7,
            "maintainability_score": 6,
            "best_practices_adherence": 8,
            "positive_feedback": "The auto-generation of response code contracts enhances developer efficiency by ensuring consistency.",
            "improvement_suggestion": "Implement error handling for network requests to avoid crashes if the response is delayed or fails.",
            "group_summary": "Generates Solidity contract for Hedera response codes from protobuf definitions."
          },
          "totalTokens": 447,
          "usage": {
            "prompt_tokens": 634,
            "completion_tokens": 127,
            "total_tokens": 761
          }
        }
      ],
      "chunkingDetails": {
        "filePath": "scripts/hedera-response-codes-protobuf-parser.js",
        "totalFileTokens": 422,
        "chunks": [
          {
            "originalText": "// SPDX-License-Identifier: Apache-2.0\n\nconst fs = require('fs');\nconst axios = require('axios');\nconst protobufjs = require('protobufjs');\n\nasync function main() {\n  const version = (await axios.get('https://raw.githubusercontent.com/hashgraph/hedera-services/refs/heads/main/version.txt')).data.replace('\\n', '');\n  const res = (await axios.get('https://raw.githubusercontent.com/hashgraph/hedera-services/refs/heads/main/hapi/hedera-protobufs/services/response_code.proto')).data;\n  const parsedProto = protobufjs.parse(res, {\n    keepCase: true,\n    alternateCommentMode: true,\n    preferTrailingComment: true\n  });\n  const responseCodes = parsedProto.root.nested.proto.nested.ResponseCodeEnum;\n\n  let contract =\n      `// SPDX-License-Identifier: Apache-2.0\\n` +\n      `pragma solidity >=0.4.9 <0.9.0;\\n` +\n      `\\n// this contract is auto-generated by a manual triggered script in utils/hedera-response-codes-protobuf-parser.js` +\n      `\\n// the generated contract is using hedera response codes from services version ${version}` +\n      `\\n// https://github.com/hashgraph/hedera-services/blob/main/hapi/hedera-protobufs/services/response_code.proto\\n\\n` +\n      `library HederaResponseCodes {\\n`;\n  for (const [name, code] of Object.entries(responseCodes.values)) {\n    const comment = responseCodes?.comments[name];\n    if (comment) {\n      contract += `    /// ${comment.replaceAll('\\n', ' ') ?? ''}\\n`;\n    }\n    contract += `    int32 internal constant ${name} = ${code};\\n\\n`;\n  }\n  contract += '}\\n';\n\n  console.log(`The generated contract is using hedera response codes from services version ${version}`);\n\n  fs.writeFileSync('./contracts/system-contracts/HederaResponseCodes.sol', contract);\n}\n\nmain();\n",
            "codeOnlyTokens": 422,
            "startLine": 1,
            "endLine": 39,
            "type": ".js",
            "isOversized": false
          }
        ],
        "groupedChunks": [
          {
            "combinedText": "// File: scripts/hedera-response-codes-protobuf-parser.js\n// Relevant file context:\n// Type: .js\n// SPDX-License-Identifier: Apache-2.0\n\nconst fs = require('fs');\nconst axios = require('axios');\nconst protobufjs = require('protobufjs');\n\nasync function main() {\n  const version = (await axios.get('https://raw.githubusercontent.com/hashgraph/hedera-services/refs/heads/main/version.txt')).data.replace('\\n', '');\n  const res = (await axios.get('https://raw.githubusercontent.com/hashgraph/hedera-services/refs/heads/main/hapi/hedera-protobufs/services/response_code.proto')).data;\n  const parsedProto = protobufjs.parse(res, {\n    keepCase: true,\n    alternateCommentMode: true,\n    preferTrailingComment: true\n  });\n  const responseCodes = parsedProto.root.nested.proto.nested.ResponseCodeEnum;\n\n  let contract =\n      `// SPDX-License-Identifier: Apache-2.0\\n` +\n      `pragma solidity >=0.4.9 <0.9.0;\\n` +\n      `\\n// this contract is auto-generated by a manual triggered script in utils/hedera-response-codes-protobuf-parser.js` +\n      `\\n// the generated contract is using hedera response codes from services version ${version}` +\n      `\\n// https://github.com/hashgraph/hedera-services/blob/main/hapi/hedera-protobufs/services/response_code.proto\\n\\n` +\n      `library HederaResponseCodes {\\n`;\n  for (const [name, code] of Object.entries(responseCodes.values)) {\n    const comment = responseCodes?.comments[name];\n    if (comment) {\n      contract += `    /// ${comment.replaceAll('\\n', ' ') ?? ''}\\n`;\n    }\n    contract += `    int32 internal constant ${name} = ${code};\\n\\n`;\n  }\n  contract += '}\\n';\n\n  console.log(`The generated contract is using hedera response codes from services version ${version}`);\n\n  fs.writeFileSync('./contracts/system-contracts/HederaResponseCodes.sol', contract);\n}\n\nmain();\n",
            "totalTokens": 447,
            "chunks": [
              {
                "originalText": "// SPDX-License-Identifier: Apache-2.0\n\nconst fs = require('fs');\nconst axios = require('axios');\nconst protobufjs = require('protobufjs');\n\nasync function main() {\n  const version = (await axios.get('https://raw.githubusercontent.com/hashgraph/hedera-services/refs/heads/main/version.txt')).data.replace('\\n', '');\n  const res = (await axios.get('https://raw.githubusercontent.com/hashgraph/hedera-services/refs/heads/main/hapi/hedera-protobufs/services/response_code.proto')).data;\n  const parsedProto = protobufjs.parse(res, {\n    keepCase: true,\n    alternateCommentMode: true,\n    preferTrailingComment: true\n  });\n  const responseCodes = parsedProto.root.nested.proto.nested.ResponseCodeEnum;\n\n  let contract =\n      `// SPDX-License-Identifier: Apache-2.0\\n` +\n      `pragma solidity >=0.4.9 <0.9.0;\\n` +\n      `\\n// this contract is auto-generated by a manual triggered script in utils/hedera-response-codes-protobuf-parser.js` +\n      `\\n// the generated contract is using hedera response codes from services version ${version}` +\n      `\\n// https://github.com/hashgraph/hedera-services/blob/main/hapi/hedera-protobufs/services/response_code.proto\\n\\n` +\n      `library HederaResponseCodes {\\n`;\n  for (const [name, code] of Object.entries(responseCodes.values)) {\n    const comment = responseCodes?.comments[name];\n    if (comment) {\n      contract += `    /// ${comment.replaceAll('\\n', ' ') ?? ''}\\n`;\n    }\n    contract += `    int32 internal constant ${name} = ${code};\\n\\n`;\n  }\n  contract += '}\\n';\n\n  console.log(`The generated contract is using hedera response codes from services version ${version}`);\n\n  fs.writeFileSync('./contracts/system-contracts/HederaResponseCodes.sol', contract);\n}\n\nmain();\n",
                "codeOnlyTokens": 422,
                "startLine": 1,
                "endLine": 39,
                "type": "full_file",
                "isOversized": false
              }
            ],
            "startLine": 1,
            "endLine": 39,
            "groupId": 1
          }
        ],
        "oversizedChunks": [],
        "sendStrategy": "full_file",
        "finalTokenCount": 447,
        "skippedContent": [],
        "contextHeader": "// File: scripts/hedera-response-codes-protobuf-parser.js\n// Relevant file context:\n// Type: .js\n",
        "tokenBreakdown": {
          "originalFile": 422,
          "finalSent": 447,
          "codeTokensInGroups": 422,
          "fileHeaderTokensInGroups": 25,
          "shellContextTokensInGroups": 0,
          "separatorTokensInGroups": 0,
          "skippedCodeTokens": 0,
          "unprocessedOversizedTokens": 0,
          "totalSavings": -25,
          "savingsPercentage": -5.924170616113744,
          "fileHeaderCount": 1,
          "fileHeaderAvgSize": 25,
          "shellContextCount": 0,
          "shellContextAvgSize": 0,
          "separatorCount": 1,
          "separatorAvgSize": 0
        }
      }
    },
    {
      "filePath": "system-contract-dapp-playground/src/components/contract-interaction/hts/token-management-contract/methods/manageTokenInfo/index.tsx",
      "totalOriginalTokens": 3211,
      "finalTokenCount": 3380,
      "impactScore": 48.75,
      "averageComplexity": 6.5,
      "averageQuality": 7.5,
      "usage": {
        "prompt_tokens": 5075,
        "completion_tokens": 232,
        "total_tokens": 5307
      },
      "retries": 0,
      "hadError": false,
      "scoredChunkGroups": [
        {
          "groupId": 1,
          "score": {
            "complexity_score": 7,
            "code_quality_score": 8,
            "maintainability_score": 7,
            "best_practices_adherence": 8,
            "positive_feedback": "Excellent use of hooks for managing form states and error handling, improving the user experience for token management.",
            "improvement_suggestion": "Consider modularizing API interaction logic to simplify testing and enhance reusability across similar components.",
            "group_summary": "Manages token information updates on Hedera using a React form interface, handling multiple API interactions."
          },
          "totalTokens": 2500,
          "usage": {
            "prompt_tokens": 3343,
            "completion_tokens": 119,
            "total_tokens": 3462,
            "prompt_tokens_details": {
              "cached_tokens": 0,
              "audio_tokens": 0
            },
            "completion_tokens_details": {
              "reasoning_tokens": 0,
              "audio_tokens": 0,
              "accepted_prediction_tokens": 0,
              "rejected_prediction_tokens": 0
            }
          }
        },
        {
          "groupId": 2,
          "score": {
            "complexity_score": 6,
            "code_quality_score": 7,
            "maintainability_score": 7,
            "best_practices_adherence": 8,
            "positive_feedback": "The component effectively manages different API methods and their corresponding forms, enhancing user experience in token management.",
            "improvement_suggestion": "Consider breaking down the component into smaller, reusable parts for better readability and maintainability.",
            "group_summary": "Manages updates for Hedera token information through a dynamic React form interface."
          },
          "totalTokens": 880,
          "usage": {
            "prompt_tokens": 1732,
            "completion_tokens": 113,
            "total_tokens": 1845,
            "prompt_tokens_details": {
              "cached_tokens": 0,
              "audio_tokens": 0
            },
            "completion_tokens_details": {
              "reasoning_tokens": 0,
              "audio_tokens": 0,
              "accepted_prediction_tokens": 0,
              "rejected_prediction_tokens": 0
            }
          }
        }
      ],
      "chunkingDetails": {
        "filePath": "system-contract-dapp-playground/src/components/contract-interaction/hts/token-management-contract/methods/manageTokenInfo/index.tsx",
        "totalFileTokens": 3211,
        "chunks": [
          {
            "originalText": "// SPDX-License-Identifier: Apache-2.0\n\nimport Cookies from 'js-cookie';\nimport { Contract } from 'ethers';\nimport TokenInfoForm from './TokenInfoForm';\nimport { useToast } from '@chakra-ui/react';\nimport TokenExpiryForm from './TokenExpiryForm';\nimport { useState, useMemo, useEffect } from 'react';\nimport { CommonErrorToast } from '@/components/toast/CommonToast';\nimport { ITransactionResult } from '@/types/contract-interactions/shared';\nimport { handleAPIErrors } from '../../../../../common/methods/handleAPIErrors';\nimport { useToastSuccessful } from '../../../../../../hooks/useToastSuccessful';\nimport { usePaginatedTxResults } from '../../../../../../hooks/usePaginatedTxResults';\nimport { SharedSigningKeysComponent } from '../../../shared/components/SigningKeysForm';\nimport { TransactionResultTable } from '../../../../../common/components/TransactionResultTable';\nimport { HederaTokenKeyTypes, TRANSACTION_PAGE_SIZE } from '../../../shared/states/commonStates';\nimport { manageTokenInfomation } from '@/api/hedera/hts-interactions/tokenManagement-interactions';\nimport { handleSanitizeHederaFormInputs } from '../../../../../common/methods/handleSanitizeFormInputs';\nimport { useUpdateTransactionResultsToLocalStorage } from '../../../../../../hooks/useUpdateLocalStorage';\nimport useFilterTransactionsByContractAddress from '../../../../../../hooks/useFilterTransactionsByContractAddress';\nimport { handleRetrievingTransactionResultsFromLocalStorage } from '../../../../../common/methods/handleRetrievingTransactionResultsFromLocalStorage';\nimport {\n  CONTRACT_NAMES,\n  HEDERA_COMMON_TRANSACTION_TYPE,\n  HEDERA_TRANSACTION_RESULT_STORAGE_KEYS,\n} from '@/utils/common/constants';\nimport {\n  DEFAULT_TOKEN_EXIPIRY_VALUE,\n  htsUpdateTokenInfoParamFields,\n  DEFAULT_HEDERA_TOKEN_INFO_VALUE,\n} from '@/utils/contract-interactions/HTS/token-management/constant';\nimport {\n  SharedFormButton,\n  SharedFormInputField,\n  SharedExecuteButtonWithFee,\n} from '../../../shared/components/ParamInputForm';\n\ninterface PageProps {\n  baseContract: Contract;\n}\n\ntype API_NAMES = 'UPDATE_INFO' | 'UPDATE_EXPIRY' | 'UPDATE_KEYS';\n\nconst ManageTokenInfo = ({ baseContract }: PageProps) => {\n  // general states\n  const toaster = useToast();\n  const [isLoading, setIsLoading] = useState(false);\n  const [isSuccessful, setIsSuccessful] = useState(false);\n  const HEDERA_NETWORK = JSON.parse(Cookies.get('_network') as string);\n  const [APIMethods, setAPIMethods] = useState<API_NAMES>('UPDATE_INFO');\n  const [currentTransactionPage, setCurrentTransactionPage] = useState(1);\n  const signerAddress = JSON.parse(Cookies.get('_connectedAccounts') as string)[0];\n  const currentContractAddress = Cookies.get(CONTRACT_NAMES.TOKEN_MANAGE) as string;\n  const [transactionResults, setTransactionResults] = useState<ITransactionResult[]>([]);\n  const transactionResultStorageKey = HEDERA_TRANSACTION_RESULT_STORAGE_KEYS['TOKEN-MANAGE']['TOKEN-INFO'];\n  const APIButtonTitles: { API: API_NAMES; apiSwitchTitle: string; executeTitle: string }[] = [\n    {\n      API: 'UPDATE_INFO',\n      apiSwitchTitle: 'General Information',\n      executeTitle: 'Update Token Information',\n    },\n    { API: 'UPDATE_EXPIRY', apiSwitchTitle: 'Token Exipry', executeTitle: 'Update Token Expiry' },\n    { API: 'UPDATE_KEYS', apiSwitchTitle: 'Token Keys', executeTitle: 'Update Token Keys' },\n  ];\n\n  const tokenInfoFields = useMemo(() => {\n    switch (APIMethods) {\n      case 'UPDATE_INFO':\n        return [\n          ['name', 'symbol', 'memo'],",
            "codeOnlyTokens": 804,
            "startLine": 1,
            "endLine": 70,
            "type": ".tsx_part_1",
            "isOversized": false
          },
          {
            "originalText": "          ['treasury', 'maxSupply'],\n        ];\n      case 'UPDATE_EXPIRY':\n        return ['second', 'autoRenewAccount', 'autoRenewPeriod'];\n    }\n  }, [APIMethods]);\n\n  const initialParamValues = {\n    name: '',\n    memo: '',\n    second: '',\n    symbol: '',\n    treasury: '',\n    feeValue: '',\n    maxSupply: '',\n    freezeStatus: false,\n    autoRenewPeriod: '',\n    autoRenewAccount: '',\n    tokenSupplyType: false,\n    hederaTokenAddress: '',\n  };\n  const [paramValues, setParamValues] = useState<any>(initialParamValues);\n\n  const transactionResultsToShow = useFilterTransactionsByContractAddress(\n    transactionResults,\n    currentContractAddress\n  );\n\n  const HederaTokenKeyValueType: IHederaTokenServiceKeyValueType[] = [\n    'inheritAccountKey',\n    'contractId',\n    'ed25519',\n    'ECDSA_secp256k1',\n    'delegatableContractId',\n  ];\n\n  const keyTypeArrays = [\n    'ADMIN',\n    'KYC',\n    'FREEZE',\n    'WIPE',\n    'SUPPLY',\n    'FEE',\n    'PAUSE',\n  ] as IHederaTokenServiceKeyType[];\n\n  const transactionTypeMap = {\n    UPDATE_INFO: HEDERA_COMMON_TRANSACTION_TYPE.HTS_FREEZE_TOKEN,\n    UPDATE_EXPIRY: HEDERA_COMMON_TRANSACTION_TYPE.HTS_REVOKE_KYC,\n    UPDATE_KEYS: HEDERA_COMMON_TRANSACTION_TYPE.HTS_UNFREEZE_TOKEN,\n  };\n\n  const initialKeyValues = keyTypeArrays.map((keyType) => ({\n    keyType: keyType,\n    keyValueType: 'inheritAccountKey',\n    keyValue: '',\n  })) as ICommonKeyObject[];\n\n  // Keys states\n  const [keys, setKeys] = useState<ICommonKeyObject[]>([]); // keeps track of keys array to pass to the API\n  const [chosenKeys, setChosenKeys] = useState(new Set<IHederaTokenServiceKeyType>()); // keeps track of keyTypes which have already been chosen in the list\n  const [keyTypesToShow, setKeyTypesToShow] = useState(new Set(HederaTokenKeyTypes)); // keeps track of the left over keyTypes to show in the drop down\n\n  useEffect(() => {\n    setKeys((prev) =>\n      prev.map((key) => {\n        key.keyValueType = 'inheritAccountKey';\n        return key;\n      })\n    );\n  }, [APIMethods]);\n\n  /** @dev retrieve token creation results from localStorage to maintain data on re-renders */\n  useEffect(() => {\n    handleRetrievingTransactionResultsFromLocalStorage(\n      toaster,\n      transactionResultStorageKey,\n      setCurrentTransactionPage,\n      setTransactionResults\n    );\n  }, [toaster, transactionResultStorageKey]);\n\n  // declare a paginatedTransactionResults\n  const paginatedTransactionResults = usePaginatedTxResults(currentTransactionPage, transactionResultsToShow);\n\n  /** @dev handle form inputs on change */\n  const handleInputOnChange = (e: any, param: string) => {\n    setParamValues((prev: any) => ({ ...prev, [param]: e.target.value }));\n  };\n\n  /** @dev handle invoking the API to interact with smart contract and update token information */\n  const handleUpdatingTokenInfo = async (API: API_NAMES) => {\n    // destructuring param values\n    const {\n      name,\n      memo,\n      second,\n      symbol,\n      treasury,\n      feeValue,\n      maxSupply,\n      freezeStatus,\n      autoRenewPeriod,\n      tokenSupplyType,\n      autoRenewAccount,\n      hederaTokenAddress,\n    } = paramValues;\n\n    // sanitize params\n    let sanitizeErr;",
            "codeOnlyTokens": 800,
            "startLine": 71,
            "endLine": 180,
            "type": ".tsx_part_2",
            "isOversized": false
          },
          {
            "originalText": "    switch (API) {\n      case 'UPDATE_INFO':\n        sanitizeErr = handleSanitizeHederaFormInputs({\n          API: 'UpdateTokenInfo',\n          hederaTokenAddress,\n          maxSupply,\n          treasury,\n          symbol,\n          name,\n        });\n        break;\n      case 'UPDATE_EXPIRY':\n        sanitizeErr = handleSanitizeHederaFormInputs({\n          API: 'UpdateTokenExpiry',\n          second,\n          autoRenewPeriod,\n          autoRenewAccount,\n          hederaTokenAddress,\n        });\n        break;\n    }\n    // toast error if any param is invalid\n    if (sanitizeErr) {\n      CommonErrorToast({ toaster, title: 'Invalid parameters', description: sanitizeErr });\n      return;\n    }\n\n    // prepare params for manageTokenInformation() API method\n    const tokenInfo = {\n      ...DEFAULT_HEDERA_TOKEN_INFO_VALUE,\n      name,\n      symbol,\n      memo,\n      treasury,\n      maxSupply,\n      freezeStatus,\n      tokenSupplyType,\n    } as IHederaTokenServiceHederaToken;\n\n    const expiryInfo = {\n      ...DEFAULT_TOKEN_EXIPIRY_VALUE,\n      second: Number(second),\n      autoRenewAccount,\n      autoRenewPeriod,\n    } as IHederaTokenServiceExpiry;\n\n    // turn is loading on\n    setIsLoading(true);\n\n    // invoke method APIS\n    const { result, transactionHash, err } = await manageTokenInfomation(\n      baseContract,\n      signerAddress,\n      HEDERA_NETWORK,\n      APIMethods,\n      hederaTokenAddress,\n      Number(feeValue),\n      tokenInfo,\n      expiryInfo,\n      keys\n    );\n\n    // turn is loading on\n    setIsLoading(false);\n\n    // handle err\n    if (err || !result) {\n      handleAPIErrors({\n        err,\n        toaster,\n        transactionHash,\n        setTransactionResults,\n        transactionResultStorageKey,\n        tokenAddress: hederaTokenAddress,\n        transactionType: transactionTypeMap[APIMethods],\n        sessionedContractAddress: currentContractAddress,\n      });\n      return;\n    } else {\n      // handle succesfull\n      setTransactionResults((prev) => [\n        ...prev,\n        {\n          status: 'success',\n          transactionResultStorageKey,\n          tokenAddress: hederaTokenAddress,\n          transactionTimeStamp: Date.now(),\n          txHash: transactionHash as string,\n          transactionType: transactionTypeMap[APIMethods],\n          sessionedContractAddress: currentContractAddress,\n        },\n      ]);\n\n      setIsSuccessful(true);\n    }\n  };\n\n  /** @dev listen to change event on transactionResults state => load to localStorage  */\n  useUpdateTransactionResultsToLocalStorage(transactionResults, transactionResultStorageKey);\n\n  /** @dev toast successful */\n  useToastSuccessful({\n    toaster,\n    setKeys,\n    isSuccessful,\n    setParamValues,\n    setIsSuccessful,\n    initialKeyValues,\n    transactionResults,\n    setCurrentTransactionPage,\n    resetParamValues: initialParamValues,\n    toastTitle: 'Token update successful',\n  });\n\n  return (\n    <div className=\"w-full mx-3 flex justify-center mt-6 flex-col gap-20\">\n      {/* Update token form */}\n      <div className=\"flex flex-col gap-6 justify-center tracking-tight text-white/70\">\n        {/* notice component */}\n        <p className=\"text-sm whitespace-normal -mb-4\">\n          <span className=\"italic font-bold\">*important:</span> Should you choose not to update certain\n          fields, kindly populate the token&apos;s current values.\n        </p>\n\n        {/* API methods */}\n        <div className=\"w-full flex gap-3\">\n          {APIButtonTitles.map((APIButton) => {\n            return (\n              <div key={APIButton.API} className=\"w-full\">\n                <SharedFormButton",
            "codeOnlyTokens": 802,
            "startLine": 181,
            "endLine": 310,
            "type": ".tsx_part_3",
            "isOversized": false
          },
          {
            "originalText": "                  switcher={APIMethods === APIButton.API}\n                  buttonTitle={APIButton.apiSwitchTitle}\n                  handleButtonOnClick={() => setAPIMethods(APIButton.API)}\n                  explanation={''}\n                />\n              </div>\n            );\n          })}\n        </div>\n\n        {/* Hedera token address */}\n        <SharedFormInputField\n          param={'hederaTokenAddress'}\n          handleInputOnChange={handleInputOnChange}\n          paramValue={paramValues['hederaTokenAddress']}\n          paramKey={(htsUpdateTokenInfoParamFields as any)['hederaTokenAddress'].paramKey}\n          paramType={(htsUpdateTokenInfoParamFields as any)['hederaTokenAddress'].inputType}\n          paramSize={(htsUpdateTokenInfoParamFields as any)['hederaTokenAddress'].inputSize}\n          explanation={(htsUpdateTokenInfoParamFields as any)['hederaTokenAddress'].explanation}\n          paramClassName={(htsUpdateTokenInfoParamFields as any)['hederaTokenAddress'].inputClassname}\n          paramPlaceholder={(htsUpdateTokenInfoParamFields as any)['hederaTokenAddress'].inputPlaceholder}\n          paramFocusColor={(htsUpdateTokenInfoParamFields as any)['hederaTokenAddress'].inputFocusBorderColor}\n        />\n\n        {/* UPDATE_INFO form */}\n        {APIMethods === 'UPDATE_INFO' && (\n          <TokenInfoForm\n            paramValues={paramValues}\n            setParamValues={setParamValues}\n            handleInputOnChange={handleInputOnChange}\n            tokenInfoFields={tokenInfoFields as string[][]}\n          />\n        )}\n\n        {/* UPDATE_EXPIRY form */}\n        {APIMethods === 'UPDATE_EXPIRY' && (\n          <TokenExpiryForm\n            paramValues={paramValues}\n            handleInputOnChange={handleInputOnChange}\n            tokenInfoFields={tokenInfoFields as string[]}\n          />\n        )}\n\n        {/* UPDATE_KEYS form */}\n        {APIMethods === 'UPDATE_KEYS' && (\n          <>\n            {/* keys */}\n            <SharedSigningKeysComponent\n              keys={keys}\n              setKeys={setKeys}\n              chosenKeys={chosenKeys}\n              setChosenKeys={setChosenKeys}\n              keyTypesToShow={keyTypesToShow}\n              setKeyTypesToShow={setKeyTypesToShow}\n              HederaTokenKeyTypes={HederaTokenKeyTypes}\n              buttonTitle=\"Add desired signing keys to update\"\n              HederaTokenKeyValueType={HederaTokenKeyValueType}\n            />\n          </>\n        )}\n\n        {/* Execute buttons */}\n        {APIButtonTitles.map((APIButton) => {\n          if (APIMethods === APIButton.API) {\n            return (\n              <div key={APIButton.API} className=\"w-full\">\n                <SharedExecuteButtonWithFee\n                  isLoading={isLoading}\n                  feeType={'GAS'}\n                  paramValues={paramValues.feeValue}\n                  placeHolder={'Gas limit...'}\n                  executeBtnTitle={APIButton.executeTitle}\n                  handleInputOnChange={handleInputOnChange}\n                  explanation={'Optional gas limit for the transaction.'}\n                  handleInvokingAPIMethod={() => handleUpdatingTokenInfo(APIButton.API)}\n                />\n              </div>\n            );\n          }\n        })}\n      </div>\n\n      {/* transaction results table */}\n      {transactionResultsToShow.length > 0 && (\n        <TransactionResultTable\n          API=\"TokenCreate\"\n          hederaNetwork={HEDERA_NETWORK}\n          transactionResults={transactionResults}\n          TRANSACTION_PAGE_SIZE={TRANSACTION_PAGE_SIZE}\n          setTransactionResults={setTransactionResults}\n          currentTransactionPage={currentTransactionPage}\n          setCurrentTransactionPage={setCurrentTransactionPage}\n          transactionResultStorageKey={transactionResultStorageKey}\n          paginatedTransactionResults={paginatedTransactionResults}\n        />\n      )}\n    </div>\n  );\n};\n\nexport default ManageTokenInfo;",
            "codeOnlyTokens": 804,
            "startLine": 311,
            "endLine": 411,
            "type": ".tsx_part_4",
            "isOversized": false
          },
          {
            "originalText": "",
            "codeOnlyTokens": 0,
            "startLine": 412,
            "endLine": 412,
            "type": ".tsx_part_5",
            "isOversized": false
          }
        ],
        "groupedChunks": [
          {
            "combinedText": "// File: system-contract-dapp-playground/src/components/contract-interaction/hts/token-management-contract/methods/manageTokenInfo/index.tsx\n// Relevant file context:\n// Type: .tsx\n\n\n// --- Next chunk ---\n\n// Lines 1-70 (.tsx_part_1)\n// SPDX-License-Identifier: Apache-2.0\n\nimport Cookies from 'js-cookie';\nimport { Contract } from 'ethers';\nimport TokenInfoForm from './TokenInfoForm';\nimport { useToast } from '@chakra-ui/react';\nimport TokenExpiryForm from './TokenExpiryForm';\nimport { useState, useMemo, useEffect } from 'react';\nimport { CommonErrorToast } from '@/components/toast/CommonToast';\nimport { ITransactionResult } from '@/types/contract-interactions/shared';\nimport { handleAPIErrors } from '../../../../../common/methods/handleAPIErrors';\nimport { useToastSuccessful } from '../../../../../../hooks/useToastSuccessful';\nimport { usePaginatedTxResults } from '../../../../../../hooks/usePaginatedTxResults';\nimport { SharedSigningKeysComponent } from '../../../shared/components/SigningKeysForm';\nimport { TransactionResultTable } from '../../../../../common/components/TransactionResultTable';\nimport { HederaTokenKeyTypes, TRANSACTION_PAGE_SIZE } from '../../../shared/states/commonStates';\nimport { manageTokenInfomation } from '@/api/hedera/hts-interactions/tokenManagement-interactions';\nimport { handleSanitizeHederaFormInputs } from '../../../../../common/methods/handleSanitizeFormInputs';\nimport { useUpdateTransactionResultsToLocalStorage } from '../../../../../../hooks/useUpdateLocalStorage';\nimport useFilterTransactionsByContractAddress from '../../../../../../hooks/useFilterTransactionsByContractAddress';\nimport { handleRetrievingTransactionResultsFromLocalStorage } from '../../../../../common/methods/handleRetrievingTransactionResultsFromLocalStorage';\nimport {\n  CONTRACT_NAMES,\n  HEDERA_COMMON_TRANSACTION_TYPE,\n  HEDERA_TRANSACTION_RESULT_STORAGE_KEYS,\n} from '@/utils/common/constants';\nimport {\n  DEFAULT_TOKEN_EXIPIRY_VALUE,\n  htsUpdateTokenInfoParamFields,\n  DEFAULT_HEDERA_TOKEN_INFO_VALUE,\n} from '@/utils/contract-interactions/HTS/token-management/constant';\nimport {\n  SharedFormButton,\n  SharedFormInputField,\n  SharedExecuteButtonWithFee,\n} from '../../../shared/components/ParamInputForm';\n\ninterface PageProps {\n  baseContract: Contract;\n}\n\ntype API_NAMES = 'UPDATE_INFO' | 'UPDATE_EXPIRY' | 'UPDATE_KEYS';\n\nconst ManageTokenInfo = ({ baseContract }: PageProps) => {\n  // general states\n  const toaster = useToast();\n  const [isLoading, setIsLoading] = useState(false);\n  const [isSuccessful, setIsSuccessful] = useState(false);\n  const HEDERA_NETWORK = JSON.parse(Cookies.get('_network') as string);\n  const [APIMethods, setAPIMethods] = useState<API_NAMES>('UPDATE_INFO');\n  const [currentTransactionPage, setCurrentTransactionPage] = useState(1);\n  const signerAddress = JSON.parse(Cookies.get('_connectedAccounts') as string)[0];\n  const currentContractAddress = Cookies.get(CONTRACT_NAMES.TOKEN_MANAGE) as string;\n  const [transactionResults, setTransactionResults] = useState<ITransactionResult[]>([]);\n  const transactionResultStorageKey = HEDERA_TRANSACTION_RESULT_STORAGE_KEYS['TOKEN-MANAGE']['TOKEN-INFO'];\n  const APIButtonTitles: { API: API_NAMES; apiSwitchTitle: string; executeTitle: string }[] = [\n    {\n      API: 'UPDATE_INFO',\n      apiSwitchTitle: 'General Information',\n      executeTitle: 'Update Token Information',\n    },\n    { API: 'UPDATE_EXPIRY', apiSwitchTitle: 'Token Exipry', executeTitle: 'Update Token Expiry' },\n    { API: 'UPDATE_KEYS', apiSwitchTitle: 'Token Keys', executeTitle: 'Update Token Keys' },\n  ];\n\n  const tokenInfoFields = useMemo(() => {\n    switch (APIMethods) {\n      case 'UPDATE_INFO':\n        return [\n          ['name', 'symbol', 'memo'],\n\n// --- Next chunk ---\n\n// Lines 71-180 (.tsx_part_2)\n          ['treasury', 'maxSupply'],\n        ];\n      case 'UPDATE_EXPIRY':\n        return ['second', 'autoRenewAccount', 'autoRenewPeriod'];\n    }\n  }, [APIMethods]);\n\n  const initialParamValues = {\n    name: '',\n    memo: '',\n    second: '',\n    symbol: '',\n    treasury: '',\n    feeValue: '',\n    maxSupply: '',\n    freezeStatus: false,\n    autoRenewPeriod: '',\n    autoRenewAccount: '',\n    tokenSupplyType: false,\n    hederaTokenAddress: '',\n  };\n  const [paramValues, setParamValues] = useState<any>(initialParamValues);\n\n  const transactionResultsToShow = useFilterTransactionsByContractAddress(\n    transactionResults,\n    currentContractAddress\n  );\n\n  const HederaTokenKeyValueType: IHederaTokenServiceKeyValueType[] = [\n    'inheritAccountKey',\n    'contractId',\n    'ed25519',\n    'ECDSA_secp256k1',\n    'delegatableContractId',\n  ];\n\n  const keyTypeArrays = [\n    'ADMIN',\n    'KYC',\n    'FREEZE',\n    'WIPE',\n    'SUPPLY',\n    'FEE',\n    'PAUSE',\n  ] as IHederaTokenServiceKeyType[];\n\n  const transactionTypeMap = {\n    UPDATE_INFO: HEDERA_COMMON_TRANSACTION_TYPE.HTS_FREEZE_TOKEN,\n    UPDATE_EXPIRY: HEDERA_COMMON_TRANSACTION_TYPE.HTS_REVOKE_KYC,\n    UPDATE_KEYS: HEDERA_COMMON_TRANSACTION_TYPE.HTS_UNFREEZE_TOKEN,\n  };\n\n  const initialKeyValues = keyTypeArrays.map((keyType) => ({\n    keyType: keyType,\n    keyValueType: 'inheritAccountKey',\n    keyValue: '',\n  })) as ICommonKeyObject[];\n\n  // Keys states\n  const [keys, setKeys] = useState<ICommonKeyObject[]>([]); // keeps track of keys array to pass to the API\n  const [chosenKeys, setChosenKeys] = useState(new Set<IHederaTokenServiceKeyType>()); // keeps track of keyTypes which have already been chosen in the list\n  const [keyTypesToShow, setKeyTypesToShow] = useState(new Set(HederaTokenKeyTypes)); // keeps track of the left over keyTypes to show in the drop down\n\n  useEffect(() => {\n    setKeys((prev) =>\n      prev.map((key) => {\n        key.keyValueType = 'inheritAccountKey';\n        return key;\n      })\n    );\n  }, [APIMethods]);\n\n  /** @dev retrieve token creation results from localStorage to maintain data on re-renders */\n  useEffect(() => {\n    handleRetrievingTransactionResultsFromLocalStorage(\n      toaster,\n      transactionResultStorageKey,\n      setCurrentTransactionPage,\n      setTransactionResults\n    );\n  }, [toaster, transactionResultStorageKey]);\n\n  // declare a paginatedTransactionResults\n  const paginatedTransactionResults = usePaginatedTxResults(currentTransactionPage, transactionResultsToShow);\n\n  /** @dev handle form inputs on change */\n  const handleInputOnChange = (e: any, param: string) => {\n    setParamValues((prev: any) => ({ ...prev, [param]: e.target.value }));\n  };\n\n  /** @dev handle invoking the API to interact with smart contract and update token information */\n  const handleUpdatingTokenInfo = async (API: API_NAMES) => {\n    // destructuring param values\n    const {\n      name,\n      memo,\n      second,\n      symbol,\n      treasury,\n      feeValue,\n      maxSupply,\n      freezeStatus,\n      autoRenewPeriod,\n      tokenSupplyType,\n      autoRenewAccount,\n      hederaTokenAddress,\n    } = paramValues;\n\n    // sanitize params\n    let sanitizeErr;\n\n// --- Next chunk ---\n\n// Lines 181-310 (.tsx_part_3)\n    switch (API) {\n      case 'UPDATE_INFO':\n        sanitizeErr = handleSanitizeHederaFormInputs({\n          API: 'UpdateTokenInfo',\n          hederaTokenAddress,\n          maxSupply,\n          treasury,\n          symbol,\n          name,\n        });\n        break;\n      case 'UPDATE_EXPIRY':\n        sanitizeErr = handleSanitizeHederaFormInputs({\n          API: 'UpdateTokenExpiry',\n          second,\n          autoRenewPeriod,\n          autoRenewAccount,\n          hederaTokenAddress,\n        });\n        break;\n    }\n    // toast error if any param is invalid\n    if (sanitizeErr) {\n      CommonErrorToast({ toaster, title: 'Invalid parameters', description: sanitizeErr });\n      return;\n    }\n\n    // prepare params for manageTokenInformation() API method\n    const tokenInfo = {\n      ...DEFAULT_HEDERA_TOKEN_INFO_VALUE,\n      name,\n      symbol,\n      memo,\n      treasury,\n      maxSupply,\n      freezeStatus,\n      tokenSupplyType,\n    } as IHederaTokenServiceHederaToken;\n\n    const expiryInfo = {\n      ...DEFAULT_TOKEN_EXIPIRY_VALUE,\n      second: Number(second),\n      autoRenewAccount,\n      autoRenewPeriod,\n    } as IHederaTokenServiceExpiry;\n\n    // turn is loading on\n    setIsLoading(true);\n\n    // invoke method APIS\n    const { result, transactionHash, err } = await manageTokenInfomation(\n      baseContract,\n      signerAddress,\n      HEDERA_NETWORK,\n      APIMethods,\n      hederaTokenAddress,\n      Number(feeValue),\n      tokenInfo,\n      expiryInfo,\n      keys\n    );\n\n    // turn is loading on\n    setIsLoading(false);\n\n    // handle err\n    if (err || !result) {\n      handleAPIErrors({\n        err,\n        toaster,\n        transactionHash,\n        setTransactionResults,\n        transactionResultStorageKey,\n        tokenAddress: hederaTokenAddress,\n        transactionType: transactionTypeMap[APIMethods],\n        sessionedContractAddress: currentContractAddress,\n      });\n      return;\n    } else {\n      // handle succesfull\n      setTransactionResults((prev) => [\n        ...prev,\n        {\n          status: 'success',\n          transactionResultStorageKey,\n          tokenAddress: hederaTokenAddress,\n          transactionTimeStamp: Date.now(),\n          txHash: transactionHash as string,\n          transactionType: transactionTypeMap[APIMethods],\n          sessionedContractAddress: currentContractAddress,\n        },\n      ]);\n\n      setIsSuccessful(true);\n    }\n  };\n\n  /** @dev listen to change event on transactionResults state => load to localStorage  */\n  useUpdateTransactionResultsToLocalStorage(transactionResults, transactionResultStorageKey);\n\n  /** @dev toast successful */\n  useToastSuccessful({\n    toaster,\n    setKeys,\n    isSuccessful,\n    setParamValues,\n    setIsSuccessful,\n    initialKeyValues,\n    transactionResults,\n    setCurrentTransactionPage,\n    resetParamValues: initialParamValues,\n    toastTitle: 'Token update successful',\n  });\n\n  return (\n    <div className=\"w-full mx-3 flex justify-center mt-6 flex-col gap-20\">\n      {/* Update token form */}\n      <div className=\"flex flex-col gap-6 justify-center tracking-tight text-white/70\">\n        {/* notice component */}\n        <p className=\"text-sm whitespace-normal -mb-4\">\n          <span className=\"italic font-bold\">*important:</span> Should you choose not to update certain\n          fields, kindly populate the token&apos;s current values.\n        </p>\n\n        {/* API methods */}\n        <div className=\"w-full flex gap-3\">\n          {APIButtonTitles.map((APIButton) => {\n            return (\n              <div key={APIButton.API} className=\"w-full\">\n                <SharedFormButton",
            "totalTokens": 2500,
            "chunks": [
              {
                "originalText": "// SPDX-License-Identifier: Apache-2.0\n\nimport Cookies from 'js-cookie';\nimport { Contract } from 'ethers';\nimport TokenInfoForm from './TokenInfoForm';\nimport { useToast } from '@chakra-ui/react';\nimport TokenExpiryForm from './TokenExpiryForm';\nimport { useState, useMemo, useEffect } from 'react';\nimport { CommonErrorToast } from '@/components/toast/CommonToast';\nimport { ITransactionResult } from '@/types/contract-interactions/shared';\nimport { handleAPIErrors } from '../../../../../common/methods/handleAPIErrors';\nimport { useToastSuccessful } from '../../../../../../hooks/useToastSuccessful';\nimport { usePaginatedTxResults } from '../../../../../../hooks/usePaginatedTxResults';\nimport { SharedSigningKeysComponent } from '../../../shared/components/SigningKeysForm';\nimport { TransactionResultTable } from '../../../../../common/components/TransactionResultTable';\nimport { HederaTokenKeyTypes, TRANSACTION_PAGE_SIZE } from '../../../shared/states/commonStates';\nimport { manageTokenInfomation } from '@/api/hedera/hts-interactions/tokenManagement-interactions';\nimport { handleSanitizeHederaFormInputs } from '../../../../../common/methods/handleSanitizeFormInputs';\nimport { useUpdateTransactionResultsToLocalStorage } from '../../../../../../hooks/useUpdateLocalStorage';\nimport useFilterTransactionsByContractAddress from '../../../../../../hooks/useFilterTransactionsByContractAddress';\nimport { handleRetrievingTransactionResultsFromLocalStorage } from '../../../../../common/methods/handleRetrievingTransactionResultsFromLocalStorage';\nimport {\n  CONTRACT_NAMES,\n  HEDERA_COMMON_TRANSACTION_TYPE,\n  HEDERA_TRANSACTION_RESULT_STORAGE_KEYS,\n} from '@/utils/common/constants';\nimport {\n  DEFAULT_TOKEN_EXIPIRY_VALUE,\n  htsUpdateTokenInfoParamFields,\n  DEFAULT_HEDERA_TOKEN_INFO_VALUE,\n} from '@/utils/contract-interactions/HTS/token-management/constant';\nimport {\n  SharedFormButton,\n  SharedFormInputField,\n  SharedExecuteButtonWithFee,\n} from '../../../shared/components/ParamInputForm';\n\ninterface PageProps {\n  baseContract: Contract;\n}\n\ntype API_NAMES = 'UPDATE_INFO' | 'UPDATE_EXPIRY' | 'UPDATE_KEYS';\n\nconst ManageTokenInfo = ({ baseContract }: PageProps) => {\n  // general states\n  const toaster = useToast();\n  const [isLoading, setIsLoading] = useState(false);\n  const [isSuccessful, setIsSuccessful] = useState(false);\n  const HEDERA_NETWORK = JSON.parse(Cookies.get('_network') as string);\n  const [APIMethods, setAPIMethods] = useState<API_NAMES>('UPDATE_INFO');\n  const [currentTransactionPage, setCurrentTransactionPage] = useState(1);\n  const signerAddress = JSON.parse(Cookies.get('_connectedAccounts') as string)[0];\n  const currentContractAddress = Cookies.get(CONTRACT_NAMES.TOKEN_MANAGE) as string;\n  const [transactionResults, setTransactionResults] = useState<ITransactionResult[]>([]);\n  const transactionResultStorageKey = HEDERA_TRANSACTION_RESULT_STORAGE_KEYS['TOKEN-MANAGE']['TOKEN-INFO'];\n  const APIButtonTitles: { API: API_NAMES; apiSwitchTitle: string; executeTitle: string }[] = [\n    {\n      API: 'UPDATE_INFO',\n      apiSwitchTitle: 'General Information',\n      executeTitle: 'Update Token Information',\n    },\n    { API: 'UPDATE_EXPIRY', apiSwitchTitle: 'Token Exipry', executeTitle: 'Update Token Expiry' },\n    { API: 'UPDATE_KEYS', apiSwitchTitle: 'Token Keys', executeTitle: 'Update Token Keys' },\n  ];\n\n  const tokenInfoFields = useMemo(() => {\n    switch (APIMethods) {\n      case 'UPDATE_INFO':\n        return [\n          ['name', 'symbol', 'memo'],",
                "codeOnlyTokens": 804,
                "startLine": 1,
                "endLine": 70,
                "type": ".tsx_part_1",
                "isOversized": false
              },
              {
                "originalText": "          ['treasury', 'maxSupply'],\n        ];\n      case 'UPDATE_EXPIRY':\n        return ['second', 'autoRenewAccount', 'autoRenewPeriod'];\n    }\n  }, [APIMethods]);\n\n  const initialParamValues = {\n    name: '',\n    memo: '',\n    second: '',\n    symbol: '',\n    treasury: '',\n    feeValue: '',\n    maxSupply: '',\n    freezeStatus: false,\n    autoRenewPeriod: '',\n    autoRenewAccount: '',\n    tokenSupplyType: false,\n    hederaTokenAddress: '',\n  };\n  const [paramValues, setParamValues] = useState<any>(initialParamValues);\n\n  const transactionResultsToShow = useFilterTransactionsByContractAddress(\n    transactionResults,\n    currentContractAddress\n  );\n\n  const HederaTokenKeyValueType: IHederaTokenServiceKeyValueType[] = [\n    'inheritAccountKey',\n    'contractId',\n    'ed25519',\n    'ECDSA_secp256k1',\n    'delegatableContractId',\n  ];\n\n  const keyTypeArrays = [\n    'ADMIN',\n    'KYC',\n    'FREEZE',\n    'WIPE',\n    'SUPPLY',\n    'FEE',\n    'PAUSE',\n  ] as IHederaTokenServiceKeyType[];\n\n  const transactionTypeMap = {\n    UPDATE_INFO: HEDERA_COMMON_TRANSACTION_TYPE.HTS_FREEZE_TOKEN,\n    UPDATE_EXPIRY: HEDERA_COMMON_TRANSACTION_TYPE.HTS_REVOKE_KYC,\n    UPDATE_KEYS: HEDERA_COMMON_TRANSACTION_TYPE.HTS_UNFREEZE_TOKEN,\n  };\n\n  const initialKeyValues = keyTypeArrays.map((keyType) => ({\n    keyType: keyType,\n    keyValueType: 'inheritAccountKey',\n    keyValue: '',\n  })) as ICommonKeyObject[];\n\n  // Keys states\n  const [keys, setKeys] = useState<ICommonKeyObject[]>([]); // keeps track of keys array to pass to the API\n  const [chosenKeys, setChosenKeys] = useState(new Set<IHederaTokenServiceKeyType>()); // keeps track of keyTypes which have already been chosen in the list\n  const [keyTypesToShow, setKeyTypesToShow] = useState(new Set(HederaTokenKeyTypes)); // keeps track of the left over keyTypes to show in the drop down\n\n  useEffect(() => {\n    setKeys((prev) =>\n      prev.map((key) => {\n        key.keyValueType = 'inheritAccountKey';\n        return key;\n      })\n    );\n  }, [APIMethods]);\n\n  /** @dev retrieve token creation results from localStorage to maintain data on re-renders */\n  useEffect(() => {\n    handleRetrievingTransactionResultsFromLocalStorage(\n      toaster,\n      transactionResultStorageKey,\n      setCurrentTransactionPage,\n      setTransactionResults\n    );\n  }, [toaster, transactionResultStorageKey]);\n\n  // declare a paginatedTransactionResults\n  const paginatedTransactionResults = usePaginatedTxResults(currentTransactionPage, transactionResultsToShow);\n\n  /** @dev handle form inputs on change */\n  const handleInputOnChange = (e: any, param: string) => {\n    setParamValues((prev: any) => ({ ...prev, [param]: e.target.value }));\n  };\n\n  /** @dev handle invoking the API to interact with smart contract and update token information */\n  const handleUpdatingTokenInfo = async (API: API_NAMES) => {\n    // destructuring param values\n    const {\n      name,\n      memo,\n      second,\n      symbol,\n      treasury,\n      feeValue,\n      maxSupply,\n      freezeStatus,\n      autoRenewPeriod,\n      tokenSupplyType,\n      autoRenewAccount,\n      hederaTokenAddress,\n    } = paramValues;\n\n    // sanitize params\n    let sanitizeErr;",
                "codeOnlyTokens": 800,
                "startLine": 71,
                "endLine": 180,
                "type": ".tsx_part_2",
                "isOversized": false
              },
              {
                "originalText": "    switch (API) {\n      case 'UPDATE_INFO':\n        sanitizeErr = handleSanitizeHederaFormInputs({\n          API: 'UpdateTokenInfo',\n          hederaTokenAddress,\n          maxSupply,\n          treasury,\n          symbol,\n          name,\n        });\n        break;\n      case 'UPDATE_EXPIRY':\n        sanitizeErr = handleSanitizeHederaFormInputs({\n          API: 'UpdateTokenExpiry',\n          second,\n          autoRenewPeriod,\n          autoRenewAccount,\n          hederaTokenAddress,\n        });\n        break;\n    }\n    // toast error if any param is invalid\n    if (sanitizeErr) {\n      CommonErrorToast({ toaster, title: 'Invalid parameters', description: sanitizeErr });\n      return;\n    }\n\n    // prepare params for manageTokenInformation() API method\n    const tokenInfo = {\n      ...DEFAULT_HEDERA_TOKEN_INFO_VALUE,\n      name,\n      symbol,\n      memo,\n      treasury,\n      maxSupply,\n      freezeStatus,\n      tokenSupplyType,\n    } as IHederaTokenServiceHederaToken;\n\n    const expiryInfo = {\n      ...DEFAULT_TOKEN_EXIPIRY_VALUE,\n      second: Number(second),\n      autoRenewAccount,\n      autoRenewPeriod,\n    } as IHederaTokenServiceExpiry;\n\n    // turn is loading on\n    setIsLoading(true);\n\n    // invoke method APIS\n    const { result, transactionHash, err } = await manageTokenInfomation(\n      baseContract,\n      signerAddress,\n      HEDERA_NETWORK,\n      APIMethods,\n      hederaTokenAddress,\n      Number(feeValue),\n      tokenInfo,\n      expiryInfo,\n      keys\n    );\n\n    // turn is loading on\n    setIsLoading(false);\n\n    // handle err\n    if (err || !result) {\n      handleAPIErrors({\n        err,\n        toaster,\n        transactionHash,\n        setTransactionResults,\n        transactionResultStorageKey,\n        tokenAddress: hederaTokenAddress,\n        transactionType: transactionTypeMap[APIMethods],\n        sessionedContractAddress: currentContractAddress,\n      });\n      return;\n    } else {\n      // handle succesfull\n      setTransactionResults((prev) => [\n        ...prev,\n        {\n          status: 'success',\n          transactionResultStorageKey,\n          tokenAddress: hederaTokenAddress,\n          transactionTimeStamp: Date.now(),\n          txHash: transactionHash as string,\n          transactionType: transactionTypeMap[APIMethods],\n          sessionedContractAddress: currentContractAddress,\n        },\n      ]);\n\n      setIsSuccessful(true);\n    }\n  };\n\n  /** @dev listen to change event on transactionResults state => load to localStorage  */\n  useUpdateTransactionResultsToLocalStorage(transactionResults, transactionResultStorageKey);\n\n  /** @dev toast successful */\n  useToastSuccessful({\n    toaster,\n    setKeys,\n    isSuccessful,\n    setParamValues,\n    setIsSuccessful,\n    initialKeyValues,\n    transactionResults,\n    setCurrentTransactionPage,\n    resetParamValues: initialParamValues,\n    toastTitle: 'Token update successful',\n  });\n\n  return (\n    <div className=\"w-full mx-3 flex justify-center mt-6 flex-col gap-20\">\n      {/* Update token form */}\n      <div className=\"flex flex-col gap-6 justify-center tracking-tight text-white/70\">\n        {/* notice component */}\n        <p className=\"text-sm whitespace-normal -mb-4\">\n          <span className=\"italic font-bold\">*important:</span> Should you choose not to update certain\n          fields, kindly populate the token&apos;s current values.\n        </p>\n\n        {/* API methods */}\n        <div className=\"w-full flex gap-3\">\n          {APIButtonTitles.map((APIButton) => {\n            return (\n              <div key={APIButton.API} className=\"w-full\">\n                <SharedFormButton",
                "codeOnlyTokens": 802,
                "startLine": 181,
                "endLine": 310,
                "type": ".tsx_part_3",
                "isOversized": false
              }
            ],
            "startLine": 1,
            "endLine": 310,
            "groupId": 1
          },
          {
            "combinedText": "// File: system-contract-dapp-playground/src/components/contract-interaction/hts/token-management-contract/methods/manageTokenInfo/index.tsx\n// Relevant file context:\n// Type: .tsx\n\n\n// --- Next chunk ---\n\n// Lines 311-411 (.tsx_part_4)\n                  switcher={APIMethods === APIButton.API}\n                  buttonTitle={APIButton.apiSwitchTitle}\n                  handleButtonOnClick={() => setAPIMethods(APIButton.API)}\n                  explanation={''}\n                />\n              </div>\n            );\n          })}\n        </div>\n\n        {/* Hedera token address */}\n        <SharedFormInputField\n          param={'hederaTokenAddress'}\n          handleInputOnChange={handleInputOnChange}\n          paramValue={paramValues['hederaTokenAddress']}\n          paramKey={(htsUpdateTokenInfoParamFields as any)['hederaTokenAddress'].paramKey}\n          paramType={(htsUpdateTokenInfoParamFields as any)['hederaTokenAddress'].inputType}\n          paramSize={(htsUpdateTokenInfoParamFields as any)['hederaTokenAddress'].inputSize}\n          explanation={(htsUpdateTokenInfoParamFields as any)['hederaTokenAddress'].explanation}\n          paramClassName={(htsUpdateTokenInfoParamFields as any)['hederaTokenAddress'].inputClassname}\n          paramPlaceholder={(htsUpdateTokenInfoParamFields as any)['hederaTokenAddress'].inputPlaceholder}\n          paramFocusColor={(htsUpdateTokenInfoParamFields as any)['hederaTokenAddress'].inputFocusBorderColor}\n        />\n\n        {/* UPDATE_INFO form */}\n        {APIMethods === 'UPDATE_INFO' && (\n          <TokenInfoForm\n            paramValues={paramValues}\n            setParamValues={setParamValues}\n            handleInputOnChange={handleInputOnChange}\n            tokenInfoFields={tokenInfoFields as string[][]}\n          />\n        )}\n\n        {/* UPDATE_EXPIRY form */}\n        {APIMethods === 'UPDATE_EXPIRY' && (\n          <TokenExpiryForm\n            paramValues={paramValues}\n            handleInputOnChange={handleInputOnChange}\n            tokenInfoFields={tokenInfoFields as string[]}\n          />\n        )}\n\n        {/* UPDATE_KEYS form */}\n        {APIMethods === 'UPDATE_KEYS' && (\n          <>\n            {/* keys */}\n            <SharedSigningKeysComponent\n              keys={keys}\n              setKeys={setKeys}\n              chosenKeys={chosenKeys}\n              setChosenKeys={setChosenKeys}\n              keyTypesToShow={keyTypesToShow}\n              setKeyTypesToShow={setKeyTypesToShow}\n              HederaTokenKeyTypes={HederaTokenKeyTypes}\n              buttonTitle=\"Add desired signing keys to update\"\n              HederaTokenKeyValueType={HederaTokenKeyValueType}\n            />\n          </>\n        )}\n\n        {/* Execute buttons */}\n        {APIButtonTitles.map((APIButton) => {\n          if (APIMethods === APIButton.API) {\n            return (\n              <div key={APIButton.API} className=\"w-full\">\n                <SharedExecuteButtonWithFee\n                  isLoading={isLoading}\n                  feeType={'GAS'}\n                  paramValues={paramValues.feeValue}\n                  placeHolder={'Gas limit...'}\n                  executeBtnTitle={APIButton.executeTitle}\n                  handleInputOnChange={handleInputOnChange}\n                  explanation={'Optional gas limit for the transaction.'}\n                  handleInvokingAPIMethod={() => handleUpdatingTokenInfo(APIButton.API)}\n                />\n              </div>\n            );\n          }\n        })}\n      </div>\n\n      {/* transaction results table */}\n      {transactionResultsToShow.length > 0 && (\n        <TransactionResultTable\n          API=\"TokenCreate\"\n          hederaNetwork={HEDERA_NETWORK}\n          transactionResults={transactionResults}\n          TRANSACTION_PAGE_SIZE={TRANSACTION_PAGE_SIZE}\n          setTransactionResults={setTransactionResults}\n          currentTransactionPage={currentTransactionPage}\n          setCurrentTransactionPage={setCurrentTransactionPage}\n          transactionResultStorageKey={transactionResultStorageKey}\n          paginatedTransactionResults={paginatedTransactionResults}\n        />\n      )}\n    </div>\n  );\n};\n\nexport default ManageTokenInfo;\n\n// --- Next chunk ---\n\n// Lines 412-412 (.tsx_part_5)\n",
            "totalTokens": 880,
            "chunks": [
              {
                "originalText": "                  switcher={APIMethods === APIButton.API}\n                  buttonTitle={APIButton.apiSwitchTitle}\n                  handleButtonOnClick={() => setAPIMethods(APIButton.API)}\n                  explanation={''}\n                />\n              </div>\n            );\n          })}\n        </div>\n\n        {/* Hedera token address */}\n        <SharedFormInputField\n          param={'hederaTokenAddress'}\n          handleInputOnChange={handleInputOnChange}\n          paramValue={paramValues['hederaTokenAddress']}\n          paramKey={(htsUpdateTokenInfoParamFields as any)['hederaTokenAddress'].paramKey}\n          paramType={(htsUpdateTokenInfoParamFields as any)['hederaTokenAddress'].inputType}\n          paramSize={(htsUpdateTokenInfoParamFields as any)['hederaTokenAddress'].inputSize}\n          explanation={(htsUpdateTokenInfoParamFields as any)['hederaTokenAddress'].explanation}\n          paramClassName={(htsUpdateTokenInfoParamFields as any)['hederaTokenAddress'].inputClassname}\n          paramPlaceholder={(htsUpdateTokenInfoParamFields as any)['hederaTokenAddress'].inputPlaceholder}\n          paramFocusColor={(htsUpdateTokenInfoParamFields as any)['hederaTokenAddress'].inputFocusBorderColor}\n        />\n\n        {/* UPDATE_INFO form */}\n        {APIMethods === 'UPDATE_INFO' && (\n          <TokenInfoForm\n            paramValues={paramValues}\n            setParamValues={setParamValues}\n            handleInputOnChange={handleInputOnChange}\n            tokenInfoFields={tokenInfoFields as string[][]}\n          />\n        )}\n\n        {/* UPDATE_EXPIRY form */}\n        {APIMethods === 'UPDATE_EXPIRY' && (\n          <TokenExpiryForm\n            paramValues={paramValues}\n            handleInputOnChange={handleInputOnChange}\n            tokenInfoFields={tokenInfoFields as string[]}\n          />\n        )}\n\n        {/* UPDATE_KEYS form */}\n        {APIMethods === 'UPDATE_KEYS' && (\n          <>\n            {/* keys */}\n            <SharedSigningKeysComponent\n              keys={keys}\n              setKeys={setKeys}\n              chosenKeys={chosenKeys}\n              setChosenKeys={setChosenKeys}\n              keyTypesToShow={keyTypesToShow}\n              setKeyTypesToShow={setKeyTypesToShow}\n              HederaTokenKeyTypes={HederaTokenKeyTypes}\n              buttonTitle=\"Add desired signing keys to update\"\n              HederaTokenKeyValueType={HederaTokenKeyValueType}\n            />\n          </>\n        )}\n\n        {/* Execute buttons */}\n        {APIButtonTitles.map((APIButton) => {\n          if (APIMethods === APIButton.API) {\n            return (\n              <div key={APIButton.API} className=\"w-full\">\n                <SharedExecuteButtonWithFee\n                  isLoading={isLoading}\n                  feeType={'GAS'}\n                  paramValues={paramValues.feeValue}\n                  placeHolder={'Gas limit...'}\n                  executeBtnTitle={APIButton.executeTitle}\n                  handleInputOnChange={handleInputOnChange}\n                  explanation={'Optional gas limit for the transaction.'}\n                  handleInvokingAPIMethod={() => handleUpdatingTokenInfo(APIButton.API)}\n                />\n              </div>\n            );\n          }\n        })}\n      </div>\n\n      {/* transaction results table */}\n      {transactionResultsToShow.length > 0 && (\n        <TransactionResultTable\n          API=\"TokenCreate\"\n          hederaNetwork={HEDERA_NETWORK}\n          transactionResults={transactionResults}\n          TRANSACTION_PAGE_SIZE={TRANSACTION_PAGE_SIZE}\n          setTransactionResults={setTransactionResults}\n          currentTransactionPage={currentTransactionPage}\n          setCurrentTransactionPage={setCurrentTransactionPage}\n          transactionResultStorageKey={transactionResultStorageKey}\n          paginatedTransactionResults={paginatedTransactionResults}\n        />\n      )}\n    </div>\n  );\n};\n\nexport default ManageTokenInfo;",
                "codeOnlyTokens": 804,
                "startLine": 311,
                "endLine": 411,
                "type": ".tsx_part_4",
                "isOversized": false
              },
              {
                "originalText": "",
                "codeOnlyTokens": 0,
                "startLine": 412,
                "endLine": 412,
                "type": ".tsx_part_5",
                "isOversized": false
              }
            ],
            "startLine": 311,
            "endLine": 412,
            "groupId": 2
          }
        ],
        "oversizedChunks": [],
        "sendStrategy": "multiple_groups",
        "finalTokenCount": 3380,
        "skippedContent": [],
        "contextHeader": "// File: system-contract-dapp-playground/src/components/contract-interaction/hts/token-management-contract/methods/manageTokenInfo/index.tsx\n// Relevant file context:\n// Type: .tsx\n",
        "tokenBreakdown": {
          "originalFile": 3211,
          "finalSent": 3380,
          "codeTokensInGroups": 3210,
          "fileHeaderTokensInGroups": 82,
          "shellContextTokensInGroups": 0,
          "separatorTokensInGroups": 88,
          "skippedCodeTokens": 0,
          "unprocessedOversizedTokens": 0,
          "totalSavings": -169,
          "savingsPercentage": -5.263157894736842,
          "fileHeaderCount": 2,
          "fileHeaderAvgSize": 41,
          "shellContextCount": 0,
          "shellContextAvgSize": 0,
          "separatorCount": 5,
          "separatorAvgSize": 18
        }
      }
    },
    {
      "filePath": "system-contract-dapp-playground/src/components/navbar/index.tsx",
      "totalOriginalTokens": 1263,
      "finalTokenCount": 1289,
      "impactScore": 42,
      "averageComplexity": 6,
      "averageQuality": 7,
      "usage": {
        "prompt_tokens": 1524,
        "completion_tokens": 140,
        "total_tokens": 1664
      },
      "retries": 0,
      "hadError": false,
      "scoredChunkGroups": [
        {
          "groupId": 1,
          "score": {
            "file_path": "system-contract-dapp-playground/src/components/navbar/index.tsx",
            "complexity_score": 6,
            "code_quality_score": 7,
            "maintainability_score": 8,
            "best_practices_adherence": 6,
            "positive_feedback": "Good use of hooks to manage state and effects based on navigation routes, providing a good user experience.",
            "improvement_suggestion": "Centralize state management for account information to avoid repetitive parsing of cookie data.",
            "group_summary": "This component renders a dynamic navbar that adapts based on user connection status to Hedera."
          },
          "totalTokens": 1289,
          "usage": {
            "prompt_tokens": 1524,
            "completion_tokens": 140,
            "total_tokens": 1664
          }
        }
      ],
      "chunkingDetails": {
        "filePath": "system-contract-dapp-playground/src/components/navbar/index.tsx",
        "totalFileTokens": 1263,
        "chunks": [
          {
            "originalText": "// SPDX-License-Identifier: Apache-2.0\n\n'use client';\n\nimport Link from 'next/link';\nimport Image from 'next/image';\nimport { motion } from 'framer-motion';\nimport WalletPopup from '../wallet-popup';\nimport { useToast } from '@chakra-ui/react';\nimport { useEffect, useState } from 'react';\nimport { TNetworkName } from '@/types/common';\nimport { usePathname } from 'next/navigation';\nimport { BsChevronDown } from 'react-icons/bs';\nimport { CommonErrorToast } from '../toast/CommonToast';\nimport { isProtectedRoute } from '@/utils/common/helpers';\nimport { loadAccountInfoFromCookies } from '@/api/cookies';\nimport { navVariants } from '@/libs/framer-motion/variants';\nimport { HEDERA_COMMON_WALLET_REVERT_REASONS } from '@/utils/common/constants';\n\nconst Navbar = () => {\n  // local states\n  const toaster = useToast();\n  const pathname = usePathname();\n  const [accounts, setAccounts] = useState<string[]>([]);\n  const [isConnected, setIsConnected] = useState(false);\n  const [didWalletPop, setDidWalletPop] = useState(false);\n  const [network, setNetwork] = useState<TNetworkName>('testnet');\n\n  // listen to pathname change event to retrieve account information cookies\n  useEffect(() => {\n    if (isProtectedRoute(pathname)) {\n      // retrieve account info from cookies\n      const accountsInfo = loadAccountInfoFromCookies();\n\n      // just best pratice to handle error as this would rarely happen as we have already gated all the checks in middleware.js\n      if (\n        !accountsInfo.isConnected ||\n        !accountsInfo.accounts ||\n        !accountsInfo.network ||\n        accountsInfo.error\n      ) {\n        CommonErrorToast({\n          toaster,\n          title: 'Error retrieving account information',\n          description: HEDERA_COMMON_WALLET_REVERT_REASONS.DEFAULT.description,\n        });\n        return;\n      }\n\n      // update states\n      setAccounts(JSON.parse(accountsInfo.accounts));\n      setIsConnected(JSON.parse(accountsInfo.isConnected));\n      setNetwork(JSON.parse(accountsInfo.network) as TNetworkName);\n    }\n  }, [pathname, toaster]);\n\n  return (\n    <motion.nav\n      initial={{ opacity: 0 }}\n      whileInView={{ opacity: 1 }}\n      transition={{\n        delay: 0.3,\n        duration: 0.3,\n      }}\n      viewport={{ once: true }}\n      className=\"px-6 pt-6 flex flex-col justify-between items-center z-50\"\n    >\n      {/* Protected Navbar */}\n      {isConnected ? (\n        <div className=\"grid grid-rows-2 sm:grid-rows-1 sm:grid-cols-2 lg:grid-cols-3 w-full justify-center gap-3 pb-6\">\n          {/* Logo */}\n          <Link href={'/'} className=\"flex gap-3 items-center justify-center sm:justify-start\">\n            <Image\n              src={'/brandings/hedera-logomark.svg'}\n              alt={'hedera-logomark'}\n              width={50}\n              height={50}\n              className=\"z-50\"\n            />\n            <p className=\"text-white text-[2rem]\">Hedera</p>\n          </Link>\n\n          {/* DApp playground */}\n          <div className=\"hidden lg:flex lg:gap-1 lg:items-center lg:justify-center\">\n            <div className=\"flex justify-center items-center text-hedera-green\">\n              <div className=\"rounded-r-[9px] border-hedera-green w-[52px] h-[27px] border-[5px] mt-1\" />\n              <div className=\"font-medium text-[2rem] uppercase\">App</div>\n            </div>\n\n            {/* Playground */}\n            <div className=\"uppercase text-[2rem] bg-clip-text text-white\">Playground</div>",
            "codeOnlyTokens": 818,
            "startLine": 1,
            "endLine": 91,
            "type": ".tsx_part_1",
            "isOversized": false
          },
          {
            "originalText": "          </div>\n\n          {/* wallet info */}\n          <div className=\"text-white flex justify-end\">\n            {/* wallet wrapper */}\n            <div\n              className=\"bg-gradient-to-r from-hedera-gradient-2-lime/60 to-hedera-gradient-2-teal rounded-lg flex items-center px-3 cursor-pointer\"\n              onClick={() => {\n                setDidWalletPop(true);\n              }}\n            >\n              {/* logo */}\n              <Image src={'/brandings/hedera-logomark.svg'} alt={'hedera-logomark'} width={30} height={30} />\n\n              {/* vertical bar */}\n              <div className=\"bg-white/30 w-[1px] h-full mx-3\" />\n\n              {/* address */}\n              <p className=\"text-lg font-medium\">\n                {accounts[0].slice(0, 7)}...{accounts[0].slice(-5)}\n              </p>\n\n              {/* downward arrow */}\n              <div className=\"text-xl ml-1\">\n                <BsChevronDown />\n              </div>\n            </div>\n          </div>\n        </div>\n      ) : (\n        <motion.div\n          variants={navVariants}\n          initial=\"hidden\"\n          whileInView=\"show\"\n          viewport={{ once: true }}\n          className=\"flex justify-between w-full\"\n        >\n          {/* Unprotected Navbar */}\n          <Link href={'/'}>\n            {/* Logo */}\n            <Image\n              src={'/brandings/hedera-logomark.svg'}\n              alt={'hedera-logomark'}\n              width={50}\n              height={50}\n              className=\"z-50\"\n            />\n          </Link>\n\n          {/* Text logo */}\n          <p className=\"text-white text-[2rem]\">Hedera</p>\n        </motion.div>\n      )}\n\n      {isConnected && <hr className=\"w-[99vw] border-t border-white/40\" />}\n\n      {didWalletPop && (\n        <WalletPopup network={network} userAddress={accounts[0]} setIsOpen={setDidWalletPop} />\n      )}\n    </motion.nav>\n  );\n};\n\nexport default Navbar;\n",
            "codeOnlyTokens": 445,
            "startLine": 92,
            "endLine": 156,
            "type": ".tsx_part_2",
            "isOversized": false
          }
        ],
        "groupedChunks": [
          {
            "combinedText": "// File: system-contract-dapp-playground/src/components/navbar/index.tsx\n// Relevant file context:\n// Type: .tsx\n// SPDX-License-Identifier: Apache-2.0\n\n'use client';\n\nimport Link from 'next/link';\nimport Image from 'next/image';\nimport { motion } from 'framer-motion';\nimport WalletPopup from '../wallet-popup';\nimport { useToast } from '@chakra-ui/react';\nimport { useEffect, useState } from 'react';\nimport { TNetworkName } from '@/types/common';\nimport { usePathname } from 'next/navigation';\nimport { BsChevronDown } from 'react-icons/bs';\nimport { CommonErrorToast } from '../toast/CommonToast';\nimport { isProtectedRoute } from '@/utils/common/helpers';\nimport { loadAccountInfoFromCookies } from '@/api/cookies';\nimport { navVariants } from '@/libs/framer-motion/variants';\nimport { HEDERA_COMMON_WALLET_REVERT_REASONS } from '@/utils/common/constants';\n\nconst Navbar = () => {\n  // local states\n  const toaster = useToast();\n  const pathname = usePathname();\n  const [accounts, setAccounts] = useState<string[]>([]);\n  const [isConnected, setIsConnected] = useState(false);\n  const [didWalletPop, setDidWalletPop] = useState(false);\n  const [network, setNetwork] = useState<TNetworkName>('testnet');\n\n  // listen to pathname change event to retrieve account information cookies\n  useEffect(() => {\n    if (isProtectedRoute(pathname)) {\n      // retrieve account info from cookies\n      const accountsInfo = loadAccountInfoFromCookies();\n\n      // just best pratice to handle error as this would rarely happen as we have already gated all the checks in middleware.js\n      if (\n        !accountsInfo.isConnected ||\n        !accountsInfo.accounts ||\n        !accountsInfo.network ||\n        accountsInfo.error\n      ) {\n        CommonErrorToast({\n          toaster,\n          title: 'Error retrieving account information',\n          description: HEDERA_COMMON_WALLET_REVERT_REASONS.DEFAULT.description,\n        });\n        return;\n      }\n\n      // update states\n      setAccounts(JSON.parse(accountsInfo.accounts));\n      setIsConnected(JSON.parse(accountsInfo.isConnected));\n      setNetwork(JSON.parse(accountsInfo.network) as TNetworkName);\n    }\n  }, [pathname, toaster]);\n\n  return (\n    <motion.nav\n      initial={{ opacity: 0 }}\n      whileInView={{ opacity: 1 }}\n      transition={{\n        delay: 0.3,\n        duration: 0.3,\n      }}\n      viewport={{ once: true }}\n      className=\"px-6 pt-6 flex flex-col justify-between items-center z-50\"\n    >\n      {/* Protected Navbar */}\n      {isConnected ? (\n        <div className=\"grid grid-rows-2 sm:grid-rows-1 sm:grid-cols-2 lg:grid-cols-3 w-full justify-center gap-3 pb-6\">\n          {/* Logo */}\n          <Link href={'/'} className=\"flex gap-3 items-center justify-center sm:justify-start\">\n            <Image\n              src={'/brandings/hedera-logomark.svg'}\n              alt={'hedera-logomark'}\n              width={50}\n              height={50}\n              className=\"z-50\"\n            />\n            <p className=\"text-white text-[2rem]\">Hedera</p>\n          </Link>\n\n          {/* DApp playground */}\n          <div className=\"hidden lg:flex lg:gap-1 lg:items-center lg:justify-center\">\n            <div className=\"flex justify-center items-center text-hedera-green\">\n              <div className=\"rounded-r-[9px] border-hedera-green w-[52px] h-[27px] border-[5px] mt-1\" />\n              <div className=\"font-medium text-[2rem] uppercase\">App</div>\n            </div>\n\n            {/* Playground */}\n            <div className=\"uppercase text-[2rem] bg-clip-text text-white\">Playground</div>\n          </div>\n\n          {/* wallet info */}\n          <div className=\"text-white flex justify-end\">\n            {/* wallet wrapper */}\n            <div\n              className=\"bg-gradient-to-r from-hedera-gradient-2-lime/60 to-hedera-gradient-2-teal rounded-lg flex items-center px-3 cursor-pointer\"\n              onClick={() => {\n                setDidWalletPop(true);\n              }}\n            >\n              {/* logo */}\n              <Image src={'/brandings/hedera-logomark.svg'} alt={'hedera-logomark'} width={30} height={30} />\n\n              {/* vertical bar */}\n              <div className=\"bg-white/30 w-[1px] h-full mx-3\" />\n\n              {/* address */}\n              <p className=\"text-lg font-medium\">\n                {accounts[0].slice(0, 7)}...{accounts[0].slice(-5)}\n              </p>\n\n              {/* downward arrow */}\n              <div className=\"text-xl ml-1\">\n                <BsChevronDown />\n              </div>\n            </div>\n          </div>\n        </div>\n      ) : (\n        <motion.div\n          variants={navVariants}\n          initial=\"hidden\"\n          whileInView=\"show\"\n          viewport={{ once: true }}\n          className=\"flex justify-between w-full\"\n        >\n          {/* Unprotected Navbar */}\n          <Link href={'/'}>\n            {/* Logo */}\n            <Image\n              src={'/brandings/hedera-logomark.svg'}\n              alt={'hedera-logomark'}\n              width={50}\n              height={50}\n              className=\"z-50\"\n            />\n          </Link>\n\n          {/* Text logo */}\n          <p className=\"text-white text-[2rem]\">Hedera</p>\n        </motion.div>\n      )}\n\n      {isConnected && <hr className=\"w-[99vw] border-t border-white/40\" />}\n\n      {didWalletPop && (\n        <WalletPopup network={network} userAddress={accounts[0]} setIsOpen={setDidWalletPop} />\n      )}\n    </motion.nav>\n  );\n};\n\nexport default Navbar;\n",
            "totalTokens": 1289,
            "chunks": [
              {
                "originalText": "// SPDX-License-Identifier: Apache-2.0\n\n'use client';\n\nimport Link from 'next/link';\nimport Image from 'next/image';\nimport { motion } from 'framer-motion';\nimport WalletPopup from '../wallet-popup';\nimport { useToast } from '@chakra-ui/react';\nimport { useEffect, useState } from 'react';\nimport { TNetworkName } from '@/types/common';\nimport { usePathname } from 'next/navigation';\nimport { BsChevronDown } from 'react-icons/bs';\nimport { CommonErrorToast } from '../toast/CommonToast';\nimport { isProtectedRoute } from '@/utils/common/helpers';\nimport { loadAccountInfoFromCookies } from '@/api/cookies';\nimport { navVariants } from '@/libs/framer-motion/variants';\nimport { HEDERA_COMMON_WALLET_REVERT_REASONS } from '@/utils/common/constants';\n\nconst Navbar = () => {\n  // local states\n  const toaster = useToast();\n  const pathname = usePathname();\n  const [accounts, setAccounts] = useState<string[]>([]);\n  const [isConnected, setIsConnected] = useState(false);\n  const [didWalletPop, setDidWalletPop] = useState(false);\n  const [network, setNetwork] = useState<TNetworkName>('testnet');\n\n  // listen to pathname change event to retrieve account information cookies\n  useEffect(() => {\n    if (isProtectedRoute(pathname)) {\n      // retrieve account info from cookies\n      const accountsInfo = loadAccountInfoFromCookies();\n\n      // just best pratice to handle error as this would rarely happen as we have already gated all the checks in middleware.js\n      if (\n        !accountsInfo.isConnected ||\n        !accountsInfo.accounts ||\n        !accountsInfo.network ||\n        accountsInfo.error\n      ) {\n        CommonErrorToast({\n          toaster,\n          title: 'Error retrieving account information',\n          description: HEDERA_COMMON_WALLET_REVERT_REASONS.DEFAULT.description,\n        });\n        return;\n      }\n\n      // update states\n      setAccounts(JSON.parse(accountsInfo.accounts));\n      setIsConnected(JSON.parse(accountsInfo.isConnected));\n      setNetwork(JSON.parse(accountsInfo.network) as TNetworkName);\n    }\n  }, [pathname, toaster]);\n\n  return (\n    <motion.nav\n      initial={{ opacity: 0 }}\n      whileInView={{ opacity: 1 }}\n      transition={{\n        delay: 0.3,\n        duration: 0.3,\n      }}\n      viewport={{ once: true }}\n      className=\"px-6 pt-6 flex flex-col justify-between items-center z-50\"\n    >\n      {/* Protected Navbar */}\n      {isConnected ? (\n        <div className=\"grid grid-rows-2 sm:grid-rows-1 sm:grid-cols-2 lg:grid-cols-3 w-full justify-center gap-3 pb-6\">\n          {/* Logo */}\n          <Link href={'/'} className=\"flex gap-3 items-center justify-center sm:justify-start\">\n            <Image\n              src={'/brandings/hedera-logomark.svg'}\n              alt={'hedera-logomark'}\n              width={50}\n              height={50}\n              className=\"z-50\"\n            />\n            <p className=\"text-white text-[2rem]\">Hedera</p>\n          </Link>\n\n          {/* DApp playground */}\n          <div className=\"hidden lg:flex lg:gap-1 lg:items-center lg:justify-center\">\n            <div className=\"flex justify-center items-center text-hedera-green\">\n              <div className=\"rounded-r-[9px] border-hedera-green w-[52px] h-[27px] border-[5px] mt-1\" />\n              <div className=\"font-medium text-[2rem] uppercase\">App</div>\n            </div>\n\n            {/* Playground */}\n            <div className=\"uppercase text-[2rem] bg-clip-text text-white\">Playground</div>\n          </div>\n\n          {/* wallet info */}\n          <div className=\"text-white flex justify-end\">\n            {/* wallet wrapper */}\n            <div\n              className=\"bg-gradient-to-r from-hedera-gradient-2-lime/60 to-hedera-gradient-2-teal rounded-lg flex items-center px-3 cursor-pointer\"\n              onClick={() => {\n                setDidWalletPop(true);\n              }}\n            >\n              {/* logo */}\n              <Image src={'/brandings/hedera-logomark.svg'} alt={'hedera-logomark'} width={30} height={30} />\n\n              {/* vertical bar */}\n              <div className=\"bg-white/30 w-[1px] h-full mx-3\" />\n\n              {/* address */}\n              <p className=\"text-lg font-medium\">\n                {accounts[0].slice(0, 7)}...{accounts[0].slice(-5)}\n              </p>\n\n              {/* downward arrow */}\n              <div className=\"text-xl ml-1\">\n                <BsChevronDown />\n              </div>\n            </div>\n          </div>\n        </div>\n      ) : (\n        <motion.div\n          variants={navVariants}\n          initial=\"hidden\"\n          whileInView=\"show\"\n          viewport={{ once: true }}\n          className=\"flex justify-between w-full\"\n        >\n          {/* Unprotected Navbar */}\n          <Link href={'/'}>\n            {/* Logo */}\n            <Image\n              src={'/brandings/hedera-logomark.svg'}\n              alt={'hedera-logomark'}\n              width={50}\n              height={50}\n              className=\"z-50\"\n            />\n          </Link>\n\n          {/* Text logo */}\n          <p className=\"text-white text-[2rem]\">Hedera</p>\n        </motion.div>\n      )}\n\n      {isConnected && <hr className=\"w-[99vw] border-t border-white/40\" />}\n\n      {didWalletPop && (\n        <WalletPopup network={network} userAddress={accounts[0]} setIsOpen={setDidWalletPop} />\n      )}\n    </motion.nav>\n  );\n};\n\nexport default Navbar;\n",
                "codeOnlyTokens": 1263,
                "startLine": 1,
                "endLine": 156,
                "type": "full_file",
                "isOversized": false
              }
            ],
            "startLine": 1,
            "endLine": 156,
            "groupId": 1
          }
        ],
        "oversizedChunks": [],
        "sendStrategy": "full_file",
        "finalTokenCount": 1289,
        "skippedContent": [],
        "contextHeader": "// File: system-contract-dapp-playground/src/components/navbar/index.tsx\n// Relevant file context:\n// Type: .tsx\n",
        "tokenBreakdown": {
          "originalFile": 1263,
          "finalSent": 1289,
          "codeTokensInGroups": 1263,
          "fileHeaderTokensInGroups": 26,
          "shellContextTokensInGroups": 0,
          "separatorTokensInGroups": 0,
          "skippedCodeTokens": 0,
          "unprocessedOversizedTokens": 0,
          "totalSavings": -26,
          "savingsPercentage": -2.058590657165479,
          "fileHeaderCount": 1,
          "fileHeaderAvgSize": 26,
          "shellContextCount": 0,
          "shellContextAvgSize": 0,
          "separatorCount": 1,
          "separatorAvgSize": 0
        }
      }
    },
    {
      "filePath": "contracts/system-contracts/exchange-rate/ExchangeRateSystemContract.sol",
      "totalOriginalTokens": 191,
      "finalTokenCount": 218,
      "impactScore": 40,
      "averageComplexity": 6,
      "averageQuality": 6.666666666666667,
      "usage": {
        "prompt_tokens": 309,
        "completion_tokens": 127,
        "total_tokens": 436
      },
      "retries": 0,
      "hadError": false,
      "scoredChunkGroups": [
        {
          "groupId": 1,
          "score": {
            "file_path": "contracts/system-contracts/exchange-rate/ExchangeRateSystemContract.sol",
            "complexity_score": 6,
            "code_quality_score": 7,
            "maintainability_score": 6,
            "best_practices_adherence": 7,
            "positive_feedback": "The gated access function provides a useful mechanism for cost management in contract interactions.",
            "improvement_suggestion": "Implement proper visibility for the `approxUsdValue` function to adhere to best practices.",
            "group_summary": "Contract that manages exchange rates and financial transactions in a secure manner."
          },
          "totalTokens": 218,
          "usage": {
            "prompt_tokens": 309,
            "completion_tokens": 127,
            "total_tokens": 436
          }
        }
      ],
      "chunkingDetails": {
        "filePath": "contracts/system-contracts/exchange-rate/ExchangeRateSystemContract.sol",
        "totalFileTokens": 191,
        "chunks": [
          {
            "originalText": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.5.0 <0.9.0;\n\nimport \"./SelfFunding.sol\";\n\n\ncontract ExchangeRateSystemContract is SelfFunding {\n    // The USD in cents that must be sent as msg.value\n    uint256 toll;\n\n    constructor(uint256 _toll) {\n        toll = _toll;\n    }\n\n    function gatedAccess() external payable costsCents(toll) {\n        // Hope it was worth it!\n    }\n\n    function approxUsdValue() external payable returns (uint256 tinycents) {\n        tinycents = tinybarsToTinycents(msg.value);\n    }\n\n    function invalidCall() external payable {\n        // Should fail, this is not a valid selector \n        (bool success, ) = PRECOMPILE_ADDRESS.call(\n            abi.encodeWithSelector(ExchangeRateSystemContract.approxUsdValue.selector));\n        require(success);\n    }\n}\n",
            "codeOnlyTokens": 191,
            "startLine": 1,
            "endLine": 30,
            "type": ".sol",
            "isOversized": false
          }
        ],
        "groupedChunks": [
          {
            "combinedText": "// File: contracts/system-contracts/exchange-rate/ExchangeRateSystemContract.sol\n// Relevant file context:\n// Type: .sol\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.5.0 <0.9.0;\n\nimport \"./SelfFunding.sol\";\n\n\ncontract ExchangeRateSystemContract is SelfFunding {\n    // The USD in cents that must be sent as msg.value\n    uint256 toll;\n\n    constructor(uint256 _toll) {\n        toll = _toll;\n    }\n\n    function gatedAccess() external payable costsCents(toll) {\n        // Hope it was worth it!\n    }\n\n    function approxUsdValue() external payable returns (uint256 tinycents) {\n        tinycents = tinybarsToTinycents(msg.value);\n    }\n\n    function invalidCall() external payable {\n        // Should fail, this is not a valid selector \n        (bool success, ) = PRECOMPILE_ADDRESS.call(\n            abi.encodeWithSelector(ExchangeRateSystemContract.approxUsdValue.selector));\n        require(success);\n    }\n}\n",
            "totalTokens": 218,
            "chunks": [
              {
                "originalText": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.5.0 <0.9.0;\n\nimport \"./SelfFunding.sol\";\n\n\ncontract ExchangeRateSystemContract is SelfFunding {\n    // The USD in cents that must be sent as msg.value\n    uint256 toll;\n\n    constructor(uint256 _toll) {\n        toll = _toll;\n    }\n\n    function gatedAccess() external payable costsCents(toll) {\n        // Hope it was worth it!\n    }\n\n    function approxUsdValue() external payable returns (uint256 tinycents) {\n        tinycents = tinybarsToTinycents(msg.value);\n    }\n\n    function invalidCall() external payable {\n        // Should fail, this is not a valid selector \n        (bool success, ) = PRECOMPILE_ADDRESS.call(\n            abi.encodeWithSelector(ExchangeRateSystemContract.approxUsdValue.selector));\n        require(success);\n    }\n}\n",
                "codeOnlyTokens": 191,
                "startLine": 1,
                "endLine": 30,
                "type": "full_file",
                "isOversized": false
              }
            ],
            "startLine": 1,
            "endLine": 30,
            "groupId": 1
          }
        ],
        "oversizedChunks": [],
        "sendStrategy": "full_file",
        "finalTokenCount": 218,
        "skippedContent": [],
        "contextHeader": "// File: contracts/system-contracts/exchange-rate/ExchangeRateSystemContract.sol\n// Relevant file context:\n// Type: .sol\n",
        "tokenBreakdown": {
          "originalFile": 191,
          "finalSent": 218,
          "codeTokensInGroups": 191,
          "fileHeaderTokensInGroups": 27,
          "shellContextTokensInGroups": 0,
          "separatorTokensInGroups": 0,
          "skippedCodeTokens": 0,
          "unprocessedOversizedTokens": 0,
          "totalSavings": -27,
          "savingsPercentage": -14.136125654450263,
          "fileHeaderCount": 1,
          "fileHeaderAvgSize": 27,
          "shellContextCount": 0,
          "shellContextAvgSize": 0,
          "separatorCount": 1,
          "separatorAvgSize": 0
        }
      }
    },
    {
      "filePath": "system-contract-dapp-playground/src/app/layout.tsx",
      "totalOriginalTokens": 195,
      "finalTokenCount": 220,
      "impactScore": 36,
      "averageComplexity": 4,
      "averageQuality": 9,
      "usage": {
        "prompt_tokens": 312,
        "completion_tokens": 127,
        "total_tokens": 439
      },
      "retries": 0,
      "hadError": false,
      "scoredChunkGroups": [
        {
          "groupId": 1,
          "score": {
            "file_path": "system-contract-dapp-playground/src/app/layout.tsx",
            "complexity_score": 4,
            "code_quality_score": 9,
            "maintainability_score": 9,
            "best_practices_adherence": 9,
            "positive_feedback": "Utilizing Chakra UI for layout management results in clean and responsive design.",
            "improvement_suggestion": "Ensure metadata is fetched asynchronously to improve performance.",
            "group_summary": "Root layout component that wraps application content with styling and providers."
          },
          "totalTokens": 220,
          "usage": {
            "prompt_tokens": 312,
            "completion_tokens": 127,
            "total_tokens": 439
          }
        }
      ],
      "chunkingDetails": {
        "filePath": "system-contract-dapp-playground/src/app/layout.tsx",
        "totalFileTokens": 195,
        "chunks": [
          {
            "originalText": "// SPDX-License-Identifier: Apache-2.0\n\nimport '@/styles/globals.css';\nimport StyreneAWebFont from '@/fonts';\nimport dappMetadata from '@/utils/common/metadata';\nimport ChakraUIProviders from '@/libs/chakra/provider';\nimport BgGradient from '@/components/background-gradients';\n\n/** @notice Root Layout */\nexport default function RootLayout({ children }: { children: React.ReactNode }) {\n  return (\n    <html lang=\"en\" className={`${StyreneAWebFont.variable}`}>\n      <body className=\"bg-primary font-styrene\">\n        <ChakraUIProviders>\n          <div className=\"relative 2xl:max-w-[100rem] 2xl:mx-auto\">\n            {children}\n            <BgGradient />\n          </div>\n        </ChakraUIProviders>\n      </body>\n    </html>\n  );\n}\n\n/** @notice export metadata for SEO */\nexport const metadata = dappMetadata;\n",
            "codeOnlyTokens": 195,
            "startLine": 1,
            "endLine": 27,
            "type": ".tsx",
            "isOversized": false
          }
        ],
        "groupedChunks": [
          {
            "combinedText": "// File: system-contract-dapp-playground/src/app/layout.tsx\n// Relevant file context:\n// Type: .tsx\n// SPDX-License-Identifier: Apache-2.0\n\nimport '@/styles/globals.css';\nimport StyreneAWebFont from '@/fonts';\nimport dappMetadata from '@/utils/common/metadata';\nimport ChakraUIProviders from '@/libs/chakra/provider';\nimport BgGradient from '@/components/background-gradients';\n\n/** @notice Root Layout */\nexport default function RootLayout({ children }: { children: React.ReactNode }) {\n  return (\n    <html lang=\"en\" className={`${StyreneAWebFont.variable}`}>\n      <body className=\"bg-primary font-styrene\">\n        <ChakraUIProviders>\n          <div className=\"relative 2xl:max-w-[100rem] 2xl:mx-auto\">\n            {children}\n            <BgGradient />\n          </div>\n        </ChakraUIProviders>\n      </body>\n    </html>\n  );\n}\n\n/** @notice export metadata for SEO */\nexport const metadata = dappMetadata;\n",
            "totalTokens": 220,
            "chunks": [
              {
                "originalText": "// SPDX-License-Identifier: Apache-2.0\n\nimport '@/styles/globals.css';\nimport StyreneAWebFont from '@/fonts';\nimport dappMetadata from '@/utils/common/metadata';\nimport ChakraUIProviders from '@/libs/chakra/provider';\nimport BgGradient from '@/components/background-gradients';\n\n/** @notice Root Layout */\nexport default function RootLayout({ children }: { children: React.ReactNode }) {\n  return (\n    <html lang=\"en\" className={`${StyreneAWebFont.variable}`}>\n      <body className=\"bg-primary font-styrene\">\n        <ChakraUIProviders>\n          <div className=\"relative 2xl:max-w-[100rem] 2xl:mx-auto\">\n            {children}\n            <BgGradient />\n          </div>\n        </ChakraUIProviders>\n      </body>\n    </html>\n  );\n}\n\n/** @notice export metadata for SEO */\nexport const metadata = dappMetadata;\n",
                "codeOnlyTokens": 195,
                "startLine": 1,
                "endLine": 27,
                "type": "full_file",
                "isOversized": false
              }
            ],
            "startLine": 1,
            "endLine": 27,
            "groupId": 1
          }
        ],
        "oversizedChunks": [],
        "sendStrategy": "full_file",
        "finalTokenCount": 220,
        "skippedContent": [],
        "contextHeader": "// File: system-contract-dapp-playground/src/app/layout.tsx\n// Relevant file context:\n// Type: .tsx\n",
        "tokenBreakdown": {
          "originalFile": 195,
          "finalSent": 220,
          "codeTokensInGroups": 195,
          "fileHeaderTokensInGroups": 25,
          "shellContextTokensInGroups": 0,
          "separatorTokensInGroups": 0,
          "skippedCodeTokens": 0,
          "unprocessedOversizedTokens": 0,
          "totalSavings": -25,
          "savingsPercentage": -12.82051282051282,
          "fileHeaderCount": 1,
          "fileHeaderAvgSize": 25,
          "shellContextCount": 0,
          "shellContextAvgSize": 0,
          "separatorCount": 1,
          "separatorAvgSize": 0
        }
      }
    },
    {
      "filePath": "system-contract-dapp-playground/src/api/hedera/erc20-interactions/index.ts",
      "totalOriginalTokens": 1966,
      "finalTokenCount": 1998,
      "impactScore": 33.333333333333336,
      "averageComplexity": 5,
      "averageQuality": 6.666666666666667,
      "usage": {
        "prompt_tokens": 2362,
        "completion_tokens": 140,
        "total_tokens": 2502
      },
      "retries": 0,
      "hadError": false,
      "scoredChunkGroups": [
        {
          "groupId": 1,
          "score": {
            "file_path": "system-contract-dapp-playground/src/api/hedera/erc20-interactions/index.ts",
            "complexity_score": 5,
            "code_quality_score": 7,
            "maintainability_score": 6,
            "best_practices_adherence": 7,
            "positive_feedback": "The use of utility functions for estimating gas limits is a smart design that enhances flexibility.",
            "improvement_suggestion": "Error handling could be improved by providing more informative error messages instead of just logging.",
            "group_summary": "This file handles ERC20 token interactions such as minting and retrieving token information."
          },
          "totalTokens": 1998,
          "usage": {
            "prompt_tokens": 2362,
            "completion_tokens": 140,
            "total_tokens": 2502
          }
        }
      ],
      "chunkingDetails": {
        "filePath": "system-contract-dapp-playground/src/api/hedera/erc20-interactions/index.ts",
        "totalFileTokens": 1966,
        "chunks": [
          {
            "originalText": "// SPDX-License-Identifier: Apache-2.0\n\nimport { TNetworkName } from '@/types/common';\nimport { Contract, ethers, isAddress } from 'ethers';\nimport { handleEstimateGas } from '@/utils/common/helpers';\n\n/**\n * @dev get token information\n *\n * @notice execute name(), symbol(), totalSupply(), decimals()\n *\n * @param baseContract: Contract\n *\n * @param method: 'name' | 'symbol' | 'totalSupply' | 'decimals'\n *\n * @return Promise<IERCSmartContractResult>\n */\nexport const getERC20TokenInformation = async (\n  baseContract: Contract,\n  method: 'name' | 'symbol' | 'totalSupply' | 'decimals'\n): Promise<IERCSmartContractResult> => {\n  try {\n    switch (method) {\n      case 'name':\n        return { name: await baseContract.name() };\n      case 'symbol':\n        return { symbol: await baseContract.symbol() };\n      case 'totalSupply':\n        return { totalSupply: (await baseContract.totalSupply()).toString() };\n      case 'decimals':\n        return { decimals: (await baseContract.decimals()).toString() };\n    }\n  } catch (err) {\n    console.error(err);\n    return { err };\n  }\n};\n\n/**\n * @dev mints erc20 tokens\n *\n * @param baseContract: ethers.Contract\n *\n * @param signerAddress: ethers.AddressLike\n *\n * @param network: TNetworkName\n *\n * @param recipientAddress: ethers.AddressLike\n *\n * @param tokenAmount: number\n *\n * @param gasLimit: number\n *\n * @return Promise<IERCSmartContractResult>\n */\nexport const erc20Mint = async (\n  baseContract: Contract,\n  signerAddress: ethers.AddressLike,\n  network: TNetworkName,\n  recipientAddress: ethers.AddressLike,\n  tokenAmount: number,\n  gasLimit: number\n): Promise<IERCSmartContractResult> => {\n  if (!isAddress(recipientAddress)) {\n    return { err: 'Invalid recipient address' };\n  } else if (tokenAmount <= 0) {\n    return { err: 'Invalid token amount' };\n  }\n\n  try {\n    if (gasLimit === 0) {\n      const estimateGasResult = await handleEstimateGas(baseContract, signerAddress, network, 'mint', [\n        recipientAddress,\n        tokenAmount,\n      ]);\n      if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n      gasLimit = estimateGasResult.gasLimit;\n    }\n\n    const txReceipt = await (await baseContract.mint(recipientAddress, tokenAmount, { gasLimit })).wait();\n    return { mintRes: true, txHash: txReceipt.hash };\n  } catch (err) {\n    console.error(err);\n    return { err };\n  }\n};\n\n/**\n * @dev get token balance owned by `accountAddress`\n *\n * @param baseContract: Contract\n *\n * @param accountAddress: ethers.AddressLike\n *\n * @return Promise<IERCSmartContractResult>\n */\nexport const balanceOf = async (\n  baseContract: Contract,\n  accountAddress: ethers.AddressLike\n): Promise<IERCSmartContractResult> => {\n  if (!isAddress(accountAddress)) {\n    return { err: 'Invalid account address' };\n  }\n\n  try {\n    return { balanceOfRes: (await baseContract.balanceOf(accountAddress)).toString() };\n  } catch (err) {\n    console.error(err);\n    return { err };\n  }\n};\n\n/**\n * @dev handle executing APIs relate  to Token Permissions\n *\n * @dev approve() sets `amount` as the allowance of `spenderAddress` over the caller's tokens\n *\n * @dev increaseAllowance() atomically increases the allowance granted to spender by the caller.",
            "codeOnlyTokens": 801,
            "startLine": 1,
            "endLine": 118,
            "type": ".ts_part_1",
            "isOversized": false
          },
          {
            "originalText": " *\n * @dev decreaseAllowance() atomically decreases the allowance granted to spender by the caller.\n *\n * @dev allowance() returns the remaining number of tokens that `spenerAddress` will be allowed to spend on behalf of `ownerAddress`\n *\n * @param baseContract: ethers.Contract\n *\n * @param signerAddress: ethers.AddressLike\n *\n * @param network: TNetworkName\n *\n * @param method: 'approve' | 'allowance' | 'increaseAllowance' | 'decreaseAllowance'\n *\n * @param gasLimit: number\n *\n * @param spenderAddress?: ethers.AddressLike\n *\n * @param owner?: ethers.AddressLike\n *\n * @param amount?: number\n *\n * @return Promise<IERCSmartContractResult>\n */\nexport const handleErc20TokenPermissions = async (\n  baseContract: Contract,\n  signerAddress: ethers.AddressLike,\n  network: TNetworkName,\n  method: 'approve' | 'allowance' | 'increaseAllowance' | 'decreaseAllowance',\n  spenderAddress: ethers.AddressLike,\n  gasLimit: number,\n  ownerAddress?: ethers.AddressLike,\n  amount?: number\n): Promise<IERCSmartContractResult> => {\n  // sanitize params\n  if (ownerAddress && !isAddress(ownerAddress)) {\n    return { err: 'Invalid owner address' };\n  } else if (spenderAddress && !isAddress(spenderAddress)) {\n    return { err: 'Invalid spender address' };\n  }\n\n  // prepare function arguments\n  const args = method === 'allowance' ? [ownerAddress, spenderAddress] : [spenderAddress, amount];\n\n  if (gasLimit === 0) {\n    const estimateGasResult = await handleEstimateGas(baseContract, signerAddress, network, method, args);\n    if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n    gasLimit = estimateGasResult.gasLimit;\n  }\n\n  // executing logic\n  try {\n    switch (method) {\n      case 'approve':\n        const approveReceipt = await (\n          await baseContract.approve(spenderAddress, amount, { gasLimit })\n        ).wait();\n        return { approveRes: true, txHash: approveReceipt.hash };\n      case 'increaseAllowance':\n        const increaseAllowanceReceipt = await (\n          await baseContract.increaseAllowance(spenderAddress, amount, { gasLimit })\n        ).wait();\n        return { increaseAllowanceRes: true, txHash: increaseAllowanceReceipt.hash };\n      case 'decreaseAllowance':\n        const decreaseAllowanceReceipt = await (\n          await baseContract.decreaseAllowance(spenderAddress, amount, { gasLimit })\n        ).wait();\n        return { decreaseAllowanceRes: true, txHash: decreaseAllowanceReceipt.hash };\n      case 'allowance':\n        const allowance = await baseContract.allowance(ownerAddress, spenderAddress, { gasLimit });\n        return { allowanceRes: allowance.toString() };\n    }\n  } catch (err) {\n    console.error(err);\n    return { err };\n  }\n};\n\n/**\n * @dev handle executing APIs relate to Token Transfer\n *\n * @dev transfer() moves amount tokens from the caller’s account to `recipient`.\n *\n * @dev transferFrom() moves amount tokens from `tokenOwnerAddress` to `recipientAddress` using the allowance mechanism. `amount` is then deducted from the caller’s allowance.\n *\n * @param baseContract: ethers.Contract\n *\n * @param signerAddress: ethers.AddressLike\n *\n * @param network: TNetworkName\n *\n * @param method: \"transfer\" | \"transferFrom\"\n *\n * @param recipientAddress: ethers.AddressLike\n *\n * @param amount: number\n *\n * @param gasLimit: number\n *\n * @param tokenOwnerAddress?: ethers.AddressLike\n *\n * @return Promise<IERCSmartContractResult>\n */\nexport const erc20Transfers = async (",
            "codeOnlyTokens": 805,
            "startLine": 119,
            "endLine": 221,
            "type": ".ts_part_2",
            "isOversized": false
          },
          {
            "originalText": "  baseContract: Contract,\n  signerAddress: ethers.AddressLike,\n  network: TNetworkName,\n  method: 'transfer' | 'transferFrom',\n  recipientAddress: ethers.AddressLike,\n  amount: number,\n  gasLimit: number,\n  tokenOwnerAddress?: ethers.AddressLike\n): Promise<IERCSmartContractResult> => {\n  if (method === 'transferFrom' && !isAddress(tokenOwnerAddress)) {\n    return { err: 'Invalid token owner address' };\n  } else if (!isAddress(recipientAddress)) {\n    return { err: 'Invalid recipient address' };\n  }\n\n  // prepare function arguments\n  const args =\n    method === 'transfer' ? [recipientAddress, amount] : [tokenOwnerAddress, recipientAddress, amount];\n\n  if (gasLimit === 0) {\n    const estimateGasResult = await handleEstimateGas(baseContract, signerAddress, network, method, args);\n    if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n    gasLimit = estimateGasResult.gasLimit;\n  }\n\n  try {\n    switch (method) {\n      case 'transfer':\n        const transferReceipt = await (\n          await baseContract.transfer(recipientAddress, amount, { gasLimit })\n        ).wait();\n        return { transferRes: true, txHash: transferReceipt.hash };\n      case 'transferFrom':\n        const transferFromReceipt = await (\n          await baseContract.transferFrom(tokenOwnerAddress, recipientAddress, amount, { gasLimit })\n        ).wait();\n\n        return { transferFromRes: true, txHash: transferFromReceipt.hash };\n    }\n  } catch (err) {\n    console.error(err);\n    return { err };\n  }\n};\n",
            "codeOnlyTokens": 360,
            "startLine": 222,
            "endLine": 266,
            "type": ".ts_part_3",
            "isOversized": false
          }
        ],
        "groupedChunks": [
          {
            "combinedText": "// File: system-contract-dapp-playground/src/api/hedera/erc20-interactions/index.ts\n// Relevant file context:\n// Type: .ts\n// SPDX-License-Identifier: Apache-2.0\n\nimport { TNetworkName } from '@/types/common';\nimport { Contract, ethers, isAddress } from 'ethers';\nimport { handleEstimateGas } from '@/utils/common/helpers';\n\n/**\n * @dev get token information\n *\n * @notice execute name(), symbol(), totalSupply(), decimals()\n *\n * @param baseContract: Contract\n *\n * @param method: 'name' | 'symbol' | 'totalSupply' | 'decimals'\n *\n * @return Promise<IERCSmartContractResult>\n */\nexport const getERC20TokenInformation = async (\n  baseContract: Contract,\n  method: 'name' | 'symbol' | 'totalSupply' | 'decimals'\n): Promise<IERCSmartContractResult> => {\n  try {\n    switch (method) {\n      case 'name':\n        return { name: await baseContract.name() };\n      case 'symbol':\n        return { symbol: await baseContract.symbol() };\n      case 'totalSupply':\n        return { totalSupply: (await baseContract.totalSupply()).toString() };\n      case 'decimals':\n        return { decimals: (await baseContract.decimals()).toString() };\n    }\n  } catch (err) {\n    console.error(err);\n    return { err };\n  }\n};\n\n/**\n * @dev mints erc20 tokens\n *\n * @param baseContract: ethers.Contract\n *\n * @param signerAddress: ethers.AddressLike\n *\n * @param network: TNetworkName\n *\n * @param recipientAddress: ethers.AddressLike\n *\n * @param tokenAmount: number\n *\n * @param gasLimit: number\n *\n * @return Promise<IERCSmartContractResult>\n */\nexport const erc20Mint = async (\n  baseContract: Contract,\n  signerAddress: ethers.AddressLike,\n  network: TNetworkName,\n  recipientAddress: ethers.AddressLike,\n  tokenAmount: number,\n  gasLimit: number\n): Promise<IERCSmartContractResult> => {\n  if (!isAddress(recipientAddress)) {\n    return { err: 'Invalid recipient address' };\n  } else if (tokenAmount <= 0) {\n    return { err: 'Invalid token amount' };\n  }\n\n  try {\n    if (gasLimit === 0) {\n      const estimateGasResult = await handleEstimateGas(baseContract, signerAddress, network, 'mint', [\n        recipientAddress,\n        tokenAmount,\n      ]);\n      if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n      gasLimit = estimateGasResult.gasLimit;\n    }\n\n    const txReceipt = await (await baseContract.mint(recipientAddress, tokenAmount, { gasLimit })).wait();\n    return { mintRes: true, txHash: txReceipt.hash };\n  } catch (err) {\n    console.error(err);\n    return { err };\n  }\n};\n\n/**\n * @dev get token balance owned by `accountAddress`\n *\n * @param baseContract: Contract\n *\n * @param accountAddress: ethers.AddressLike\n *\n * @return Promise<IERCSmartContractResult>\n */\nexport const balanceOf = async (\n  baseContract: Contract,\n  accountAddress: ethers.AddressLike\n): Promise<IERCSmartContractResult> => {\n  if (!isAddress(accountAddress)) {\n    return { err: 'Invalid account address' };\n  }\n\n  try {\n    return { balanceOfRes: (await baseContract.balanceOf(accountAddress)).toString() };\n  } catch (err) {\n    console.error(err);\n    return { err };\n  }\n};\n\n/**\n * @dev handle executing APIs relate  to Token Permissions\n *\n * @dev approve() sets `amount` as the allowance of `spenderAddress` over the caller's tokens\n *\n * @dev increaseAllowance() atomically increases the allowance granted to spender by the caller.\n *\n * @dev decreaseAllowance() atomically decreases the allowance granted to spender by the caller.\n *\n * @dev allowance() returns the remaining number of tokens that `spenerAddress` will be allowed to spend on behalf of `ownerAddress`\n *\n * @param baseContract: ethers.Contract\n *\n * @param signerAddress: ethers.AddressLike\n *\n * @param network: TNetworkName\n *\n * @param method: 'approve' | 'allowance' | 'increaseAllowance' | 'decreaseAllowance'\n *\n * @param gasLimit: number\n *\n * @param spenderAddress?: ethers.AddressLike\n *\n * @param owner?: ethers.AddressLike\n *\n * @param amount?: number\n *\n * @return Promise<IERCSmartContractResult>\n */\nexport const handleErc20TokenPermissions = async (\n  baseContract: Contract,\n  signerAddress: ethers.AddressLike,\n  network: TNetworkName,\n  method: 'approve' | 'allowance' | 'increaseAllowance' | 'decreaseAllowance',\n  spenderAddress: ethers.AddressLike,\n  gasLimit: number,\n  ownerAddress?: ethers.AddressLike,\n  amount?: number\n): Promise<IERCSmartContractResult> => {\n  // sanitize params\n  if (ownerAddress && !isAddress(ownerAddress)) {\n    return { err: 'Invalid owner address' };\n  } else if (spenderAddress && !isAddress(spenderAddress)) {\n    return { err: 'Invalid spender address' };\n  }\n\n  // prepare function arguments\n  const args = method === 'allowance' ? [ownerAddress, spenderAddress] : [spenderAddress, amount];\n\n  if (gasLimit === 0) {\n    const estimateGasResult = await handleEstimateGas(baseContract, signerAddress, network, method, args);\n    if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n    gasLimit = estimateGasResult.gasLimit;\n  }\n\n  // executing logic\n  try {\n    switch (method) {\n      case 'approve':\n        const approveReceipt = await (\n          await baseContract.approve(spenderAddress, amount, { gasLimit })\n        ).wait();\n        return { approveRes: true, txHash: approveReceipt.hash };\n      case 'increaseAllowance':\n        const increaseAllowanceReceipt = await (\n          await baseContract.increaseAllowance(spenderAddress, amount, { gasLimit })\n        ).wait();\n        return { increaseAllowanceRes: true, txHash: increaseAllowanceReceipt.hash };\n      case 'decreaseAllowance':\n        const decreaseAllowanceReceipt = await (\n          await baseContract.decreaseAllowance(spenderAddress, amount, { gasLimit })\n        ).wait();\n        return { decreaseAllowanceRes: true, txHash: decreaseAllowanceReceipt.hash };\n      case 'allowance':\n        const allowance = await baseContract.allowance(ownerAddress, spenderAddress, { gasLimit });\n        return { allowanceRes: allowance.toString() };\n    }\n  } catch (err) {\n    console.error(err);\n    return { err };\n  }\n};\n\n/**\n * @dev handle executing APIs relate to Token Transfer\n *\n * @dev transfer() moves amount tokens from the caller’s account to `recipient`.\n *\n * @dev transferFrom() moves amount tokens from `tokenOwnerAddress` to `recipientAddress` using the allowance mechanism. `amount` is then deducted from the caller’s allowance.\n *\n * @param baseContract: ethers.Contract\n *\n * @param signerAddress: ethers.AddressLike\n *\n * @param network: TNetworkName\n *\n * @param method: \"transfer\" | \"transferFrom\"\n *\n * @param recipientAddress: ethers.AddressLike\n *\n * @param amount: number\n *\n * @param gasLimit: number\n *\n * @param tokenOwnerAddress?: ethers.AddressLike\n *\n * @return Promise<IERCSmartContractResult>\n */\nexport const erc20Transfers = async (\n  baseContract: Contract,\n  signerAddress: ethers.AddressLike,\n  network: TNetworkName,\n  method: 'transfer' | 'transferFrom',\n  recipientAddress: ethers.AddressLike,\n  amount: number,\n  gasLimit: number,\n  tokenOwnerAddress?: ethers.AddressLike\n): Promise<IERCSmartContractResult> => {\n  if (method === 'transferFrom' && !isAddress(tokenOwnerAddress)) {\n    return { err: 'Invalid token owner address' };\n  } else if (!isAddress(recipientAddress)) {\n    return { err: 'Invalid recipient address' };\n  }\n\n  // prepare function arguments\n  const args =\n    method === 'transfer' ? [recipientAddress, amount] : [tokenOwnerAddress, recipientAddress, amount];\n\n  if (gasLimit === 0) {\n    const estimateGasResult = await handleEstimateGas(baseContract, signerAddress, network, method, args);\n    if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n    gasLimit = estimateGasResult.gasLimit;\n  }\n\n  try {\n    switch (method) {\n      case 'transfer':\n        const transferReceipt = await (\n          await baseContract.transfer(recipientAddress, amount, { gasLimit })\n        ).wait();\n        return { transferRes: true, txHash: transferReceipt.hash };\n      case 'transferFrom':\n        const transferFromReceipt = await (\n          await baseContract.transferFrom(tokenOwnerAddress, recipientAddress, amount, { gasLimit })\n        ).wait();\n\n        return { transferFromRes: true, txHash: transferFromReceipt.hash };\n    }\n  } catch (err) {\n    console.error(err);\n    return { err };\n  }\n};\n",
            "totalTokens": 1998,
            "chunks": [
              {
                "originalText": "// SPDX-License-Identifier: Apache-2.0\n\nimport { TNetworkName } from '@/types/common';\nimport { Contract, ethers, isAddress } from 'ethers';\nimport { handleEstimateGas } from '@/utils/common/helpers';\n\n/**\n * @dev get token information\n *\n * @notice execute name(), symbol(), totalSupply(), decimals()\n *\n * @param baseContract: Contract\n *\n * @param method: 'name' | 'symbol' | 'totalSupply' | 'decimals'\n *\n * @return Promise<IERCSmartContractResult>\n */\nexport const getERC20TokenInformation = async (\n  baseContract: Contract,\n  method: 'name' | 'symbol' | 'totalSupply' | 'decimals'\n): Promise<IERCSmartContractResult> => {\n  try {\n    switch (method) {\n      case 'name':\n        return { name: await baseContract.name() };\n      case 'symbol':\n        return { symbol: await baseContract.symbol() };\n      case 'totalSupply':\n        return { totalSupply: (await baseContract.totalSupply()).toString() };\n      case 'decimals':\n        return { decimals: (await baseContract.decimals()).toString() };\n    }\n  } catch (err) {\n    console.error(err);\n    return { err };\n  }\n};\n\n/**\n * @dev mints erc20 tokens\n *\n * @param baseContract: ethers.Contract\n *\n * @param signerAddress: ethers.AddressLike\n *\n * @param network: TNetworkName\n *\n * @param recipientAddress: ethers.AddressLike\n *\n * @param tokenAmount: number\n *\n * @param gasLimit: number\n *\n * @return Promise<IERCSmartContractResult>\n */\nexport const erc20Mint = async (\n  baseContract: Contract,\n  signerAddress: ethers.AddressLike,\n  network: TNetworkName,\n  recipientAddress: ethers.AddressLike,\n  tokenAmount: number,\n  gasLimit: number\n): Promise<IERCSmartContractResult> => {\n  if (!isAddress(recipientAddress)) {\n    return { err: 'Invalid recipient address' };\n  } else if (tokenAmount <= 0) {\n    return { err: 'Invalid token amount' };\n  }\n\n  try {\n    if (gasLimit === 0) {\n      const estimateGasResult = await handleEstimateGas(baseContract, signerAddress, network, 'mint', [\n        recipientAddress,\n        tokenAmount,\n      ]);\n      if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n      gasLimit = estimateGasResult.gasLimit;\n    }\n\n    const txReceipt = await (await baseContract.mint(recipientAddress, tokenAmount, { gasLimit })).wait();\n    return { mintRes: true, txHash: txReceipt.hash };\n  } catch (err) {\n    console.error(err);\n    return { err };\n  }\n};\n\n/**\n * @dev get token balance owned by `accountAddress`\n *\n * @param baseContract: Contract\n *\n * @param accountAddress: ethers.AddressLike\n *\n * @return Promise<IERCSmartContractResult>\n */\nexport const balanceOf = async (\n  baseContract: Contract,\n  accountAddress: ethers.AddressLike\n): Promise<IERCSmartContractResult> => {\n  if (!isAddress(accountAddress)) {\n    return { err: 'Invalid account address' };\n  }\n\n  try {\n    return { balanceOfRes: (await baseContract.balanceOf(accountAddress)).toString() };\n  } catch (err) {\n    console.error(err);\n    return { err };\n  }\n};\n\n/**\n * @dev handle executing APIs relate  to Token Permissions\n *\n * @dev approve() sets `amount` as the allowance of `spenderAddress` over the caller's tokens\n *\n * @dev increaseAllowance() atomically increases the allowance granted to spender by the caller.\n *\n * @dev decreaseAllowance() atomically decreases the allowance granted to spender by the caller.\n *\n * @dev allowance() returns the remaining number of tokens that `spenerAddress` will be allowed to spend on behalf of `ownerAddress`\n *\n * @param baseContract: ethers.Contract\n *\n * @param signerAddress: ethers.AddressLike\n *\n * @param network: TNetworkName\n *\n * @param method: 'approve' | 'allowance' | 'increaseAllowance' | 'decreaseAllowance'\n *\n * @param gasLimit: number\n *\n * @param spenderAddress?: ethers.AddressLike\n *\n * @param owner?: ethers.AddressLike\n *\n * @param amount?: number\n *\n * @return Promise<IERCSmartContractResult>\n */\nexport const handleErc20TokenPermissions = async (\n  baseContract: Contract,\n  signerAddress: ethers.AddressLike,\n  network: TNetworkName,\n  method: 'approve' | 'allowance' | 'increaseAllowance' | 'decreaseAllowance',\n  spenderAddress: ethers.AddressLike,\n  gasLimit: number,\n  ownerAddress?: ethers.AddressLike,\n  amount?: number\n): Promise<IERCSmartContractResult> => {\n  // sanitize params\n  if (ownerAddress && !isAddress(ownerAddress)) {\n    return { err: 'Invalid owner address' };\n  } else if (spenderAddress && !isAddress(spenderAddress)) {\n    return { err: 'Invalid spender address' };\n  }\n\n  // prepare function arguments\n  const args = method === 'allowance' ? [ownerAddress, spenderAddress] : [spenderAddress, amount];\n\n  if (gasLimit === 0) {\n    const estimateGasResult = await handleEstimateGas(baseContract, signerAddress, network, method, args);\n    if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n    gasLimit = estimateGasResult.gasLimit;\n  }\n\n  // executing logic\n  try {\n    switch (method) {\n      case 'approve':\n        const approveReceipt = await (\n          await baseContract.approve(spenderAddress, amount, { gasLimit })\n        ).wait();\n        return { approveRes: true, txHash: approveReceipt.hash };\n      case 'increaseAllowance':\n        const increaseAllowanceReceipt = await (\n          await baseContract.increaseAllowance(spenderAddress, amount, { gasLimit })\n        ).wait();\n        return { increaseAllowanceRes: true, txHash: increaseAllowanceReceipt.hash };\n      case 'decreaseAllowance':\n        const decreaseAllowanceReceipt = await (\n          await baseContract.decreaseAllowance(spenderAddress, amount, { gasLimit })\n        ).wait();\n        return { decreaseAllowanceRes: true, txHash: decreaseAllowanceReceipt.hash };\n      case 'allowance':\n        const allowance = await baseContract.allowance(ownerAddress, spenderAddress, { gasLimit });\n        return { allowanceRes: allowance.toString() };\n    }\n  } catch (err) {\n    console.error(err);\n    return { err };\n  }\n};\n\n/**\n * @dev handle executing APIs relate to Token Transfer\n *\n * @dev transfer() moves amount tokens from the caller’s account to `recipient`.\n *\n * @dev transferFrom() moves amount tokens from `tokenOwnerAddress` to `recipientAddress` using the allowance mechanism. `amount` is then deducted from the caller’s allowance.\n *\n * @param baseContract: ethers.Contract\n *\n * @param signerAddress: ethers.AddressLike\n *\n * @param network: TNetworkName\n *\n * @param method: \"transfer\" | \"transferFrom\"\n *\n * @param recipientAddress: ethers.AddressLike\n *\n * @param amount: number\n *\n * @param gasLimit: number\n *\n * @param tokenOwnerAddress?: ethers.AddressLike\n *\n * @return Promise<IERCSmartContractResult>\n */\nexport const erc20Transfers = async (\n  baseContract: Contract,\n  signerAddress: ethers.AddressLike,\n  network: TNetworkName,\n  method: 'transfer' | 'transferFrom',\n  recipientAddress: ethers.AddressLike,\n  amount: number,\n  gasLimit: number,\n  tokenOwnerAddress?: ethers.AddressLike\n): Promise<IERCSmartContractResult> => {\n  if (method === 'transferFrom' && !isAddress(tokenOwnerAddress)) {\n    return { err: 'Invalid token owner address' };\n  } else if (!isAddress(recipientAddress)) {\n    return { err: 'Invalid recipient address' };\n  }\n\n  // prepare function arguments\n  const args =\n    method === 'transfer' ? [recipientAddress, amount] : [tokenOwnerAddress, recipientAddress, amount];\n\n  if (gasLimit === 0) {\n    const estimateGasResult = await handleEstimateGas(baseContract, signerAddress, network, method, args);\n    if (!estimateGasResult.gasLimit || estimateGasResult.err) return { err: estimateGasResult.err };\n    gasLimit = estimateGasResult.gasLimit;\n  }\n\n  try {\n    switch (method) {\n      case 'transfer':\n        const transferReceipt = await (\n          await baseContract.transfer(recipientAddress, amount, { gasLimit })\n        ).wait();\n        return { transferRes: true, txHash: transferReceipt.hash };\n      case 'transferFrom':\n        const transferFromReceipt = await (\n          await baseContract.transferFrom(tokenOwnerAddress, recipientAddress, amount, { gasLimit })\n        ).wait();\n\n        return { transferFromRes: true, txHash: transferFromReceipt.hash };\n    }\n  } catch (err) {\n    console.error(err);\n    return { err };\n  }\n};\n",
                "codeOnlyTokens": 1966,
                "startLine": 1,
                "endLine": 266,
                "type": "full_file",
                "isOversized": false
              }
            ],
            "startLine": 1,
            "endLine": 266,
            "groupId": 1
          }
        ],
        "oversizedChunks": [],
        "sendStrategy": "full_file",
        "finalTokenCount": 1998,
        "skippedContent": [],
        "contextHeader": "// File: system-contract-dapp-playground/src/api/hedera/erc20-interactions/index.ts\n// Relevant file context:\n// Type: .ts\n",
        "tokenBreakdown": {
          "originalFile": 1966,
          "finalSent": 1998,
          "codeTokensInGroups": 1966,
          "fileHeaderTokensInGroups": 32,
          "shellContextTokensInGroups": 0,
          "separatorTokensInGroups": 0,
          "skippedCodeTokens": 0,
          "unprocessedOversizedTokens": 0,
          "totalSavings": -32,
          "savingsPercentage": -1.627670396744659,
          "fileHeaderCount": 1,
          "fileHeaderAvgSize": 32,
          "shellContextCount": 0,
          "shellContextAvgSize": 0,
          "separatorCount": 1,
          "separatorAvgSize": 0
        }
      }
    },
    {
      "filePath": "scripts/freeze-network-node.js",
      "totalOriginalTokens": 320,
      "finalTokenCount": 340,
      "impactScore": 31.666666666666664,
      "averageComplexity": 5,
      "averageQuality": 6.333333333333333,
      "usage": {
        "prompt_tokens": 482,
        "completion_tokens": 127,
        "total_tokens": 609
      },
      "retries": 0,
      "hadError": false,
      "scoredChunkGroups": [
        {
          "groupId": 1,
          "score": {
            "file_path": "scripts/freeze-network-node.js",
            "complexity_score": 5,
            "code_quality_score": 6,
            "maintainability_score": 6,
            "best_practices_adherence": 7,
            "positive_feedback": "The use of timestamp for scheduling the freeze is a neat way to manage node states.",
            "improvement_suggestion": "Add more informative logging for different stages of the freezing process.",
            "group_summary": "Script to freeze a local Hedera network node for migration purposes."
          },
          "totalTokens": 340,
          "usage": {
            "prompt_tokens": 482,
            "completion_tokens": 127,
            "total_tokens": 609
          }
        }
      ],
      "chunkingDetails": {
        "filePath": "scripts/freeze-network-node.js",
        "totalFileTokens": 320,
        "chunks": [
          {
            "originalText": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * @notice this scripts is mainly designed to freeze the local network node to prepare for network migration (mono to mod)\n */\nconst {\n  FreezeTransaction,\n  Client,\n  Timestamp,\n  FreezeType,\n} = require('@hashgraph/sdk');\nconst { OPERATOR_ID_A, OPERATOR_KEY_A } = require('../utils/constants');\n\nasync function main() {\n  try {\n    // notice: currently this setup is only used to freeze a single network node locally.\n    const genesisClient = Client.forNetwork({\n      '127.0.0.1:50211': '0.0.3',\n    }).setOperator(OPERATOR_ID_A, OPERATOR_KEY_A);\n\n    const validStart = new Timestamp(Math.round((Date.now() + 5000) / 1000), 0); // timestamp now +  5 sec\n    const tx = new FreezeTransaction()\n      .setStartTimestamp(validStart)\n      .setFreezeType(new FreezeType(1)) // FreezeOnly\n      .freezeWith(genesisClient);\n    const execTx = await tx.execute(genesisClient);\n    await execTx.getReceipt(genesisClient);\n  } catch (e) {\n    if (e.message.includes('GrpcServiceError: read ECONNRESET')) {\n      console.log('The platform has been frozen successfully.');\n    } else {\n      throw new Error(e);\n    }\n  }\n\n  process.exit(0);\n}\n\nmain().catch((error) => {\n  console.log(error);\n  process.exit(-1);\n});\n",
            "codeOnlyTokens": 320,
            "startLine": 1,
            "endLine": 43,
            "type": ".js",
            "isOversized": false
          }
        ],
        "groupedChunks": [
          {
            "combinedText": "// File: scripts/freeze-network-node.js\n// Relevant file context:\n// Type: .js\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * @notice this scripts is mainly designed to freeze the local network node to prepare for network migration (mono to mod)\n */\nconst {\n  FreezeTransaction,\n  Client,\n  Timestamp,\n  FreezeType,\n} = require('@hashgraph/sdk');\nconst { OPERATOR_ID_A, OPERATOR_KEY_A } = require('../utils/constants');\n\nasync function main() {\n  try {\n    // notice: currently this setup is only used to freeze a single network node locally.\n    const genesisClient = Client.forNetwork({\n      '127.0.0.1:50211': '0.0.3',\n    }).setOperator(OPERATOR_ID_A, OPERATOR_KEY_A);\n\n    const validStart = new Timestamp(Math.round((Date.now() + 5000) / 1000), 0); // timestamp now +  5 sec\n    const tx = new FreezeTransaction()\n      .setStartTimestamp(validStart)\n      .setFreezeType(new FreezeType(1)) // FreezeOnly\n      .freezeWith(genesisClient);\n    const execTx = await tx.execute(genesisClient);\n    await execTx.getReceipt(genesisClient);\n  } catch (e) {\n    if (e.message.includes('GrpcServiceError: read ECONNRESET')) {\n      console.log('The platform has been frozen successfully.');\n    } else {\n      throw new Error(e);\n    }\n  }\n\n  process.exit(0);\n}\n\nmain().catch((error) => {\n  console.log(error);\n  process.exit(-1);\n});\n",
            "totalTokens": 340,
            "chunks": [
              {
                "originalText": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * @notice this scripts is mainly designed to freeze the local network node to prepare for network migration (mono to mod)\n */\nconst {\n  FreezeTransaction,\n  Client,\n  Timestamp,\n  FreezeType,\n} = require('@hashgraph/sdk');\nconst { OPERATOR_ID_A, OPERATOR_KEY_A } = require('../utils/constants');\n\nasync function main() {\n  try {\n    // notice: currently this setup is only used to freeze a single network node locally.\n    const genesisClient = Client.forNetwork({\n      '127.0.0.1:50211': '0.0.3',\n    }).setOperator(OPERATOR_ID_A, OPERATOR_KEY_A);\n\n    const validStart = new Timestamp(Math.round((Date.now() + 5000) / 1000), 0); // timestamp now +  5 sec\n    const tx = new FreezeTransaction()\n      .setStartTimestamp(validStart)\n      .setFreezeType(new FreezeType(1)) // FreezeOnly\n      .freezeWith(genesisClient);\n    const execTx = await tx.execute(genesisClient);\n    await execTx.getReceipt(genesisClient);\n  } catch (e) {\n    if (e.message.includes('GrpcServiceError: read ECONNRESET')) {\n      console.log('The platform has been frozen successfully.');\n    } else {\n      throw new Error(e);\n    }\n  }\n\n  process.exit(0);\n}\n\nmain().catch((error) => {\n  console.log(error);\n  process.exit(-1);\n});\n",
                "codeOnlyTokens": 320,
                "startLine": 1,
                "endLine": 43,
                "type": "full_file",
                "isOversized": false
              }
            ],
            "startLine": 1,
            "endLine": 43,
            "groupId": 1
          }
        ],
        "oversizedChunks": [],
        "sendStrategy": "full_file",
        "finalTokenCount": 340,
        "skippedContent": [],
        "contextHeader": "// File: scripts/freeze-network-node.js\n// Relevant file context:\n// Type: .js\n",
        "tokenBreakdown": {
          "originalFile": 320,
          "finalSent": 340,
          "codeTokensInGroups": 320,
          "fileHeaderTokensInGroups": 20,
          "shellContextTokensInGroups": 0,
          "separatorTokensInGroups": 0,
          "skippedCodeTokens": 0,
          "unprocessedOversizedTokens": 0,
          "totalSavings": -20,
          "savingsPercentage": -6.25,
          "fileHeaderCount": 1,
          "fileHeaderAvgSize": 20,
          "shellContextCount": 0,
          "shellContextAvgSize": 0,
          "separatorCount": 1,
          "separatorAvgSize": 0
        }
      }
    },
    {
      "filePath": "system-contract-dapp-playground/src/components/contract-interaction/hts/token-create-custom/methods/index.tsx",
      "totalOriginalTokens": 256,
      "finalTokenCount": 294,
      "impactScore": 30.666666666666668,
      "averageComplexity": 4,
      "averageQuality": 7.666666666666667,
      "usage": {
        "prompt_tokens": 417,
        "completion_tokens": 127,
        "total_tokens": 544
      },
      "retries": 0,
      "hadError": false,
      "scoredChunkGroups": [
        {
          "groupId": 1,
          "score": {
            "file_path": "system-contract-dapp-playground/src/components/contract-interaction/hts/token-create-custom/methods/index.tsx",
            "complexity_score": 4,
            "code_quality_score": 8,
            "maintainability_score": 7,
            "best_practices_adherence": 8,
            "positive_feedback": "The modular approach for token interaction methods enhances maintainability and scalability.",
            "improvement_suggestion": "Consider adding unit tests to ensure stability of each token method component.",
            "group_summary": "Component that conditionally renders token-related interaction methods for Hedera."
          },
          "totalTokens": 294,
          "usage": {
            "prompt_tokens": 417,
            "completion_tokens": 127,
            "total_tokens": 544
          }
        }
      ],
      "chunkingDetails": {
        "filePath": "system-contract-dapp-playground/src/components/contract-interaction/hts/token-create-custom/methods/index.tsx",
        "totalFileTokens": 256,
        "chunks": [
          {
            "originalText": "// SPDX-License-Identifier: Apache-2.0\n\nimport { Contract } from 'ethers';\nimport GrantTokenKYC from './GrantTokenKYC';\nimport MintHederaToken from './MintHederaToken';\nimport FungibleTokenCreate from './FungibleTokenCreate';\nimport AssociateHederaToken from './AssociateHederaToken';\nimport NonFungibleTokenCreate from './NonFungibleTokenCreate';\n\ninterface PageProps {\n  method: string;\n  baseContract: Contract;\n}\n\nconst HederaTokenCreateMethods = ({ baseContract, method }: PageProps) => {\n  return (\n    <>\n      {method === 'mint' && <MintHederaToken baseContract={baseContract} />}\n      {method === 'grantKYC' && <GrantTokenKYC baseContract={baseContract} />}\n      {method === 'tokenAssociation' && <AssociateHederaToken baseContract={baseContract} />}\n      {method === 'fungibleTokenCreate' && <FungibleTokenCreate baseContract={baseContract} />}\n      {method === 'non-fungibleTokenCreate' && <NonFungibleTokenCreate baseContract={baseContract} />}\n    </>\n  );\n};\n\nexport default HederaTokenCreateMethods;\n",
            "codeOnlyTokens": 256,
            "startLine": 1,
            "endLine": 28,
            "type": ".tsx",
            "isOversized": false
          }
        ],
        "groupedChunks": [
          {
            "combinedText": "// File: system-contract-dapp-playground/src/components/contract-interaction/hts/token-create-custom/methods/index.tsx\n// Relevant file context:\n// Type: .tsx\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Contract } from 'ethers';\nimport GrantTokenKYC from './GrantTokenKYC';\nimport MintHederaToken from './MintHederaToken';\nimport FungibleTokenCreate from './FungibleTokenCreate';\nimport AssociateHederaToken from './AssociateHederaToken';\nimport NonFungibleTokenCreate from './NonFungibleTokenCreate';\n\ninterface PageProps {\n  method: string;\n  baseContract: Contract;\n}\n\nconst HederaTokenCreateMethods = ({ baseContract, method }: PageProps) => {\n  return (\n    <>\n      {method === 'mint' && <MintHederaToken baseContract={baseContract} />}\n      {method === 'grantKYC' && <GrantTokenKYC baseContract={baseContract} />}\n      {method === 'tokenAssociation' && <AssociateHederaToken baseContract={baseContract} />}\n      {method === 'fungibleTokenCreate' && <FungibleTokenCreate baseContract={baseContract} />}\n      {method === 'non-fungibleTokenCreate' && <NonFungibleTokenCreate baseContract={baseContract} />}\n    </>\n  );\n};\n\nexport default HederaTokenCreateMethods;\n",
            "totalTokens": 294,
            "chunks": [
              {
                "originalText": "// SPDX-License-Identifier: Apache-2.0\n\nimport { Contract } from 'ethers';\nimport GrantTokenKYC from './GrantTokenKYC';\nimport MintHederaToken from './MintHederaToken';\nimport FungibleTokenCreate from './FungibleTokenCreate';\nimport AssociateHederaToken from './AssociateHederaToken';\nimport NonFungibleTokenCreate from './NonFungibleTokenCreate';\n\ninterface PageProps {\n  method: string;\n  baseContract: Contract;\n}\n\nconst HederaTokenCreateMethods = ({ baseContract, method }: PageProps) => {\n  return (\n    <>\n      {method === 'mint' && <MintHederaToken baseContract={baseContract} />}\n      {method === 'grantKYC' && <GrantTokenKYC baseContract={baseContract} />}\n      {method === 'tokenAssociation' && <AssociateHederaToken baseContract={baseContract} />}\n      {method === 'fungibleTokenCreate' && <FungibleTokenCreate baseContract={baseContract} />}\n      {method === 'non-fungibleTokenCreate' && <NonFungibleTokenCreate baseContract={baseContract} />}\n    </>\n  );\n};\n\nexport default HederaTokenCreateMethods;\n",
                "codeOnlyTokens": 256,
                "startLine": 1,
                "endLine": 28,
                "type": "full_file",
                "isOversized": false
              }
            ],
            "startLine": 1,
            "endLine": 28,
            "groupId": 1
          }
        ],
        "oversizedChunks": [],
        "sendStrategy": "full_file",
        "finalTokenCount": 294,
        "skippedContent": [],
        "contextHeader": "// File: system-contract-dapp-playground/src/components/contract-interaction/hts/token-create-custom/methods/index.tsx\n// Relevant file context:\n// Type: .tsx\n",
        "tokenBreakdown": {
          "originalFile": 256,
          "finalSent": 294,
          "codeTokensInGroups": 256,
          "fileHeaderTokensInGroups": 38,
          "shellContextTokensInGroups": 0,
          "separatorTokensInGroups": 0,
          "skippedCodeTokens": 0,
          "unprocessedOversizedTokens": 0,
          "totalSavings": -38,
          "savingsPercentage": -14.84375,
          "fileHeaderCount": 1,
          "fileHeaderAvgSize": 38,
          "shellContextCount": 0,
          "shellContextAvgSize": 0,
          "separatorCount": 1,
          "separatorAvgSize": 0
        }
      }
    },
    {
      "filePath": "system-contract-dapp-playground/src/app/page.tsx",
      "totalOriginalTokens": 75,
      "finalTokenCount": 100,
      "impactScore": 25,
      "averageComplexity": 3,
      "averageQuality": 8.333333333333334,
      "usage": {
        "prompt_tokens": 118,
        "completion_tokens": 140,
        "total_tokens": 258
      },
      "retries": 0,
      "hadError": false,
      "scoredChunkGroups": [
        {
          "groupId": 1,
          "score": {
            "file_path": "system-contract-dapp-playground/src/app/page.tsx",
            "complexity_score": 3,
            "code_quality_score": 8,
            "maintainability_score": 9,
            "best_practices_adherence": 8,
            "positive_feedback": "The structure of the main page is clean and well-organized with clear component separation.",
            "improvement_suggestion": "Add prop types or TypeScript interfaces to enhance type safety for props passed to components.",
            "group_summary": "This file serves as the main entry point, rendering the navbar, landing page, and footer."
          },
          "totalTokens": 100,
          "usage": {
            "prompt_tokens": 118,
            "completion_tokens": 140,
            "total_tokens": 258
          }
        }
      ],
      "chunkingDetails": {
        "filePath": "system-contract-dapp-playground/src/app/page.tsx",
        "totalFileTokens": 75,
        "chunks": [
          {
            "originalText": "// SPDX-License-Identifier: Apache-2.0\n\nimport Footer from '@/components/footer';\nimport Navbar from '@/components/navbar';\nimport LandingPage from '@/sections/landing';\n\nexport default function Home() {\n  return (\n    <main className=\"h-screen flex flex-col\">\n      <Navbar />\n      <LandingPage />;\n      <Footer />\n    </main>\n  );\n}\n",
            "codeOnlyTokens": 75,
            "startLine": 1,
            "endLine": 16,
            "type": ".tsx",
            "isOversized": false
          }
        ],
        "groupedChunks": [
          {
            "combinedText": "// File: system-contract-dapp-playground/src/app/page.tsx\n// Relevant file context:\n// Type: .tsx\n// SPDX-License-Identifier: Apache-2.0\n\nimport Footer from '@/components/footer';\nimport Navbar from '@/components/navbar';\nimport LandingPage from '@/sections/landing';\n\nexport default function Home() {\n  return (\n    <main className=\"h-screen flex flex-col\">\n      <Navbar />\n      <LandingPage />;\n      <Footer />\n    </main>\n  );\n}\n",
            "totalTokens": 100,
            "chunks": [
              {
                "originalText": "// SPDX-License-Identifier: Apache-2.0\n\nimport Footer from '@/components/footer';\nimport Navbar from '@/components/navbar';\nimport LandingPage from '@/sections/landing';\n\nexport default function Home() {\n  return (\n    <main className=\"h-screen flex flex-col\">\n      <Navbar />\n      <LandingPage />;\n      <Footer />\n    </main>\n  );\n}\n",
                "codeOnlyTokens": 75,
                "startLine": 1,
                "endLine": 16,
                "type": "full_file",
                "isOversized": false
              }
            ],
            "startLine": 1,
            "endLine": 16,
            "groupId": 1
          }
        ],
        "oversizedChunks": [],
        "sendStrategy": "full_file",
        "finalTokenCount": 100,
        "skippedContent": [],
        "contextHeader": "// File: system-contract-dapp-playground/src/app/page.tsx\n// Relevant file context:\n// Type: .tsx\n",
        "tokenBreakdown": {
          "originalFile": 75,
          "finalSent": 100,
          "codeTokensInGroups": 75,
          "fileHeaderTokensInGroups": 25,
          "shellContextTokensInGroups": 0,
          "separatorTokensInGroups": 0,
          "skippedCodeTokens": 0,
          "unprocessedOversizedTokens": 0,
          "totalSavings": -25,
          "savingsPercentage": -33.33333333333333,
          "fileHeaderCount": 1,
          "fileHeaderAvgSize": 25,
          "shellContextCount": 0,
          "shellContextAvgSize": 0,
          "separatorCount": 1,
          "separatorAvgSize": 0
        }
      }
    },
    {
      "filePath": "system-contract-dapp-playground/src/components/footer/index.tsx",
      "totalOriginalTokens": 490,
      "finalTokenCount": 516,
      "impactScore": 25,
      "averageComplexity": 3,
      "averageQuality": 8.333333333333334,
      "usage": {
        "prompt_tokens": 732,
        "completion_tokens": 127,
        "total_tokens": 859
      },
      "retries": 0,
      "hadError": false,
      "scoredChunkGroups": [
        {
          "groupId": 1,
          "score": {
            "file_path": "system-contract-dapp-playground/src/components/footer/index.tsx",
            "complexity_score": 3,
            "code_quality_score": 8,
            "maintainability_score": 8,
            "best_practices_adherence": 9,
            "positive_feedback": "The use of framer-motion adds a great user experience touch to the footer.",
            "improvement_suggestion": "Consider adding accessibility features for better user interaction with the social media icons.",
            "group_summary": "A responsive footer component displaying Hedera branding and social media links."
          },
          "totalTokens": 516,
          "usage": {
            "prompt_tokens": 732,
            "completion_tokens": 127,
            "total_tokens": 859
          }
        }
      ],
      "chunkingDetails": {
        "filePath": "system-contract-dapp-playground/src/components/footer/index.tsx",
        "totalFileTokens": 490,
        "chunks": [
          {
            "originalText": "// SPDX-License-Identifier: Apache-2.0\n\n'use client';\n\nimport Link from 'next/link';\nimport Image from 'next/image';\nimport { motion } from 'framer-motion';\nimport { HEDERA_SOCIAL_MEDIA } from '@/utils/common/constants';\n\nconst Footer = () => {\n  return (\n    <motion.footer\n      initial={{ opacity: 0 }}\n      whileInView={{ opacity: 1 }}\n      transition={{\n        delay: 0.3,\n        duration: 0.3,\n      }}\n      viewport={{ once: true }}\n      className=\"text-white px-6 w-full z-40 flex flex-col items-center\"\n    >\n      <hr className=\"w-[99vw] border-t border-white/40\" />\n      <div\n        className=\"w-full flex flex-col gap-6 py-3\n                  md:flex-row md:justify-between md:items-center md:py-6 md:pb-3\"\n      >\n        {/* Logo & copyright*/}\n        <div className=\"flex flex-col gap-1 justify-center items-center md:items-start\">\n          {/* logo */}\n          <Link href={'/'} className=\"flex gap-2 items-center justify-center\">\n            {/* logo icon */}\n            <Image\n              src={'/brandings/hedera-logomark.svg'}\n              alt={'hedera-logomark'}\n              width={30}\n              height={30}\n              className=\"z-50\"\n            />\n\n            {/* logo text */}\n            <p className=\"text-white\">Hedera</p>\n          </Link>\n\n          {/* copyright */}\n          <p className=\"font-light text-sm\">\n            &copy; 2018 - {new Date().getFullYear()} Hedera Hashgraph, LLC.\n          </p>\n        </div>\n\n        {/* social media */}\n        <div className=\"flex items-center justify-center gap-4 md:justify-start lg:gap-6\">\n          {HEDERA_SOCIAL_MEDIA.map((media) => {\n            return (\n              <Link key={media.name} href={media.link} target=\"_blank\">\n                <Image src={`/assets/socials/${media.name}.svg`} alt={media.name} width={24} height={24} />\n              </Link>\n            );\n          })}\n        </div>\n      </div>\n    </motion.footer>\n  );\n};\n\nexport default Footer;\n",
            "codeOnlyTokens": 490,
            "startLine": 1,
            "endLine": 66,
            "type": ".tsx",
            "isOversized": false
          }
        ],
        "groupedChunks": [
          {
            "combinedText": "// File: system-contract-dapp-playground/src/components/footer/index.tsx\n// Relevant file context:\n// Type: .tsx\n// SPDX-License-Identifier: Apache-2.0\n\n'use client';\n\nimport Link from 'next/link';\nimport Image from 'next/image';\nimport { motion } from 'framer-motion';\nimport { HEDERA_SOCIAL_MEDIA } from '@/utils/common/constants';\n\nconst Footer = () => {\n  return (\n    <motion.footer\n      initial={{ opacity: 0 }}\n      whileInView={{ opacity: 1 }}\n      transition={{\n        delay: 0.3,\n        duration: 0.3,\n      }}\n      viewport={{ once: true }}\n      className=\"text-white px-6 w-full z-40 flex flex-col items-center\"\n    >\n      <hr className=\"w-[99vw] border-t border-white/40\" />\n      <div\n        className=\"w-full flex flex-col gap-6 py-3\n                  md:flex-row md:justify-between md:items-center md:py-6 md:pb-3\"\n      >\n        {/* Logo & copyright*/}\n        <div className=\"flex flex-col gap-1 justify-center items-center md:items-start\">\n          {/* logo */}\n          <Link href={'/'} className=\"flex gap-2 items-center justify-center\">\n            {/* logo icon */}\n            <Image\n              src={'/brandings/hedera-logomark.svg'}\n              alt={'hedera-logomark'}\n              width={30}\n              height={30}\n              className=\"z-50\"\n            />\n\n            {/* logo text */}\n            <p className=\"text-white\">Hedera</p>\n          </Link>\n\n          {/* copyright */}\n          <p className=\"font-light text-sm\">\n            &copy; 2018 - {new Date().getFullYear()} Hedera Hashgraph, LLC.\n          </p>\n        </div>\n\n        {/* social media */}\n        <div className=\"flex items-center justify-center gap-4 md:justify-start lg:gap-6\">\n          {HEDERA_SOCIAL_MEDIA.map((media) => {\n            return (\n              <Link key={media.name} href={media.link} target=\"_blank\">\n                <Image src={`/assets/socials/${media.name}.svg`} alt={media.name} width={24} height={24} />\n              </Link>\n            );\n          })}\n        </div>\n      </div>\n    </motion.footer>\n  );\n};\n\nexport default Footer;\n",
            "totalTokens": 516,
            "chunks": [
              {
                "originalText": "// SPDX-License-Identifier: Apache-2.0\n\n'use client';\n\nimport Link from 'next/link';\nimport Image from 'next/image';\nimport { motion } from 'framer-motion';\nimport { HEDERA_SOCIAL_MEDIA } from '@/utils/common/constants';\n\nconst Footer = () => {\n  return (\n    <motion.footer\n      initial={{ opacity: 0 }}\n      whileInView={{ opacity: 1 }}\n      transition={{\n        delay: 0.3,\n        duration: 0.3,\n      }}\n      viewport={{ once: true }}\n      className=\"text-white px-6 w-full z-40 flex flex-col items-center\"\n    >\n      <hr className=\"w-[99vw] border-t border-white/40\" />\n      <div\n        className=\"w-full flex flex-col gap-6 py-3\n                  md:flex-row md:justify-between md:items-center md:py-6 md:pb-3\"\n      >\n        {/* Logo & copyright*/}\n        <div className=\"flex flex-col gap-1 justify-center items-center md:items-start\">\n          {/* logo */}\n          <Link href={'/'} className=\"flex gap-2 items-center justify-center\">\n            {/* logo icon */}\n            <Image\n              src={'/brandings/hedera-logomark.svg'}\n              alt={'hedera-logomark'}\n              width={30}\n              height={30}\n              className=\"z-50\"\n            />\n\n            {/* logo text */}\n            <p className=\"text-white\">Hedera</p>\n          </Link>\n\n          {/* copyright */}\n          <p className=\"font-light text-sm\">\n            &copy; 2018 - {new Date().getFullYear()} Hedera Hashgraph, LLC.\n          </p>\n        </div>\n\n        {/* social media */}\n        <div className=\"flex items-center justify-center gap-4 md:justify-start lg:gap-6\">\n          {HEDERA_SOCIAL_MEDIA.map((media) => {\n            return (\n              <Link key={media.name} href={media.link} target=\"_blank\">\n                <Image src={`/assets/socials/${media.name}.svg`} alt={media.name} width={24} height={24} />\n              </Link>\n            );\n          })}\n        </div>\n      </div>\n    </motion.footer>\n  );\n};\n\nexport default Footer;\n",
                "codeOnlyTokens": 490,
                "startLine": 1,
                "endLine": 66,
                "type": "full_file",
                "isOversized": false
              }
            ],
            "startLine": 1,
            "endLine": 66,
            "groupId": 1
          }
        ],
        "oversizedChunks": [],
        "sendStrategy": "full_file",
        "finalTokenCount": 516,
        "skippedContent": [],
        "contextHeader": "// File: system-contract-dapp-playground/src/components/footer/index.tsx\n// Relevant file context:\n// Type: .tsx\n",
        "tokenBreakdown": {
          "originalFile": 490,
          "finalSent": 516,
          "codeTokensInGroups": 490,
          "fileHeaderTokensInGroups": 26,
          "shellContextTokensInGroups": 0,
          "separatorTokensInGroups": 0,
          "skippedCodeTokens": 0,
          "unprocessedOversizedTokens": 0,
          "totalSavings": -26,
          "savingsPercentage": -5.3061224489795915,
          "fileHeaderCount": 1,
          "fileHeaderAvgSize": 26,
          "shellContextCount": 0,
          "shellContextAvgSize": 0,
          "separatorCount": 1,
          "separatorAvgSize": 0
        }
      }
    }
  ],
  "finalProjectScore": 7.832248764034823,
  "finalReview": {
    "model": "gemini-2.5-flash",
    "dossierBudget": 16000,
    "strategy": "global_top_impact",
    "filesSentForFinalEval": [
      "contracts/system-contracts/pseudo-random-number-generator/PrngSystemContract.sol",
      "contracts/system-contracts/hedera-account-service/HederaAccountService.sol",
      "contracts/system-contracts/hedera-token-service/HederaTokenService.sol",
      "scripts/hedera-response-codes-protobuf-parser.js",
      "system-contract-dapp-playground/src/components/navbar/index.tsx",
      "contracts/system-contracts/exchange-rate/ExchangeRateSystemContract.sol",
      "system-contract-dapp-playground/src/app/layout.tsx",
      "scripts/freeze-network-node.js",
      "system-contract-dapp-playground/src/components/contract-interaction/hts/token-create-custom/methods/index.tsx",
      "system-contract-dapp-playground/src/app/page.tsx"
    ],
    "usage": {
      "prompt_tokens": 19054,
      "completion_tokens": 2987,
      "total_tokens": 22041
    },
    "multiplier": 1.1,
    "final_score_multiplier": 1.1,
    "reasoning": {
      "multiplier_justification": "The project demonstrates excellent adherence to Hedera-specific best practices, particularly the robust and correct interaction with Hedera's precompiled smart contracts (HTS, HAS, PRNG). The inclusion of an automated script to parse Hedera protobufs and generate Solidity response codes is a significant positive, showcasing foresight in maintainability and compatibility with platform updates. While the core contracts are wrappers, their implementation is clean and accurate. Gas efficiency is inherently strong due to reliance on optimized Hedera precompiles. These strengths warrant an increase in the preliminary score.",
      "security_assessment": "The Solidity contracts act as thin wrappers around Hedera's precompiled system contracts. As such, they do not introduce typical smart contract vulnerabilities like re-entrancy, logic errors, or complex access control issues themselves. Access control is appropriately handled by the underlying Hedera network's key mechanisms. Integer overflow/underflow is mitigated by Hedera's precompile handling of `int64` and `uint256` inputs; the contracts correctly pass these values. The consistent checking of the `success` flag from precompile calls and returning `HederaResponseCodes.UNKNOWN` upon failure is a good practice for robust error handling. No critical security flaws were identified within the scope of the provided code.",
      "gas_efficiency_assessment": "The smart contracts achieve high gas efficiency by leveraging Hedera's native precompiled contracts. All core functionalities (token operations, account queries, PRNG) are delegated to these highly optimized, pre-built functions on the Hedera network. The Solidity wrappers themselves are minimal, performing simple ABI encoding/decoding and external calls. There are no complex on-chain computations or inefficient storage patterns introduced by these wrapper contracts. The `nonEmptyExpiry` modifier also subtly contributes to clean parameter handling for token creation, avoiding redundant checks in consuming contracts.",
      "sdk_and_hts_usage_assessment": "The project demonstrates a world-class understanding and usage of Hedera's core services. The Solidity contracts correctly interact with the HTS and HAS precompiles (0x167, 0x16a) and the PRNG precompile (0x169), showcasing deep knowledge of on-chain Hedera best practices. Off-chain, the `hedera-response-codes-protobuf-parser.js` script is exceptional, using Axios to fetch Hedera service protobufs and `protobufjs` to generate a Solidity library, ensuring up-to-date response codes. The `freeze-network-node.js` script correctly uses the `@hashgraph/sdk` for network operations, demonstrating practical off-chain SDK usage. The frontend components (`navbar`, `layout`, `page`) suggest proper integration with account management and display, implying robust off-chain interaction with Hedera via a wallet connection.",
      "context_sufficiency_assessment": "The provided code dossier was highly sufficient for this audit, covering key Solidity contracts for Hedera service interaction, and crucial JavaScript files demonstrating off-chain SDK usage and automated tooling. The project description also provided excellent context as a 'reference library.' If one additional file could be provided, `contracts/system-contracts/exchange-rate/SelfFunding.sol` would be helpful to fully understand the `costsCents` modifier and any potential implications for the `ExchangeRateSystemContract`."
    },
    "refined_tech_stack": [
      "Solidity",
      "Hardhat",
      "Hedera Token Service (HTS)",
      "Hedera Account Service (HAS)",
      "Hedera Smart Contracts (EVM)",
      "Hedera JavaScript SDK (@hashgraph/sdk)",
      "Next.js",
      "React",
      "Chakra UI",
      "framer-motion",
      "Protobuf.js",
      "Axios"
    ],
    "holistic_project_summary": "This project is an exemplary reference library for Hedera Smart Contracts, showcasing expert-level integration with the Hedera Token and Account Services via EVM precompiles. Its robust structure, accurate precompile interactions, and clever automated tooling for response code generation position it as a foundational resource for Hedera dApp development. The overall quality and adherence to Hedera best practices are outstanding, making it a highly reliable and educational codebase.",
    "groupsInDossier": 14,
    "dossierCode": "\n\n// =======================================================\n// FILE START: contracts/system-contracts/pseudo-random-number-generator/PrngSystemContract.sol\n// File Impact Score: 64.00\n// =======================================================\n\n\n// --- Group 1 ---\n// Initial Score: { Complexity: 8, Quality: 8.0 }\n// File: contracts/system-contracts/pseudo-random-number-generator/PrngSystemContract.sol\n// Relevant file context:\n// Type: .sol\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.5.0 <0.9.0;\n\nimport \"./IPrngSystemContract.sol\";\n\ncontract PrngSystemContract {\n    event PseudoRandomSeed(bytes32 seedBytes);\n\n    // Prng system contract address with ContractID 0.0.361\n    address constant PRECOMPILE_ADDRESS = address(0x169);\n\n    function getPseudorandomSeed() external returns (bytes32 seedBytes) {\n        (bool success, bytes memory result) = PRECOMPILE_ADDRESS.call(\n            abi.encodeWithSelector(IPrngSystemContract.getPseudorandomSeed.selector));\n        require(success, \"PRNG system call failed\");\n        seedBytes = abi.decode(result, (bytes32));\n        emit PseudoRandomSeed(seedBytes);\n    }\n}\n\n\n// =======================================================\n// FILE START: contracts/system-contracts/hedera-account-service/HederaAccountService.sol\n// File Impact Score: 53.33\n// =======================================================\n\n\n// --- Group 1 ---\n// Initial Score: { Complexity: 8, Quality: 6.7 }\n// File: contracts/system-contracts/hedera-account-service/HederaAccountService.sol\n// Relevant file context:\n// Type: .sol\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.5.0 <0.9.0;\npragma experimental ABIEncoderV2;\n\nimport \"../HederaResponseCodes.sol\";\nimport \"./IHederaAccountService.sol\";\n\nabstract contract HederaAccountService {\n    address constant HASPrecompileAddress = address(0x16a);\n\n    /// Returns the amount of hbars that the spender has been authorized to spend on behalf of the owner.\n    /// @param owner The account that has authorized the spender\n    /// @param spender The account that has been authorized by the owner\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return amount The amount of hbar that the spender has been authorized to spend on behalf of the owner.\n    function hbarAllowance(address owner, address spender) internal returns (int64 responseCode, int256 amount)\n    {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.hbarAllowance.selector,\n                owner, spender));\n        (responseCode, amount) = success ? abi.decode(result, (int32, int256)) : (HederaResponseCodes.UNKNOWN, (int256)(0));\n    }\n\n\n    /// Allows spender to withdraw hbars from the owner account multiple times, up to the value amount. If this function is called\n    /// again it overwrites the current allowance with the new amount.\n    /// @param owner The owner of the hbars\n    /// @param spender the account address authorized to spend\n    /// @param amount the amount of hbars authorized to spend.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function hbarApprove(address owner, address spender, int256 amount) internal returns (int64 responseCode)\n    {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.hbarApprove.selector,\n                owner, spender, amount));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Returns the EVM address alias for a given Hedera account.\n    /// @param accountNumAlias The Hedera account number alias to lookup. Must satisfy all of the following:\n    ///                         - Must be in long-zero format (0x000...0<account_num>)\n    ///                         - Must reference an existing Hedera account\n    ///                         - Referenced account must have an associated EVM address alias\n    /// @return responseCode The response code indicating the status of the request:\n    ///                         - SUCCESS (22) if successful\n    ///                         - INVALID_ACCOUNT_ID (15) if any validation of the accountNumAlias fails\n    ///                         - UNKNOWN (21) if the precompile call fails\n    /// @return evmAddressAlias The EVM address alias associated with the Hedera account, or address(0) if the request fails\n    function getEvmAddressAlias(address accountNumAlias) internal returns (int64 responseCode, address evmAddressAlias) \n    {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.getEvmAddressAlias.selector, accountNumAlias));\n        (responseCode, evmAddressAlias) = success ? abi.decode(result, (int32, address)) : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Returns the Hedera Account ID (as account num alias) for the given EVM address alias\n    /// @param evmAddressAlias The EVM address alias to get the Hedera account for. Must satisfy all of the following:\n    ///                         - Must be in EVM format (not a long-zero address)\n    ///                         - Must reference an existing Hedera account\n    ///                         - Referenced account must have an associated account num alias (long-zero format)\n    /// @return responseCode The response code indicating the status of the request:\n    ///                         - SUCCESS (22) if successful\n    ///                         - INVALID_SOLIDITY_ADDRESS (29) if any validation of the evmAddressAlias fails\n    ///                         - UNKNOWN (21) if the precompile call fails\n    /// @return accountNumAlias The Hedera account's num alias in long-zero format, or address(0) if the request fails\n    function getHederaAccountNumAlias(address evmAddressAlias) internal returns (int64 responseCode, address accountNumAlias) {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.getHederaAccountNumAlias.selector, evmAddressAlias));\n        (responseCode, accountNumAlias) = success ? abi.decode(result, (int32, address)) : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Returns true iff a Hedera account num alias or EVM address alias.\n    /// @param addr Some 20-byte address.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return response true iff addr is a Hedera account num alias or an EVM address alias (and false otherwise).\n    function isValidAlias(address addr) internal returns (int64 responseCode, bool response) {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.isValidAlias.selector, addr));\n        (responseCode, response) = success ? (HederaResponseCodes.SUCCESS, abi.decode(result, (bool))) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Determines if the signature is valid for the given message hash and account.\n    /// It is assumed that the signature is composed of a single EDCSA or ED25519 key.\n    /// @param account The account to check the signature against\n    /// @param messageHash The hash of the message to check the signature against\n    /// @param signature The signature to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return authorized True if the signature is valid, false otherwise\n    function isAuthorizedRaw(address account, bytes memory messageHash, bytes memory signature) internal returns (int64 responseCode, bool authorized) {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.isAuthorizedRaw.selector,\n                account, messageHash, signature));\n        (responseCode, authorized) = success ? (HederaResponseCodes.SUCCESS, abi.decode(result, (bool))) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Determines if the signature is valid for the given message and account.\n    /// It is assumed that the signature is composed of a possibly complex cryptographic key.\n    /// @param account The account to check the signature against.\n    /// @param message The message to check the signature against.\n    /// @param signature The signature to check encoded as bytes.\n    /// @return responseCode The response code for the status of the request.  SUCCESS is 22.\n    /// @return authorized True if the signature is valid, false otherwise.\n    function isAuthorized(address account, bytes memory message, bytes memory signature) internal returns (int64 responseCode, bool authorized) {\n        (bool success, bytes memory result) = HASPrecompileAddress.call(\n            abi.encodeWithSelector(IHederaAccountService.isAuthorized.selector,\n                account, message, signature));\n        (responseCode, authorized) = success ? abi.decode(result, (int32, bool)) : (HederaResponseCodes.UNKNOWN, false);\n    }\n}\n\n\n// =======================================================\n// FILE START: contracts/system-contracts/hedera-token-service/HederaTokenService.sol\n// File Impact Score: 52.73\n// =======================================================\n\n\n// --- Group 1 ---\n// Initial Score: { Complexity: 7, Quality: 7.7 }\n// File: contracts/system-contracts/hedera-token-service/HederaTokenService.sol\n// Relevant file context:\n// Type: .sol\n\n\n// --- Next chunk ---\n\n// Lines 1-65 (.sol_part_1)\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.5.0 <0.9.0;\npragma experimental ABIEncoderV2;\n\nimport \"../HederaResponseCodes.sol\";\nimport \"./IHederaTokenService.sol\";\n\nabstract contract HederaTokenService {\n    address constant precompileAddress = address(0x167);\n    // 90 days in seconds\n    int32 constant defaultAutoRenewPeriod = 7776000;\n\n    modifier nonEmptyExpiry(IHederaTokenService.HederaToken memory token)\n    {\n        if (token.expiry.second == 0 && token.expiry.autoRenewPeriod == 0) {\n            token.expiry.autoRenewPeriod = defaultAutoRenewPeriod;\n        }\n        _;\n    }\n\n    /// Generic event\n    event CallResponseEvent(bool, bytes);\n\n    /// Performs transfers among combinations of tokens and hbars\n    /// @param transferList the list of hbar transfers to do\n    /// @param tokenTransfers the list of transfers to do\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @custom:version 0.3.0 the signature of the previous version was cryptoTransfer(TokenTransferList[] memory tokenTransfers)\n    function cryptoTransfer(IHederaTokenService.TransferList memory transferList, IHederaTokenService.TokenTransferList[] memory tokenTransfers) internal\n    returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.cryptoTransfer.selector, transferList, tokenTransfers));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Mints an amount of the token to the defined treasury account\n    /// @param token The token for which to mint tokens. If token does not exist, transaction results in\n    ///              INVALID_TOKEN_ID\n    /// @param amount Applicable to tokens of type FUNGIBLE_COMMON. The amount to mint to the Treasury Account.\n    ///               Amount must be a positive non-zero number represented in the lowest denomination of the\n    ///               token. The new supply must be lower than 2^63.\n    /// @param metadata Applicable to tokens of type NON_FUNGIBLE_UNIQUE. A list of metadata that are being created.\n    ///                 Maximum allowed size of each metadata is 100 bytes\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return newTotalSupply The new supply of tokens. For NFTs it is the total count of NFTs\n    /// @return serialNumbers If the token is an NFT the newly generate serial numbers, otherwise empty.\n    function mintToken(address token, int64 amount, bytes[] memory metadata) internal\n    returns (int responseCode, int64 newTotalSupply, int64[] memory serialNumbers)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.mintToken.selector,\n            token, amount, metadata));\n        (responseCode, newTotalSupply, serialNumbers) =\n        success\n        ? abi.decode(result, (int32, int64, int64[]))\n        : (HederaResponseCodes.UNKNOWN, int64(0), new int64[](0));\n    }\n\n    /// Burns an amount of the token from the defined treasury account\n    /// @param token The token for which to burn tokens. If token does not exist, transaction results in\n    ///              INVALID_TOKEN_ID\n    /// @param amount  Applicable to tokens of type FUNGIBLE_COMMON. The amount to burn from the Treasury Account.\n    ///                Amount must be a positive non-zero number, not bigger than the token balance of the treasury\n    ///                account (0; balance], represented in the lowest denomination.\n\n// --- Next chunk ---\n\n// Lines 66-119 (.sol_part_2)\n    /// @param serialNumbers Applicable to tokens of type NON_FUNGIBLE_UNIQUE. The list of serial numbers to be burned.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return newTotalSupply The new supply of tokens. For NFTs it is the total count of NFTs\n    function burnToken(address token, int64 amount, int64[] memory serialNumbers) internal\n    returns (int responseCode, int64 newTotalSupply)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.burnToken.selector,\n            token, amount, serialNumbers));\n        (responseCode, newTotalSupply) =\n        success\n        ? abi.decode(result, (int32, int64))\n        : (HederaResponseCodes.UNKNOWN, int64(0));\n    }\n\n    ///  Associates the provided account with the provided tokens. Must be signed by the provided\n    ///  Account's key or called from the accounts contract key\n    ///  If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.\n    ///  If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.\n    ///  If any of the provided tokens is not found, the transaction will resolve to INVALID_TOKEN_REF.\n    ///  If any of the provided tokens has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.\n    ///  If an association between the provided account and any of the tokens already exists, the\n    ///  transaction will resolve to TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT.\n    ///  If the provided account's associations count exceed the constraint of maximum token associations\n    ///    per account, the transaction will resolve to TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED.\n    ///  On success, associations between the provided account and tokens are made and the account is\n    ///    ready to interact with the tokens.\n    /// @param account The account to be associated with the provided tokens\n    /// @param tokens The tokens to be associated with the provided account. In the case of NON_FUNGIBLE_UNIQUE\n    ///               Type, once an account is associated, it can hold any number of NFTs (serial numbers) of that\n    ///               token type\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function associateTokens(address account, address[] memory tokens) internal returns (int responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.associateTokens.selector,\n            account, tokens));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    function associateToken(address account, address token) internal returns (int responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.associateToken.selector,\n            account, token));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Dissociates the provided account with the provided tokens. Must be signed by the provided\n    /// Account's key.\n    /// If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.\n    /// If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.\n    /// If any of the provided tokens is not found, the transaction will resolve to INVALID_TOKEN_REF.\n    /// If any of the provided tokens has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.\n    /// If an association between the provided account and any of the tokens does not exist, the\n    /// transaction will resolve to TOKEN_NOT_ASSOCIATED_TO_ACCOUNT.\n\n// --- Next chunk ---\n\n// Lines 120-177 (.sol_part_3)\n    /// If a token has not been deleted and has not expired, and the user has a nonzero balance, the\n    /// transaction will resolve to TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES.\n    /// If a <b>fungible token</b> has expired, the user can disassociate even if their token balance is\n    /// not zero.\n    /// If a <b>non fungible token</b> has expired, the user can <b>not</b> disassociate if their token\n    /// balance is not zero. The transaction will resolve to TRANSACTION_REQUIRED_ZERO_TOKEN_BALANCES.\n    /// On success, associations between the provided account and tokens are removed.\n    /// @param account The account to be dissociated from the provided tokens\n    /// @param tokens The tokens to be dissociated from the provided account.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function dissociateTokens(address account, address[] memory tokens) internal returns (int responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.dissociateTokens.selector,\n            account, tokens));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    function dissociateToken(address account, address token) internal returns (int responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.dissociateToken.selector,\n            account, token));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Creates a Fungible Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @param initialTotalSupply Specifies the initial supply of tokens to be put in circulation. The\n    /// initial supply is sent to the Treasury Account. The supply is in the lowest denomination possible.\n    /// @param decimals the number of decimal places a token is divisible by\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createFungibleToken(\n        IHederaTokenService.HederaToken memory token,\n        int64 initialTotalSupply,\n        int32 decimals) nonEmptyExpiry(token)\n    internal returns (int responseCode, address tokenAddress) {\n        (bool success, bytes memory result) = precompileAddress.call{value : msg.value}(\n            abi.encodeWithSelector(IHederaTokenService.createFungibleToken.selector,\n            token, initialTotalSupply, decimals));\n\n\n        (responseCode, tokenAddress) = success ? abi.decode(result, (int32, address)) : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Creates a Fungible Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @param initialTotalSupply Specifies the initial supply of tokens to be put in circulation. The\n    /// initial supply is sent to the Treasury Account. The supply is in the lowest denomination possible.\n    /// @param decimals the number of decimal places a token is divisible by\n    /// @param fixedFees list of fixed fees to apply to the token\n    /// @param fractionalFees list of fractional fees to apply to the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createFungibleTokenWithCustomFees(\n        IHederaTokenService.HederaToken memory token,\n        int64 initialTotalSupply,\n        int32 decimals,\n        IHederaTokenService.FixedFee[] memory fixedFees,\n\n// --- Group 2 ---\n// Initial Score: { Complexity: 7, Quality: 7.7 }\n// File: contracts/system-contracts/hedera-token-service/HederaTokenService.sol\n// Relevant file context:\n// Type: .sol\n\n\n// --- Next chunk ---\n\n// Lines 178-228 (.sol_part_4)\n        IHederaTokenService.FractionalFee[] memory fractionalFees) nonEmptyExpiry(token)\n    internal returns (int responseCode, address tokenAddress) {\n        (bool success, bytes memory result) = precompileAddress.call{value : msg.value}(\n            abi.encodeWithSelector(IHederaTokenService.createFungibleTokenWithCustomFees.selector,\n            token, initialTotalSupply, decimals, fixedFees, fractionalFees));\n        (responseCode, tokenAddress) = success ? abi.decode(result, (int32, address)) : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Creates an Non Fungible Unique Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createNonFungibleToken(IHederaTokenService.HederaToken memory token) nonEmptyExpiry(token)\n    internal returns (int responseCode, address tokenAddress) {\n        (bool success, bytes memory result) = precompileAddress.call{value : msg.value}(\n            abi.encodeWithSelector(IHederaTokenService.createNonFungibleToken.selector, token));\n        (responseCode, tokenAddress) = success ? abi.decode(result, (int32, address)) : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Creates an Non Fungible Unique Token with the specified properties\n    /// @param token the basic properties of the token being created\n    /// @param fixedFees list of fixed fees to apply to the token\n    /// @param royaltyFees list of royalty fees to apply to the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenAddress the created token's address\n    function createNonFungibleTokenWithCustomFees(\n        IHederaTokenService.HederaToken memory token,\n        IHederaTokenService.FixedFee[] memory fixedFees,\n        IHederaTokenService.RoyaltyFee[] memory royaltyFees) nonEmptyExpiry(token)\n    internal returns (int responseCode, address tokenAddress) {\n        (bool success, bytes memory result) = precompileAddress.call{value : msg.value}(\n            abi.encodeWithSelector(IHederaTokenService.createNonFungibleTokenWithCustomFees.selector,\n            token, fixedFees, royaltyFees));\n        (responseCode, tokenAddress) = success ? abi.decode(result, (int32, address)) : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Retrieves fungible specific token info for a fungible token\n    /// @param token The ID of the token as a solidity address\n    /// @dev This function reverts if the call is not successful\n    function getFungibleTokenInfo(address token) internal returns (int responseCode, IHederaTokenService.FungibleTokenInfo memory tokenInfo) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getFungibleTokenInfo.selector, token));\n        IHederaTokenService.FungibleTokenInfo memory defaultTokenInfo;\n        (responseCode, tokenInfo) = success ? abi.decode(result, (int32, IHederaTokenService.FungibleTokenInfo)) : (HederaResponseCodes.UNKNOWN, defaultTokenInfo);\n    }\n\n    /// Retrieves general token info for a given token\n    /// @param token The ID of the token as a solidity address\n    /// @dev This function reverts if the call is not successful\n    function getTokenInfo(address token) internal returns (int responseCode, IHederaTokenService.TokenInfo memory tokenInfo) {\n        (bool success, bytes memory result) = precompileAddress.call(\n\n// --- Next chunk ---\n\n// Lines 229-282 (.sol_part_5)\n            abi.encodeWithSelector(IHederaTokenService.getTokenInfo.selector, token));\n        IHederaTokenService.TokenInfo memory defaultTokenInfo;\n        (responseCode, tokenInfo) = success ? abi.decode(result, (int32, IHederaTokenService.TokenInfo)) : (HederaResponseCodes.UNKNOWN, defaultTokenInfo);\n    }\n\n    /// Retrieves non-fungible specific token info for a given NFT\n    /// @param token The ID of the token as a solidity address\n    /// @dev This function reverts if the call is not successful\n    function getNonFungibleTokenInfo(address token, int64 serialNumber) internal returns (int responseCode, IHederaTokenService.NonFungibleTokenInfo memory tokenInfo) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getNonFungibleTokenInfo.selector, token, serialNumber));\n        IHederaTokenService.NonFungibleTokenInfo memory defaultTokenInfo;\n        (responseCode, tokenInfo) = success ? abi.decode(result, (int32, IHederaTokenService.NonFungibleTokenInfo)) : (HederaResponseCodes.UNKNOWN, defaultTokenInfo);\n    }\n\n    /// Query token custom fees\n    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return fixedFees Set of fixed fees for `token`\n    /// @return fractionalFees Set of fractional fees for `token`\n    /// @return royaltyFees Set of royalty fees for `token`\n    /// @dev This function reverts if the call is not successful\n    function getTokenCustomFees(address token) internal returns (int64 responseCode,\n        IHederaTokenService.FixedFee[] memory fixedFees,\n        IHederaTokenService.FractionalFee[] memory fractionalFees,\n        IHederaTokenService.RoyaltyFee[] memory royaltyFees) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getTokenCustomFees.selector, token));\n        IHederaTokenService.FixedFee[] memory defaultFixedFees;\n        IHederaTokenService.FractionalFee[] memory defaultFractionalFees;\n        IHederaTokenService.RoyaltyFee[] memory defaultRoyaltyFees;\n        (responseCode, fixedFees, fractionalFees, royaltyFees) =\n        success ? abi.decode\n        (result, (int32, IHederaTokenService.FixedFee[], IHederaTokenService.FractionalFee[], IHederaTokenService.RoyaltyFee[]))\n        : (HederaResponseCodes.UNKNOWN, defaultFixedFees, defaultFractionalFees, defaultRoyaltyFees);\n    }\n\n    /// Allows spender to withdraw from your account multiple times, up to the value amount. If this function is called\n    /// again it overwrites the current allowance with value.\n    /// Only Applicable to Fungible Tokens\n    /// @param token The hedera token address to approve\n    /// @param spender the account authorized to spend\n    /// @param amount the amount of tokens authorized to spend.\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function approve(address token, address spender, uint256 amount) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.approve.selector,\n            token, spender, amount));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Transfers `amount` tokens from `from` to `to` using the\n    //  allowance mechanism. `amount` is then deducted from the caller's allowance.\n\n// --- Next chunk ---\n\n// Lines 283-342 (.sol_part_6)\n    /// Only applicable to fungible tokens\n    /// @param token The address of the fungible Hedera token to transfer\n    /// @param from The account address of the owner of the token, on the behalf of which to transfer `amount` tokens\n    /// @param to The account address of the receiver of the `amount` tokens\n    /// @param amount The amount of tokens to transfer from `from` to `to`\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function transferFrom(address token, address from, address to, uint256 amount) external returns (int64 responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.transferFrom.selector,\n            token, from, to, amount));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Transfers `serialNumber` of `token` from `from` to `to` using the allowance mechanism.\n    /// Only applicable to NFT tokens\n    /// @param token The address of the non-fungible Hedera token to transfer\n    /// @param from The account address of the owner of `serialNumber` of `token`\n    /// @param to The account address of the receiver of `serialNumber`\n    /// @param serialNumber The NFT serial number to transfer\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function transferFromNFT(address token, address from, address to, uint256 serialNumber) external returns (int64 responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.transferFromNFT.selector,\n            token, from, to, serialNumber));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Returns the amount which spender is still allowed to withdraw from owner.\n    /// Only Applicable to Fungible Tokens\n    /// @param token The Hedera token address to check the allowance of\n    /// @param owner the owner of the tokens to be spent\n    /// @param spender the spender of the tokens\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function allowance(address token, address owner, address spender) internal returns (int responseCode, uint256 amount)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.allowance.selector,\n            token, owner, spender));\n        (responseCode, amount) = success ? abi.decode(result, (int32, uint256)) : (HederaResponseCodes.UNKNOWN, 0);\n    }\n\n    /// Allow or reaffirm the approved address to transfer an NFT the approved address does not own.\n    /// Only Applicable to NFT Tokens\n    /// @param token The Hedera NFT token address to approve\n    /// @param approved The new approved NFT controller.  To revoke approvals pass in the zero address.\n    /// @param serialNumber The NFT serial number  to approve\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function approveNFT(address token, address approved, uint256 serialNumber) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.approveNFT.selector,\n            token, approved, serialNumber));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Get the approved address for a single NFT\n    /// Only Applicable to NFT Tokens\n    /// @param token The Hedera NFT token address to check approval\n\n// --- Group 3 ---\n// Initial Score: { Complexity: 7, Quality: 7.7 }\n// File: contracts/system-contracts/hedera-token-service/HederaTokenService.sol\n// Relevant file context:\n// Type: .sol\n\n\n// --- Next chunk ---\n\n// Lines 343-403 (.sol_part_7)\n    /// @param serialNumber The NFT to find the approved address for\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return approved The approved address for this NFT, or the zero address if there is none\n    function getApproved(address token, uint256 serialNumber) internal returns (int responseCode, address approved)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getApproved.selector,\n            token, serialNumber));\n        (responseCode, approved) =\n        success\n        ? abi.decode(result, (int32, address))\n        : (HederaResponseCodes.UNKNOWN, address(0));\n    }\n\n    /// Query if token account is frozen\n    /// @param token The token address to check\n    /// @param account The account address associated with the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return frozen True if `account` is frozen for `token`\n    /// @dev This function reverts if the call is not successful\n    function isFrozen(address token, address account) internal returns (int64 responseCode, bool frozen){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.isFrozen.selector, token, account));\n        (responseCode, frozen) = success ? abi.decode(result, (int32, bool)) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Query if token account has kyc granted\n    /// @param token The token address to check\n    /// @param account The account address associated with the token\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return kycGranted True if `account` has kyc granted for `token`\n    /// @dev This function reverts if the call is not successful\n    function isKyc(address token, address account) internal returns (int64 responseCode, bool kycGranted){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.isKyc.selector, token, account));\n        (responseCode, kycGranted) = success ? abi.decode(result, (int32, bool)) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Operation to freeze token account\n    /// @param token The token address\n    /// @param account The account address to be frozen\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function freezeToken(address token, address account) internal returns (int64 responseCode){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.freezeToken.selector, token, account));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to unfreeze token account\n    /// @param token The token address\n    /// @param account The account address to be unfrozen\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function unfreezeToken(address token, address account) internal returns (int64 responseCode){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.unfreezeToken.selector, token, account));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to grant kyc to token account\n    /// @param token The token address\n    /// @param account The account address to grant kyc\n\n// --- Next chunk ---\n\n// Lines 404-464 (.sol_part_8)\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function grantTokenKyc(address token, address account) internal returns (int64 responseCode){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.grantTokenKyc.selector, token, account));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to revoke kyc to token account\n    /// @param token The token address\n    /// @param account The account address to revoke kyc\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function revokeTokenKyc(address token, address account) internal returns (int64 responseCode){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.revokeTokenKyc.selector, token, account));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Enable or disable approval for a third party (\"operator\") to manage\n    ///  all of `msg.sender`'s assets\n    /// @param token The Hedera NFT token address to approve\n    /// @param operator Address to add to the set of authorized operators\n    /// @param approved True if the operator is approved, false to revoke approval\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function setApprovalForAll(address token, address operator, bool approved) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.setApprovalForAll.selector,\n            token, operator, approved));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Query if an address is an authorized operator for another address\n    /// Only Applicable to NFT Tokens\n    /// @param token The Hedera NFT token address to approve\n    /// @param owner The address that owns the NFTs\n    /// @param operator The address that acts on behalf of the owner\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return approved True if `operator` is an approved operator for `owner`, false otherwise\n    function isApprovedForAll(address token, address owner, address operator) internal returns (int responseCode, bool approved)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.isApprovedForAll.selector,\n            token, owner, operator));\n        (responseCode, approved) =\n        success\n        ? abi.decode(result, (int32, bool))\n        : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Query token default freeze status\n    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return defaultFreezeStatus True if `token` default freeze status is frozen.\n    /// @dev This function reverts if the call is not successful\n    function getTokenDefaultFreezeStatus(address token) internal returns (int responseCode, bool defaultFreezeStatus) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getTokenDefaultFreezeStatus.selector, token));\n        (responseCode, defaultFreezeStatus) = success ? abi.decode(result, (int32, bool)) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Query token default kyc status\n\n// --- Next chunk ---\n\n// Lines 465-528 (.sol_part_9)\n    /// @param token The token address to check\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return defaultKycStatus True if `token` default kyc status is KycNotApplicable and false if Revoked.\n    /// @dev This function reverts if the call is not successful\n    function getTokenDefaultKycStatus(address token) internal returns (int responseCode, bool defaultKycStatus) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getTokenDefaultKycStatus.selector, token));\n        (responseCode, defaultKycStatus) = success ? abi.decode(result, (int32, bool)) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /**********************\n     * ABI v1 calls       *\n     **********************/\n\n    /// Initiates a Fungible Token Transfer\n    /// @param token The ID of the token as a solidity address\n    /// @param accountIds account to do a transfer to/from\n    /// @param amounts The amount from the accountId at the same index\n    function transferTokens(address token, address[] memory accountIds, int64[] memory amounts) internal\n    returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.transferTokens.selector,\n            token, accountIds, amounts));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Initiates a Non-Fungable Token Transfer\n    /// @param token The ID of the token as a solidity address\n    /// @param sender the sender of an nft\n    /// @param receiver the receiver of the nft sent by the same index at sender\n    /// @param serialNumber the serial number of the nft sent by the same index at sender\n    function transferNFTs(address token, address[] memory sender, address[] memory receiver, int64[] memory serialNumber)\n    internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.transferNFTs.selector,\n            token, sender, receiver, serialNumber));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Transfers tokens where the calling account/contract is implicitly the first entry in the token transfer list,\n    /// where the amount is the value needed to zero balance the transfers. Regular signing rules apply for sending\n    /// (positive amount) or receiving (negative amount)\n    /// @param token The token to transfer to/from\n    /// @param sender The sender for the transaction\n    /// @param receiver The receiver of the transaction\n    /// @param amount Non-negative value to send. a negative value will result in a failure.\n    function transferToken(address token, address sender, address receiver, int64 amount) internal\n    returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.transferToken.selector,\n            token, sender, receiver, amount));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Transfers tokens where the calling account/contract is implicitly the first entry in the token transfer list,\n    /// where the amount is the value needed to zero balance the transfers. Regular signing rules apply for sending\n    /// (positive amount) or receiving (negative amount)\n    /// @param token The token to transfer to/from\n    /// @param sender The sender for the transaction\n    /// @param receiver The receiver of the transaction\n    /// @param serialNumber The serial number of the NFT to transfer.\n\n// --- Group 4 ---\n// Initial Score: { Complexity: 8, Quality: 7.3 }\n// File: contracts/system-contracts/hedera-token-service/HederaTokenService.sol\n// Relevant file context:\n// Type: .sol\n\n\n// --- Next chunk ---\n\n// Lines 529-597 (.sol_part_10)\n    function transferNFT(address token, address sender, address receiver, int64 serialNumber) internal\n    returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.transferNFT.selector,\n            token, sender, receiver, serialNumber));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to pause token\n    /// @param token The token address to be paused\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function pauseToken(address token) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.pauseToken.selector, token));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to unpause token\n    /// @param token The token address to be unpaused\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function unpauseToken(address token) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.unpauseToken.selector, token));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to wipe fungible tokens from account\n    /// @param token The token address\n    /// @param account The account address to revoke kyc\n    /// @param amount The number of tokens to wipe\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function wipeTokenAccount(address token, address account, int64 amount) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.wipeTokenAccount.selector, token, account, amount));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to wipe non fungible tokens from account\n    /// @param token The token address\n    /// @param account The account address to revoke kyc\n    /// @param  serialNumbers The serial numbers of token to wipe\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function wipeTokenAccountNFT(address token, address account, int64[] memory serialNumbers) internal\n    returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.wipeTokenAccountNFT.selector, token, account, serialNumbers));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to delete token\n    /// @param token The token address\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function deleteToken(address token) internal returns (int responseCode)\n    {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.deleteToken.selector, token));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to update token keys\n    /// @param token The token address\n    /// @param keys The token keys\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateTokenKeys(address token, IHederaTokenService.TokenKey[] memory keys)\n\n// --- Next chunk ---\n\n// Lines 598-650 (.sol_part_11)\n    internal returns (int64 responseCode){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.updateTokenKeys.selector, token, keys));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Query token KeyValue\n    /// @param token The token address to check\n    /// @param keyType The keyType of the desired KeyValue\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return key KeyValue info for key of type `keyType`\n    /// @dev This function reverts if the call is not successful\n    function getTokenKey(address token, uint keyType)\n    internal returns (int64 responseCode, IHederaTokenService.KeyValue memory key){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getTokenKey.selector, token, keyType));\n        IHederaTokenService.KeyValue memory defaultKeyValueInfo;\n        (responseCode, key) = success ? abi.decode(result, (int32,IHederaTokenService.KeyValue) ) : (HederaResponseCodes.UNKNOWN, defaultKeyValueInfo);\n    }\n\n\n    /// Query if valid token found for the given address\n    /// @param token The token address\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return isTokenFlag True if valid token found for the given address\n    /// @dev This function reverts if the call is not successful\n    function isToken(address token) internal returns (int64 responseCode, bool isTokenFlag) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.isToken.selector, token));\n        (responseCode, isTokenFlag) = success ? abi.decode(result, (int32, bool)) : (HederaResponseCodes.UNKNOWN, false);\n    }\n\n    /// Query to return the token type for a given address\n    /// @param token The token address\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return tokenType the token type. 0 is FUNGIBLE_COMMON, 1 is NON_FUNGIBLE_UNIQUE, -1 is UNRECOGNIZED\n    /// @dev This function reverts if the call is not successful\n    function getTokenType(address token) internal returns (int64 responseCode, int32 tokenType) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getTokenType.selector, token));\n        (responseCode, tokenType) = success ? abi.decode(result, (int32, int32)) : (HederaResponseCodes.UNKNOWN, - 1);\n    }\n\n    /// Operation to get token expiry info\n    /// @param token The token address\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return expiryInfo The expiry info of the token\n    /// @dev This function reverts if the call is not successful\n    function getTokenExpiryInfo(address token) internal returns (int responseCode, IHederaTokenService.Expiry memory expiryInfo){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.getTokenExpiryInfo.selector, token));\n        IHederaTokenService.Expiry memory defaultExpiryInfo;\n        (responseCode, expiryInfo) = success ? abi.decode(result, (int32, IHederaTokenService.Expiry)) : (HederaResponseCodes.UNKNOWN, defaultExpiryInfo);\n\n// --- Next chunk ---\n\n// Lines 651-704 (.sol_part_12)\n    }\n\n    /// Operation to update token expiry info\n    /// @param token The token address\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateTokenExpiryInfo(address token, IHederaTokenService.Expiry memory expiryInfo) internal returns (int responseCode){\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.updateTokenExpiryInfo.selector, token, expiryInfo));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Operation to update token info\n    /// @param token The token address\n    /// @param tokenInfo The hedera token info to update token with\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateTokenInfo(address token, IHederaTokenService.HederaToken memory tokenInfo) internal returns (int responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.updateTokenInfo.selector, token, tokenInfo));\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Redirect for token\n    /// @param token The token address\n    /// @param encodedFunctionSelector The function selector from the ERC20 interface + the bytes input for the function called\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    /// @return response The result of the call that had been encoded and sent for execution.\n    function redirectForToken(address token, bytes memory encodedFunctionSelector) external returns (int responseCode, bytes memory response) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.redirectForToken.selector, token, encodedFunctionSelector)\n        );\n\n        emit CallResponseEvent(success, result);\n        (responseCode, response) = success ? (HederaResponseCodes.SUCCESS, result) : (HederaResponseCodes.UNKNOWN, bytes(\"\"));\n    }\n\n    /// Update the custom fees for a fungible token\n    /// @param token The token address\n    /// @param fixedFees Set of fixed fees for `token`\n    /// @param fractionalFees Set of fractional fees for `token`\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateFungibleTokenCustomFees(address token,  IHederaTokenService.FixedFee[] memory fixedFees, IHederaTokenService.FractionalFee[] memory fractionalFees) internal returns (int64 responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.updateFungibleTokenCustomFees.selector, token, fixedFees, fractionalFees));\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// Update the custom fees for a non-fungible token\n    /// @param token The token address\n    /// @param fixedFees Set of fixed fees for `token`\n    /// @param royaltyFees Set of royalty fees for `token`\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function updateNonFungibleTokenCustomFees(address token, IHederaTokenService.FixedFee[] memory fixedFees, IHederaTokenService.RoyaltyFee[] memory royaltyFees) internal returns (int64 responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.updateNonFungibleTokenCustomFees.selector, token, fixedFees, royaltyFees));\n\n// --- Group 5 ---\n// Initial Score: { Complexity: 6, Quality: 7.3 }\n// File: contracts/system-contracts/hedera-token-service/HederaTokenService.sol\n// Relevant file context:\n// Type: .sol\n\n\n// --- Next chunk ---\n\n// Lines 705-750 (.sol_part_13)\n        responseCode = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// @notice Airdrop one or more tokens to one or more accounts\n    /// @param tokenTransfers Array of token transfer lists containing token addresses and recipient details\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function airdropTokens(IHederaTokenService.TokenTransferList[] memory tokenTransfers) internal returns (int64 responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.airdropTokens.selector, tokenTransfers));\n\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// @notice Cancels pending airdrops that have not yet been claimed\n    /// @param pendingAirdrops Array of pending airdrops to cancel\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function cancelAirdrops(IHederaTokenService.PendingAirdrop[] memory pendingAirdrops) internal returns (int64 responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.cancelAirdrops.selector, pendingAirdrops)\n        );\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// @notice Claims pending airdrops that were sent to the calling account\n    /// @param pendingAirdrops Array of pending airdrops to claim\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function claimAirdrops(IHederaTokenService.PendingAirdrop[] memory pendingAirdrops) internal returns (int64 responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.claimAirdrops.selector, pendingAirdrops)\n        );\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n\n    /// @notice Rejects one or more tokens by transferring their full balance from the requesting account to the treasury\n    /// @param rejectingAddress The address rejecting the tokens\n    /// @param ftAddresses Array of fungible token addresses to reject\n    /// @param nftIds Array of NFT IDs to reject\n    /// @return responseCode The response code for the status of the request. SUCCESS is 22.\n    function rejectTokens(address rejectingAddress, address[] memory ftAddresses, IHederaTokenService.NftID[] memory nftIds) internal returns (int64 responseCode) {\n        (bool success, bytes memory result) = precompileAddress.call(\n            abi.encodeWithSelector(IHederaTokenService.rejectTokens.selector, rejectingAddress, ftAddresses, nftIds)\n        );\n        (responseCode) = success ? abi.decode(result, (int32)) : HederaResponseCodes.UNKNOWN;\n    }\n}\n\n\n// =======================================================\n// FILE START: scripts/hedera-response-codes-protobuf-parser.js\n// File Impact Score: 49.00\n// =======================================================\n\n\n// --- Group 1 ---\n// Initial Score: { Complexity: 7, Quality: 7.0 }\n// File: scripts/hedera-response-codes-protobuf-parser.js\n// Relevant file context:\n// Type: .js\n// SPDX-License-Identifier: Apache-2.0\n\nconst fs = require('fs');\nconst axios = require('axios');\nconst protobufjs = require('protobufjs');\n\nasync function main() {\n  const version = (await axios.get('https://raw.githubusercontent.com/hashgraph/hedera-services/refs/heads/main/version.txt')).data.replace('\\n', '');\n  const res = (await axios.get('https://raw.githubusercontent.com/hashgraph/hedera-services/refs/heads/main/hapi/hedera-protobufs/services/response_code.proto')).data;\n  const parsedProto = protobufjs.parse(res, {\n    keepCase: true,\n    alternateCommentMode: true,\n    preferTrailingComment: true\n  });\n  const responseCodes = parsedProto.root.nested.proto.nested.ResponseCodeEnum;\n\n  let contract =\n      `// SPDX-License-Identifier: Apache-2.0\\n` +\n      `pragma solidity >=0.4.9 <0.9.0;\\n` +\n      `\\n// this contract is auto-generated by a manual triggered script in utils/hedera-response-codes-protobuf-parser.js` +\n      `\\n// the generated contract is using hedera response codes from services version ${version}` +\n      `\\n// https://github.com/hashgraph/hedera-services/blob/main/hapi/hedera-protobufs/services/response_code.proto\\n\\n` +\n      `library HederaResponseCodes {\\n`;\n  for (const [name, code] of Object.entries(responseCodes.values)) {\n    const comment = responseCodes?.comments[name];\n    if (comment) {\n      contract += `    /// ${comment.replaceAll('\\n', ' ') ?? ''}\\n`;\n    }\n    contract += `    int32 internal constant ${name} = ${code};\\n\\n`;\n  }\n  contract += '}\\n';\n\n  console.log(`The generated contract is using hedera response codes from services version ${version}`);\n\n  fs.writeFileSync('./contracts/system-contracts/HederaResponseCodes.sol', contract);\n}\n\nmain();\n\n\n// =======================================================\n// FILE START: system-contract-dapp-playground/src/components/navbar/index.tsx\n// File Impact Score: 42.00\n// =======================================================\n\n\n// --- Group 1 ---\n// Initial Score: { Complexity: 6, Quality: 7.0 }\n// File: system-contract-dapp-playground/src/components/navbar/index.tsx\n// Relevant file context:\n// Type: .tsx\n// SPDX-License-Identifier: Apache-2.0\n\n'use client';\n\nimport Link from 'next/link';\nimport Image from 'next/image';\nimport { motion } from 'framer-motion';\nimport WalletPopup from '../wallet-popup';\nimport { useToast } from '@chakra-ui/react';\nimport { useEffect, useState } from 'react';\nimport { TNetworkName } from '@/types/common';\nimport { usePathname } from 'next/navigation';\nimport { BsChevronDown } from 'react-icons/bs';\nimport { CommonErrorToast } from '../toast/CommonToast';\nimport { isProtectedRoute } from '@/utils/common/helpers';\nimport { loadAccountInfoFromCookies } from '@/api/cookies';\nimport { navVariants } from '@/libs/framer-motion/variants';\nimport { HEDERA_COMMON_WALLET_REVERT_REASONS } from '@/utils/common/constants';\n\nconst Navbar = () => {\n  // local states\n  const toaster = useToast();\n  const pathname = usePathname();\n  const [accounts, setAccounts] = useState<string[]>([]);\n  const [isConnected, setIsConnected] = useState(false);\n  const [didWalletPop, setDidWalletPop] = useState(false);\n  const [network, setNetwork] = useState<TNetworkName>('testnet');\n\n  // listen to pathname change event to retrieve account information cookies\n  useEffect(() => {\n    if (isProtectedRoute(pathname)) {\n      // retrieve account info from cookies\n      const accountsInfo = loadAccountInfoFromCookies();\n\n      // just best pratice to handle error as this would rarely happen as we have already gated all the checks in middleware.js\n      if (\n        !accountsInfo.isConnected ||\n        !accountsInfo.accounts ||\n        !accountsInfo.network ||\n        accountsInfo.error\n      ) {\n        CommonErrorToast({\n          toaster,\n          title: 'Error retrieving account information',\n          description: HEDERA_COMMON_WALLET_REVERT_REASONS.DEFAULT.description,\n        });\n        return;\n      }\n\n      // update states\n      setAccounts(JSON.parse(accountsInfo.accounts));\n      setIsConnected(JSON.parse(accountsInfo.isConnected));\n      setNetwork(JSON.parse(accountsInfo.network) as TNetworkName);\n    }\n  }, [pathname, toaster]);\n\n  return (\n    <motion.nav\n      initial={{ opacity: 0 }}\n      whileInView={{ opacity: 1 }}\n      transition={{\n        delay: 0.3,\n        duration: 0.3,\n      }}\n      viewport={{ once: true }}\n      className=\"px-6 pt-6 flex flex-col justify-between items-center z-50\"\n    >\n      {/* Protected Navbar */}\n      {isConnected ? (\n        <div className=\"grid grid-rows-2 sm:grid-rows-1 sm:grid-cols-2 lg:grid-cols-3 w-full justify-center gap-3 pb-6\">\n          {/* Logo */}\n          <Link href={'/'} className=\"flex gap-3 items-center justify-center sm:justify-start\">\n            <Image\n              src={'/brandings/hedera-logomark.svg'}\n              alt={'hedera-logomark'}\n              width={50}\n              height={50}\n              className=\"z-50\"\n            />\n            <p className=\"text-white text-[2rem]\">Hedera</p>\n          </Link>\n\n          {/* DApp playground */}\n          <div className=\"hidden lg:flex lg:gap-1 lg:items-center lg:justify-center\">\n            <div className=\"flex justify-center items-center text-hedera-green\">\n              <div className=\"rounded-r-[9px] border-hedera-green w-[52px] h-[27px] border-[5px] mt-1\" />\n              <div className=\"font-medium text-[2rem] uppercase\">App</div>\n            </div>\n\n            {/* Playground */}\n            <div className=\"uppercase text-[2rem] bg-clip-text text-white\">Playground</div>\n          </div>\n\n          {/* wallet info */}\n          <div className=\"text-white flex justify-end\">\n            {/* wallet wrapper */}\n            <div\n              className=\"bg-gradient-to-r from-hedera-gradient-2-lime/60 to-hedera-gradient-2-teal rounded-lg flex items-center px-3 cursor-pointer\"\n              onClick={() => {\n                setDidWalletPop(true);\n              }}\n            >\n              {/* logo */}\n              <Image src={'/brandings/hedera-logomark.svg'} alt={'hedera-logomark'} width={30} height={30} />\n\n              {/* vertical bar */}\n              <div className=\"bg-white/30 w-[1px] h-full mx-3\" />\n\n              {/* address */}\n              <p className=\"text-lg font-medium\">\n                {accounts[0].slice(0, 7)}...{accounts[0].slice(-5)}\n              </p>\n\n              {/* downward arrow */}\n              <div className=\"text-xl ml-1\">\n                <BsChevronDown />\n              </div>\n            </div>\n          </div>\n        </div>\n      ) : (\n        <motion.div\n          variants={navVariants}\n          initial=\"hidden\"\n          whileInView=\"show\"\n          viewport={{ once: true }}\n          className=\"flex justify-between w-full\"\n        >\n          {/* Unprotected Navbar */}\n          <Link href={'/'}>\n            {/* Logo */}\n            <Image\n              src={'/brandings/hedera-logomark.svg'}\n              alt={'hedera-logomark'}\n              width={50}\n              height={50}\n              className=\"z-50\"\n            />\n          </Link>\n\n          {/* Text logo */}\n          <p className=\"text-white text-[2rem]\">Hedera</p>\n        </motion.div>\n      )}\n\n      {isConnected && <hr className=\"w-[99vw] border-t border-white/40\" />}\n\n      {didWalletPop && (\n        <WalletPopup network={network} userAddress={accounts[0]} setIsOpen={setDidWalletPop} />\n      )}\n    </motion.nav>\n  );\n};\n\nexport default Navbar;\n\n\n// =======================================================\n// FILE START: contracts/system-contracts/exchange-rate/ExchangeRateSystemContract.sol\n// File Impact Score: 40.00\n// =======================================================\n\n\n// --- Group 1 ---\n// Initial Score: { Complexity: 6, Quality: 6.7 }\n// File: contracts/system-contracts/exchange-rate/ExchangeRateSystemContract.sol\n// Relevant file context:\n// Type: .sol\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.5.0 <0.9.0;\n\nimport \"./SelfFunding.sol\";\n\n\ncontract ExchangeRateSystemContract is SelfFunding {\n    // The USD in cents that must be sent as msg.value\n    uint256 toll;\n\n    constructor(uint256 _toll) {\n        toll = _toll;\n    }\n\n    function gatedAccess() external payable costsCents(toll) {\n        // Hope it was worth it!\n    }\n\n    function approxUsdValue() external payable returns (uint256 tinycents) {\n        tinycents = tinybarsToTinycents(msg.value);\n    }\n\n    function invalidCall() external payable {\n        // Should fail, this is not a valid selector \n        (bool success, ) = PRECOMPILE_ADDRESS.call(\n            abi.encodeWithSelector(ExchangeRateSystemContract.approxUsdValue.selector));\n        require(success);\n    }\n}\n\n\n// =======================================================\n// FILE START: system-contract-dapp-playground/src/app/layout.tsx\n// File Impact Score: 36.00\n// =======================================================\n\n\n// --- Group 1 ---\n// Initial Score: { Complexity: 4, Quality: 9.0 }\n// File: system-contract-dapp-playground/src/app/layout.tsx\n// Relevant file context:\n// Type: .tsx\n// SPDX-License-Identifier: Apache-2.0\n\nimport '@/styles/globals.css';\nimport StyreneAWebFont from '@/fonts';\nimport dappMetadata from '@/utils/common/metadata';\nimport ChakraUIProviders from '@/libs/chakra/provider';\nimport BgGradient from '@/components/background-gradients';\n\n/** @notice Root Layout */\nexport default function RootLayout({ children }: { children: React.ReactNode }) {\n  return (\n    <html lang=\"en\" className={`${StyreneAWebFont.variable}`}>\n      <body className=\"bg-primary font-styrene\">\n        <ChakraUIProviders>\n          <div className=\"relative 2xl:max-w-[100rem] 2xl:mx-auto\">\n            {children}\n            <BgGradient />\n          </div>\n        </ChakraUIProviders>\n      </body>\n    </html>\n  );\n}\n\n/** @notice export metadata for SEO */\nexport const metadata = dappMetadata;\n\n\n// =======================================================\n// FILE START: scripts/freeze-network-node.js\n// File Impact Score: 31.67\n// =======================================================\n\n\n// --- Group 1 ---\n// Initial Score: { Complexity: 5, Quality: 6.3 }\n// File: scripts/freeze-network-node.js\n// Relevant file context:\n// Type: .js\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * @notice this scripts is mainly designed to freeze the local network node to prepare for network migration (mono to mod)\n */\nconst {\n  FreezeTransaction,\n  Client,\n  Timestamp,\n  FreezeType,\n} = require('@hashgraph/sdk');\nconst { OPERATOR_ID_A, OPERATOR_KEY_A } = require('../utils/constants');\n\nasync function main() {\n  try {\n    // notice: currently this setup is only used to freeze a single network node locally.\n    const genesisClient = Client.forNetwork({\n      '127.0.0.1:50211': '0.0.3',\n    }).setOperator(OPERATOR_ID_A, OPERATOR_KEY_A);\n\n    const validStart = new Timestamp(Math.round((Date.now() + 5000) / 1000), 0); // timestamp now +  5 sec\n    const tx = new FreezeTransaction()\n      .setStartTimestamp(validStart)\n      .setFreezeType(new FreezeType(1)) // FreezeOnly\n      .freezeWith(genesisClient);\n    const execTx = await tx.execute(genesisClient);\n    await execTx.getReceipt(genesisClient);\n  } catch (e) {\n    if (e.message.includes('GrpcServiceError: read ECONNRESET')) {\n      console.log('The platform has been frozen successfully.');\n    } else {\n      throw new Error(e);\n    }\n  }\n\n  process.exit(0);\n}\n\nmain().catch((error) => {\n  console.log(error);\n  process.exit(-1);\n});\n\n\n// =======================================================\n// FILE START: system-contract-dapp-playground/src/components/contract-interaction/hts/token-create-custom/methods/index.tsx\n// File Impact Score: 30.67\n// =======================================================\n\n\n// --- Group 1 ---\n// Initial Score: { Complexity: 4, Quality: 7.7 }\n// File: system-contract-dapp-playground/src/components/contract-interaction/hts/token-create-custom/methods/index.tsx\n// Relevant file context:\n// Type: .tsx\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Contract } from 'ethers';\nimport GrantTokenKYC from './GrantTokenKYC';\nimport MintHederaToken from './MintHederaToken';\nimport FungibleTokenCreate from './FungibleTokenCreate';\nimport AssociateHederaToken from './AssociateHederaToken';\nimport NonFungibleTokenCreate from './NonFungibleTokenCreate';\n\ninterface PageProps {\n  method: string;\n  baseContract: Contract;\n}\n\nconst HederaTokenCreateMethods = ({ baseContract, method }: PageProps) => {\n  return (\n    <>\n      {method === 'mint' && <MintHederaToken baseContract={baseContract} />}\n      {method === 'grantKYC' && <GrantTokenKYC baseContract={baseContract} />}\n      {method === 'tokenAssociation' && <AssociateHederaToken baseContract={baseContract} />}\n      {method === 'fungibleTokenCreate' && <FungibleTokenCreate baseContract={baseContract} />}\n      {method === 'non-fungibleTokenCreate' && <NonFungibleTokenCreate baseContract={baseContract} />}\n    </>\n  );\n};\n\nexport default HederaTokenCreateMethods;\n\n\n// =======================================================\n// FILE START: system-contract-dapp-playground/src/app/page.tsx\n// File Impact Score: 25.00\n// =======================================================\n\n\n// --- Group 1 ---\n// Initial Score: { Complexity: 3, Quality: 8.3 }\n// File: system-contract-dapp-playground/src/app/page.tsx\n// Relevant file context:\n// Type: .tsx\n// SPDX-License-Identifier: Apache-2.0\n\nimport Footer from '@/components/footer';\nimport Navbar from '@/components/navbar';\nimport LandingPage from '@/sections/landing';\n\nexport default function Home() {\n  return (\n    <main className=\"h-screen flex flex-col\">\n      <Navbar />\n      <LandingPage />;\n      <Footer />\n    </main>\n  );\n}\n"
  }
}